<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Typescript快速入门</title>
      <link href="/My-Blogs/2022/03/06/Typescript/Typescript%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/My-Blogs/2022/03/06/Typescript/Typescript%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.</p><p>Any browser. Any host. Any OS. Open source.</p></blockquote><p>漫漫前端路，语言何其多。行走在前端开发的道路上，新鲜事物层出不穷，你是否有些应接不暇呢？在众多耀眼的前端语言明星中，TypeScript 无疑是你值得探究一番的那一颗（<del>对，就是这么武断</del>）。</p><a id="more"></a><h1 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h1><p>大家都知道 JavaScript 是一种弱类型语言，想必很多人也知道不少有关自动类型转换的奇技淫巧。弱类型在我们写代码时带来了不少便利，也为面试题扩充了不少题库，但同时也埋下了一个个地雷，时不时踩一个。尤其是写一些基础库时，为了使用者的正确使用，要编写各种冗长的使用文档，遇上<del>不靠谱</del>不看文档的开发者，不仅要花时间解释用法，有时为了代码鲁棒性还得做各种各样的校验和兼容，费时费力。这时候类似 TypeScript 的强类型语言的优势就体现出来了，不按正确的方式调用编译都通不过，把问题直接挡在门外。</p><p>那么问题来了：“我习惯了开发 JavaScript，会不会很难接受 TypeScript 啊？”这个问题暂时放放，我们先来看看 TypeScript 的类型究竟是啥。</p><h2 id="Primitive-Types"><a href="#Primitive-Types" class="headerlink" title="Primitive Types"></a>Primitive Types</h2><p>说到<strong>基本类型</strong>，首先就能想到御三家：<code>string</code>、<code>number</code> 和 <code>boolean</code>，这三个类型在 TypeScript 的类型体系中占据了半壁江山，为其他复杂类型奠定了基石。</p><p>要指定一个变量的类型很简单，在 JavaScript 的变量声明后加上 <code>: type</code> 就可以了。</p><pre><code class="typescript">const numberVal: number = 0;const booleanVal: boolean = true;const stringVal: string = 'string';</code></pre><p>赋值、使用变量时和 JavaScript 完全一样。</p><pre><code class="typescript">let numberVal: number = 0;numberVal += 10;console.log(`Value: ${numberVal}`);</code></pre><p>对于有初值并且类型唯一的变量，我们也可以省略类型的声明，由 TypeScript 自动推导。</p><pre><code class="typescript">let inferredNumberVal = 1;inferredNumberVal = 2;</code></pre><p>当变量被赋予错误类型的值，或是用于错误的函数时，TypeScript 会给出错误。</p><pre><code class="typescript">let numberVal: number = 0;numberVal = '1'; // TS2322: Type '"1"' is not assignable to type 'number'.stringVal.localeCompare(numberVal); // TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.</code></pre><p><code>symbol</code> 的使用与 <code>string</code> 等大同小异，至于 <code>null</code> 和 <code>undefined</code> 放到后文再说。</p><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>数组也是很常见的数据类型，定义也很浅显易懂。</p><pre><code class="typescript">let list: number[] = [1, 2, 3];list.push(4);const numberVal = list.shift();</code></pre><p>除了用 <code>[]</code> 的形式，也可以通过泛型（Generics）定义。</p><pre><code class="typescript">let list: Array&lt;number&gt; = [1, 2, 3];</code></pre><p>大部分情况建议使用 <code>[]</code> 的形式，遇到较复杂的类型时再考虑使用 <code>Array&lt;elementType&gt;</code> 的形式。</p><h2 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h2><p>对于一些事先确定范围的数据类型，我们一般会通过定义常量对象来描述。</p><pre><code class="javascript">const NetworkType = {    None: 0,    Wifi: 1,    Edge: 2,    Unknown: 3,};let type = NetworkType.None;</code></pre><p>按照上面这种写法，可以推导出变量 <code>type</code> 的类型其实是 <code>number</code>，但是并没有体现出 <code>NetworkType</code> 的取值范围。对于这种情况，TypeScript 给我们提供了枚举类型。</p><pre><code class="typescript">enum NetworkType {    None,    Wifi,    Edge,    Unknown,}let type: NetworkType = NetworkType.Wifi;</code></pre><p>通常情况下，枚举值会从 <code>0</code> 开始被依次赋值，当然我们也可以在定义时修改。</p><pre><code class="typescript">enum NetworkType {    None = 1,            // 1    Wifi,                     // 2    Edge,                  // 3    Unknown = 9,    // 9}</code></pre><p>也可以使用 <code>string</code> 类型定义枚举类型，此时每一个枚举值都必须赋初值。</p><pre><code class="typescript">enum NetworkType {    None = 'NONE',    Wifi = 'WIFI',    Edge = 'EDGE',    Unknown = 'UNKNOWN',}</code></pre><p>可以通过枚举值获得枚举名。</p><pre><code class="typescript">enum NetworkType {    None,    Wifi,    Edge,    Unknown,}const type = NetworkType.None;const nameOfType = NetworkType[type]; // name === 'None'</code></pre><p>是不是有点神奇？其实看一下编译成 JavaScript 的代码就很好理解了：</p><pre><code class="javascript">var NetworkType;(function (NetworkType) {    NetworkType[NetworkType["None"] = 0] = "None";    NetworkType[NetworkType["Wifi"] = 1] = "Wifi";    NetworkType[NetworkType["Edge"] = 2] = "Edge";    NetworkType[NetworkType["Unknown"] = 3] = "Unknown";})(NetworkType || (NetworkType = {}));var type = NetworkType.None;var nameOfType = NetworkType[type]; // name === 'None'</code></pre><p>不过很多场景下我们并不需要通过枚举值反推枚举名，或是担心在运行时枚举值被修改，这时候我们就可以使用 <code>const enum</code> 了。</p><pre><code class="typescript">const enum NetworkType {    None,    Wifi,    Edge,    Unknown,}const type = NetworkType.None;</code></pre><p>对应的编译后代码：</p><pre><code class="js">var type = 0 /* None */;</code></pre><p>简洁明了。</p><h2 id="Nullable"><a href="#Nullable" class="headerlink" title="Nullable"></a>Nullable</h2><p>默认情况下 <code>null</code> 和 <code>undefined</code> 包含在其他类型内，例如：</p><pre><code class="typescript">let numberVal: number; // numberVal is undefinedlet stringVal: string = null;</code></pre><p>大多数情况我们不会定义某个变量类型为 <code>null</code> 或 <code>undefined</code>，毕竟没有使用场景。不过在启用 TypeScript 的 <code>--strictNullChecks</code> 参数时， <code>null</code> 和 <code>undefined</code> 将从其他类型独立出来。</p><pre><code class="typescript">let stringVal: string | null = null;</code></pre><p>由 <code>|</code> 分隔的若干类型构成联合类型，例如 <code>string | null</code> 表示类型可以是 <code>string</code> 或 <code>null</code>。</p><h2 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h2><p>假设有一个场景，需要解析用户配置，配置项以对象的形式提供，看起来好像很简单：</p><pre><code class="typescript">let config: Object = getConfig();console.log(config.name); // TS2339: Property 'name' does not exist on type 'Object'.</code></pre><p>咦，怎么报错了？不是说好的配置项是个对象吗？其实这是很多人在编写 TypeScript 时会遇到的第一个误区。我们知道在 JavaScript 的世界所有对象都继承自 <code>Object</code>，TypeScript 也一样。对于一个 <code>Object</code> 类型的变量，我们可以给它赋任意值：</p><pre><code class="typescript">let obj: Object;obj = 1;obj = 'Hello world!';obj = false;obj = function noop() {};obj = [false, 1, '2'];obj = {};obj = null;</code></pre><p>也正因此我们无法从 <code>Object</code> 类型推导出真正的类型，自然也就无法验证类型的合法性了。那这个方法应该怎么写？</p><pre><code class="typescript">let config: any = getConfig();console.log(config.name); // OK!</code></pre><p>是的，TypeScript 有个厉害的类型叫 <code>any</code>。严格来说不应该把 <code>any</code> 归为类型，更多时候应该说是一个让 Typescript 忽略类型检查的标记。</p><h2 id="Object-VS-object"><a href="#Object-VS-object" class="headerlink" title="Object VS object"></a>Object VS object</h2><p>除了刚刚说到的 <code>Object</code> 类型，可能大家还会遇到 <code>object</code> 这个类型。初看之下好像两者没什么区别，但实际上两者属于两个不同的世界。</p><p><code>Object</code> 来自 JavaScript，就是大家熟知的那个所有对象类型的根；<code>object</code> 是 TypeScript 的基本类型，用于指代除了基本类型之外的所有类型。</p><p>把刚才的例子改一下，看看会发生什么？</p><pre><code class="typescript">let obj: object;obj = 1; // Errorobj = 'Hello world!'; // Errorobj = false; // Errorobj = function noop() {};obj = [false, 1, '2'];obj = {};obj = null; // Error when enable --strictNullChecks</code></pre><hr><h1 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h1><p>只有基础类型是肯定不够用的，而 <code>any</code> 虽然能用于各种复杂的类型，但我们都应该明白 <code>any</code> 不能用于类型检查，自然不是最好的选择。这里就要介绍一下 TypeScript 的接口（interface）了，这可是 TypeScript 的核心之一，主打定义类型和类型检查。</p><h2 id="接口声明"><a href="#接口声明" class="headerlink" title="接口声明"></a>接口声明</h2><p>声明和使用一个接口很简单，作为类型定义时，接口的使用方法与基础类型完全一样。</p><pre><code class="typescript">interface Point {    x: number;    y: number;}let p: Point;p = { x: 0 }; // TS2322: Type '{ x: number; }' is not assignable to type 'Point'.p = { x: 0, z: 0 }; // TS2322: Type '{ x: number; z: number; }' is not assignable to type 'Point'.p = { x: 0, y: 0 }; // OK!</code></pre><h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><p>接口的属性值可以设置为可选。</p><pre><code class="typescript">interface ColorizedPoint extends Point {    color?: string;}let defaultPoint: ColorizedPoint = { x: 0, y: 0 };defaultPoint.color = 'blue';let redPoint: ColorizedPoint = { x: 0, y: 0, color: 'red' };</code></pre><h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><p>接口的属性值可以设置为只读。</p><pre><code class="typescript">interface FixedPoint extends Point {    readonly x: number;    readonly y: number;}let p: FixedPoint = { x: 0, y: 0 };p.x = 1; // TS2540: Cannot assign to 'x' because it is a constant or a read-only property.</code></pre><h2 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h2><p>接口可以被继承，父类型可以接受子类型，但不意味着可以接受与子类型同构的数据。</p><pre><code class="typescript">interface StereoPoint extends Point {    z: number;}let point: Point;let stereoPoint: StereoPoint = { x: 0, y: 0, z: 0 };point = stereoPoint; // OK!point = { x: 0, y: 0, z: 0 }; // TS2322: Type '{ x: number; y: number; z: number; }' is not assignable to type 'Point'.</code></pre><h2 id="索引属性"><a href="#索引属性" class="headerlink" title="索引属性"></a>索引属性</h2><p>在某些场景，我们可能只关心数据结构中的特定属性，或是数据有统一的结构但属性名不可枚举，例如 HTTP 请求的响应头。</p><pre><code class="typescript">interface ResponseHeaders {    'accept'?: string;    'set-cookie'?: string[];    [header: string]: string | string[];}</code></pre><p>这里的 <code>[header: string]: string | string[] | undefined;</code> 定义了接口的索引属性，表示 <code>ResponseHeaders</code> 可以接受任意属性名为 <code>string</code> 类型、值为 <code>string | stirng[]</code> 类型的数据。</p><p>索引属性的属性名类型也支持 <code>number</code> 类型，例如：</p><pre><code class="typescript">interface ArrayLike {    length: number;    [index: number]: any;}let array: ArrayLike = [0, 1, 2];array[3] = 3;</code></pre><hr><h1 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h1><p>函数（function）是 JavaScript 应用程序的基础，TypeScript 为 JavaScript 的基础上为函数添加了许多额外的功能。</p><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>函数的声明与 JavaScript 没有太大区别，给参数和函数加上 <code>: type</code> 声明即可。</p><pre><code class="typescript">function filterData(list: string[]): string[] {    return list.filter((val) =&gt; val.length &gt; 5);}function log(...args: string[]): void {    console.log(...filterData(args));}</code></pre><p>这里顺便提一下，<code>void</code> 也是 TypeScript 的基本类型，但基本都用来定义函数的返回值，就不在之前赘述了。</p><h2 id="函数类型声明"><a href="#函数类型声明" class="headerlink" title="函数类型声明"></a>函数类型声明</h2><p>这里稍稍有点绕，函数声明在 JavaScript 也有，但是函数类型的声明就是 TypeScript 独有的了，用来定义一系列函数的类型，包括参数数量和类型、返回值类型。</p><p>通过 <code>type</code> 声明</p><pre><code class="typescript">type DataFilter = (value: string) =&gt; boolean;</code></pre><p>通过 <code>interface</code> 声明</p><pre><code class="typescript">interface DataFilter {    (value: string): boolean;}</code></pre><p>声明了函数类型就可以开心地用了</p><pre><code class="typescript">function filterData(list: string[], dataFilter: DataFilter): string[] {    return list.filter(dataFilter);}</code></pre><p>不过很多时候函数类型声明并不是必须的，比如上面的例子，也可以直接写成</p><pre><code class="typescript">function filterData(list: string[], dataFilter: (value: string) =&gt; boolean): string[] {    return list.filter(dataFilter);}</code></pre><h2 id="函数超载"><a href="#函数超载" class="headerlink" title="函数超载"></a>函数超载</h2><p>先看一个例子：</p><pre><code class="typescript">function padding(all: number);function padding(topAndBottom: number, leftAndRight: number);function padding(top: number, right: number, bottom: number, left: number);function padding(all: number, leftAndRight?: number, bottom?: number, left?: number) {    if (leftAndRight === undefined &amp;&amp; bottom === undefined &amp;&amp; left === undefined) {        leftAndRight = bottom = left = all;    } else if (bottom === undefined &amp;&amp; left === undefined) {        bottom = all;        left = leftAndRight;    }    return {        top: all,        right: leftAndRight,        bottom: bottom,        left: left    };}padding(1); // { top: 1, right: 1, bottom: 1, left: 1 }padding(1, 2); // { top: 1, right: 2, bottom: 1, left: 2 }padding(1, 2, 1); // TS2575: No overload expects 3 arguments, but overloads do exist that expect either 2 or 4 arguments.padding(1, 2, 1, 2); // { top: 1, right: 2, bottom: 1, left: 2 }</code></pre><p>执行 <code>padding()</code> 函数时，传入不同的参数列表，不同位置上的参数所代表的含义也会发生变化。此时前三行函数声明只用于 TypeScript 的类型检查和推导，真正执行的还是第四行开始的代码。</p><h2 id="工厂函数"><a href="#工厂函数" class="headerlink" title="工厂函数"></a>工厂函数</h2><p>某些情况下我们需要动态生成一些函数，完成一些特定的功能，比如下面这个例子：</p><pre><code class="typescript">// 声明需要生成的函数类型interface Validator {    tester: RegExp;    (value: string, index?: number): boolean;    (values: string[]): boolean;}// 工厂函数function createValidator(tester: RegExp): Validator {    /**     * `&lt;Validator&gt;` 用于把 `function` 类型转换成 `Validator` 类型；     * `this: Validator` 用于指定函数运行时的上下文。     */    const validator = &lt;Validator&gt;function (this: Validator, value: string | string[], index?: number): boolean {        if (typeof value === 'string') {            return this.tester.test(value.slice(index));        }        return value.every((val) =&gt; this.tester.test(val));    };    validator.tester = tester;    return validator.bind(validator);}const validate: Validator = createValidator(/\.fordeal\.com$/i);validate('12345'); // falsevalidate('www.fordeal.com', 3); // truevalidate(['www.fordeal.com', 'api.fordeal.com']); // truevalidate(['www.fordeal.com', 'api.fordeal.com'], 3); // TS2345: Argument of type 'string[]' is not assignable to parameter of type 'string'.</code></pre><p><em>注：这里为了体现函数运行时的上下文，把 <code>tester</code> 挂到了 <code>Validator</code> 对象上，实际上通过闭包也可以实现一样的功能，在实际开发中请合理选择实现方法。</em></p><h1 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h1><p>接触过 ES6 的同学肯定知道 JavaScript 的类（class），这可以说是面向对象编程的基石。TypeScript 里的类完全向 JavaScript 兼容，并添加了很多额外的功能。</p><h2 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h2><p>拿之前的 <code>Point</code> 为例：</p><pre><code class="typescript">class Point {    x: number;    y: number;    constructor(x: number, y: number) {        this.x = x;        this.y = y;    }    toString(): string {        return `(${this.x}, ${this.y})`;    }}</code></pre><p>可以看到除了增加类型定义，和 ES6 的类声明基本一样。</p><h2 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h2><p>和接口一样，类也可以被继承。</p><pre><code class="typescript">class NamedPoint extends Point {    name: string;    constructor(x: number, y: number, name: string) {        super(x, y);        this.name = name;    }    toString(): string {        return this.name + super.toString();    }}</code></pre><p>在派生类中可以通过 <code>super</code> 关键字访问基类。</p><p>此外，接口同样可以继承类。</p><pre><code class="typescript">interface FixedPoint extends Point {    readonly x: number;    readonly y: number;}let p0: Point = new Point(0, 0);let p1: FixedPoint = p0;p0.x += 10; // OK!p1.x += 10; // TS2540: Cannot assign to 'x' because it is a constant or a read-only property.</code></pre><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>访问修饰符（Access modifiers）包括：<code>public</code>、<code>private</code> 和 <code>protected</code>，默认均为 <code>public</code>。</p><pre><code class="typescript">class A {    public a: number = 0;    protected b: number = 1;    private c: number = 2;}class B extends A {    getB(): number {        return this.b; // OK!    }    getC(): number {        return this.c; // Error!    }}new A().a; // OK!new A().b; // Error!new A().c; // Error!</code></pre><ul><li><code>public</code> 在任意地方都可以访问；</li><li><code>private</code> 不能在声明它的类的外部访问；</li><li><code>protected</code> 与 <code>private</code> 比较类似，不过可以在类的派生类中访问。</li></ul><h2 id="只读修饰符"><a href="#只读修饰符" class="headerlink" title="只读修饰符"></a>只读修饰符</h2><p>与接口的只读属性类似，类的属性也可以通过 <code>readonly</code> 修饰。</p><pre><code class="typescript">class FixedPoint extends Point {    readonly x: number;    readonly y: number;    readonly isReadonly: boolean = true;    setX(x: number): void {        this.x = x; // Error!    }}new FixedPoint(0, 0).x = 1; // Error!</code></pre><p>被 <code>readonly</code> 修饰的属性只能在定义属性或构造函数中被初始化。</p><h2 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h2><p>都说“懒惰是进步的源泉”，参数属性（Parameter property）就是一个很好的印证，还是以之前的 <code>Point</code> 为例：</p><pre><code class="typescript">class Point {    constructor(protected x: number, public y: number) {    }    toString(): string {        return `(${this.x}, ${this.y})`;    }}</code></pre><p>这样的类声明和之前的写法等效，通过给构造函数的参数添加修饰符，把声明和赋值合并至一处。</p><pre><code class="typescript">class A {    constructor(protected a: number) {    }}class B {    constructor(private b: number) {    }}class C {    constructor(readonly c: number) {    }}class D {    constructor(private readonly d: number) {    }}</code></pre><h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><p>接口可以继承自类，那类可以继承自接口吗？这是个好问题，不过在这之前我们先要分清两个概念：类型和实现。</p><p>类似 <code>type A = string | number</code> 和接口这些都属于类型，只作用在 TypeScript 的环境里，并不会对真实的 JavaScript 环境产生影响；而对于变量、函数或类这些定义都属于实现，是可以在 JavaScript 环境运行的逻辑。</p><p>现在再来看“类可以继承自接口吗”这个问题，显然是不可以的。类是实现，接口是类型，举个不太好的例子，有点像从虚无中产生物质（不要说是暗物质），自然不能实现。</p><p>但是！虽然类不能继承接口，但是我们可以实现（implement）接口。</p><pre><code class="typescript">interface IStorage {    readonly size: number;    delete(key: string): boolean;    get(key: string): any;    has(key: string): boolean;    set(key: string, value: any): void;}class PersistentStorage implements IStorage {    get size(): number {        /* Implement */    }    delete(key: string): boolean {        /* Implement */    }    get(key: string): any {        /* Implement */    }    has(key: string): boolean {        /* Implement */    }    set(key: string, value: any): void {        /* Implement */    }    protected save(): void {        /* Implement */    }}class MemoryStorage implements IStorage {    get size(): number {        /* Implement */    }    delete(key: string): boolean {        /* Implement */    }    get(key: string): any {        /* Implement */    }    has(key: string): boolean {        /* Implement */    }    set(key: string, value: any): void {        /* Implement */    }}</code></pre><ul><li>这种场景下，接口建议以 <code>I</code>（Interface）开头以与类做区分；</li><li>接口给类的实现提供了指导作用，类需要实现接口中定义的所有属性和方法；</li><li>接口只定义类的 <code>public</code> 部分，不需要也不能定义 <code>protected</code> 和 <code>private</code> 部分。</li></ul><p>具体的使用场景在这里就不展开了，有兴趣的可以关注后续的分享。</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类（Abstract class）介于接口和类之间，它可以被继承，但是无法实例化。</p><pre><code class="typescript">abstract class Shape {    abstract readonly perimeter: number;    abstract calcArea(): number;    toString(): string {        return `Perimeter: ${this.perimeter}, area: ${this.calcArea()}`;    }}class Square extends Shape {    readonly perimeter: number;    constructor(public readonly n: number) {        super();        this.perimeter = n * 4;    }    calcArea(): number {        return this.n ** 2;    }}class Circle extends Shape {    constructor(public radius: number) {        super();    }    get perimeter(): number {        return 2 * Math.PI * this.radius;    }    calcArea(): number {        return Math.PI * (this.radius ** 2);    }}new Shape().toString(); // TS2511: Cannot create an instance of an abstract class.new Square(1).toString(); // 'Perimeter: 4, area: 1'new Circle(1).toString(); // 'Perimeter: 6.283185307179586, area: 3.141592653589793'</code></pre><p>在抽象类 <code>Shape</code> 中，<code>perimeter</code> 属性和 <code>calcArea()</code> 方法都被标记为 <code>abstract</code>，所以派生类在继承时必须都实现。<code>calcArea()</code> 方法很简单就不多说了，注意一下 <code>perimeter</code> 属性：</p><ul><li>在 <code>Square</code> 类的构造函数中，边长 <code>n</code> 带有 <code>readonly</code> 修饰符，意味着 <code>perimeter</code> 也固定不变，所以可以直接通过 <code>n * 4</code> 赋值；</li><li>而 <code>Circle</code> 类的半径 <code>radius</code> 是可变的，意味着当 <code>radius</code> 改变时 <code>perimeter</code> 也应该随之变化，所以选择 getter 实现。</li></ul><p>在复杂的项目开发中经常会遇到类似的情况，是选择属性还是通过 getter/setter 实现可以多斟酌下。</p><h2 id="类方法超载"><a href="#类方法超载" class="headerlink" title="类方法超载"></a>类方法超载</h2><p>函数可以超载，类似的类方法也可以。</p><pre><code class="typescript">interface IStyle {    padding(all: number);    padding(topAndBottom: number, leftAndRight: number);    padding(top: number, right: number, bottom: number, left: number);}class Style implements IStyle {    padding(all: number);    padding(topAndBottom: number, leftAndRight: number);    padding(top: number, right: number, bottom: number, left: number);    padding(all: number, leftAndRight?: number, bottom?: number, left?: number) {        if (leftAndRight === undefined &amp;&amp; bottom === undefined &amp;&amp; left === undefined) {            leftAndRight = bottom = left = all;        } else if (bottom === undefined &amp;&amp; left === undefined) {            bottom = all;            left = leftAndRight;        }        return {            top: all,            right: leftAndRight,            bottom: bottom,            left: left        };    }}const style = new Style();style.padding(1);style.padding(1, 2);style.padding(1, 2, 1);style.padding(1, 2, 1, 2);</code></pre><h1 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h1><p>泛型（generics）是在定义类型时非常常见，对于可复用的类型，泛型的引入使得同一份定义可以满足多样的数据类型，大大提高类型的灵活性。</p><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>先回忆一下之前我们定义的 <code>ArrayLike</code></p><pre><code class="typescript">interface ArrayLike {    length: number;    [index: number]: any;}let array: ArrayLike = [0, true, '2'];let element = array[0];</code></pre><p>通过 <code>ArrayLike</code> 我们可以简单的接受一个数组类型，但这样存在一个问题：无法描述数组元素的类型。例子里的 <code>element</code> 变量的类型只能推导出 <code>any</code>，同时在对 <code>array</code> 赋值时我们也没法限制数组元素的类型。</p><p>现在回忆一下如何定义一个数字类型的数组：<code>number[]</code> 或是 <code>Array&lt;number&gt;</code>。这里的 <code>Array&lt;number&gt;</code> 用的就是泛型。那么泛型怎么定义呢？</p><pre><code class="typescript">interface ArrayLike&lt;T&gt; {    length: number;    [index: number]: T;}let numbers: ArrayLike&lt;number&gt; = [0, 1, 2];let val: string = numbers[0]; // TS2322: Type 'number' is not assignable to type 'string'.let strings: ArrayLike&lt;string&gt; = [0, 1, 2]; // TS2322: Type 'number[]' is not assignable to type 'ArrayLike&lt;string&gt;'.</code></pre><p>通过 <code>&lt;T1, T2, ...&gt;</code> 传入若干<strong>类型变量</strong>，可以在后续定义中使用类型变量替代具体的类型。需要注意的是类型变量是一种特殊的变量，只用于表示类型而不是值。</p><h2 id="范型函数"><a href="#范型函数" class="headerlink" title="范型函数"></a>范型函数</h2><p>我们同样可以用泛型定义函数。</p><pre><code class="typescript">function filterData&lt;T&gt;(list: T[], dataFilter: (value: T) =&gt; boolean): T[] {    return list.filter(dataFilter);}let numbers: number[] = filterData([0, 1, 2, 3], (value) =&gt; value % 2 === 0);let strings: string[] = filterData(['0', '11', '222', '333'], (value) =&gt; value.length % 2 === 0);</code></pre><p>通过泛型我们的 <code>filterData()</code> 就可以处理各种不同类型的数据了。</p><h2 id="范型类"><a href="#范型类" class="headerlink" title="范型类"></a>范型类</h2><p>范型类的定义和接口类似。</p><pre><code class="typescript">class ValueHolder&lt;T&gt; {    constructor(public value: T) {    }    toString(): string {        return `I have a ${typeof this.value}`;    }}new ValueHolder(0).toString(); // 'I have a number'new ValueHolder('0').toString(); // 'I have a string'</code></pre><h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p>有的时候我们的逻辑并不能支持所有类型，所以需要在定义泛型时约束可选的类型。</p><pre><code class="typescript">function logShape&lt;T extends Shape&gt;(shape: T): void {    console.log(shape.constructor.name, shape.perimeter, shape.calcArea());}logShape(new Square(1)); // Square 4 1logShape(new Circle(1)); // Circle 6.283185307179586 3.141592653589793logShape('Shape'); // TS2345: Argument of type '"Shape"' is not assignable to parameter of type 'Shape'.</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法篇-例题</title>
      <link href="/My-Blogs/2021/12/22/JavaScript/%E7%AE%97%E6%B3%95%E7%AF%87-%E4%BE%8B%E9%A2%98/"/>
      <url>/My-Blogs/2021/12/22/JavaScript/%E7%AE%97%E6%B3%95%E7%AF%87-%E4%BE%8B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="JavaScript-算法与数据结构"><a href="#JavaScript-算法与数据结构" class="headerlink" title="JavaScript 算法与数据结构"></a>JavaScript 算法与数据结构</h1><p>本仓库包含了多种基于 JavaScript 的算法与数据结构。</p><p><em>注意：这个项目仅用于学习和研究，<strong>不是</strong>用于生产环境。</em></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据结构是在计算机中组织和存储数据的一种特殊方式，使得数据可以高效地被访问和修改。更确切地说，数据结构是数据值的集合，表示数据之间的关系，也包括了作用在数据上的函数或操作。</p><p><code>B</code> - 初学者， <code>A</code> - 进阶</p><ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/linked-list/README.zh-CN.md">链表</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/doubly-linked-list/README.zh-CN.md">双向链表</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/queue/README.zh-CN.md">队列</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/stack/README.zh-CN.md">栈</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/hash-table/README.zh-CN.md">哈希表(散列)</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/heap/README.zh-CN.md">堆</a> - 最大堆 &amp; 最小堆</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/priority-queue/README.zh-CN.md">优先队列</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/trie/README.zh-CN.md">字典树</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/tree/README.zh-CN.md">树</a><ul><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/tree/binary-search-tree">二叉查找树</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/tree/avl-tree">AVL 树</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/tree/red-black-tree">红黑树</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/tree/segment-tree">线段树</a> - 使用 <code>最小/最大/总和</code> 范围查询示例</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/tree/fenwick-tree">树状数组</a> (二叉索引树)</li></ul></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/graph/README.zh-CN.md">图</a> (有向图与无向图)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/disjoint-set">并查集</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/bloom-filter">布隆过滤器</a></li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法是如何解决一类问题的明确规范。算法是一组精确定义操作序列的规则。</p><p><code>B</code> - 初学者， <code>A</code> - 进阶</p><h3 id="算法主题"><a href="#算法主题" class="headerlink" title="算法主题"></a>算法主题</h3><ul><li><strong>数学</strong><ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/bits">位运算</a> - set/get/update/clear 位、乘以/除以二进制位 、变负等</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/factorial/README.zh-CN.md">阶乘</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/fibonacci">斐波那契数</a> - <code>经典</code> 和 <code>闭式</code> 版本</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/primality-test">素数检测</a> (排除法)</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/euclidean-algorithm">欧几里得算法</a> - 计算最大公约数 (GCD)</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/least-common-multiple">最小公倍数</a> (LCM)</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/sieve-of-eratosthenes">素数筛</a> - 查找任意给定范围内的所有素数</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/is-power-of-two">判断 2 次方数</a> - 检查数字是否为 2 的幂 (原生和按位算法)</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/pascal-triangle">杨辉三角形</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/complex-number">复数</a> - 复数及其基本运算</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/radian">弧度和角</a> - 弧度与角的相互转换</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/fast-powering">快速算次方</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/integer-partition">整数拆分</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/liu-hui">割圆术</a> - 基于 N-gons 的近似 π 计算</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/fourier-transform">离散傅里叶变换</a> - 把时间信号解析成构成它的频率</li></ul></li><li><strong>集合</strong><ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/cartesian-product">笛卡尔积</a> - 多集合结果</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/fisher-yates">洗牌算法</a> - 随机置换有限序列</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/power-set">幂集</a> - 该集合的所有子集</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/permutations">排列</a> (有/无重复)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/combinations">组合</a> (有/无重复)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/longest-common-subsequence">最长公共子序列</a> (LCS)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/longest-increasing-subsequence">最长递增子序列</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/shortest-common-supersequence">最短公共父序列</a> (SCS)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/knapsack-problem">背包问题</a> - <code>0/1</code> 和 <code>无边界</code> 问题</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/maximum-subarray">最大子数列问题</a> - <code>BF 算法</code> 和 <code>动态规划</code></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/combination-sum">组合求和</a> - 查找形成特定总和的所有组合</li></ul></li><li><strong>字符串</strong><ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/hamming-distance">汉明距离</a> - 符号不同的位置数</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/levenshtein-distance">莱温斯坦距离</a> - 两个序列之间的最小编辑距离</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/knuth-morris-pratt">Knuth–Morris–Pratt 算法</a> KMP 算法 - 子串搜索 (模式匹配)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/z-algorithm">字符串快速查找</a> - 子串搜索 (模式匹配)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/rabin-karp">Rabin Karp 算法</a> - 子串搜索</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/longest-common-substring">最长公共子串</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/regular-expression-matching">正则表达式匹配</a></li></ul></li><li><strong>搜索</strong><ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/search/linear-search">线性搜索</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/search/jump-search">跳转搜索/块搜索</a> - 搜索有序数组</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/search/binary-search">二分查找</a> - 搜索有序数组</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/search/interpolation-search">插值搜索</a> - 搜索均匀分布的有序数组</li></ul></li><li><strong>排序</strong><ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/bubble-sort">冒泡排序</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/selection-sort">选择排序</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/insertion-sort">插入排序</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/heap-sort">堆排序</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/merge-sort">归并排序</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/quick-sort">快速排序</a> - in-place (原地) 和 non-in-place 版本</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/shell-sort">希尔排序</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/counting-sort">计数排序</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/radix-sort">基数排序</a></li></ul></li><li><strong>链表</strong><ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/linked-list/traversal">正向遍历</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/linked-list/reverse-traversal">反向遍历</a></li></ul></li><li><strong>树</strong><ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/tree/depth-first-search">深度优先搜索</a> (DFS)</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/tree/breadth-first-search">广度优先搜索</a> (BFS)</li></ul></li><li><strong>图</strong><ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/depth-first-search">深度优先搜索</a> (DFS)</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/breadth-first-search">广度优先搜索</a> (BFS)</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/kruskal">克鲁斯克尔演算法</a> - 寻找加权无向图的最小生成树 (MST)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/dijkstra">戴克斯特拉算法</a> - 找到图中所有顶点的最短路径</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/bellman-ford">贝尔曼-福特算法</a> - 找到图中所有顶点的最短路径</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/floyd-warshall">弗洛伊德算法</a> - 找到所有顶点对 之间的最短路径</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/detect-cycle">判圈算法</a> - 对于有向图和无向图 (基于 DFS 和不相交集的版本)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/prim">普林演算法</a> - 寻找加权无向图的最小生成树 (MST)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/topological-sorting">拓扑排序</a> - DFS 方法</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/articulation-points">关节点</a> - Tarjan 算法 (基于 DFS)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/bridges">桥</a> - 基于 DFS 的算法</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/eulerian-path">欧拉回径与一笔画问题</a> - Fleury 的算法 - 一次访问每个边</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/hamiltonian-cycle">哈密顿图</a> - 恰好访问每个顶点一次</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/strongly-connected-components">强连通分量</a> - Kosaraju 算法</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/travelling-salesman">旅行推销员问题</a> - 尽可能以最短的路线访问每个城市并返回原始城市</li></ul></li><li><strong>加密</strong><ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/cryptography/polynomial-hash">多项式 hash</a> - 基于多项式的 rolling hash 函数</li></ul></li><li><strong>机器学习</strong><ul><li><code>B</code> <a href="https://github.com/trekhleb/nano-neuron">NanoNeuron</a> -7个简单的JS函数，说明机器如何实际学习（向前/向后传播）</li></ul></li><li><strong>未分类</strong><ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/hanoi-tower">汉诺塔</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/square-matrix-rotation">旋转矩阵</a> - 原地算法</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/jump-game">跳跃游戏</a> - 回溯,、动态编程 (自上而下+自下而上) 和贪婪的例子</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/unique-paths">独特(唯一) 路径</a> - 回溯、动态编程和基于 Pascal 三角形的例子</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/rain-terraces">雨水收集</a> - 诱捕雨水问题 (动态编程和暴力版本)</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/recursive-staircase">递归楼梯</a> - 计算有共有多少种方法可以到达顶层 (4 种解题方案)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/n-queens">八皇后问题</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/knight-tour">骑士巡逻</a></li></ul></li></ul><h3 id="算法范式"><a href="#算法范式" class="headerlink" title="算法范式"></a>算法范式</h3><p>算法范式是一种通用方法，基于一类算法的设计。这是比算法更高的抽象，就像算法是比计算机程序更高的抽象。</p><ul><li><strong>BF 算法</strong> - <code>查找/搜索</code> 所有可能性并选择最佳解决方案<ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/search/linear-search">线性搜索</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/rain-terraces">雨水收集</a> - 诱导雨水问题</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/recursive-staircase">递归楼梯</a> - 计算有共有多少种方法可以到达顶层 (4 种解题方案)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/maximum-subarray">最大子数列</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/travelling-salesman">旅行推销员问题</a> - 尽可能以最短的路线访问每个城市并返回原始城市</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/fourier-transform">离散傅里叶变换</a> - 把时间信号解析成构成它的频率</li></ul></li><li><strong>贪心法</strong> - 在当前选择最佳选项，不考虑以后情况<ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/jump-game">跳跃游戏</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/knapsack-problem">背包问题</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/dijkstra">戴克斯特拉算法</a> - 找到所有图顶点的最短路径</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/prim">普里姆算法</a> - 寻找加权无向图的最小生成树 (MST)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/kruskal">克鲁斯卡尔算法</a> - 寻找加权无向图的最小生成树 (MST)</li></ul></li><li><strong>分治法</strong> - 将问题分成较小的部分，然后解决这些部分<ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/search/binary-search">二分查找</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/hanoi-tower">汉诺塔</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/pascal-triangle">杨辉三角形</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/euclidean-algorithm">欧几里得算法</a> - 计算最大公约数 (GCD)</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/merge-sort">归并排序</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/quick-sort">快速排序</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/tree/depth-first-search">树深度优先搜索</a> (DFS)</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/depth-first-search">图深度优先搜索</a> (DFS)</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/jump-game">跳跃游戏</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/fast-powering">快速算次方</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/permutations">排列</a> (有/无重复)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/combinations">组合</a> (有/无重复)</li></ul></li><li><strong>动态编程</strong> - 使用以前找到的子解决方案构建解决方案<ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/fibonacci">斐波那契数</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/jump-game">跳跃游戏</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/unique-paths">独特路径</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/rain-terraces">雨水收集</a> - 疏导雨水问题</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/recursive-staircase">递归楼梯</a> - 计算有共有多少种方法可以到达顶层 (4 种解题方案)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/levenshtein-distance">莱温斯坦距离</a> - 两个序列之间的最小编辑距离</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/longest-common-subsequence">最长公共子序列</a> (LCS)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/longest-common-substring">最长公共子串</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/longest-increasing-subsequence">最长递增子序列</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/shortest-common-supersequence">最短公共子序列</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/knapsack-problem">0-1背包问题</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/integer-partition">整数拆分</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/maximum-subarray">最大子数列</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/bellman-ford">贝尔曼-福特算法</a> - 找到所有图顶点的最短路径</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/floyd-warshall">弗洛伊德算法</a> - 找到所有顶点对之间的最短路径</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/regular-expression-matching">正则表达式匹配</a></li></ul></li><li><strong>回溯法</strong> - 类似于 <code>BF 算法</code> 试图产生所有可能的解决方案，但每次生成解决方案测试如果它满足所有条件，那么只有继续生成后续解决方案。否则回溯并继续寻找不同路径的解决方案。<ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/jump-game">跳跃游戏</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/unique-paths">独特路径</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/power-set">幂集</a> - 该集合的所有子集</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/hamiltonian-cycle">哈密顿图</a> - 恰好访问每个顶点一次</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/n-queens">八皇后问题</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/knight-tour">骑士巡逻</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/combination-sum">组合求和</a> - 从规定的总和中找出所有的组合</li></ul></li><li><strong>Branch &amp; Bound</strong> - 记住在回溯搜索的每个阶段找到的成本最低的解决方案，并使用到目前为止找到的成本最小值作为下限。以便丢弃成本大于最小值的解决方案。通常，使用 BFS 遍历以及状态空间树的 DFS 遍历。</li></ul><h2 id="如何使用本仓库"><a href="#如何使用本仓库" class="headerlink" title="如何使用本仓库"></a>如何使用本仓库</h2><p><strong>安装依赖</strong></p><pre><code>npm install</code></pre><p><strong>运行 ESLint</strong></p><p>检查代码质量</p><pre><code>npm run lint</code></pre><p><strong>执行测试</strong></p><pre><code>npm test</code></pre><p><strong>按照名称执行测试</strong></p><pre><code>npm test -- 'LinkedList'</code></pre><p><strong>Playground</strong></p><p>你可以在 <code>./https://github.com/trekhleb/javascript-algorithms/blob/master/src/playground/playground.js</code> 文件中操作数据结构与算法，并在 <code>./https://github.com/trekhleb/javascript-algorithms/blob/master/src/playground/__test__/playground.test.js</code> 中编写测试。</p><p>然后，只需运行以下命令来测试你的 Playground 是否无误:</p><pre><code>npm test -- 'playground'</code></pre><h2 id="有用的信息"><a href="#有用的信息" class="headerlink" title="有用的信息"></a>有用的信息</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.youtube.com/playlist?list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8">▶ YouTube</a></p><h3 id="大O符号"><a href="#大O符号" class="headerlink" title="大O符号"></a>大O符号</h3><p>大O符号中指定的算法的增长顺序。</p><p><img src="/My-Blogs/./assets/big-o-graph.png" alt="Big O graphs"></p><p>源: <a href="http://bigocheatsheet.com/">Big O Cheat Sheet</a>.</p><p>以下是一些最常用的 大O标记法 列表以及它们与不同大小输入数据的性能比较。</p><table><thead><tr><th>大O标记法</th><th>计算10个元素</th><th>计算100个元素</th><th>计算1000个元素</th></tr></thead><tbody><tr><td><strong>O(1)</strong></td><td>1</td><td>1</td><td>1</td></tr><tr><td><strong>O(log N)</strong></td><td>3</td><td>6</td><td>9</td></tr><tr><td><strong>O(N)</strong></td><td>10</td><td>100</td><td>1000</td></tr><tr><td><strong>O(N log N)</strong></td><td>30</td><td>600</td><td>9000</td></tr><tr><td><strong>O(N^2)</strong></td><td>100</td><td>10000</td><td>1000000</td></tr><tr><td><strong>O(2^N)</strong></td><td>1024</td><td>1.26e+29</td><td>1.07e+301</td></tr><tr><td><strong>O(N!)</strong></td><td>3628800</td><td>9.3e+157</td><td>4.02e+2567</td></tr></tbody></table><h3 id="数据结构操作的复杂性"><a href="#数据结构操作的复杂性" class="headerlink" title="数据结构操作的复杂性"></a>数据结构操作的复杂性</h3><table><thead><tr><th>数据结构</th><th align="center">连接</th><th align="center">查找</th><th align="center">插入</th><th align="center">删除</th><th>备注</th></tr></thead><tbody><tr><td><strong>数组</strong></td><td align="center">1</td><td align="center">n</td><td align="center">n</td><td align="center">n</td><td></td></tr><tr><td><strong>栈</strong></td><td align="center">n</td><td align="center">n</td><td align="center">1</td><td align="center">1</td><td></td></tr><tr><td><strong>队列</strong></td><td align="center">n</td><td align="center">n</td><td align="center">1</td><td align="center">1</td><td></td></tr><tr><td><strong>链表</strong></td><td align="center">n</td><td align="center">n</td><td align="center">1</td><td align="center">1</td><td></td></tr><tr><td><strong>哈希表</strong></td><td align="center">-</td><td align="center">n</td><td align="center">n</td><td align="center">n</td><td>在完全哈希函数情况下，复杂度是 O(1）</td></tr><tr><td><strong>二分查找树</strong></td><td align="center">n</td><td align="center">n</td><td align="center">n</td><td align="center">n</td><td>在平衡树情况下，复杂度是 O(log(n))</td></tr><tr><td><strong>B 树</strong></td><td align="center">log(n)</td><td align="center">log(n)</td><td align="center">log(n)</td><td align="center">log(n)</td><td></td></tr><tr><td><strong>红黑树</strong></td><td align="center">log(n)</td><td align="center">log(n)</td><td align="center">log(n)</td><td align="center">log(n)</td><td></td></tr><tr><td><strong>AVL 树</strong></td><td align="center">log(n)</td><td align="center">log(n)</td><td align="center">log(n)</td><td align="center">log(n)</td><td></td></tr><tr><td><strong>布隆过滤器</strong></td><td align="center">-</td><td align="center">1</td><td align="center">1</td><td align="center">-</td><td>存在一定概率的判断错误（误判成存在）</td></tr></tbody></table><h3 id="数组排序算法的复杂性"><a href="#数组排序算法的复杂性" class="headerlink" title="数组排序算法的复杂性"></a>数组排序算法的复杂性</h3><table><thead><tr><th>名称</th><th align="center">最优</th><th align="center">平均</th><th align="center">最坏</th><th align="center">内存</th><th align="center">稳定</th><th>备注</th></tr></thead><tbody><tr><td><strong>冒泡排序</strong></td><td align="center">n</td><td align="center">n^2</td><td align="center">n^2</td><td align="center">1</td><td align="center">Yes</td><td></td></tr><tr><td><strong>插入排序</strong></td><td align="center">n</td><td align="center">n^2</td><td align="center">n^2</td><td align="center">1</td><td align="center">Yes</td><td></td></tr><tr><td><strong>选择排序</strong></td><td align="center">n^2</td><td align="center">n^2</td><td align="center">n^2</td><td align="center">1</td><td align="center">No</td><td></td></tr><tr><td><strong>堆排序</strong></td><td align="center">n log(n)</td><td align="center">n log(n)</td><td align="center">n log(n)</td><td align="center">1</td><td align="center">No</td><td></td></tr><tr><td><strong>归并排序</strong></td><td align="center">n log(n)</td><td align="center">n log(n)</td><td align="center">n log(n)</td><td align="center">n</td><td align="center">Yes</td><td></td></tr><tr><td><strong>快速排序</strong></td><td align="center">n log(n)</td><td align="center">n log(n)</td><td align="center">n^2</td><td align="center">log(n)</td><td align="center">No</td><td>在 in-place 版本下，内存复杂度通常是 O(log(n))</td></tr><tr><td><strong>希尔排序</strong></td><td align="center">n log(n)</td><td align="center">取决于差距序列</td><td align="center">n (log(n))^2</td><td align="center">1</td><td align="center">No</td><td></td></tr><tr><td><strong>计数排序</strong></td><td align="center">n + r</td><td align="center">n + r</td><td align="center">n + r</td><td align="center">n + r</td><td align="center">Yes</td><td>r - 数组里最大的数</td></tr><tr><td><strong>基数排序</strong></td><td align="center">n * k</td><td align="center">n * k</td><td align="center">n * k</td><td align="center">n + k</td><td align="center">Yes</td><td>k - 最长 key 的升序</td></tr></tbody></table><blockquote><p>ℹ️ A few more <a href="https://trekhleb.dev/projects/">projects</a> and <a href="https://trekhleb.dev/blog/">articles</a> about JavaScript and algorithms on <a href="https://trekhleb.dev/">trekhleb.dev</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法篇-基础</title>
      <link href="/My-Blogs/2021/12/21/JavaScript/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%9F%BA%E7%A1%80/"/>
      <url>/My-Blogs/2021/12/21/JavaScript/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="算法知识总结"><a href="#算法知识总结" class="headerlink" title="算法知识总结"></a>算法知识总结</h1><p>本部分主要是笔者在学习算法知识和一些相关面试题所做的笔记，如果出现错误，希望大家指出！</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93">常用算法和数据结构总结</a><ul><li><a href="#%E6%8E%92%E5%BA%8F">排序</a><ul><li><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a></li><li><a href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a></li><li><a href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a></li><li><a href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a></li><li><a href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a></li><li><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></li><li><a href="#%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></li><li><a href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基数排序</a></li><li><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%AF%B9%E4%BA%8E%E5%85%B6%E4%BB%96%E6%8E%92%E5%BA%8F%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98%E7%9A%84%E5%8E%9F%E5%9B%A0">快速排序相对于其他排序效率更高的原因</a></li><li><a href="#%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0">系统自带排序实现</a></li><li><a href="#%E7%A8%B3%E5%AE%9A%E6%80%A7">稳定性</a></li><li><a href="#%E6%8E%92%E5%BA%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93">排序面试题目总结</a></li></ul></li><li><a href="#%E6%A0%91">树</a><ul><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E6%80%A7%E8%B4%A8">二叉树相关性质</a></li><li><a href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91">满二叉树</a></li><li><a href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91">完全二叉树</a></li><li><a href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91avl">平衡二叉查找树（AVL）</a></li><li><a href="#b-%E6%A0%91">B-树</a></li><li><a href="#b%E6%A0%91">B 树</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95">数据库索引</a></li><li><a href="#%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a></li><li><a href="#huffman-%E6%A0%91">Huffman 树</a></li><li><a href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">二叉查找树</a></li><li><a href="#%E6%B1%82%E8%A7%A3%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E8%8A%82%E7%82%B9">求解二叉树中两个节点的最近公共祖先节点</a></li></ul></li><li><a href="#%E9%93%BE%E8%A1%A8">链表</a><ul><li><a href="#%E5%8F%8D%E8%BD%AC%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8">反转单向链表</a></li></ul></li><li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a><ul><li><a href="#%E7%88%AC%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98">爬楼梯问题</a></li><li><a href="#%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90">递归方法分析</a></li><li><a href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%96%B9%E6%B3%95">备忘录方法</a></li><li><a href="#%E8%BF%AD%E4%BB%A3%E6%B3%95">迭代法</a></li></ul></li><li><a href="#%E7%BB%8F%E5%85%B8%E7%AC%94%E8%AF%95%E9%A2%98">经典笔试题</a><ul><li><a href="#1-js-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%AE%8C%E6%88%90%E8%B6%85%E8%BF%87%E8%8C%83%E5%9B%B4%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%A4%A7%E6%95%B4%E6%95%B0%E7%9B%B8%E5%8A%A0%E5%8A%9F%E8%83%BD">1. js 实现一个函数，完成超过范围的两个大整数相加功能</a></li><li><a href="#2-js-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96">2. js 如何实现数组扁平化？</a></li><li><a href="#3-js-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D">3. js 如何实现数组去重？</a></li><li><a href="#4-%E5%A6%82%E4%BD%95%E6%B1%82%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC">4. 如何求数组的最大值和最小值？</a></li><li><a href="#5-%E5%A6%82%E4%BD%95%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0">5. 如何求两个数的最大公约数？</a></li><li><a href="#6-%E5%A6%82%E4%BD%95%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0">6. 如何求两个数的最小公倍数？</a></li><li><a href="#7-%E5%AE%9E%E7%8E%B0-indexof-%E6%96%B9%E6%B3%95">7. 实现 IndexOf 方法？</a></li><li><a href="#8-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2">8. 判断一个字符串是否为回文字符串？</a></li><li><a href="#9-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%B4%AF%E5%8A%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E6%AF%94%E5%A6%82-sum1232valueof">9. 实现一个累加函数的功能比如 sum(1,2,3)(2).valueOf()</a></li><li><a href="#10-%E4%BD%BF%E7%94%A8-reduce-%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0-foreachmapfilter">10. 使用 reduce 方法实现 forEach、map、filter</a></li><li><a href="#11-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E8%A6%81%E6%B1%82v%E5%88%86%E5%88%AB%E5%9C%A8-134-%E7%A7%92%E5%90%8E%E6%89%93%E5%8D%B0%E5%87%BA-1-2-3">11. 设计一个简单的任务队列，要求分别在 1,3,4 秒后打印出 “1”, “2”, “3”</a></li><li><a href="#12-%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E4%B8%80%E7%AF%87%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0%E4%B8%AD%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%9C%80%E9%AB%98%E7%9A%84%E5%8D%95%E8%AF%8D">12. 如何查找一篇英文文章中出现频率最高的单词？</a></li></ul></li></ul></li><li><a href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E6%99%BA%E5%8A%9B%E9%A2%98%E6%80%BB%E7%BB%93">常见面试智力题总结</a><ul><li><a href="#1-%E6%97%B6%E9%92%88%E4%B8%8E%E5%88%86%E9%92%88%E5%A4%B9%E8%A7%92%E5%BA%A6%E6%95%B0%E9%97%AE%E9%A2%98">1. 时针与分针夹角度数问题？</a></li><li><a href="#2-%E7%94%A83%E5%8D%875%E5%8D%87%E6%9D%AF%E5%AD%90%E6%80%8E%E4%B9%88%E9%87%8F%E5%87%BA4%E5%8D%87%E6%B0%B4">2. 用3升，5升杯子怎么量出4升水？</a></li><li><a href="#3-%E5%9B%9B%E4%B8%AA%E8%8D%AF%E7%BD%90%E4%B8%AD%E6%9C%89%E4%B8%80%E4%B8%AA%E6%B5%91%E6%B5%8A%E7%9A%84%E8%8D%AF%E7%BD%90%E6%B5%91%E6%B5%8A%E7%9A%84%E6%AF%8F%E7%89%87%E8%8D%AF%E7%89%87%E9%83%BD%E6%AF%94%E5%85%B6%E4%BB%96%E4%B8%89%E4%B8%AA%E5%B9%B2%E5%87%80%E7%9A%84%E8%8D%AF%E7%BD%90%E5%A4%9A%E4%B8%80%E5%85%8B%E5%A6%82%E4%BD%95%E5%8F%AA%E7%94%A8%E4%B8%80%E6%AC%A1%E5%A4%A9%E5%B9%B3%E6%89%BE%E5%87%BA%E6%B5%91%E6%B5%8A%E7%9A%84%E8%8D%AF%E7%BD%90">3. 浑浊药罐问题</a></li><li><a href="#4-%E5%9B%9B%E5%BC%A0%E5%8D%A1%E7%89%87%E5%8D%A1%E7%89%87%E6%AD%A3%E9%9D%A2%E6%98%AF%E6%95%B0%E5%AD%97%E5%8F%8D%E9%9D%A2%E6%98%AF%E5%AD%97%E6%AF%8D%E7%8E%B0%E5%9C%A8%E6%A1%8C%E4%B8%8A%E5%9B%9B%E5%BC%A0%E5%8D%A1%E7%89%87%E7%8A%B6%E6%80%81%E4%B8%BA-a-1-b-2-%E7%8E%B0%E5%9C%A8%E6%88%91%E6%83%B3%E8%A6%81%E8%AF%81%E6%98%8E-a-%E7%9A%84%E5%8F%8D%E9%9D%A2%E5%BF%85%E7%84%B6%E6%98%AF-1">4. 卡片证明问题</a></li><li><a href="#5-%E8%B5%9B%E9%A9%AC%E9%97%AE%E9%A2%9825-%E5%8C%B9%E9%A9%AC5-%E4%B8%AA%E8%B5%9B%E9%81%93%E6%9C%80%E5%B0%91%E5%87%A0%E6%AC%A1%E8%83%BD%E9%80%89%E5%87%BA%E6%9C%80%E5%BF%AB%E7%9A%84%E4%B8%89%E5%8C%B9%E9%A9%AC">5. 赛马问题，25 匹马，5 个赛道，最少几次能选出最快的三匹马？</a></li><li><a href="#6-%E4%BA%94%E9%98%9F%E5%A4%AB%E5%A6%87%E5%8F%82%E5%8A%A0%E8%81%9A%E4%BC%9A%E6%AF%8F%E4%B8%AA%E4%BA%BA%E4%B8%8D%E8%83%BD%E5%92%8C%E8%87%AA%E5%B7%B1%E7%9A%84%E9%85%8D%E5%81%B6%E6%8F%A1%E6%89%8B%E5%8F%AA%E8%83%BD%E6%9C%80%E5%A4%9A%E5%92%8C%E4%BB%96%E4%BA%BA%E6%8F%A1%E6%89%8B%E4%B8%80%E6%AC%A1a%E9%97%AE%E4%BA%86%E5%85%B6%E4%BB%96%E4%BA%BA%E5%8F%91%E7%8E%B0%E6%AF%8F%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%8F%A1%E6%89%8B%E6%AC%A1%E6%95%B0%E9%83%BD">6. 五队夫妇参加聚会握手问题</a></li><li><a href="#7-%E4%BD%A0%E5%8F%AA%E8%83%BD%E5%B8%A6%E8%A1%8C%E8%B5%B0-60-%E5%85%AC%E9%87%8C%E7%9A%84%E6%B2%B9%E5%8F%AA%E8%83%BD%E5%9C%A8%E8%B5%B7%E5%A7%8B%E7%82%B9%E5%8A%A0%E6%B2%B9%E5%A6%82%E4%BD%95%E7%A9%BF%E8%BF%87-80-%E5%85%AC%E9%87%8C%E7%9A%84%E6%B2%99%E6%BC%A0">7. 你只能带行走 60 公里的油，只能在起始点加油，如何穿过 80 公里的沙漠？</a></li><li><a href="#8-%E7%83%A7%E4%B8%80%E6%A0%B9%E4%B8%8D%E5%9D%87%E5%8C%80%E7%9A%84%E7%BB%B3%E8%A6%81%E7%94%A8%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%97%B6%E5%A6%82%E4%BD%95%E7%94%A8%E5%AE%83%E6%9D%A5%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%97%B6%E5%8D%81%E4%BA%94%E5%88%86%E9%92%9F">8. 烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？</a></li><li><a href="#9-%E6%9C%897%E5%85%8B2%E5%85%8B%E7%A0%9D%E7%A0%81%E5%90%84%E4%B8%80%E4%B8%AA%E5%A4%A9%E5%B9%B3%E4%B8%80%E5%8F%AA%E5%A6%82%E4%BD%95%E5%8F%AA%E7%94%A8%E8%BF%99%E4%BA%9B%E7%89%A9%E5%93%81%E4%B8%89%E6%AC%A1%E5%B0%86140%E5%85%8B%E7%9A%84%E7%9B%90%E5%88%86%E6%88%905090%E5%85%8B%E5%90%84%E4%B8%80%E4%BB%BD">9. 有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？</a></li><li><a href="#10-%E6%9C%89%E4%B8%80%E8%BE%86%E7%81%AB%E8%BD%A6%E4%BB%A5%E6%AF%8F%E5%B0%8F%E6%97%B615%E5%85%AC%E9%87%8C%E7%9A%84%E9%80%9F%E5%BA%A6%E7%A6%BB%E5%BC%80%E6%B4%9B%E6%9D%89%E7%9F%B6%E7%9B%B4%E5%A5%94%E7%BA%BD%E7%BA%A6%E5%8F%A6%E4%B8%80%E8%BE%86%E7%81%AB%E8%BD%A6%E4%BB%A5%E7%AC%AC%E5%B0%8F%E6%97%B620%E5%85%AC%E9%87%8C%E7%9A%84%E9%80%9F%E5%BA%A6%E4%BB%8E%E7%BA%BD%E7%BA%A6%E5%BC%80%E5%BE%80%E6%B4%9B%E6%9D%89%E7%9F%B6%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E5%8F%AA%E9%B8%9F%E4%BB%A5%E5%A4%9630%E5%85%AC%E9%87%8C%E6%AF%8F%E5%B0%8F%E6%97%B6%E7%9A%84%E9%80%9F%E5%BA%A6%E5%92%8C%E4%B8%A4%E8%BE%86%E7%81%AB%E8%BD%A6%E7%8E%B0%E6%97%B6%E5%90%AF%E5%8A%A8%E4%BB%8E%E6%B4%9B%E6%9D%89%E7%9F%B6%E5%87%BA%E5%8F%91%E7%A2%B0%E5%88%B0%E5%8F%A6%E8%BE%86%E8%BD%A6%E5%90%8E%E8%BF%94%E5%9B%9E%E4%BE%9D%E6%AC%A1%E5%9C%A8%E4%B8%A4%E8%BE%86%E7%81%AB%E8%BD%A6%E6%9D%A5%E5%9B%9E%E7%9A%84%E9%A3%9E%E8%A1%8C%E7%9B%B4%E9%81%93%E4%B8%A4%E9%9D%A2%E8%BE%86%E7%81%AB%E8%BD%A6%E7%9B%B8%E9%81%87%E8%AF%B7%E9%97%AE%E8%BF%99%E5%8F%AA%E5%B0%8F%E9%B8%9F%E9%A3%9E%E8%A1%8C%E4%BA%86%E5%A4%9A%E9%95%BF%E8%B7%9D%E7%A6%BB">10. 火车相对而行，小鸟飞行距离问题 </a></li><li><a href="#11-%E4%BD%A0%E6%9C%89%E4%B8%A4%E4%B8%AA%E7%BD%90%E5%AD%9050%E4%B8%AA%E7%BA%A2%E8%89%B2%E5%BC%B9%E7%90%8350%E4%B8%AA%E8%93%9D%E8%89%B2%E5%BC%B9%E7%90%83%E9%9A%8F%E6%9C%BA%E9%80%89%E5%87%BA%E4%B8%80%E4%B8%AA%E7%BD%90%E5%AD%90%E9%9A%8F%E6%9C%BA%E9%80%89%E5%8F%96%E5%87%BA%E4%B8%80%E4%B8%AA%E5%BC%B9%E7%90%83%E6%94%BE%E5%85%A5%E7%BD%90%E5%AD%90%E6%80%8E%E4%B9%88%E7%BB%99%E7%BA%A2%E8%89%B2%E5%BC%B9%E7%90%83%E6%9C%80%E5%A4%A7%E7%9A%84%E9%80%89%E4%B8%AD%E6%9C%BA%E4%BC%9A%E5%9C%A8%E4%BD%A0%E7%9A%84%E8%AE%A1%E5%88%92%E4%B8%AD%E5%BE%97%E5%88%B0%E7%BA%A2%E7%90%83%E7%9A%84%E5%87%86%E7%A1%AE%E5%87%A0%E7%8E%87%E6%98%AF%E5%A4%9A%E5%B0%91">11. 弹球拾取几率问题</a></li><li><a href="#12-%E5%81%87%E8%AE%BE%E4%BD%A0%E6%9C%898%E4%B8%AA%E7%90%83%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%95%A5%E5%BE%AE%E9%87%8D%E4%B8%80%E4%BA%9B%E4%BD%86%E6%98%AF%E6%89%BE%E5%87%BA%E8%BF%99%E4%B8%AA%E7%90%83%E7%9A%84%E6%83%9F%E4%B8%80%E6%96%B9%E6%B3%95%E6%98%AF%E5%B0%86%E4%B8%A4%E4%B8%AA%E7%90%83%E6%94%BE%E5%9C%A8%E5%A4%A9%E5%B9%B3%E4%B8%8A%E5%AF%B9%E6%AF%94%E6%9C%80%E5%B0%91%E8%A6%81%E7%A7%B0%E5%A4%9A%E5%B0%91%E6%AC%A1%E6%89%8D%E8%83%BD%E6%89%BE%E5%87%BA%E8%BF%99%E4%B8%AA%E8%BE%83%E9%87%8D%E7%9A%84%E7%90%83">12. 8个球使用天平称重问题</a></li><li><a href="#13-%E5%9C%A8%E6%88%BF%E9%87%8C%E6%9C%89%E4%B8%89%E7%9B%8F%E7%81%AF%E6%88%BF%E5%A4%96%E6%9C%89%E4%B8%89%E4%B8%AA%E5%BC%80%E5%85%B3%E5%9C%A8%E6%88%BF%E5%A4%96%E7%9C%8B%E4%B8%8D%E8%A7%81%E6%88%BF%E5%86%85%E7%9A%84%E6%83%85%E5%86%B5%E4%BD%A0%E5%8F%AA%E8%83%BD%E8%BF%9B%E9%97%A8%E4%B8%80%E6%AC%A1%E4%BD%A0%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E6%9D%A5%E5%8C%BA%E5%88%86%E9%82%A3%E4%B8%AA%E5%BC%80%E5%85%B3%E6%8E%A7%E5%88%B6%E9%82%A3%E4%B8%80%E7%9B%8F%E7%81%AF">13. 三盏灯区分开关问题</a></li><li><a href="#14-%E4%BB%96%E4%BB%AC%E9%83%BD%E5%90%84%E8%87%AA%E4%B9%B0%E4%BA%86%E4%B8%A4%E5%AF%B9%E9%BB%91%E8%A2%9C%E5%92%8C%E4%B8%A4%E5%AF%B9%E7%99%BD%E8%A2%9C%E5%85%AB%E5%AF%B9%E8%A2%9C%E5%AD%90%E7%9A%84%E5%B8%83%E8%B4%A8%E5%A4%A7%E5%B0%8F%E5%AE%8C%E5%85%A8%E7%9B%B8%E5%90%8C%E8%80%8C%E6%AF%8F%E5%AF%B9%E8%A2%9C%E5%AD%90%E9%83%BD%E6%9C%89%E4%B8%80%E5%BC%A0%E5%95%86%E6%A0%87%E7%BA%B8%E8%BF%9E%E7%9D%80%E4%B8%A4%E4%BD%8D%E7%9B%B2%E4%BA%BA%E4%B8%8D%E5%B0%8F%E5%BF%83%E5%B0%86%E5%85%AB%E5%AF%B9%E8%A2%9C%E5%AD%90%E6%B7%B7%E5%9C%A8%E4%B8%80%E8%B5%B7%E4%BB%96%E4%BB%AC%E6%AF%8F%E4%BA%BA%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E5%8F%96%E5%9B%9E%E9%BB%91%E8%A2%9C%E5%92%8C%E7%99%BD%E8%A2%9C%E5%90%84%E4%B8%A4%E5%AF%B9%E5%91%A2">14. 盲人黑白袜子问题</a></li><li><a href="#15-%E6%9C%89%E4%B8%89%E7%AD%90%E6%B0%B4%E6%9E%9C%E4%B8%80%E7%AD%90%E8%A3%85%E7%9A%84%E5%85%A8%E6%98%AF%E8%8B%B9%E6%9E%9C%E7%AC%AC%E4%BA%8C%E7%AD%90%E8%A3%85%E7%9A%84%E5%85%A8%E6%98%AF%E6%A9%98%E5%AD%90%E7%AC%AC%E4%B8%89%E7%AD%90%E6%98%AF%E6%A9%98%E5%AD%90%E4%B8%8E%E8%8B%B9%E6%9E%9C%E6%B7%B7%E5%9C%A8%E4%B8%80%E8%B5%B7%E7%AD%90%E4%B8%8A%E7%9A%84%E6%A0%87%E7%AD%BE%E9%83%BD%E6%98%AF%E9%AA%97%E4%BA%BA%E7%9A%84%E5%B0%B1%E6%98%AF%E8%AF%B4%E7%AD%90%E4%B8%8A%E7%9A%84%E6%A0%87%E7%AD%BE%E9%83%BD%E6%98%AF%E9%94%99%E7%9A%84%E4%BD%A0%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%98%AF%E6%8B%BF%E5%87%BA%E5%85%B6%E4%B8%AD%E4%B8%80%E7%AD%90%E4%BB%8E%E9%87%8C%E9%9D%A2%E5%8F%AA%E6%8B%BF%E4%B8%80%E5%8F%AA%E6%B0%B4%E6%9E%9C%E7%84%B6%E5%90%8E%E6%AD%A3%E7%A1%AE%E5%86%99%E5%87%BA%E4%B8%89%E7%AD%90%E6%B0%B4%E6%9E%9C%E7%9A%84%E6%A0%87%E7%AD%BE">15. 水果标签问题</a></li><li><a href="#16-%E4%B8%80%E4%B8%AA%E7%8F%AD%E7%BA%A760%E5%96%9C%E6%AC%A2%E8%B6%B3%E7%90%8370%E5%96%9C%E6%AC%A2%E7%AF%AE%E7%90%8380%E5%96%9C%E6%AC%A2%E6%8E%92%E7%90%83%E9%97%AE%E5%8D%B3%E4%B8%89%E7%A7%8D%E7%90%83%E9%83%BD%E5%96%9C%E6%AC%A2%E5%8D%A0%E6%AF%94%E6%9C%89%E5%A4%9A%E5%B0%91">16. 一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球，问即三种球都喜欢占比有多少？</a></li><li><a href="#17-%E4%BA%94%E5%8F%AA%E9%B8%A1%E4%BA%94%E5%A4%A9%E8%83%BD%E4%B8%8B%E4%BA%94%E4%B8%AA%E8%9B%8B%E4%B8%80%E7%99%BE%E5%A4%A9%E4%B8%8B%E4%B8%80%E7%99%BE%E4%B8%AA%E8%9B%8B%E9%9C%80%E8%A6%81%E5%A4%9A%E5%B0%91%E5%8F%AA%E9%B8%A1">17. 五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？</a></li></ul></li><li><a href="#%E5%89%91%E6%8C%87-offer-%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93">剑指 offer 思路总结</a><ul><li><a href="#%E9%A2%98%E7%9B%AE">题目</a><ul><li><a href="#1-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE">1. 二维数组中的查找</a></li><li><a href="#2-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC">2. 替换空格</a></li><li><a href="#3-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8">3. 从尾到头打印链表</a></li><li><a href="#4-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91">4. 重建二叉树</a></li><li><a href="#5-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">5. 用两个栈实现队列</a></li><li><a href="#6-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97">6. 旋转数组的最小数字</a></li><li><a href="#7-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">7. 斐波那契数列</a></li><li><a href="#8-%E8%B7%B3%E5%8F%B0%E9%98%B6">8. 跳台阶</a></li><li><a href="#9-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6">9. 变态跳台阶</a></li><li><a href="#10-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96">10. 矩形覆盖</a></li><li><a href="#11-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0">11. 二进制中1的个数</a></li><li><a href="#12-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9">12. 数值的整数次方</a></li><li><a href="#13-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2">13. 调整数组顺序使奇数位于偶数前面</a></li><li><a href="#14-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9">14. 链表中倒数第 k 个节点</a></li><li><a href="#15-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">15. 反转链表</a></li><li><a href="#16-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8">16. 合并两个排序的链表</a></li><li><a href="#17-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84">17. 树的子结构</a></li><li><a href="#18-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F">18. 二叉树的镜像</a></li><li><a href="#19-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5">19. 顺时针打印矩阵</a></li><li><a href="#20-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0-min-%E5%87%BD%E6%95%B0">20. 定义一个栈，实现 min 函数</a></li><li><a href="#21-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA">21. 栈的压入弹出</a></li><li><a href="#22-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91">22. 从上往下打印二叉树</a></li><li><a href="#23-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">23. 二叉搜索树的后序遍历</a></li><li><a href="#24-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E8%B7%AF%E5%BE%84">24. 二叉树中和为某一值路径</a></li><li><a href="#25-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6">25. 复杂链表的复制</a></li><li><a href="#26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8">26. 二叉搜索树与双向链表</a></li><li><a href="#27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97">27. 字符串的排列</a></li><li><a href="#28-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97">28. 数组中出现次数超过一半的数字</a></li><li><a href="#29-%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E4%B8%AA%E6%95%B0">29. 最小的 K 个数</a></li><li><a href="#30-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C">30. 连续子数组的最大和</a></li><li><a href="#31-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">31. 整数中1出现的次数（待深入理解）</a></li><li><a href="#32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0">32. 把数组排成最小的数</a></li><li><a href="#33-%E4%B8%91%E6%95%B0%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">33. 丑数（待深入理解）</a></li><li><a href="#34-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6">34. 第一个只出现一次的字符</a></li><li><a href="#35-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9">35. 数组中的逆序对</a></li><li><a href="#36-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9">36. 两个链表的第一个公共结点</a></li><li><a href="#37-%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0">37. 数字在排序数组中出现的次数</a></li><li><a href="#38-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6">38. 二叉树的深度</a></li><li><a href="#39-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">39. 平衡二叉树</a></li><li><a href="#40-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97">40. 数组中只出现一次的数字</a></li><li><a href="#41-%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97">41. 和为 S 的连续正数序列</a></li><li><a href="#42-%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97">42. 和为 S 的两个数字</a></li><li><a href="#43-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2">43. 左旋转字符串</a></li><li><a href="#44-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97">44. 翻转单词顺序列</a></li><li><a href="#45-%E6%89%91%E5%85%8B%E7%89%8C%E7%9A%84%E9%A1%BA%E5%AD%90">45. 扑克牌的顺子</a></li><li><a href="#46-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98">46. 圆圈中最后剩下的数字（约瑟夫环问题）</a></li><li><a href="#47-123n">47. 1 2 3 … n</a></li><li><a href="#48-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95">48. 不用加减乘除做加法</a></li><li><a href="#49-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0">49. 把字符串转换成整数。</a></li><li><a href="#50-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97">50. 数组中重复的数字</a></li><li><a href="#51-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84">51. 构建乘积数组</a></li><li><a href="#52-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8C%B9%E9%85%8D">52. 正则表达式的匹配</a></li><li><a href="#53-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2">53. 表示数值的字符串</a></li><li><a href="#54-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6">54. 字符流中第一个不重复的字符</a></li><li><a href="#55-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9">55. 链表中环的入口结点</a></li><li><a href="#56-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9">56. 删除链表中重复的结点</a></li><li><a href="#57-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9">57. 二叉树的下一个结点</a></li><li><a href="#58-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91">58. 对称二叉树</a></li><li><a href="#59-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">59. 按之字形顺序打印二叉树（待深入理解）</a></li><li><a href="#60-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%8C%89%E5%B1%82%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8C%E4%B8%80%E5%B1%82%E7%BB%93%E7%82%B9%E4%BB%8E%E5%B7%A6%E8%87%B3%E5%8F%B3%E8%BE%93%E5%87%BA%E6%AF%8F%E4%B8%80%E5%B1%82%E8%BE%93%E5%87%BA%E4%B8%80%E8%A1%8C">60. 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</a></li><li><a href="#61-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">61. 序列化二叉树（待深入理解）</a></li><li><a href="#62-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9">62. 二叉搜索树的第 K 个节点</a></li><li><a href="#63-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">63. 数据流中的中位数（待深入理解）</a></li><li><a href="#64-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">64. 滑动窗口中的最大值（待深入理解）</a></li><li><a href="#65-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">65. 矩阵中的路径（待深入理解）</a></li><li><a href="#66-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">66. 机器人的运动范围（待深入理解）</a></li></ul></li><li><a href="#%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98">相关算法题</a><ul><li><a href="#1-%E6%98%8E%E6%98%9F%E9%97%AE%E9%A2%98">1. 明星问题</a></li><li><a href="#2-%E6%AD%A3%E8%B4%9F%E6%95%B0%E7%BB%84%E6%B1%82%E5%92%8C">2. 正负数组求和</a></li></ul></li></ul></li></ul><h1 id="常用算法和数据结构总结"><a href="#常用算法和数据结构总结" class="headerlink" title="常用算法和数据结构总结"></a>常用算法和数据结构总结</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序的基本思想是，对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟会将最小或最大的元素“浮”到顶端，<br>最终达到完全有序。</p><p>代码实现：</p><pre><code class="js">function bubbleSort(arr) {    if (!Array.isArray(arr) || arr.length &lt;= 1) return;    let lastIndex = arr.length - 1;    while (lastIndex &gt; 0) { // 当最后一个交换的元素为第一个时，说明后面全部排序完毕        let flag = true, k = lastIndex;        for (let j = 0; j &lt; k; j++) {            if (arr[j] &gt; arr[j + 1]) {                flag = false;                  lastIndex = j; // 设置最后一次交换元素的位置                [arr[j], arr[j+1]] = [arr[j+1], arr[j]];            }        }          if (flag) break;    }}</code></pre><p>冒泡排序有两种优化方式。</p><p>一种是外层循环的优化，我们可以记录当前循环中是否发生了交换，如果没有发生交换，则说明该序列已经为有序序列了。<br>因此我们不需要再执行之后的外层循环，此时可以直接结束。</p><p>一种是内层循环的优化，我们可以记录当前循环中最后一次元素交换的位置，该位置以后的序列都是已排好的序列，因此下<br>一轮循环中无需再去比较。</p><p>优化后的冒泡排序，当排序序列为已排序序列时，为最好的时间复杂度为 O(n)。</p><p>冒泡排序的平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6103002.html">《图解排序算法(一)》</a><br><a href="http://bubkoo.com/2014/01/15/sort-algorithm/shaker-sort/">《常见排序算法 - 鸡尾酒排序 》</a><br><a href="https://juejin.im/post/5b72f0caf265da282809f3b5#heading-1">《前端笔试&amp;面试爬坑系列—算法》</a><br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc724af265da610f632e41">《前端面试之道》</a></p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序的基本思想为每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止。</p><p>在算法实现时，每一趟确定最小元素的时候会通过不断地比较交换来使得首位置为当前最小，交换是个比较耗时的操作。其实<br>我们很容易发现，在还未完全确定当前最小元素之前，这些交换都是无意义的。我们可以通过设置一个变量 min，每一次比较<br>仅存储较小元素的数组下标，当轮循环结束之后，那这个变量存储的就是当前最小元素的下标，此时再执行交换操作即可。</p><p>代码实现：</p><pre><code class="js">function selectSort(array) {  let length = array.length;  // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序   if (!Array.isArray(array) || length &lt;= 1) return;  for (let i = 0; i &lt; length - 1; i++) {    let minIndex = i; // 设置当前循环最小元素索引    for (let j = i + 1; j &lt; length; j++) {      // 如果当前元素比最小元素索引，则更新最小元素索引      if (array[minIndex] &gt; array[j]) {        minIndex = j;      }    }    // 交换最小元素到当前位置    // [array[i], array[minIndex]] = [array[minIndex], array[i]];    swap(array, i, minIndex);  }  return array;}// 交换数组中两个元素的位置function swap(array, left, right) {  var temp = array[left];  array[left] = array[right];  array[right] = temp;}</code></pre><p>选择排序不管初始序列是否有序，时间复杂度都为 O(n²)。</p><p>选择排序的平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，不是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6103002.html">《图解排序算法(一)》</a></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>直接插入排序基本思想是每一步将一个待排序的记录，插入到前面已经排好序的有序序列中去，直到插完所有元素为止。</p><p>插入排序核心–扑克牌思想： 就想着自己在打扑克牌，接起来一张，放哪里无所谓，再接起来一张，比第一张小，放左边，<br>继续接，可能是中间数，就插在中间….依次</p><p>代码实现：</p><pre><code class="js">function insertSort(array) {  let length = array.length;  // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序   if (!Array.isArray(array) || length &lt;= 1) return;  // 循环从 1 开始，0 位置为默认的已排序的序列  for (let i = 1; i &lt; length; i++) {    let temp = array[i]; // 保存当前需要排序的元素    let j = i;    // 在当前已排序序列中比较，如果比需要排序的元素大，就依次往后移动位置    while (j -1 &gt;= 0 &amp;&amp; array[j - 1] &gt; temp) {      array[j] = array[j - 1];      j--;    }    // 将找到的位置插入元素    array[j] = temp;  }  return array;}</code></pre><p>当排序序列为已排序序列时，为最好的时间复杂度 O(n)。</p><p>插入排序的平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6103002.html">《图解排序算法(一)》</a></p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序的基本思想是把数组按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的元<br>素越来越多，当增量减至1时，整个数组恰被分成一组，算法便终止。</p><p>代码实现：</p><pre><code class="js">function hillSort(array) {  let length = array.length;  // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序   if (!Array.isArray(array) || length &lt;= 1) return;  // 第一层确定增量的大小，每次增量的大小减半  for (let gap = parseInt(length &gt;&gt; 1); gap &gt;= 1; gap = parseInt(gap &gt;&gt; 1)) {    // 对每个分组使用插入排序，相当于将插入排序的1换成了 n    for (let i = gap; i &lt; length; i++) {      let temp = array[i];      let j = i;      while (j - gap &gt;= 0 &amp;&amp; array[j - gap] &gt; temp) {        array[j] = array[j - gap];        j -= gap;      }      array[j] = temp;    }  }  return array;}</code></pre><p>希尔排序是利用了插入排序对于已排序序列排序效果最好的特点，在一开始序列为无序序列时，将序列分为多个小的分组进行<br>基数排序，由于排序基数小，每次基数排序的效果较好，然后在逐步增大增量，将分组的大小增大，由于每一次都是基于上一<br>次排序后的结果，所以每一次都可以看做是一个基本排序的序列，所以能够最大化插入排序的优点。</p><p>简单来说就是，由于开始时每组只有很少整数，所以排序很快。之后每组含有的整数越来越多，但是由于这些数也越来越有序，<br>所以排序速度也很快。</p><p>希尔排序的时间复杂度根据选择的增量序列不同而不同，但总的来说时间复杂度是小于 O(n^2) 的。</p><p>插入排序是一个稳定排序，但是在希尔排序中，由于相同的元素可能在不同的分组中，所以可能会造成相同元素位置的变化，<br>所以希尔排序是一个不稳定的排序。</p><p>希尔排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(n^s) ，空间复杂度为 O(1) ，不是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6104371.html">《图解排序算法(二)之希尔排序》</a><br><a href="https://blog.csdn.net/u013630349/article/details/48250109">《数据结构基础 希尔排序 之 算法复杂度浅析》</a></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略。递归的将数组两两分开直到只包含一个元素，然后<br>将数组排序合并，最终合并为排序好的数组。</p><p>代码实现：</p><pre><code class="js">function mergeSort(array) {  let length = array.length;  // 如果不是数组或者数组长度小于等于0，直接返回，不需要排序   if (!Array.isArray(array) || length === 0) return;  if (length === 1) {    return array;  }  let mid = parseInt(length &gt;&gt; 1), // 找到中间索引值    left = array.slice(0, mid), // 截取左半部分    right = array.slice(mid, length); // 截取右半部分  return merge(mergeSort(left), mergeSort(right)); // 递归分解后，进行排序合并}function merge(leftArray, rightArray) {  let result = [],    leftLength = leftArray.length,    rightLength = rightArray.length,    il = 0,    ir = 0;  // 左右两个数组的元素依次比较，将较小的元素加入结果数组中，直到其中一个数组的元素全部加入完则停止  while (il &lt; leftLength &amp;&amp; ir &lt; rightLength) {    if (leftArray[il] &lt; rightArray[ir]) {      result.push(leftArray[il++]);    } else {      result.push(rightArray[ir++]);    }  }  // 如果是左边数组还有剩余，则把剩余的元素全部加入到结果数组中。  while (il &lt; leftLength) {    result.push(leftArray[il++]);  }  // 如果是右边数组还有剩余，则把剩余的元素全部加入到结果数组中。  while (ir &lt; rightLength) {    result.push(rightArray[ir++]);  }  return result;}</code></pre><p>归并排序将整个排序序列看成一个二叉树进行分解，首先将树分解到每一个子节点，树的每一层都是一个归并排序的过程，每<br>一层归并的时间复杂度为 O(n)，因为整个树的高度为 lgn，所以归并排序的时间复杂度不管在什么情况下都为O(nlogn)。</p><p>归并排序的空间复杂度取决于递归的深度和用于归并时的临时数组，所以递归的深度为 logn，临时数组的大小为 n，所以归<br>并排序的空间复杂度为 O(n)。</p><p>归并排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(nlogn) ，空间复杂度为 O(n) ，是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6194356.html">《图解排序算法(四)之归并排序》</a><br><a href="https://www.zhihu.com/question/27274006">《归并排序的空间复杂度？》</a></p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序的基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据<br>都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>代码实现：</p><pre><code class="js">function quickSort(array, start, end) {  let length = array.length;  // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序   if (!Array.isArray(array) || length &lt;= 1 || start &gt;= end) return;  let index = partition(array, start, end); // 将数组划分为两部分，并返回右部分的第一个元素的索引值  quickSort(array, start, index - 1); // 递归排序左半部分  quickSort(array, index + 1, end); // 递归排序右半部分}function partition(array, start, end) {  let pivot = array[start]; // 取第一个值为枢纽值，获取枢纽值的大小  // 当 start 等于 end 指针时结束循环  while (start &lt; end) {    // 当 end 指针指向的值大等于枢纽值时，end 指针向前移动    while (array[end] &gt;= pivot &amp;&amp; start &lt; end) {      end--;    }    // 将比枢纽值小的值交换到 start 位置    array[start] = array[end];    // 移动 start 值，当 start 指针指向的值小于枢纽值时，start 指针向后移动    while (array[start] &lt; pivot &amp;&amp; start &lt; end) {      start++;    }    // 将比枢纽值大的值交换到 end 位置，进入下一次循环    array[end] = array[start];  }  // 将枢纽值交换到中间点  array[start] = pivot;  // 返回中间索引值  return start;}</code></pre><p>这一种方法是填空法，首先将第一个位置的数作为枢纽值，然后 end 指针向前移动，当遇到比枢纽值小的值或者 end 值<br>等于 start 值的时候停止，然后将这个值填入 start 的位置，然后 start 指针向后移动，当遇到比枢纽值大的值或者<br>start 值等于 end 值的时候停止，然后将这个值填入 end 的位置。反复循环这个过程，直到 start 的值等于 end 的<br>值为止。将一开始保留的枢纽值填入这个位置，此时枢纽值左边的值都比枢纽值小，枢纽值右边的值都比枢纽值大。然后在递<br>归左右两边的的序列。</p><p>当每次换分的结果为含 ⌊n/2⌋和 ⌈n/2⌉−1 个元素时，最好情况发生，此时递归的次数为 logn，然后每次划分的时间复杂<br>度为 O(n)，所以最优的时间复杂度为 O(nlogn)。一般来说只要每次换分都是常比例的划分，时间复杂度都为 O(nlogn)。</p><p>当每次换分的结果为 n-1 和 0 个元素时，最坏情况发生。划分操作的时间复杂度为 O(n)，递归的次数为 n-1，所以最坏<br>的时间复杂度为 O(n²)。所以当排序序列有序的时候，快速排序有可能被转换为冒泡排序。</p><p>快速排序的空间复杂度取决于递归的深度，所以最好的时候为 O(logn)，最坏的时候为 O(n)。</p><p>快速排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(logn) ，不是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6262208.html">《图解排序算法(五)之快速排序——三数取中法》</a><br><a href="https://segmentfault.com/a/1190000004410119#articleHeader2">《关于快速排序的四种写法》</a><br><a href="https://harttle.land/2015/09/27/quick-sort.html">《快速排序的时间和空间复杂度》</a><br><a href="https://blog.csdn.net/weshjiness/article/details/8660583">《快速排序最好，最坏，平均复杂度分析》</a><br><a href="https://blog.csdn.net/qq_33758761/article/details/76782610">《快速排序算法的递归深度》</a></p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行<br>交换，此时末尾就为最大值。然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，<br>便能得到一个有序序列了。</p><pre><code class="js">function heapSort(array) {  let length = array.length;  // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序   if (!Array.isArray(array) || length &lt;= 1) return;  buildMaxHeap(array); // 将传入的数组建立为大顶堆  // 每次循环，将最大的元素与末尾元素交换，然后剩下的元素重新构建为大顶堆  for (let i = length - 1; i &gt; 0; i--) {    swap(array, 0, i);    adjustMaxHeap(array, 0, i); // 将剩下的元素重新构建为大顶堆  }  return array;}function adjustMaxHeap(array, index, heapSize) {  let iMax,    iLeft,    iRight;  while (true) {    iMax = index; // 保存最大值的索引    iLeft = 2 * index + 1; // 获取左子元素的索引    iRight = 2 * index + 2; // 获取右子元素的索引    // 如果左子元素存在，且左子元素大于最大值，则更新最大值索引    if (iLeft &lt; heapSize &amp;&amp; array[iMax] &lt; array[iLeft]) {      iMax = iLeft;    }    // 如果右子元素存在，且右子元素大于最大值，则更新最大值索引    if (iRight &lt; heapSize &amp;&amp; array[iMax] &lt; array[iRight]) {      iMax = iRight;    }    // 如果最大元素被更新了，则交换位置，使父节点大于它的子节点，同时将索引值跟新为被替换的值，继续检查它的子树    if (iMax !== index) {      swap(array, index, iMax);      index = iMax;    } else {      // 如果未被更新，说明该子树满足大顶堆的要求，退出循环      break;    }  }}// 构建大顶堆function buildMaxHeap(array) {  let length = array.length,    iParent = parseInt(length &gt;&gt; 1) - 1; // 获取最后一个非叶子点的元素  for (let i = iParent; i &gt;= 0; i--) {    adjustMaxHeap(array, i, length); // 循环调整每一个子树，使其满足大顶堆的要求  }}// 交换数组中两个元素的位置function swap(array, i, j) {  let temp = array[i];  array[i] = array[j];  array[j] = temp;}</code></pre><p>建立堆的时间复杂度为 O(n)，排序循环的次数为 n-1，每次调整堆的时间复杂度为 O(logn)，因此堆排序的时间复杂度在<br>不管什么情况下都是 O(nlogn)。</p><p>堆排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(nlogn) ，空间复杂度为 O(1) ，不是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6129630.html">《图解排序算法(三)之堆排序》</a><br><a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/">《常见排序算法 - 堆排序 (Heap Sort)》</a><br><a href="https://www.zhihu.com/question/20729324">《堆排序中建堆过程时间复杂度O(n)怎么来的？》</a><br><a href="https://blog.csdn.net/YuZhiHui_No1/article/details/44258297">《排序算法之 堆排序 及其时间复杂度和空间复杂度》</a><br><a href="https://blog.csdn.net/hrn1216/article/details/51465270">《最小堆 构建、插入、删除的过程图解》</a></p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。排序过程：将<br>所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样<br>从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p><p>代码实现：</p><pre><code class="js">function radixSort(array) {  let length = array.length;  // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序   if (!Array.isArray(array) || length &lt;= 1) return;  let bucket = [],    max = array[0],    loop;  // 确定排序数组中的最大值  for (let i = 1; i &lt; length; i++) {    if (array[i] &gt; max) {      max = array[i];    }  }  // 确定最大值的位数  loop = (max + '').length;  // 初始化桶  for (let i = 0; i &lt; 10; i++) {    bucket[i] = [];  }  for (let i = 0; i &lt; loop; i++) {    for (let j = 0; j &lt; length; j++) {      let str = array[j] + '';      if (str.length &gt;= i + 1) {        let k = parseInt(str[str.length - 1 - i]); // 获取当前位的值，作为插入的索引        bucket[k].push(array[j]);      } else {        // 处理位数不够的情况，高位默认为 0        bucket[0].push(array[j]);      }    }    array.splice(0, length); // 清空旧的数组    // 使用桶重新初始化数组    for (let i = 0; i &lt; 10; i++) {      let t = bucket[i].length;      for (let j = 0; j &lt; t; j++) {        array.push(bucket[i][j]);      }      bucket[i] = [];    }  }  return array;}</code></pre><p>基数排序的平均时间复杂度为 O(nk)，k 为最大元素的长度，最坏时间复杂度为 O(nk)，空间复杂度为 O(n) ，是稳定<br>排序。</p><p>详细资料可以参考：<br><a href="http://bubkoo.com/2014/01/15/sort-algorithm/radix-sort/">《常见排序算法 - 基数排序》</a><br><a href="https://blog.csdn.net/YuZhiHui_No1/article/details/44594415">《排序算法之 基数排序 及其时间复杂度和空间复杂度》</a></p><p>算法总结可以参考：<br><a href="https://blog.csdn.net/zolalad/article/details/11848739">《算法的时间复杂度和空间复杂度-总结》</a><br><a href="https://www.cnblogs.com/onepixel/p/7674659.html">《十大经典排序算法（动图演示）》</a><br><a href="https://blog.csdn.net/wangiijing/article/details/51485119">《各类排序算法的对比及实现》</a></p><h3 id="快速排序相对于其他排序效率更高的原因"><a href="#快速排序相对于其他排序效率更高的原因" class="headerlink" title="快速排序相对于其他排序效率更高的原因"></a>快速排序相对于其他排序效率更高的原因</h3><p>上面一共提到了8种排序的方法，在实际使用中，应用最广泛的是快速排序。快速排序相对于其他排序算法的优势在于在相同<br>数据量的情况下，它的运算效率最高，并且它额外所需空间最小。</p><p>我们首先从时间复杂度来判断，由于前面几种方法的时间复杂度平均情况下基本趋向于 O(n²)，因此只从时间复杂度上来看<br>的话，显然归并排序、堆排序和快速排序的时间复杂度最小。但是既然这几种方法的时间复杂度基本一致，并且快速排序在最<br>坏情况下时间的复杂度还会变为 O(n²)，那么为什么它的效率反而更高呢？</p><p>首先在对大数据量排序的时候，由于归并排序的空间复杂度为 O(n)，因此归并排序在这种情况下会需要过多的额外内存，因<br>此归并排序首先就被排除掉了。</p><p>接下来就剩下了堆排序和快速排序的比较。我认为堆排序相对于快速排序的效率不高的原因有两个方面。</p><p>第一个方面是对于比较操作的有效性来说。对于快速排序来说，每一次元素的比较都会确定该元素在数组中的位置，也就是在<br>枢纽值的左边或者右边，快速排序的每一次比较操作都是有意义的结果。而对于堆排序来说，在每一次重新调整堆的时候，我<br>们在迭代时，已经知道上层的节点值一定比下层的节点值大，因此当我们每次为了打乱堆结构而将最后一个元素与堆顶元素互<br>换时，互换后的元素一定是比下层元素小的，因此我们知道比较结果却还要在堆结构调整时去进行再一次的比较，这样的比较<br>是没有意义的，以此在堆排序中会产生大量的没有意义的比较操作。</p><p>第二个方面是对于缓存局部性原理的利用上来考虑的，我认为这应该是造成堆排序的效率不如快速排序的主要原因。在计算机<br>中利用了多级缓存的机制，来解决 cpu 计算速度与存储器数据读取速度间差距过大的问题。缓存的原理主要是基于局部性原<br>理，局部性原理简单来说就是，当前被访问过的数据，很有可能在一段时间内被再次访问，这被称为时间局部性。还有就是当<br>前访问的数据，那么它相邻的数据，也有可能在一段时间内被访问到，这被称为空间局部性。计算机缓存利用了局部性的原理<br>来对数据进行缓存，来尽可能少的减少磁盘的 I/O 次数，以此来提高执行效率。对于堆排序来说，它最大的问题就是它对于<br>空间局部性的违背，它在进行比较时，比较的并不是相邻的元素，而是与自己相隔很远的元素，这对于利用空间局部性来进行<br>数据缓存的计算机来说，它的很多缓存都是无效的。并且对于大数据量的排序来说，缓存的命中率就会变得很低，因此会明显<br>提高磁盘的 I/O 次数，并且由于堆排序的大量的无效比较，因此这样就造成了堆排序执行效率的低下。而相对来快速排序来<br>说，它的排序每一次都是在相邻范围内的比较，并且比较的范围越来越小，它很好的利用了局部性原理，因此它的执行效率更<br>高。简单来说就是在堆排序中获取一个元素的值所花费的时间比在快速排序获取一个元素的值所花费的时间要大。因此我们可<br>以看出，时间复杂度类似的算法，在计算机中实际执行可能会有很大的差别，因为决定算法执行效率的还有内存读取这样的其<br>他的因素。</p><p>相关资料可以参考：<br><a href="https://www.zhihu.com/question/23873747">《为什么在平均情况下快速排序比堆排序要优秀？》</a><br><a href="https://blog.csdn.net/qq_36770641/article/details/82669788">《为什么说快速排序是性能最好的排序算法？》</a></p><h3 id="系统自带排序实现"><a href="#系统自带排序实现" class="headerlink" title="系统自带排序实现"></a>系统自带排序实现</h3><p>每个语言的排序内部实现都是不同的。</p><p>对于 JS 来说，数组长度大于 10 会采用快排，否则使用插入排序。选择插入排序是因为虽然时间复杂度很差，但是在数据<br>量很小的情况下和 O(N * logN) 相差无几，然而插入排序需要的常数时间很小，所以相对别的排序来说更快。</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>稳定性的意思就是对于相同值来说，相对顺序不能改变。通俗的讲有两个相同的数 A 和 B，在排序之前 A 在 B 的前面，<br>而经过排序之后，B 跑到了 A 的前面，对于这种情况的发生，我们管他叫做排序的不稳定性。</p><p>稳定性有什么意义？个人理解对于前端来说，比如我们熟知框架中的虚拟 DOM 的比较，我们对一个<code>&lt;ul&gt;</code>列表进行渲染，<br>当数据改变后需要比较变化时，不稳定排序或操作将会使本身不需要变化的东西变化，导致重新渲染，带来性能的损耗。</p><h3 id="排序面试题目总结"><a href="#排序面试题目总结" class="headerlink" title="排序面试题目总结"></a>排序面试题目总结</h3><ol><li><p>快速排序在完全无序的情况下效果最好，时间复杂度为O(nlogn)，在有序情况下效果最差，时间复杂度为O(n^2)。</p></li><li><p>初始数据集的排列顺序对算法的性能无影响的有堆排序，直接选择排序，归并排序，基数排序。</p></li><li><p>合并 m 个长度为 n 的已排序数组的时间复杂度为 O(nmlogm)。</p></li><li><p>外部排序常用的算法是归并排序。</p></li><li><p>数组元素基本有序的情况下，插入排序效果最好，因为这样只需要比较大小，不需要移动，时间复杂度趋近于O(n)。</p></li><li><p>如果只想得到1000个元素组成的序列中第5个最小元素之前的部分排序的序列，用堆排序方法最快。</p></li><li><p>插入排序和优化后的冒泡在最优情况（有序）都只用比较 n-1 次。</p></li><li><p>对长度为 n 的线性表作快速排序，在最坏情况下，比较次数为 n(n-1)/2。</p></li><li><p>下标从1开始，在含有 n 个关键字的小根堆（堆顶元素最小）中，关键字最大的记录有可能存储在 [n/2]+2 位置上。<br>因为小根堆中最大的数一定是放在叶子节点上，堆本身是个完全二叉树，完全二叉树的叶子节点的位置大于 [n/2]。</p></li><li><p>拓扑排序的算法，每次都选择入度为0的结点从图中删去，并从图中删除该顶点和所有以它为起点的有向边。</p></li><li><p>任何一个基于”比较”的内部排序的算法，若对 n 个元素进行排序，则在最坏情况下所需的比较次数 k 满足 2^k &gt; n!，<br>时间下界为 O(nlogn)</p></li><li><p>m 个元素 k 路归并的归并趟数 s=logk(m)，代入数据：logk(100)≦3</p></li><li><p>对 n 个记录的线性表进行快速排序为减少算法的递归深度，每次分区后，先处理较短的部分。</p></li><li><p>在用邻接表表示图时，拓扑排序算法时间复杂度为 O(n+e)</p></li></ol><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树相关性质"><a href="#二叉树相关性质" class="headerlink" title="二叉树相关性质"></a>二叉树相关性质</h3><ol><li><p>节点的度：一个节点含有的子树的个数称为该节点的度；</p></li><li><p>叶节点或终端节点：度为零的节点； </p></li><li><p>节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推。 </p></li><li><p>树的高度或深度：树中节点的最大层次。</p></li><li><p>在非空二叉树中，第 i 层的结点总数不超过 2^(i-1)，i&gt;=1。 </p></li><li><p>深度为 h 的二叉树最多有 2^h-1个结点(h&gt;=1)，最少有 h 个结点。</p></li><li><p>对于任意一棵二叉树，如果其叶结点数为 N0，而度数为2的结点总数为 N2，则 N0 = N2+1； </p></li><li><p>给定 N 个节点，能构成 h(N) 种不同的二叉树。h(N)为卡特兰数的第 N 项。(2n)!/(n!(n+1)!)。</p></li><li><p>二叉树的前序遍历，首先访问根结点，然后遍历左子树，最后遍历右子树。简记根-左-右。 </p></li><li><p>二叉树的中序遍历，首先遍历左子树，然后访问根结点，最后遍历右子树。简记左-根-右。 </p></li><li><p>二叉树的后序遍历，首先遍历左子树，然后遍历右子树，最后访问根结点。简记左-右-根。</p></li><li><p>二叉树是非线性数据结构，但是顺序存储结构和链式存储结构都能存储。</p></li><li><p>一个带权的无向连通图的最小生成树的权值之和是唯一的。</p></li><li><p>只有一个结点的二叉树的度为 0 。</p></li><li><p>二叉树的度是以节点的最大的度数定义的。</p></li><li><p>树的后序遍历序列等同于该树对应的二叉树的中序序列。</p></li><li><p>树的先序遍历序列等同于该树对应的二叉树的先序序列。 </p></li><li><p>线索二叉树的线索实际上指向的是相应遍历序列特定结点的前驱结点和后继结点，所以先写出二叉树的中序遍历序列：<br>debxac，中序遍历中在x左边和右边的字符，就是它在中序线索化的左、右线索，即 b、a 。</p></li><li><p>递归式的先序遍历一个 n 节点，深度为 d 的二叉树，需要栈空间的大小为 O（d），因为二叉树并不一定是平衡的，<br>也就是深度d！=logn，有可能d&gt;&gt;logn。所以栈大小应该是O（d）</p></li><li><p>一棵具有 N 个结点的二叉树的前序序列和后序序列正好相反 ，则该二叉树一定满足该二叉树只有左子树或只有右子树，<br>即该二叉树一定是一条链（二叉树的高度为N，高度等于结点数）。</p></li><li><p>引入二叉线索树的目的是加快查找结点的前驱或后继的速度。</p></li><li><p>二叉树线索化后，先序线索化与后序线索化最多有1个空指针域，而中序线索化最多有2个空指针域。</p></li><li><p>不管是几叉树，节点数等于=分叉数+1</p></li><li><p>任何一棵二叉树的叶子结点在先序、中序和后序遍历中的相对次序不发生改变。</p></li></ol><p>详细资料可以参考：<br><a href="https://blog.csdn.net/adminabcd/article/details/46672759">《n 个节点的二叉树有多少种形态》</a><br><a href="https://www.cnblogs.com/guoyaohua/p/8595289.html">《数据结构二叉树知识点总结》</a><br><a href="https://www.jianshu.com/p/2943a21d2a99">《还原二叉树–已知先序中序或者后序中序》</a><br><a href="https://blog.csdn.net/linraise/article/details/11745559">《树、森林与二叉树的转换》</a></p><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>对于一棵二叉树，如果每一个非叶子节点都存在左右子树，并且二叉树中所有的叶子节点都在同一层中，这样的二叉树称为满<br>二叉树。</p><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>对于一棵具有 n 个节点的二叉树按照层次编号，同时，左右子树按照先左后右编号，如果编号为 i 的节点与同样深度的满<br>二叉树中编号为i的节点在满二叉树中的位置完全相同，则这棵二叉树称为完全二叉树。</p><p>性质：</p><ol><li><p>具有 n 个结点的完全二叉树的深度为 K =[log2n」+1(取下整数) </p></li><li><p>有 N 个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系： 若 I 为结点编号（从1开始编号）则<br>如果 I&gt;1，则其父结点的编号为 I/2；</p></li><li><p>完全二叉树，如果 2 * I &lt;= N，则其左儿子（即左子树的根结点）的编号为2 * I；若2 * I &gt; N，则无左儿子；如<br>果 2 * I + 1 &lt;= N，则其右儿子的结点编号为 2 * I + 1；若 2 * I + 1 &gt; N，则无右儿子。</p></li></ol><h3 id="平衡二叉查找树（AVL）"><a href="#平衡二叉查找树（AVL）" class="headerlink" title="平衡二叉查找树（AVL）"></a>平衡二叉查找树（AVL）</h3><p>平衡二叉查找树具有如下几个性质：</p><ol><li>可以是空树。</li><li>假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过1。</li></ol><p>平衡二叉树是为了解决二叉查找树中出现链式结构（只有左子树或只有右子树）的情况，这样的情况出现后对我们的查找没有<br>一点帮帮助，反而增加了维护的成本。</p><p>平衡因子使用两个字母来表示。第一个字母表示最小不平衡子树根结点的平衡因子，第二个字母表示最小不平衡子树较高子树<br>的根结点的平衡因子。根据不同的情况使用不同的方法来调整失衡的子树。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/suimeng/p/4560056.html">《平衡二叉树，AVL树之图解篇》</a></p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><p>B-树主要用于文件系统以及部分数据库索引，如 MongoDB。使用 B-树来作为数据库的索引主要是为了减少查找是磁盘的 I/O<br>次数。试想，如果我们使用二叉查找树来作为索引，那么查找次数的最坏情况等于二叉查找树的高度，由于索引存储在磁盘中，<br>我们每次都只能加载对应索引的磁盘页进入内存中比较，那么磁盘的 I/O 次数就等于索引树的高度。所以采用一种办法来减少<br>索引树的高度是提高索引效率的关键。</p><p>B-树是一种多路平衡查找树，它的每一个节点最多包含 K 个子节点，K 被称为 B-树的阶，K 的大小取决于磁盘页的大小。每<br>个节点中的元素从小到大排列，节点当中 k-1 个元素正好是 k 个孩子包含的元素的值域分划。简单来说就是以前一个磁盘页<br>只存储一个索引的值，但 B-树中一个磁盘页中存储了多个索引的值，因此在相同的比较范围内，B-树相对于一般的二叉查找树<br>的高度更小。其实它的主要目的就是每次尽可能多的将索引值加载入内存中进行比较，以此来减少磁盘的 I/O 次数，其实就查<br>找次数而言，和二叉查找树比较差不了多少，只是说这个比较过程是在内存中完成的，速度更快而已。</p><p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;mid=2650561220&amp;idx=1&amp;sn=2a6d8a0290f967027b1d54456f586405&amp;chksm=f1feec47c689655113fa65f7911a1f59bbd994030ad685152b30e53d643049f969eefaa13058&amp;scene=21#wechat_redirect">《漫画：什么是 B- 树？》</a></p><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h3><p>B+ 树相对于 B-树有着更好的查找性能，根据 B-树我们可以知道，要想加快索引速度的方法就是尽量减少磁盘 I/O 的次数。<br>B+ 树相对于 B-的主要变化是，每个中间节点中不再包含卫星数据，只有叶子节点包含卫星数据，每个父节点都出现在子节点<br>中，叶子节点依次相连，形成一个顺序链表。中间节点不包含卫星数据，只用来作为索引使用，这意味着每一个磁盘页中能够<br>包含更多的索引值。因此 B+ 树的高度相对于 B-来说更低，所以磁盘的 I/O 次数更少。由于叶子节点依次相连，并且包含<br>了父节点，所以可以通过叶子节点来找到对应的值。同时 B+ 树所有查询都要查找到叶子节点，查询性能比 B-树稳定。</p><p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;mid=2650561244&amp;idx=1&amp;sn=df3abafd3aa2f5a3abfe507bfc26982f&amp;chksm=f1feec5fc6896549f89cbb82ee3d8010c63da76814030b285fa29322795de512ccca207064ee&amp;scene=21#wechat_redirect">《漫画：什么是 B+ 树？》</a></p><h3 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h3><p>数据库以 B 树或者 B+ 树格式来储存的数据的，一张表是根据主键来构建的树的结构。因此如果想查找其他字段，就需要建<br>立索引，我对于索引的理解是它就是以某个字段为关键字的 B 树文件，通过这个 B 树文件就能够提高数据查找的效率。但是<br>由于我们需要维护的是平衡树的结构，因此对于数据的写入、修改、删除就会变慢，因为这有可能会涉及到树的平衡调整。</p><p>相关资料可以参考：<br><a href="https://zhuanlan.zhihu.com/p/23624390">《深入浅出数据库索引原理》</a><br><a href="http://www.ruanyifeng.com/blog/2014/07/database_implementation.html">《数据库的最简单实现》</a></p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树是一种自平衡的二叉查找树，它主要是为了解决不平衡的二叉查找树的查找效率不高的缺点。红黑树保证了从根到叶子<br>节点的最长路径不会超过最短路径的两倍。</p><p>红黑树的有具体的规则：</p><p>1.节点是红色或黑色。</p><p>2.根节点是黑色。</p><p>3.每个叶子节点都是黑色的空节点（NIL节点）。</p><p>4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</p><p>5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p><p>当红黑树发生删除和插入导致红黑树不满足这些规则时，需要通过处理，使其重新满足这些规则。</p><p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;mid=2650561574&amp;idx=1&amp;sn=edab54460a85c9686e0ec0f5d178907c&amp;chksm=f1feeaa5c68963b3689d23db68ab14a9c50a33dd5e9244a74d7765321b42af7ec14abfadf9ac&amp;scene=21#wechat_redirect">《漫画：什么是红黑树？》</a><br><a href="https://cloud.tencent.com/developer/article/1101517">《漫画算法等精选文章目录》</a></p><h3 id="Huffman-树"><a href="#Huffman-树" class="headerlink" title="Huffman 树"></a>Huffman 树</h3><p>给定 n 权值作为 n 个叶子节点，构造一棵二叉树，若这棵二叉树的带权路径长度达到最小，则称这样的二叉树为最优二叉<br>树，也称为 Huffman 树。</p><p>利用 Huffman 树对每一个字符编码，该编码又称为 Huffman 编码，Huffman 编码是一种前缀编码，即一个字符的编码<br>不是另一个字符编码的前缀。</p><p>性质：</p><ol><li><p>对应一组权重构造出来的 Huffman 树一般不是唯一的</p></li><li><p>Huffman 树具有最小的带权路径长度</p></li><li><p>Huffman 树中没有度为1的结点</p></li><li><p>哈夫曼树是带权路径长度最短的树，路径上权值较大的结点离根较近</p></li><li><p>Huffman 树的带权路径长度 WPL 等于各叶子结点的带权路径长度之和</p></li></ol><p>详细资料可以参考：</p><p><a href="https://blog.csdn.net/google19890102/article/details/54848262">《数据结构和算法—— Huffman 树和 Huffman 编码》</a><br><a href="https://blog.csdn.net/fx677588/article/details/70767446">《详细图解哈夫曼 Huffman 编码树》</a></p><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>二叉查找树是一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中，这一特性使得查找的效率很高，<br>对于数值型和非数值型数据，比如字母和字符串，都是如此。</p><p>实现树节点类：</p><pre><code class="js">// 节点类，树的节点class Node {  constructor(value) {    this.value = value;    this.left = null;    this.right = null;  }  show() {    console.log(this.value);  }}</code></pre><p>实现二叉查找树类：</p><pre><code class="js">class BinarySearchTree {  constructor() {    this.root = null  }}</code></pre><p>实现树的节点插入方法</p><p>节点插入的基本思想是将插入节点和当前节点做比较，如果比当前节点值小，并且没有左子树，那么将节点作为左叶子节点，<br>否则继续和左子树进行比较。如果比当前节点值大，并且没有右子树，则将节点作为右叶子节点，否则继续和右子树进行比较。<br>循环这个过程直到找到合适的插入位置。</p><pre><code class="js">  insert(value) {    let newNode = new Node(value);    // 判断根节点是否为空，如果不为空则递归插入到树中    if (this.root === null) {      this.root = newNode;    } else {      this.insertNode(this.root, newNode);    }  }  insertNode(node, newNode) {    // 将插入节点的值与当前节点的进行比较，如果比当前节点小，则递归判断左子树，如果比当前节点大，则递归判断右子树。    if (newNode.value &lt; node.value) {      if (node.left === null) {        node.left = newNode;      } else {        this.insertNode(node.left, newNode);      }    } else {      if (node.right === null) {        node.right = newNode;      } else {        this.insertNode(node.right, newNode);      }    }  }</code></pre><p>通过递归实现树的先序、中序、后序遍历</p><pre><code class="js"> // 先序遍历通过递归实现 // 先序遍历则先打印当前节点，再递归打印左子节点和右子节点。  preOrderTraverse() {    this.preOrderTraverseNode(this.root);  }  preOrderTraverseNode(node) {    if (node !== null) {      node.show();      this.preOrderTraverseNode(node.left);      this.preOrderTraverseNode(node.right);    }  }  // 中序遍历通过递归实现  // 中序遍历则先递归打印左子节点，再打印当前节点，最后再递归打印右子节点。  inOrderTraverse() {    this.inOrderTraverseNode(this.root);  }  inOrderTraverseNode(node) {    if (node !== null) {      this.inOrderTraverseNode(node.left);      node.show();      this.inOrderTraverseNode(node.right);    }  }  // 后序遍历通过递归实现  // 后序遍历则先递归打印左子节点和右子节点，最后再打印当前节点。  postOrderTraverse() {    this.postOrderTraverseNode(this.root);  }  postOrderTraverseNode(node) {    if (node !== null) {      this.postOrderTraverseNode(node.left);      this.postOrderTraverseNode(node.right);      node.show();    }  }</code></pre><p>通过循环实现树的先序、中序、后序遍历</p><pre><code class="js">  // 先序遍历通过循环实现  // 通过栈来实现循环先序遍历，首先将根节点入栈。然后进入循环，每次循环开始，当前节点出栈，打印当前节点，然后将  // 右子节点入栈，再将左子节点入栈，然后进入下一循环，直到栈为空结束循环。  preOrderTraverseByStack() {    let stack = [];    // 现将根节点入栈，开始遍历    stack.push(this.root);    while (stack.length &gt; 0) {      // 从栈中获取当前节点      let node = stack.pop();      // 执行节点操作      node.show();      // 判断节点是否还有左右子节点，如果存在则加入栈中，注意，由于中序遍历先序遍历是先访问根      // 再访问左和右子节点，因此左右子节点的入栈顺序应该是反过来的      if (node.right) {        stack.push(node.right);      }      if (node.left) {        stack.push(node.left);      }    }  }  // 中序遍历通过循环实现  // 中序遍历先将所有的左子节点入栈，如果左子节点为 null 时，打印栈顶元素，然后判断该元素是否有右子树，如果有  // 则将右子树作为起点重复上面的过程，一直循环直到栈为空并且节点为空时。  inOrderTraverseByStack() {    let stack = [],      node = this.root;    // 中序遍历是先左再根最后右    // 所以首先应该先把最左边节点遍历到底依次 push 进栈    // 当左边没有节点时，就打印栈顶元素，然后寻找右节点    while (stack.length &gt; 0 || node) {      if (node) {        stack.push(node);        node = node.left;      } else {        node = stack.pop();        node.show();        node = node.right;      }    }  }  // 后序遍历通过循环来实现  // 使用两个栈来是实现，先将根节点放入栈1中，然后进入循环，每次循环将栈顶元素加入栈2，再依次将左节点和右节点依次  // 加入栈1中，然后进入下一次循环，直到栈1的长度为0。最后再循环打印栈2的值。  postOrderTraverseByStack() {    let stack1 = [],      stack2 = [],      node = null;    // 后序遍历是先左再右最后根    // 所以对于一个栈来说，应该先 push 根节点    // 然后 push 右节点，最后 push 左节点    stack1.push(this.root);    while (stack1.length &gt; 0) {      node = stack1.pop();      stack2.push(node);        if (node.left) {        stack1.push(node.left);      }      if (node.right) {        stack1.push(node.right);      }    }    while (stack2.length &gt; 0) {      node = stack2.pop();      node.show();    }  }</code></pre><p>实现寻找最大最小节点值</p><pre><code class="js"> // 寻找最小值，在最左边的叶子节点上  findMinNode(root) {    let node = root;    while (node &amp;&amp; node.left) {      node = node.left;    }    return node;  }  // 寻找最大值，在最右边的叶子节点上  findMaxNode(root) {    let node = root;    while (node &amp;&amp; node.right) {      node = node.right;    }    return node;  }</code></pre><p>实现寻找特定大小节点值</p><pre><code class="js">  // 寻找特定值  find(value) {    return this.findNode(this.root, value);  }  findNode(node, value) {    if (node === null) {      return node;    }    if (value &lt; node.value) {      return this.findNode(node.left, value);    } else if (value &gt; node.value) {      return this.findNode(node.right, value);    } else {      return node;    }  }</code></pre><p>实现移除节点值</p><p>移除节点的基本思想是，首先找到需要移除的节点的位置，然后判断该节点是否有叶节点。如果没有叶节点，则直接删除，如<br>果有一个叶子节点，则用这个叶子节点替换当前的位置。如果有两个叶子节点，则去右子树中找到最小的节点来替换当前节点。</p><pre><code class="js">  // 移除指定值节点  remove(value) {    this.removeNode(this.root, value);  }  removeNode(node, value) {    if (node === null) {      return node;    }    // 寻找指定节点    if (value &lt; node.value) {      node.left = this.removeNode(node.left, value);      return node;    } else if (value &gt; node.value) {      node.right = this.removeNode(node.right, value);      return node;    } else { // 找到节点      // 第一种情况——没有叶节点      if (node.left === null &amp;&amp; node.right === null) {        node = null;        return node;      }      // 第二种情况——一个只有一个子节点的节点，将节点替换为节点的子节点      if (node.left === null) {        node = node.right;        return node;      } else if (node.right === null) {        node = node.left;      }      // 第三种情况——一个有两个子节点的节点，去右子树中找到最小的节点，用它的值来替换当前节点      // 的值，保持树的特性，然后将替换的节点去掉      let aux = this.findMinNode(node.right);      node.value = aux.value;      node.right = this.removeNode(node.right, aux);      return node;    }  }</code></pre><h3 id="求解二叉树中两个节点的最近公共祖先节点"><a href="#求解二叉树中两个节点的最近公共祖先节点" class="headerlink" title="求解二叉树中两个节点的最近公共祖先节点"></a>求解二叉树中两个节点的最近公共祖先节点</h3><pre><code>求解二叉树中的两个节点的最近公共祖先节点可以分为三种情况来考虑（1）该二叉树为搜索二叉树     解决办法，首先从根节点开始遍历。如果根节点的值比两个节点的值都大的情况下，则说明两个节点的共同祖先存在于    根节点的左子树中，因此递归遍历左子树。反之，则遍历右子树。当当前节点的值比其中一个节点的值大，比其中一个    节点的值小时，该节点则为两个节点的最近公共祖先节点。（2）该二叉树为普通二叉树，但是每个节点含有指向父节点的指针。    通过指向父节点的指针，我们可以通过节点得到它的所有父节点，该父节点列表可以看做是一个链表，因此求两个节点    的最近公共祖先节点就可以看做是求两个链表的最近公共节点，以此来找到两个节点的最近公共祖先节点。（3）该二叉树为普通二叉树，节点不含有指向父节点的指针。    这种情况下，我们可以从根节点出发，分别得到根节点到两个节点的路径。然后遍历两条路径，直到遇到第一个不相同    的节点为止，这个时候该节点前面的那个节点则为两个节点的最近公共祖先节点。</code></pre><p>详细资料可以参考：<br><a href="https://blog.csdn.net/xyzbaihaiping/article/details/52122885">《二叉树中两个节点的最近公共祖先节点》</a></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="反转单向链表"><a href="#反转单向链表" class="headerlink" title="反转单向链表"></a>反转单向链表</h3><p>需要将一个单向链表反转。思路很简单，使用三个变量分别表示当前节点和当前节点的前后节点，虽然这题很简单，但是却是<br>一道面试常考题。</p><p>思路是从头节点往后遍历，先获取下一个节点，然后将当前节点的 next 设置为前一个节点，然后再继续循环。</p><pre><code class="js">var reverseList = function(head) {    // 判断下变量边界问题    if (!head || !head.next) return head;    // 初始设置为空，因为第一个节点反转后就是尾部，尾部节点指向 null    let pre = null;    let current = head;    let next;    // 判断当前节点是否为空    // 不为空就先获取当前节点的下一节点    // 然后把当前节点的 next 设为上一个节点    // 然后把 current 设为下一个节点，pre 设为当前节点    while(current) {        next = current.next;        current.next = pre;        pre = current;        current = next;    }    return pre;};</code></pre><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="爬楼梯问题"><a href="#爬楼梯问题" class="headerlink" title="爬楼梯问题"></a>爬楼梯问题</h3><p>有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法？</p><h4 id="递归方法分析"><a href="#递归方法分析" class="headerlink" title="递归方法分析"></a>递归方法分析</h4><p>由分析可知，假设我们只差最后一步就能走上第10级阶梯，这个时候一共有两种情况，因为每一步只允许走1级或2级阶梯，<br>因此分别为从8级阶梯和从9九级阶梯走上去的情况。因此从0到10级阶梯的走法数量就等于从0到9级阶梯的走法数量加上<br>从0到8级阶梯的走法数量。依次类推，我们可以得到一个递归关系，递归结束的标志为从0到1级阶梯的走法数量和从0到<br>2级阶梯的走法数量。</p><p>代码实现</p><pre><code class="js">function getClimbingWays(n) {  if (n &lt; 1) {    return 0;  }  if (n === 1) {    return 1;  }  if (n === 2) {    return 2;  }  return getClimbingWays(n - 1) + getClimbingWays(n - 2);}</code></pre><p>使用这种方法时整个的递归过程是一个二叉树的结构，因此该方法的时间复杂度可以近似的看为 O(2^n)，空间复杂度<br>为递归的深度 O(logn)。</p><h4 id="备忘录方法"><a href="#备忘录方法" class="headerlink" title="备忘录方法"></a>备忘录方法</h4><p>分析递归的方法我们可以发现，其实有很多的计算过程其实是重复的，因此我们可以使用一个数组，将已经计算出的值给<br>保存下来，每次计算时，先判断计算结果是否已经存在，如果已经存在就直接使用。</p><p>代码实现</p><pre><code class="js">let map = new Map();function getClimbingWays(n) {  if (n &lt; 1) {    return 0;  }  if (n === 1) {    return 1;  }  if (n === 2) {    return 2;  }  if (map.has(n)) {    return map.get(n);  } else {    let value = getClimbingWays(n - 1) + getClimbingWays(n - 2);    map.set(n, value);    return value;  }}</code></pre><p>通过这种方式，我们将算法的时间复杂度降低为 O(n)，但是增加空间复杂度为 O(n)</p><h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><p>通过观察，我们可以发现每一个值其实都等于它的前面两个值的和，因此我们可以使用自底向上的方式来实现。</p><p>代码实现</p><pre><code class="js">function getClimbingWays(n) {  if (n &lt; 1) {    return 0;  }  if (n === 1) {    return 1;  }  if (n === 2) {    return 2;  }  let a = 1,    b = 2,    temp = 0;  for (let i = 3; i &lt;= n; i++) {    temp = a + b;    a = b;    b = temp;  }  return temp;}</code></pre><p>通过这种方式我们可以将算法的时间复杂度降低为 O(n)，并且将算法的空间复杂度降低为 O(1)。</p><p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;mid=2650561168&amp;idx=1&amp;sn=9d1c6f7ba6d651c75399c4aa5254a7d8&amp;chksm=f1feec13c6896505f7886d9455278ad39749d377a63908c59c1fdceb11241e577ff6d66931e4&amp;scene=21#wechat_redirect">《漫画：什么是动态规划？（整合版）》</a></p><h2 id="经典笔试题"><a href="#经典笔试题" class="headerlink" title="经典笔试题"></a>经典笔试题</h2><h4 id="1-js-实现一个函数，完成超过范围的两个大整数相加功能"><a href="#1-js-实现一个函数，完成超过范围的两个大整数相加功能" class="headerlink" title="1. js 实现一个函数，完成超过范围的两个大整数相加功能"></a>1. js 实现一个函数，完成超过范围的两个大整数相加功能</h4><pre><code class="js">主要思路是通过将数字转换为字符串，然后每个字符串在按位相加。function bigNumberAdd(number1, number2) {  let result = "", // 保存最后结果    carry = false; // 保留进位结果  // 将字符串转换为数组  number1 = number1.split("");  number2 = number2.split("");  // 当数组的长度都变为0，并且最终不再进位时，结束循环  while (number1.length || number2.length || carry) {    // 每次将最后的数字进行相加，使用~~的好处是，即使返回值为 undefined 也能转换为 0    carry += ~~number1.pop() + ~~number2.pop();    // 取加法结果的个位加入最终结果    result = carry % 10 + result;    // 判断是否需要进位，true 和 false 的值在加法中会被转换为 1 和 0    carry = carry &gt; 9;  }  // 返回最终结果  return result;}</code></pre><p>   详细资料可以参考：<br>   <a href="https://blog.csdn.net/fe_dev/article/details/80079372">《JavaScript实现超范围的数相加》</a><br>   <a href="https://blog.csdn.net/q1059081877q/article/details/80689194">《js 实现大整数加法》</a></p><h4 id="2-js-如何实现数组扁平化？"><a href="#2-js-如何实现数组扁平化？" class="headerlink" title="2. js 如何实现数组扁平化？"></a>2. js 如何实现数组扁平化？</h4><pre><code class="js">// 这一种方法通过递归来实现，当元素为数组时递归调用，兼容性好function flattenArray(array) {  if (!Array.isArray(array)) return;  let result = [];  result = array.reduce(function (pre, item) {    // 判断元素是否为数组，如果为数组则递归调用，如果不是则加入结果数组中    return pre.concat(Array.isArray(item) ? flattenArray(item) : item);  }, []);  return result;}// 这一种方法是利用了 toString 方法，它的一个缺点是改变了元素的类型，只适合于数组中元素都是整数的情况function flattenArray(array) {  return array.toString().split(",").map(function (item) {    return +item;  })}</code></pre><p>   详细资料可以参考：<br>   <a href="https://github.com/mqyqingfeng/Blog/issues/36">《JavaScript专题之数组扁平化》</a></p><h4 id="3-js-如何实现数组去重？"><a href="#3-js-如何实现数组去重？" class="headerlink" title="3. js 如何实现数组去重？"></a>3. js 如何实现数组去重？</h4><pre><code class="js">function unique(array) {  if (!Array.isArray(array) || array.length &lt;= 1) return;  var result = [];  array.forEach(function (item) {    if (result.indexOf(item) === -1) {      result.push(item);    }  })  return result;}function unique(array) {  if (!Array.isArray(array) || array.length &lt;= 1) return;  return [...new Set(array)];}</code></pre><p>   详细资料可以参考：<br>   <a href="https://github.com/mqyqingfeng/Blog/issues/27">《JavaScript专题之数组去重》</a></p><h4 id="4-如何求数组的最大值和最小值？"><a href="#4-如何求数组的最大值和最小值？" class="headerlink" title="4. 如何求数组的最大值和最小值？"></a>4. 如何求数组的最大值和最小值？</h4><pre><code class="js">var arr = [6, 4, 1, 8, 2, 11, 23];console.log(Math.max.apply(null, arr))</code></pre><p>   详细资料可以参考：<br>   <a href="https://github.com/mqyqingfeng/Blog/issues/35">《JavaScript专题之如何求数组的最大值和最小值》</a></p><h4 id="5-如何求两个数的最大公约数？"><a href="#5-如何求两个数的最大公约数？" class="headerlink" title="5. 如何求两个数的最大公约数？"></a>5. 如何求两个数的最大公约数？</h4><pre><code class="js">基本思想是采用辗转相除的方法，用大的数去除以小的那个数，然后再用小的数去除以的得到的余数，一直这样递归下去，直到余数为0时，最后的被除数就是两个数的最大公约数。function getMaxCommonDivisor(a, b) {  if (b === 0) return a;  return getMaxCommonDivisor(b, a % b);}</code></pre><h4 id="6-如何求两个数的最小公倍数？"><a href="#6-如何求两个数的最小公倍数？" class="headerlink" title="6. 如何求两个数的最小公倍数？"></a>6. 如何求两个数的最小公倍数？</h4><pre><code class="js">基本思想是采用将两个数相乘，然后除以它们的最大公约数function getMinCommonMultiple(a, b){  return a * b / getMaxCommonDivisor(a, b);}</code></pre><p>   详细资料可以参考：<br>   <a href="https://www.cnblogs.com/cssfirefly/archive/2012/10/23/2734936.html">《百度 web 前端面试题之求两个数的最大公约数和最小公倍数》</a></p><h4 id="7-实现-IndexOf-方法？"><a href="#7-实现-IndexOf-方法？" class="headerlink" title="7. 实现 IndexOf 方法？"></a>7. 实现 IndexOf 方法？</h4><pre><code class="js">function indexFun(array, val) {  if (!Array.isArray(array)) return;  let length = array.length;  for (let i = 0; i &lt; length; i++) {    if (array[i] === val) {      return i;    }  }  return -1;}   </code></pre><h4 id="8-判断一个字符串是否为回文字符串？"><a href="#8-判断一个字符串是否为回文字符串？" class="headerlink" title="8. 判断一个字符串是否为回文字符串？"></a>8. 判断一个字符串是否为回文字符串？</h4><pre><code class="js">function isPalindrome(str) {  let reg = /[\W_]/g, // 匹配所有非单词的字符以及下划线    newStr = str.replace(reg, "").toLowerCase(), // 替换为空字符并将大写字母转换为小写    reverseStr = newStr.split("").reverse().join(""); // 将字符串反转  return reverseStr === newStr;}</code></pre><h4 id="9-实现一个累加函数的功能比如-sum-1-2-3-2-valueOf"><a href="#9-实现一个累加函数的功能比如-sum-1-2-3-2-valueOf" class="headerlink" title="9. 实现一个累加函数的功能比如 sum(1,2,3)(2).valueOf()"></a>9. 实现一个累加函数的功能比如 sum(1,2,3)(2).valueOf()</h4><pre><code class="js">function sum(...args) {let result = 0;result = args.reduce(function (pre, item) {  return pre + item;}, 0);let add = function (...args) {  result = args.reduce(function (pre, item) {    return pre + item;  }, result);  return add;};add.valueOf = function () {  console.log(result);}return add;}</code></pre><h4 id="10-使用-reduce-方法实现-forEach、map、filter"><a href="#10-使用-reduce-方法实现-forEach、map、filter" class="headerlink" title="10. 使用 reduce 方法实现 forEach、map、filter"></a>10. 使用 reduce 方法实现 forEach、map、filter</h4><pre><code class="js"> // forEach function forEachUseReduce(array, handler) {   array.reduce(function (pre, item, index) {     handler(item, index);   }, null); } // map function mapUseReduce(array, handler) {   let result = [];   array.reduce(function (pre, item, index) {     let mapItem = handler(item, index);     result.push(mapItem);   }, null);   return result; } // filter function filterUseReduce(array, handler) {   let result = [];   array.reduce(function (pre, item, index) {     if (handler(item, index)) {       result.push(item);     }   }, null);   return result; }</code></pre><h4 id="11-设计一个简单的任务队列，要求分别在-1-3-4-秒后打印出-“1”-“2”-“3”"><a href="#11-设计一个简单的任务队列，要求分别在-1-3-4-秒后打印出-“1”-“2”-“3”" class="headerlink" title="11. 设计一个简单的任务队列，要求分别在 1,3,4 秒后打印出 “1”, “2”, “3”"></a>11. 设计一个简单的任务队列，要求分别在 1,3,4 秒后打印出 “1”, “2”, “3”</h4><pre><code class="js"> class Queue {   constructor() {     this.queue = [];     this.time = 0;   }   addTask(task, t) {     this.time += t;     this.queue.push([task, this.time]);     return this;   }   start() {     this.queue.forEach(item =&gt; {       setTimeout(() =&gt; {         item[0]();       }, item[1]);     })   } }</code></pre><h4 id="12-如何查找一篇英文文章中出现频率最高的单词？"><a href="#12-如何查找一篇英文文章中出现频率最高的单词？" class="headerlink" title="12. 如何查找一篇英文文章中出现频率最高的单词？"></a>12. 如何查找一篇英文文章中出现频率最高的单词？</h4><pre><code class="js"> function findMostWord(article) { // 合法性判断 if (!article) return; // 参数处理 article = article.trim().toLowerCase(); let wordList = article.match(/[a-z]+/g),  visited = [],  maxNum = 0,  maxWord = ""; article = " " + wordList.join("  ") + " "; // 遍历判断单词出现次数 wordList.forEach(function (item) {  if (visited.indexOf(item) &lt; 0) {    let word = new RegExp(" " + item + " ", "g"),      num = article.match(word).length;    if (num &gt; maxNum) {      maxNum = num;      maxWord = item;    }  } }); return maxWord + "  " + maxNum; }</code></pre><h1 id="常见面试智力题总结"><a href="#常见面试智力题总结" class="headerlink" title="常见面试智力题总结"></a>常见面试智力题总结</h1><h4 id="1-时针与分针夹角度数问题？"><a href="#1-时针与分针夹角度数问题？" class="headerlink" title="1. 时针与分针夹角度数问题？"></a>1. 时针与分针夹角度数问题？</h4><p>   分析：</p><pre><code>当时间为 m 点 n 分时，其时针与分针夹角的度数为多少？我们可以这样考虑，分针每走一格为 6 度，分针每走一格对应的时针会走 0.5 度。时针每走一格为 30 度。因此，时针走过的度数为 m * 30 + n * 0.5，分针走过的度数为 n * 6。因此时针与分针的夹角度数为 |m * 30 + n * 0.5 - n * 6|;</code></pre><p>   答案：</p><pre><code>因此时针与分针的夹角度数为 |m * 30 + n * 0.5 - n * 6|; </code></pre><p>   详细资料参考：<br>   <a href="https://blog.csdn.net/prstaxy/article/details/22210829">《面试智力题 — 时针与分针夹角度数问题》</a></p><h4 id="2-用3升，5升杯子怎么量出4升水？"><a href="#2-用3升，5升杯子怎么量出4升水？" class="headerlink" title="2. 用3升，5升杯子怎么量出4升水？"></a>2. 用3升，5升杯子怎么量出4升水？</h4><pre><code>（1）将 5 升杯子装满水，然后倒入 3 升杯子中，之后 5 升杯子还剩 2 升水。（2）将 3 升杯子的水倒出，然后将 5 升杯子中的 2 升水倒入 3 升杯子中。（3）将 5 升杯子装满水，然后向 3 升杯子中倒水，直到 3 升杯子装满为止，此时 5 升杯子中就还剩 4 升水。</code></pre><h4 id="3-四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？"><a href="#3-四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？" class="headerlink" title="3. 四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？"></a>3. 四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？</h4><pre><code>由于浑浊的每片药片比正常药片都多出了一克，因此我认为可以通过控制药片的数量来实现判断。（1）首先将每个药罐进行编号，分别标记为 1、2、3、4 号药罐。（2）然后从 1 号药罐中取出 1 片药片，从 2 号药罐中取出 2 片药片，从 3 号药罐中取出 3 片药片，从 4 号药罐中取出 4    片药片。（3）将 10 片药片使用天平称重，药片的重量比正常重量多出几克，就是哪一号药罐的问题。</code></pre><h4 id="4-四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为-a-1-b-2-现在我想要证明-a-的反面必然是-1-，我只能翻两张牌，我翻哪两张？"><a href="#4-四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为-a-1-b-2-现在我想要证明-a-的反面必然是-1-，我只能翻两张牌，我翻哪两张？" class="headerlink" title="4. 四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为 a 1 b 2 现在我想要证明 a 的反面必然是 1 ，我只能翻两张牌，我翻哪两张？"></a>4. 四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为 a 1 b 2 现在我想要证明 a 的反面必然是 1 ，我只能翻两张牌，我翻哪两张？</h4><pre><code>我认为证明 a 的反面一定是 1 的充要条件为 a 的反面为 1，并且 2 的反面不能为 a，因此应该翻 a 和 2 两张牌。</code></pre><h4 id="5-赛马问题，25-匹马，5-个赛道，最少几次能选出最快的三匹马？"><a href="#5-赛马问题，25-匹马，5-个赛道，最少几次能选出最快的三匹马？" class="headerlink" title="5. 赛马问题，25 匹马，5 个赛道，最少几次能选出最快的三匹马？"></a>5. 赛马问题，25 匹马，5 个赛道，最少几次能选出最快的三匹马？</h4><pre><code>我认为一共至少需要 7 次才能选出最快的三匹马。（1）首先，我们将 25 匹马分为 5 组，每组进行比赛，选出每组最快的三匹马，其余的马由于已经不可能成为前三了，因此可以直    接淘汰掉，那么我们现在还剩下了 15 匹马。（2）然后我们将 5 组中的第一名来进行一轮比赛，最终的结果能够确定最快的马一定是第一名，四五名的马以及它们对应组的其余    马就可以淘汰掉了，因为它们已经没有进入前三的机会了。并且第二名那一组的第三名和第三组的第二第三名都可以淘汰掉了，    它们也没有进入前三的机会了。因此我们最终剩下了第一名那一组的二三名和第二名那一组的一二名，以及第三名一共 5 匹马，    它们都有竞争最快第二第三的机会。（3）最后一次对最后的 5 匹马进行比赛，选择最快的一二名作为最终结果的二三名，因此就能够通过 7 次比较，选择出最快的马。</code></pre><h4 id="6-五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都不同，那么A的配偶握手了几次？"><a href="#6-五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都不同，那么A的配偶握手了几次？" class="headerlink" title="6. 五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都不同，那么A的配偶握手了几次？"></a>6. 五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都不同，那么A的配偶握手了几次？</h4><pre><code>（1）由于每个人不能和自己的配偶握手，并且最多只能和他人握手一次，因此一个人最多能握 8 次手。（2）因为 A 问了除自己配偶的其他人，每个人的握手次数都不同。因此一共有九种握手的情况，由于一个人最多只能握 8 次手，因    此握手的情况分别为 0、1、2、3、4、5、6、7、8 这九种情况。（3）我们首先分析握了 8 次手的人，由于他和除了自己配偶的每一个人都握了一次手，因此其他人的握手次数都不为 0，因此只有    他的配偶握手次数为0，由此我们可以知道握手次数为 8 的人和握手次数为 0 的人是配偶。（4）我们再来分析握了 7 次手的人，他和除了握了 0 次手以外的人都握了一次手，由于握了 8 次手的人和其余人也都握了一次手    ，因此其他人的握手次数至少为 2 ，因此只有他的配偶的握手次数才能为 1。由此我们可以知道握手次数为 7 的人和握手次数    为 1 的人是配偶。（5）依次可以类推，握手次数为 6 的人和握手次数为 2 的人为配偶，握手次数为 5 的人和握手次数为 3 的人为配偶。（6）最终剩下了握手次数为 4 的人，按照规律我们可以得知他的配偶的握手次数也为4。（7）由于 A 和其他人的握手次数都不同，因此我们可以得知握手次数为 4 的人就是 A。因此他的配偶的握手次数为 4 。</code></pre><h4 id="7-你只能带行走-60-公里的油，只能在起始点加油，如何穿过-80-公里的沙漠？"><a href="#7-你只能带行走-60-公里的油，只能在起始点加油，如何穿过-80-公里的沙漠？" class="headerlink" title="7. 你只能带行走 60 公里的油，只能在起始点加油，如何穿过 80 公里的沙漠？"></a>7. 你只能带行走 60 公里的油，只能在起始点加油，如何穿过 80 公里的沙漠？</h4><pre><code>（1）先走到离起点 20 公里的地方，然后放下 20 公里的油在这，然后返回起点加油。（2）当第二次到达这时，车还剩 40 公里的油，加上上一次放在这的 20 公里的油，一共就有 60 公里的油，能够走完剩下的路    程。</code></pre><h4 id="8-烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？"><a href="#8-烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？" class="headerlink" title="8. 烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？"></a>8. 烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？</h4><pre><code>一共需要三根绳子，假设分别为 1、2、3 号绳子，每个绳子一共有 A、B 两端。（1）首先点燃 1 号绳子的 A、B 两端，然后点燃 2 号绳子的 A 端。（2）当 1 号绳子燃尽时，此时过去了半小时，然后同时点燃 2 号绳子的 B 端。（3）当 2 号绳子燃尽时，此时又过去了 15 分钟，然后同时点燃 3 号绳子的 A、B 两端。（4）当 3 号绳子燃尽时，又过去了半小时，以此一共加起来过去了一个小时十五分钟。</code></pre><h4 id="9-有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？"><a href="#9-有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？" class="headerlink" title="9. 有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？"></a>9. 有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？</h4><pre><code>（1） 第一次用 7 克砝码和 2 克砝码称取 9 克盐。（2） 第二次再用第一次称取的盐和砝码称取 16 克盐。（3） 第三次再用前两次称取的盐和砝码称取 25 克盐，这样就总共称取了 50 克盐，剩下的就是 90 克。</code></pre><h4 id="10-有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第-小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和-两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？"><a href="#10-有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第-小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和-两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？" class="headerlink" title="10. 有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第&nbsp;小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和&nbsp;两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？&nbsp;"></a>10. 有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第&nbsp;小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和&nbsp;两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？&nbsp;</h4><pre><code> 由于小鸟一直都在飞，直到两车相遇时才停下来。因此小鸟飞行的时间为两车相遇的时间，由于两车是相向而行，因此 两车相遇的时间为总路程除以两车的速度之和，然后再用飞行的时间去乘以小鸟的速度，就能够得出小鸟飞行的距离。</code></pre><h4 id="11-你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？"><a href="#11-你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？" class="headerlink" title="11. 你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？"></a>11. 你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？</h4><pre><code> 第一个罐子里放一个红球，第二个罐子里放剩余的球，这样概率接近75%，这是概率最大的方法</code></pre><h4 id="12-假设你有8个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？"><a href="#12-假设你有8个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？" class="headerlink" title="12. 假设你有8个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？"></a>12. 假设你有8个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？</h4><pre><code> 最少两次可以称出。 首先将 8 个球分为 3 组，其中两组为 3 个球，一组为 2 个球。 第一次将两组三个的球进行比较，如果两边相等，则说明重的球在最后一组里。第二次将最后一组的球进行比较即可。如 果两边不等，则说明重的球在较重的一边，第二次只需从这一组中随机取两球出来比较即可判断。</code></pre><h4 id="13-在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？"><a href="#13-在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？" class="headerlink" title="13. 在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？"></a>13. 在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？</h4><pre><code> （1）首先打开一盏灯 10 分钟，然后打开第二盏。 （2）进入房间，看看那盏灯亮，摸摸那盏灯热，热的是第一个开关打开的，亮的是第二个开关打开的，而剩下的就是第三个开关打开     的。</code></pre><h4 id="14-他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？"><a href="#14-他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？" class="headerlink" title="14. 他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？"></a>14. 他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？</h4><pre><code> 将每一对袜子分开，一人拿一只袜子，因为袜子不分左右脚的，因此最后每个人都能取回白袜和黑袜两对。</code></pre><h4 id="15-有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签。"><a href="#15-有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签。" class="headerlink" title="15. 有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签。"></a>15. 有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签。</h4><pre><code> 从混合标签里取出一个水果，取出的是什么水果，就写上相应的标签。 对应水果标签的筐的标签改为另一种水果。 另一种水果标签的框改为混合。</code></pre><h4 id="16-一个班级60-喜欢足球，70-喜欢篮球，80-喜欢排球，问即三种球都喜欢占比有多少？"><a href="#16-一个班级60-喜欢足球，70-喜欢篮球，80-喜欢排球，问即三种球都喜欢占比有多少？" class="headerlink" title="16. 一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球，问即三种球都喜欢占比有多少？"></a>16. 一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球，问即三种球都喜欢占比有多少？</h4><pre><code> （1）首先确定最多的一种情况，就是 60% 喜欢足球的人同时也喜欢篮球和排球，此时为三种球都喜欢的人的最大比例。 （2）然后确定最小的一种情况，根据题目可以知道有 40%的人不喜欢足球，30%的人不喜欢篮球，20%的人不喜欢排球，因此有最多     90% 的人三种球中有一种球不喜欢，因此三种球都喜欢的人的最小比例为 10%。 因此三种球都喜欢的人占比为 10%-60%</code></pre><h4 id="17-五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？"><a href="#17-五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？" class="headerlink" title="17. 五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？"></a>17. 五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？</h4><pre><code> 五只鸡五天能下五个蛋，平均下来五只鸡每天能下一个蛋，因此五只鸡一百天就能够下一百个蛋。</code></pre><p>   更多的智力题可以参考：<br>   <a href="https://blog.csdn.net/hilyoo/article/details/4445858">《经典面试智力题200+题和解答》</a></p><h1 id="剑指-offer-思路总结"><a href="#剑指-offer-思路总结" class="headerlink" title="剑指 offer 思路总结"></a>剑指 offer 思路总结</h1><p>本部分主要是笔者在练习剑指 offer 时所做的笔记，如果出现错误，希望大家指出！</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h4 id="1-二维数组中的查找"><a href="#1-二维数组中的查找" class="headerlink" title="1. 二维数组中的查找"></a>1. 二维数组中的查找</h4><pre><code>题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。思路：（1）第一种方式是使用两层循环依次遍历，判断是否含有该整数。这一种方式最坏情况下的时间复杂度为 O(n^2)。（2）第二种方式是利用递增序列的特点，我们可以从二维数组的右上角开始遍历。如果当前数值比所求的数要小，则将位置向下移动    ，再进行判断。如果当前数值比所求的数要大，则将位置向左移动，再进行判断。这一种方式最坏情况下的时间复杂度为 O(n)。</code></pre><h4 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2. 替换空格"></a>2. 替换空格</h4><pre><code>题目：请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20Are%20Happy思路：使用正则表达式，结合字符串的 replace 方法将空格替换为 “%20”str.replace(/\s/g,"%20")</code></pre><h4 id="3-从尾到头打印链表"><a href="#3-从尾到头打印链表" class="headerlink" title="3. 从尾到头打印链表"></a>3. 从尾到头打印链表</h4><pre><code>题目：输入一个链表，从尾到头打印链表每个节点的值。思路：利用栈来实现，首先根据头结点以此遍历链表节点，将节点加入到栈中。当遍历完成后，再将栈中元素弹出并打印，以此来实现。栈的实现可以利用 Array 的 push 和 pop 方法来模拟。</code></pre><h4 id="4-重建二叉树"><a href="#4-重建二叉树" class="headerlink" title="4. 重建二叉树"></a>4. 重建二叉树</h4><pre><code>题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列 {1,2,4,7,3,5,6,8} 和中序遍历序列 {4,7,2,1,5,3,8,6}，则重建二叉树并返回。思路：利用递归的思想来求解，首先先序序列中的第一个元素一定是根元素。然后我们去中序遍历中寻找到该元素的位置，找到后该元素的左边部分就是根节点的左子树，右边部分就是根节点的右子树。因此我们可以分别截取对应的部分进行子树的递归构建。使用这种方式的时间复杂度为 O(n)，空间复杂度为 O(logn)。</code></pre><h4 id="5-用两个栈实现队列"><a href="#5-用两个栈实现队列" class="headerlink" title="5. 用两个栈实现队列"></a>5. 用两个栈实现队列</h4><pre><code>题目：用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。思路：队列的一个基本特点是，元素先进先出。通过两个栈来模拟时，首先我们将两个栈分为栈1和栈2。当执行队列的 push 操作时，直接将元素 push 进栈1中。当队列执行 pop 操作时，首先判断栈2是否为空，如果不为空则直接 pop 元素。如果栈2为空，则将栈1中的所有元素 pop 然后 push 到栈2中，然后再执行栈2的 pop 操作。扩展：当使用两个长度不同的栈来模拟队列时，队列的最大长度为较短栈的长度的两倍。</code></pre><h4 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6. 旋转数组的最小数字"></a>6. 旋转数组的最小数字</h4><pre><code>题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。思路：（1）我们输入的是一个非递减排序的数组的一个旋转，因此原始数组的值递增或者有重复。旋转之后原始数组的值一定和一个值相    邻，并且不满足递增关系。因此我们就可以进行遍历，找到不满足递增关系的一对值，后一个值就是旋转数组的最小数字。（2）二分法</code></pre><p>   相关资料可以参考：<br>   <a href="https://www.cnblogs.com/edisonchou/p/4746561.html">《旋转数组的最小数字》</a></p><h4 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7. 斐波那契数列"></a>7. 斐波那契数列</h4><pre><code>题目：大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项。 n&lt;=39思路：斐波那契数列的规律是，第一项为0，第二项为1，第三项以后的值都等于前面两项的和，因此我们可以通过循环的方式，不断通过叠加来实现第 n 项值的构建。通过循环而不是递归的方式来实现，时间复杂度降为了 O(n)，空间复杂度为 O(1)。</code></pre><h4 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8. 跳台阶"></a>8. 跳台阶</h4><pre><code>题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。思路：跳台阶的问题是一个动态规划的问题，由于一次只能够跳1级或者2级，因此跳上 n 级台阶一共有两种方案，一种是从 n-1 跳上，一种是从 n-2 级跳上，因此 f(n) = f(n-1) + f(n-2)。和斐波那契数列类似，不过初始两项的值变为了 1 和 2，后面每项的值等于前面两项的和。</code></pre><h4 id="9-变态跳台阶"><a href="#9-变态跳台阶" class="headerlink" title="9. 变态跳台阶"></a>9. 变态跳台阶</h4><pre><code>题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。思路：变态跳台阶的问题同上一个问题的思考方案是一样的，我们可以得到一个结论是，每一项的值都等于前面所有项的值的和。f(1) = 1f(2) = f(2-1) + f(2-2)         //f(2-2) 表示2阶一次跳2阶的次数。f(3) = f(3-1) + f(3-2) + f(3-3) ...f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n) 再次总结可得              | 1       ,(n=0 ) f(n) =        | 1       ,(n=1 )              | 2*f(n-1),(n&gt;=2)</code></pre><h4 id="10-矩形覆盖"><a href="#10-矩形覆盖" class="headerlink" title="10. 矩形覆盖"></a>10. 矩形覆盖</h4><pre><code> 题目： 我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共 有多少种方法？ 思路： 依旧是斐波那契数列的应用</code></pre><h4 id="11-二进制中1的个数"><a href="#11-二进制中1的个数" class="headerlink" title="11. 二进制中1的个数"></a>11. 二进制中1的个数</h4><pre><code> 题目： 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 思路： 一个不为 0 的整数的二进制表示，一定会有一位为1。我们找到最右边的一位1，当我们将整数减去1时，最右边的一位1变为0，它后 面的所有位都取反，因此将减一后的值与原值相与，我们就会能够消除最右边的一位1。因此判断一个二进制中1的个数，我们可以判 断这个数可以经历多少次这样的过程。 如：1100&amp;1011=1000 </code></pre><h4 id="12-数值的整数次方"><a href="#12-数值的整数次方" class="headerlink" title="12. 数值的整数次方"></a>12. 数值的整数次方</h4><pre><code> 题目： 给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的 exponent 次方。 思路： 首先我们需要判断 exponent 正负和零取值三种情况，根据不同的情况通过递归来实现。 </code></pre><h4 id="13-调整数组顺序使奇数位于偶数前面"><a href="#13-调整数组顺序使奇数位于偶数前面" class="headerlink" title="13. 调整数组顺序使奇数位于偶数前面"></a>13. 调整数组顺序使奇数位于偶数前面</h4><pre><code> 题目： 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半 部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 思路： 由于需要考虑到调整之后的稳定性，因此我们可以使用辅助数组的方式。首先对数组中的元素进行遍历，每遇到一个奇数就将它加入到 奇数辅助数组中，每遇到一个偶数，就将它将入到偶数辅助数组中。最后再将两个数组合并。这一种方法的时间复杂度为 O(n)，空间 复杂度为 O(n)。</code></pre><h4 id="14-链表中倒数第-k-个节点"><a href="#14-链表中倒数第-k-个节点" class="headerlink" title="14. 链表中倒数第 k 个节点"></a>14. 链表中倒数第 k 个节点</h4><pre><code> 题目： 输入一个链表，输出该链表中倒数第 k 个结点。 思路： 使用两个指针，先让第一个和第二个指针都指向头结点，然后再让第二个指针走 k-1 步，到达第 k 个节点。然后两个指针同时向后 移动，当第二个指针到达末尾时，第一个指针指向的就是倒数第 k 个节点了。</code></pre><h4 id="15-反转链表"><a href="#15-反转链表" class="headerlink" title="15. 反转链表"></a>15. 反转链表</h4><pre><code> 题目： 输入一个链表，反转链表后，输出链表的所有元素。 思路： 通过设置三个变量 pre、current 和 next，分别用来保存前继节点、当前节点和后继结点。从第一个节点开始向后遍历，首先将当 前节点的后继节点保存到 next 中，然后将当前节点的后继节点设置为 pre，然后再将 pre 设置为当前节点，current 设置为 ne xt 节点，实现下一次循环。</code></pre><h4 id="16-合并两个排序的链表"><a href="#16-合并两个排序的链表" class="headerlink" title="16. 合并两个排序的链表"></a>16. 合并两个排序的链表</h4><pre><code> 题目： 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 思路： 通过递归的方式，依次将两个链表的元素递归进行对比。</code></pre><h4 id="17-树的子结构"><a href="#17-树的子结构" class="headerlink" title="17. 树的子结构"></a>17. 树的子结构</h4><pre><code> 题目： 输入两棵二叉树A、B，判断 B 是不是 A 的子结构。（ps：我们约定空树不是任意一个树的子结构） 思路： 通过递归的思想来解决 第一步首先从树 A 的根节点开始遍历，在左右子树中找到和树 B 根结点的值一样的结点 R 。 第二步两棵树同时从 R 节点和根节点以相同的遍历方式进行遍历，依次比较对应的值是否相同，当树 B 遍历结束时，结束比较。</code></pre><h4 id="18-二叉树的镜像"><a href="#18-二叉树的镜像" class="headerlink" title="18. 二叉树的镜像"></a>18. 二叉树的镜像</h4><pre><code> 题目： 操作给定的二叉树，将其变换为源二叉树的镜像。  思路： 从根节点开始遍历，首先通过临时变量保存左子树的引用，然后将根节点的左右子树的引用交换。然后再递归左右节点的子树交换。</code></pre><h4 id="19-顺时针打印矩阵"><a href="#19-顺时针打印矩阵" class="headerlink" title="19. 顺时针打印矩阵"></a>19. 顺时针打印矩阵</h4><pre><code> 题目： 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字， 例如，如果输入如下矩阵： 1 2 3 4                                          5 6 7 8                                           9 10 11 12                                           13 14 15 16  则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10 思路： （1）根据左上角和右下角可以定位出一次要旋转打印的数据。一次旋转打印结束后，往对角分别前进和后退一个单位，可以确定下一     次需要打印的数据范围。 （2）使用模拟魔方逆时针解法，每打印一行，则将矩阵逆时针旋转 90 度，打印下一行，依次重复。</code></pre><h4 id="20-定义一个栈，实现-min-函数"><a href="#20-定义一个栈，实现-min-函数" class="headerlink" title="20. 定义一个栈，实现 min 函数"></a>20. 定义一个栈，实现 min 函数</h4><pre><code> 题目： 定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。 思路： 使用一个辅助栈，每次将数据压入数据栈时，就把当前栈里面最小的值压入辅助栈当中。这样辅助栈的栈顶数据一直是数据栈中最小 的值。</code></pre><h4 id="21-栈的压入弹出"><a href="#21-栈的压入弹出" class="headerlink" title="21. 栈的压入弹出"></a>21. 栈的压入弹出</h4><pre><code> 题目： 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如 序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序 列的弹出序列。（注意：这两个序列的长度是相等的） 思路： 我们可以使用一个辅助栈的方式来实现，首先遍历压栈顺序，依次将元素压入辅助栈中，每次压入元素后我们首先判断该元素是否与出 栈顺序中的此刻位置的元素相等，如果不相等，则将元素继续压栈，如果相等，则将辅助栈中的栈顶元素出栈，出栈后，将出栈顺序中 的位置后移一位继续比较。当压栈顺序遍历完成后，如果辅助栈不为空，则说明该出栈顺序不正确。</code></pre><h4 id="22-从上往下打印二叉树"><a href="#22-从上往下打印二叉树" class="headerlink" title="22. 从上往下打印二叉树"></a>22. 从上往下打印二叉树</h4><pre><code> 题目： 从上往下打印出二叉树的每个节点，同层节点从左至右打印。 思路： 本质上是二叉树的层序遍历，可以通过队列来实现。首先将根节点入队。然后对队列进行出队操作，每次出队时，将出队元素的左右子 节点依次加入到队列中，直到队列长度变为 0 时，结束遍历。</code></pre><h4 id="23-二叉搜索树的后序遍历"><a href="#23-二叉搜索树的后序遍历" class="headerlink" title="23. 二叉搜索树的后序遍历"></a>23. 二叉搜索树的后序遍历</h4><pre><code> 题目： 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出 Yes，否则输出 No。假设输入的数组的任意两 个数字都互不相同。 思路： 对于一个合法而二叉树的后序遍历来说，最末尾的元素为根元素。该元素前面的元素可以划分为两个部分，一部分为该元素的左子树， 所有元素的值比根元素小，一部分为该元素的右子树，所有的元素的值比该根元素大。并且每一部分都是一个合法的后序序列，因此我 们可以利用这些特点来递归判断。</code></pre><h4 id="24-二叉树中和为某一值路径"><a href="#24-二叉树中和为某一值路径" class="headerlink" title="24. 二叉树中和为某一值路径"></a>24. 二叉树中和为某一值路径</h4><pre><code> 题目： 输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经 过的结点形成一条路径。 思路： 通过对树进行深度优先遍历，遍历时保存当前节点的值并判断是否和期望值相等，如果遍历到叶节点不符合要求则回退处理。</code></pre><h4 id="25-复杂链表的复制"><a href="#25-复杂链表的复制" class="headerlink" title="25. 复杂链表的复制"></a>25. 复杂链表的复制</h4><pre><code> 题目： 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为 复制后复杂链表的 head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 思路： （1）第一种方式，首先对原有链表每个节点进行复制，通过 next 连接起来。然后当链表复制完成之后，再来设置每个节点的 ra     ndom 指针，这个时候每个节点的 random 的设置都需要从头结点开始遍历，因此时间的复杂度为 O(n^2)。 （2）第二种方式，首先对原有链表每个节点进行复制，并且使用 Map 以键值对的方式将原有节点和复制节点保存下来。当链表复     制完成之后，再来设置每个节点的 random 指针，这个时候我们通过 Map 中的键值关系就可以获取到对应的复制节点，因此     不必再从头结点遍历，将时间的复杂度降低为了 O(n)，但是空间复杂度变为了 O(n)。这是一种以空间换时间的做法。 （3）第三种方式，首先对原有链表的每个节点进行复制，并将复制后的节点加入到原有节点的后面。当链表复制完成之后，再进行     random 指针的设置，由于每个节点后面都跟着自己的复制节点，因此我们可以很容易的获取到 random 指向对应的复制节点     。最后再将链表分离，通过这种方法我们也能够将时间复杂度降低为 O(n)。</code></pre><h4 id="26-二叉搜索树与双向链表"><a href="#26-二叉搜索树与双向链表" class="headerlink" title="26. 二叉搜索树与双向链表"></a>26. 二叉搜索树与双向链表</h4><pre><code> 题目： 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 思路： 需要生成一个排序的双向列表，那么我们应该通过中序遍历的方式来调整树结构，因为只有中序遍历，返回才是一个从小到大的排序 序列。 基本的思路是我们首先从根节点开始遍历，先将左子树调整为一个双向链表，并将左子树双向链表的末尾元素的指针指向根节点，并 将根节点的左节点指向末尾节点。再将右子树调整为一个双向链表，并将右子树双向链表的首部元素的指针指向根元素，再将根节点 的右节点指向首部节点。通过对左右子树递归调整，因此来实现排序的双向链表的构建。</code></pre><h4 id="27-字符串的排列"><a href="#27-字符串的排列" class="headerlink" title="27. 字符串的排列"></a>27. 字符串的排列</h4><pre><code> 题目： 输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc，则打印出由字符 a,b,c 所能排列出来的所有 字符串 abc,acb,bac,bca,cab 和 cba。输入描述：输入一个字符串，长度不超过9（可能有字符重复），字符只包括大小写字母。 思路： 我们可以把一个字符串看做是两个部分，第一部分为它的第一个字符，第二部分是它后面的所有字符。求整个字符串的一个全排列，可 以看做两步，第一步是求所有可能出现在第一个位置的字符，即把第一个字符和后面的所有字符交换。第二步就是求后面所有字符的一 个全排列。因此通过这种方式，我们可以以递归的思路来求出当前字符串的全排列。</code></pre><p>   详细资料可以参考：<br>   <a href="https://wiki.jikexueyuan.com/project/for-offer/question-twenty-eight.html">《字符串的排列》</a></p><h4 id="28-数组中出现次数超过一半的数字"><a href="#28-数组中出现次数超过一半的数字" class="headerlink" title="28. 数组中出现次数超过一半的数字"></a>28. 数组中出现次数超过一半的数字</h4><pre><code> 题目： 数组中有一个数字出现的次数超过数组长度的一半。请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数 字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 思路： （1）对数组进行排序，排序后的中位数就是所求数字。这种方法的时间复杂度取决于我们采用的排序方法的时间复杂度，因此最快为     O(nlogn)。 （2）由于所求数字的数量超过了数组长度的一半，因此排序后的中位数就是所求数字。因此我们可以将问题简化为求一个数组的中     位数问题。其实数组并不需要全排序，只需要部分排序。我们通过利用快排中的 partition 函数来实现，我们现在数组中随     机选取一个数字，而后通过 partition 函数返回该数字在数组中的索引 index，如果 index 刚好等于 n/2，则这个数字     便是数组的中位数，也即是要求的数，如果 index 大于 n/2，则中位数肯定在 index的左边，在左边继续寻找即可，反之     在右边寻找。这样可以只在 index 的一边寻找，而不用两边都排序，减少了一半排序时间，这种方法的时间复杂度为 O(n)。 （3）由于该数字的出现次数比所有其他数字出现次数的和还要多，因此可以考虑在遍历数组时保存两个值：一个是数组中的一个数     字，一个是次数。当遍历到下一个数字时，如果下一个数字与之前保存的数字相同，则次数加1，如果不同，则次数减1，如果     次数为0，则需要保存下一个数字，并把次数设定为1。由于我们要找的数字出现的次数比其他所有数字的出现次数之和还要大，     则要找的数字肯定是最后一次把次数设为1时对应的数字。该方法的时间复杂度为O(n)，空间复杂度为 O(1)。</code></pre><p>   详细资料可以参考：<br>   <a href="https://blog.csdn.net/ns_code/article/details/26957383">《出现次数超过一半的数字》</a></p><h4 id="29-最小的-K-个数"><a href="#29-最小的-K-个数" class="headerlink" title="29. 最小的 K 个数"></a>29. 最小的 K 个数</h4><pre><code> 题目： 输入 n 个整数，找出其中最小的 K 个数。例如输入 4,5,1,6,2,7,3,8 这8个数字，则最小的4个数字是 1,2,3,4 。 思路： （1）第一种思路是首先将数组排序，排序后再取最小的 k 个数。这一种方法的时间复杂度取决于我们选择的排序算法的时间复杂     度，最好的情况下为 O(nlogn)。 （2）第二种思路是由于我们只需要获得最小的 k 个数，这 k 个数不一定是按序排序的。因此我们可以使用快速排序中的 part     ition函数来实现。每一次选择一个枢纽值，将数组分为比枢纽值大和比枢纽值小的两个部分，判断枢纽值的位置，如果该枢     纽值的位置为 k-1 的话，那么枢纽值和它前面的所有数字就是最小的 k 个数。如果枢纽值的位置小于 k-1 的话，假设枢     纽值的位置为 n-1，那么我们已经找到了前 n 小的数字了，我们就还需要到后半部分去寻找后半部分 k-n 小的值，进行划     分。当该枢纽值的位置比 k-1大时，说明最小的 k 个值还在左半部分，我们需要继续对左半部分进行划分。这一种方法的平     均时间复杂度为 O(n)。 （3）第三种方法是维护一个容量为 k 的最大堆。对数组进行遍历时，如果堆的容量还没有达到 k ，则直接将元素加入到堆中，这     就相当于我们假设前 k 个数就是最小的 k 个数。对 k 以后的元素遍历时，我们将该元素与堆的最大值进行比较，如果比最     大值小，那么我们则将最大值与其交换，然后调整堆。如果大于等于堆的最大值，则继续向后遍历，直到数组遍历完成。这一     种方法的平均时间复杂度为 O(nlogk)。</code></pre><p>   详细资料可以参考：<br>   <a href="https://www.kancloud.cn/kancloud/the-art-of-programming/41579">《寻找最小的 k 个数》</a></p><h4 id="30-连续子数组的最大和"><a href="#30-连续子数组的最大和" class="headerlink" title="30. 连续子数组的最大和"></a>30. 连续子数组的最大和</h4><pre><code> 题目： HZ 偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后，他又发话了:在古老的一维模式识别中，常常需要计 算连续子向量的最大和,当向量全为正数的时候，问题很好解决。但是，如果向量中包含负数，是否应该包含某个负数，并期望旁边的 正数会弥补它呢？例如：{6,-3,-2,7,-15,1,2,2}，连续子向量的最大和为8（从第0个开始，到第3个为止）。你会不会被他忽悠 住？（子向量的长度至少是1） 思路： （1）第一种思路是直接暴力求解的方式，先以第一个数字为首往后开始叠加，叠加的过程中保存最大的值。然后再以第二个数字为首     往后开始叠加，并与先前保存的最大的值进行比较。这一种方法的时间复杂度为 O(n^2)。 （2）第二种思路是，首先我们观察一个最大和的连续数组的规律，我们可以发现，子数组一定是以正数开头的，中间包含了正负数。     因此我们可以从第一个数开始向后叠加，每次保存最大的值。叠加的值如果为负数，则将叠加值初始化为0，因为后面的数加上负     数只会更小，因此需要寻找下一个正数开始下一个子数组的判断。一直往后判断，直到这个数组遍历完成为止，得到最大的值。     使用这一种方法的时间复杂度为 O(n)。</code></pre><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-one.html">《连续子数组的最大和》</a></p><h4 id="31-整数中1出现的次数（待深入理解）"><a href="#31-整数中1出现的次数（待深入理解）" class="headerlink" title="31. 整数中1出现的次数（待深入理解）"></a>31. 整数中1出现的次数（待深入理解）</h4><pre><code> 题目： 求出1~13的整数中1出现的次数，并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、 12、13因此共出现6次，但是对于后面问题他就没辙了。ACMer希望你们帮帮他，并把问题更加普遍化，可以很快的求出任意非负整 数区间中1出现的次数。 思路： （1）第一种思路是直接遍历每个数，然后将判断每个数中 1 的个数，一直叠加。 （2）第二种思路是求出1出现在每位上的次数，然后进行叠加。</code></pre><p>   详细资料可以参考：<br>   <a href="https://blog.csdn.net/yi_Afly/article/details/52012593">《从1到n整数中1出现的次数：O(logn)算法》</a></p><h4 id="32-把数组排成最小的数"><a href="#32-把数组排成最小的数" class="headerlink" title="32. 把数组排成最小的数"></a>32. 把数组排成最小的数</h4><pre><code> 题目： 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321 }，则打印出这三个数字能排成的最小数字为321323。 思路： （1）求出数组的全排列，然后对每个排列结果进行比较。 （2）利用排序算法实现，但是比较时，比较的并不是两个元素的大小，而是两个元素正序拼接和逆序拼接的大小，如果逆序拼接的     结果更小，则交换两个元素的位置。排序结束后，数组的顺序则为最小数的排列组合顺序。</code></pre><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-three.html">《把数组排成最小的数》</a></p><h4 id="33-丑数（待深入理解）"><a href="#33-丑数（待深入理解）" class="headerlink" title="33. 丑数（待深入理解）"></a>33. 丑数（待深入理解）</h4><pre><code> 题目： 把只包含质因子2、3和5的数称作丑数。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求 按从小到大的顺序的第 N 个丑数。 思路： （1）判断一个数是否为丑数，可以判断该数不断除以2，最后余数是否为1。判断该数不断除以3，最后余数是否为1。判断不断除以     5，最后余数是否为1。在不考虑时间复杂度的情况下，可以依次遍历找到第 N 个丑数。 （2）使用一个数组来保存已排序好的丑数，后面的丑数由前面生成。</code></pre><h4 id="34-第一个只出现一次的字符"><a href="#34-第一个只出现一次的字符" class="headerlink" title="34. 第一个只出现一次的字符"></a>34. 第一个只出现一次的字符</h4><pre><code> 题目： 在一个字符串（1&lt;=字符串长度&lt;=10000，全部由大写字母组成）中找到第一个只出现一次的字符，并返回它的位置。 思路： （1）第一种思路是，从前往后遍历每一个字符。每遍历一个字符，则将字符与后边的所有字符依次比较，判断是否含有相同字符。这     一种方法的时间复杂度为 O(n^2)。 （2）第二种思路是，首先对字符串进行一次遍历，将字符和字符出现的次数以键值对的形式存储在 Map 结构中。然后第二次遍历时     ，去 Map 中获取对应字符出现的次数，找到第一个只出现一次的字符。这一种方法的时间复杂度为 O(n)。</code></pre><h4 id="35-数组中的逆序对"><a href="#35-数组中的逆序对" class="headerlink" title="35. 数组中的逆序对"></a>35. 数组中的逆序对</h4><pre><code> 题目： 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对 的总数 P。 思路： （1）第一种思路是直接求解的方式，顺序扫描整个数组。每扫描到一个数字的时候，逐个比较该数字和它后面的数字的大小。如果     后面的数字比它小，则这两个数字就组成了一个逆序对。假设数组中含有 n 个数字。由于每个数字都要和 O(n）个数字作比     较，因此这个算法的时间复杂度是 O(n^2)。 （2）第二种方式是使用归并排序的方式，通过利用归并排序分解后进行合并排序时，来进行逆序对的统计，这一种方法的时间复杂     度为 O(nlogn)。</code></pre><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-six.html">《数组中的逆序对》</a></p><h4 id="36-两个链表的第一个公共结点"><a href="#36-两个链表的第一个公共结点" class="headerlink" title="36. 两个链表的第一个公共结点"></a>36. 两个链表的第一个公共结点</h4><pre><code> 题目： 输入两个链表，找出它们的第一个公共结点。 思路： （1）第一种方法是在第一个链表上顺序遍历每个结点，每遍历到一个结点的时候，在第二个链表上顺序遍历每个结点。如果在第二     个链表上有一个结点和第一个链表上的结点一样，说明两个链表在这个结点上重合，于是就找到了它们的公共结点。如果第一     个链表的长度为 m，第二个链表的长度为 n。这一种方法的时间复杂度是 O(mn）。 （2）第二种方式是利用栈的方式，通过观察我们可以发现两个链表的公共节点，都位于链表的尾部，以此我们可以分别使用两个栈     ，依次将链表元素入栈。然后在两个栈同时将元素出栈，比较出栈的节点，最后一个相同的节点就是我们要找的公共节点。这     一种方法的时间复杂度为 O(m+n)，空间复杂度为 O(m+n)。 （3）第三种方式是，首先分别遍历两个链表，得到两个链表的长度。然后得到较长的链表与较短的链表长度的差值。我们使用两个     指针来分别对两个链表进行遍历，首先将较长链表的指针移动 n 步，n 为两个链表长度的差值，然后两个指针再同时移动，     判断所指向节点是否为同一节点。这一种方法的时间复杂度为 O(m+n)，相同对于上一种方法不需要额外的空间。</code></pre><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-seven.html">《两个链表的第一个公共结点》</a></p><h4 id="37-数字在排序数组中出现的次数"><a href="#37-数字在排序数组中出现的次数" class="headerlink" title="37. 数字在排序数组中出现的次数"></a>37. 数字在排序数组中出现的次数</h4><pre><code> 题目： 统计一个数字：在排序数组中出现的次数。例如输入排序数组｛ 1, 2, 3, 3, 3, 3, 4, 5｝和数字 3 ，由于 3 在这个数组中出 现了 4 次，因此输出 4 。 思路： （1）第一种方法是直接对数组顺序遍历的方式，通过这种方法来统计数字的出现次数。这种方法的时间复杂度为 O(n)。 （2）第二种方法是使用二分查找的方法，由于数组是排序好的数组，因此相同数字是排列在一起的。统计数字出现的次数，我们需要     去找到该段数字开始和结束的位置，以此来确定数字出现的次数。因此我们可以使用二分查找的方式来确定该数字的开始和结束     位置。如果我们第一次我们数组的中间值为 k ，如果 k 值比所求值大的话，那么我们下一次只需要判断前面一部分就行了，如     果 k值比所求值小的话，那么我们下一次就只需要判断后面一部分就行了。如果 k 值等于所求值的时候，我们则需要判断该值     是否为开始位置或者结束位置。如果是开始位置，那么我们下一次需要到后半部分去寻找结束位置。如果是结束位置，那么我们     下一次需要到前半部分去寻找开始位置。如果既不是开始位置也不是结束位置，那么我们就分别到前后两个部分去寻找开始和结     束位置。这一种方法的平均时间复杂度为 O(logn)。</code></pre><h4 id="38-二叉树的深度"><a href="#38-二叉树的深度" class="headerlink" title="38. 二叉树的深度"></a>38. 二叉树的深度</h4><pre><code> 题目： 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深 度。 思路： 根节点的深度等于左右深度较大值加一，因此可以通过递归遍历来实现。</code></pre><h4 id="39-平衡二叉树"><a href="#39-平衡二叉树" class="headerlink" title="39. 平衡二叉树"></a>39. 平衡二叉树</h4><pre><code> 题目： 输入一棵二叉树，判断该二叉树是否是平衡二叉树。 思路： （1）在遍历树的每个结点的时候，调用函数得到它的左右子树的深度。如果每个结点的左右子树的深度相差都不超过 1 ，那么它     就是一棵平衡的二叉树。使用这种方法时，节点会被多次遍历，因此会造成效率不高的问题。 （2）在求一个节点的深度时，同时判断它是否平衡。如果不平衡则直接返回 -1，否则返回树高度。如果一个节点的一个子树的深     度为-1，那么就直接向上返回 -1 ，该树已经是不平衡的了。通过这种方式确保了节点只能够被访问一遍。</code></pre><h4 id="40-数组中只出现一次的数字"><a href="#40-数组中只出现一次的数字" class="headerlink" title="40. 数组中只出现一次的数字"></a>40. 数组中只出现一次的数字</h4><pre><code> 题目： 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 思路： （1）第一种方式是依次遍历数组，记录下数字出现的次数，从而找出两个只出现一次的数字。 （2）第二种方式，根据位运算的异或的性质，我们可以知道两个相同的数字异或等于0，一个数和 0 异或还是它本身。由于数组中     的其他数字都是成对出现的，因此我们可以将数组中的所有数依次进行异或运算。如果只有一个数出现一次的话，那么最后剩下     的就是落单的数字。如果是两个数只出现了一次的话，那么最后剩下的就是这两个数异或的结果。这个结果中的1表示的是 A 和     B 不同的位。我们取异或结果的第一个1所在的位数，假如是第3位，接着通过比较第三位来将数组分为两组，相同数字一定会     被分到同一组。分组完成后再按照依次异或的思路，求得剩余数字即为两个只出现一次的数字。</code></pre><h4 id="41-和为-S-的连续正数序列"><a href="#41-和为-S-的连续正数序列" class="headerlink" title="41. 和为 S 的连续正数序列"></a>41. 和为 S 的连续正数序列</h4><pre><code> 题目： 小明很喜欢数学，有一天他在做数学作业时，要求计算出9~16的和，他马上就写出了正确答案是100。但是他并不满足于此，他在想究 竟有多少种连续的正数序列的和为100（至少包括两个数）。没多久，他就得到另一组连续正数和为100的序列：18,19,20,21,22。 现在把问题交给你，你能不能也很快的找出所有和为 S 的连续正数序列？Good Luck!输出描述：输出所有和为S的连续正数序列。序 列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序。 思路： 维护一个正数序列数组，数组中初始只含有值1和2，然后从3依次往后遍历，每遍历到一个元素则将这个元素加入到序列数组中，然后 判断此时序列数组的和。如果序列数组的和大于所求值，则将第一个元素（最小的元素弹出）。如果序列数组的和小于所求值，则继续 往后遍历，将元素加入到序列中继续判断。当序列数组的和等于所求值时，打印出此时的正数序列，然后继续往后遍历，寻找下一个连 续序列，直到数组遍历完成终止。</code></pre><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-forty-one.html">《和为 s 的连续正数序列》</a></p><h4 id="42-和为-S-的两个数字"><a href="#42-和为-S-的两个数字" class="headerlink" title="42. 和为 S 的两个数字"></a>42. 和为 S 的两个数字</h4><pre><code> 题目： 输入一个递增排序的数组和一个数字 S，在数组中查找两个数，是的他们的和正好是 S，如果有多对数字的和等于 S，输出两个数 的乘积最小的。输出描述：对应每个测试案例，输出两个数，小的先输出。 思路： 首先我们通过规律可以发现，和相同的两个数字，两个数字的差值越大，乘积越小。因此我们只需要从数组的首尾开始找到第一对和 为 s 的数字对进行了。因此我们可以使用双指针的方式，左指针初始指向数组的第一个元素，右指针初始指向数组的最后一个元素 。然后首先判断两个指针指向的数字的和是否为 s ，如果为 s ，两个指针指向的数字就是我们需要寻找的数字对。如果两数的和 比 s 小，则将左指针向左移动一位后继续判断。如果两数的和比 s 大，则将右指针向右移动一位后继续判断。</code></pre><p>   详细资料可以参考：<br>   <a href="https://www.cnblogs.com/wuguanglin/p/FindNumbersWithSum.html">《和为 S 的字符串》</a></p><h4 id="43-左旋转字符串"><a href="#43-左旋转字符串" class="headerlink" title="43. 左旋转字符串"></a>43. 左旋转字符串</h4><pre><code> 题目： 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的 字符序列 S，请你把其循环左移 K 位后的序列输出。例如，字符序列 S=”abcXYZdef”，要求输出循环左移3位后的结果，即 “X YZdefabc”。是不是很简单？OK，搞定它！ 思路： 字符串裁剪后拼接</code></pre><h4 id="44-翻转单词顺序列"><a href="#44-翻转单词顺序列" class="headerlink" title="44. 翻转单词顺序列"></a>44. 翻转单词顺序列</h4><pre><code> 题目： 牛客最近来了一个新员工 Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事 Cat 对 Fish 写的内容颇感兴趣，有 一天他向 Fish 借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了 ，正确的句子应该是“I am a student.”。Cat 对一一的翻转这些单词顺序可不在行，你能帮助他么？ 思路： 通过空格将单词分隔，然后将数组反序后，重新拼接为字符串。</code></pre><h4 id="45-扑克牌的顺子"><a href="#45-扑克牌的顺子" class="headerlink" title="45. 扑克牌的顺子"></a>45. 扑克牌的顺子</h4><pre><code> 题目： LL 今天心情特别好，因为他去买了一副扑克牌，发现里面居然有2个大王，2个小王（一副牌原本是54张^_^）...他随机从中抽出 了5张牌，想测测自己的手气，看看能不能抽到顺子，如果抽到的话，他决定去买体育彩票，嘿嘿！！“红心 A，黑桃3，小王，大王 ，方片5”，“Oh My God!”不是顺子..... LL 不高兴了，他想了想，决定大\小王可以看成任何数字，并且 A 看作1，J 为11， Q 为12，K 为13。上面的5张牌就可以变成“1,2,3,4,5”（大小王分别看作2和4），“So Lucky!”。LL 决定去买体育彩票啦。 现在，要求你使用这幅牌模拟上面的过程，然后告诉我们 LL 的运气如何。为了方便起见，你可以认为大小王是0。 思路： 首先判断5个数字是不是连续的，最直观的方法是把数组排序。值得注意的是，由于 0 可以当成任意数字，我们可以用 0 去补满数 组中的空缺。如果排序之后的数组不是连续的，即相邻的两个数字相隔若干个数字，但只要我们有足够的。可以补满这两个数字的空 缺，这个数组实际上还是连续的。 于是我们需要做 3 件事情：首先把数组排序，再统计数组中 0 的个数，最后统计排序之后的数组中相邻数字之间的空缺总数。如 果空缺的总数小于或者等于 0 的个数，那么这个数组就是连续的：反之则不连续。最后，我们还需要注意一点：如果数组中的非 0 数字重复出现，则该数组不是连续的。换成扑克牌的描述方式就是如果一副牌里含有对子，则不可能是顺子。</code></pre><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-forty-four.html">《扑克牌的顺子》</a></p><h4 id="46-圆圈中最后剩下的数字（约瑟夫环问题）"><a href="#46-圆圈中最后剩下的数字（约瑟夫环问题）" class="headerlink" title="46. 圆圈中最后剩下的数字（约瑟夫环问题）"></a>46. 圆圈中最后剩下的数字（约瑟夫环问题）</h4><pre><code> 题目： 0, 1, … , n-1 这 n 个数字排成一个圈圈，从数字 0 开始每次从圆圏里删除第 m 个数字。求出这个圈圈里剩下的最后一个数 字。 思路： （1）使用环形链表进行模拟。 （2）根据规律得出（待深入理解）</code></pre><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-forty-five.html">《圆圈中最后剩下的数字》</a></p><h4 id="47-1-2-3-…-n"><a href="#47-1-2-3-…-n" class="headerlink" title="47. 1+2+3+…+n"></a>47. 1+2+3+…+n</h4><pre><code> 题目： 求 1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。 思路： 由于不能使用循环语句，因此我们可以通过递归来实现。并且由于不能够使用条件判断运算符，我们可以利用 &amp;&amp; 操作符的短路特 性来实现。</code></pre><h4 id="48-不用加减乘除做加法"><a href="#48-不用加减乘除做加法" class="headerlink" title="48. 不用加减乘除做加法"></a>48. 不用加减乘除做加法</h4><pre><code> 题目： 写一个函数，求两个整数之和，要求在函数体内不得使用 ＋、－、×、÷ 四则运算符号。 思路： 通过位运算，递归来实现。</code></pre><h4 id="49-把字符串转换成整数。"><a href="#49-把字符串转换成整数。" class="headerlink" title="49. 把字符串转换成整数。"></a>49. 把字符串转换成整数。</h4><pre><code> 题目： 将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。数值为0或者字符串不是一个合法的数值则返回 0。输入描 述：输入一个字符串，包括数字字母符号，可以为空。输出描述：如果是合法的数值表达则返回该数字，否则返回0。 思路： 首先需要进行符号判断，其次我们根据字符串的每位通过减0运算转换为整数和，依次根据位数叠加。</code></pre><h4 id="50-数组中重复的数字"><a href="#50-数组中重复的数字" class="headerlink" title="50. 数组中重复的数字"></a>50. 数组中重复的数字</h4><pre><code> 题目： 在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知 道每个数字重复了几次。请找出数组中任意一个重复的数字。 思路： （1）首先将数组排序，排序后再进行判断。这一种方法的时间复杂度为 O(nlogn)。 （2）使用 Map 结构的方式，依次记录下每一个数字出现的次数，从而可以判断是否出现重复数字。这一种方法的时间复杂度为 O     (n)，空间复杂度为 O(n)。 （3）从数组首部开始遍历，每遍历一个数字，则将该数字和它的下标相比较，如果数字和下标不等，则将该数字和它对应下标的值     交换。如果对应的下标值上已经是正确的值了，那么说明当前元素是一个重复数字。这一种方法相对于上一种方法来说不需要     额外的内存空间。</code></pre><h4 id="51-构建乘积数组"><a href="#51-构建乘积数组" class="headerlink" title="51. 构建乘积数组"></a>51. 构建乘积数组</h4><pre><code> 题目： 给定一个数组 A[0,1,...,n-1]，请构建一个数组 B[0,1,...,n-1]，其中 B 中的元素 B[i]=A[0]*A[1]*...*A[i-1]*A [i+1]*...*A[n-1]。不能使用除法。 思路： （1）  C[i]=A[0]×A[1]×...×A[i-1]=C[i-1]×A[i-1]        D[i]=A[i+1]×...×A[n-1]=D[i+1]×A[i+1]        B[i]=C[i]×D[i]       将乘积分为前后两个部分，分别循环求出后，再进行相乘。 （2）上面的方法需要额外的内存空间，我们可以引入中间变量的方式，来降低空间复杂度。（待深入理解）</code></pre><p>   详细资料可以参考：<br>   <a href="https://zhuanlan.zhihu.com/p/34804711">《构建乘积数组》</a></p><h4 id="52-正则表达式的匹配"><a href="#52-正则表达式的匹配" class="headerlink" title="52. 正则表达式的匹配"></a>52. 正则表达式的匹配</h4><pre><code> 题目： 请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任 意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配， 但是与"aa.a"和"ab*a"均不匹配。 思路： （1）状态机思路（待深入理解）</code></pre><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-fifty-three.html">《正则表达式匹配》</a></p><h4 id="53-表示数值的字符串"><a href="#53-表示数值的字符串" class="headerlink" title="53. 表示数值的字符串"></a>53. 表示数值的字符串</h4><pre><code> 题目： 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E- 16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。、 思路： 利用正则表达式实现</code></pre><h4 id="54-字符流中第一个不重复的字符"><a href="#54-字符流中第一个不重复的字符" class="headerlink" title="54. 字符流中第一个不重复的字符"></a>54. 字符流中第一个不重复的字符</h4><pre><code> 题目： 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 "go" 时，第一个只出现一次 的字符是 "g" 。当从该字符流中读出前六个字符 "google" 时，第一个只出现一次的字符是 "l"。 输出描述：如果当前字符流 没有存在出现一次的字符，返回#字符。 思路： 同第 34 题</code></pre><h4 id="55-链表中环的入口结点"><a href="#55-链表中环的入口结点" class="headerlink" title="55. 链表中环的入口结点"></a>55. 链表中环的入口结点</h4><pre><code> 题目： 一个链表中包含环，如何找出环的入口结点？ 思路： 首先使用快慢指针的方式我们可以判断链表中是否存在环，当快慢指针相遇时，说明链表中存在环。相遇点一定存在于环中，因此我 们可以从使用一个指针从这个点开始向前移动，每移动一个点，环的长度加一，当指针再次回到这个点的时候，指针走了一圈，因此 通过这个方法我们可以得到链表中的环的长度，我们将它记为 n 。 然后我们设置两个指针，首先分别指向头结点，然后将一个指针先移动 n 步，然后两个指针再同时移动，当两个指针相遇时，相遇 点就是环的入口节点。</code></pre><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-fifty-six.html">《链表中环的入口结点》</a><br>   <a href="https://blog.csdn.net/shansusu/article/details/50285735">《《剑指offer》——链表中环的入口结点》</a></p><h4 id="56-删除链表中重复的结点"><a href="#56-删除链表中重复的结点" class="headerlink" title="56. 删除链表中重复的结点"></a>56. 删除链表中重复的结点</h4><pre><code> 题目： 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。例如，链表1-&gt;2-&gt;3- &gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 思路： 解决这个问题的第一步是确定删除的参数。当然这个函数需要输入待删除链表的头结点。头结点可能与后面的结点重复，也就是说头 结点也可能被删除，所以在链表头额外添加一个结点。 接下来我们从头遍历整个链表。如果当前结点的值与下一个结点的值相同，那么它们就是重复的结点，都可以被删除。为了保证删除 之后的链表仍然是相连的而没有中间断开，我们要把当前的前一个结点和后面值比当前结点的值要大的结点相连。我们要确保 prev 要始终与下一个没有重复的结点连接在一起。</code></pre><h4 id="57-二叉树的下一个结点"><a href="#57-二叉树的下一个结点" class="headerlink" title="57. 二叉树的下一个结点"></a>57. 二叉树的下一个结点</h4><pre><code> 题目： 给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？树中的结点除了有两个分别指向左右子结点的指针以外， 还有一个指向父节点的指针。 思路： 这个问题我们可以分为三种情况来讨论。 第一种情况，当前节点含有右子树，这种情况下，中序遍历的下一个节点为该节点右子树的最左子节点。因此我们只要从右子节点 出发，一直沿着左子节点的指针，就能找到下一个节点。 第二种情况是，当前节点不含有右子树，并且当前节点为父节点的左子节点，这种情况下中序遍历的下一个节点为当前节点的父节 点。 第三种情况是，当前节点不含有右子树，并且当前节点为父节点的右子节点，这种情况下我们沿着父节点一直向上查找，直到找到 一个节点，该节点为父节点的左子节点。这个左子节点的父节点就是中序遍历的下一个节点。</code></pre><h4 id="58-对称二叉树"><a href="#58-对称二叉树" class="headerlink" title="58. 对称二叉树"></a>58. 对称二叉树</h4><pre><code> 题目： 请实现一个函数来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 思路： 我们对一颗二叉树进行前序遍历的时候，是先访问左子节点，然后再访问右子节点。因此我们可以定义一种对称的前序遍历的方式 ，就是先访问右子节点，然后再访问左子节点。通过比较两种遍历方式最后的结果是否相同，以此来判断该二叉树是否为对称二叉 树。</code></pre><h4 id="59-按之字形顺序打印二叉树（待深入理解）"><a href="#59-按之字形顺序打印二叉树（待深入理解）" class="headerlink" title="59. 按之字形顺序打印二叉树（待深入理解）"></a>59. 按之字形顺序打印二叉树（待深入理解）</h4><pre><code> 题目： 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，即第一行按照 从左到右的顺序打印，第二层按照从右到左顺序打印，第三行再按照从左到右的顺序打印，其他以此类推。 思路： 按之字形顺序打印二叉树需要两个栈。我们在打印某一行结点时，把下一层的子结点保存到相应的栈里。如果当前打印的是奇数层 ，则先保存左子结点再保存右子结点到一个栈里；如果当前打印的是偶数层，则先保存右子结点再保存左子结点到第二个栈里。每 一个栈遍历完成后进入下一层循环。</code></pre><p>   详细资料可以参考：<br>   <a href="https://www.cnblogs.com/wuguanglin/p/Print.html">《按之字形顺序打印二叉树》</a></p><h4 id="60-从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。"><a href="#60-从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。" class="headerlink" title="60. 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。"></a>60. 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</h4><pre><code> 题目： 从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印一行。 思路： 用一个队列来保存将要打印的结点。为了把二叉树的每一行单独打印到一行里，我们需要两个变量：一个变量表示在当前的层中还 没有打印的结点数，另一个变量表示下一次结点的数目。</code></pre><h4 id="61-序列化二叉树（待深入理解）"><a href="#61-序列化二叉树（待深入理解）" class="headerlink" title="61. 序列化二叉树（待深入理解）"></a>61. 序列化二叉树（待深入理解）</h4><pre><code> 题目： 请实现两个函数，分别用来序列化和反序列化二叉树。 思路： 数组模拟</code></pre><h4 id="62-二叉搜索树的第-K-个节点"><a href="#62-二叉搜索树的第-K-个节点" class="headerlink" title="62. 二叉搜索树的第 K 个节点"></a>62. 二叉搜索树的第 K 个节点</h4><pre><code> 题目： 给定一颗二叉搜索树，请找出其中的第 k 小的结点。 思路： 对一颗树首先进行中序遍历，在遍历的同时记录已经遍历的节点数，当遍历到第 k 个节点时，这个节点即为第 k 大的节点。</code></pre><h4 id="63-数据流中的中位数（待深入理解）"><a href="#63-数据流中的中位数（待深入理解）" class="headerlink" title="63. 数据流中的中位数（待深入理解）"></a>63. 数据流中的中位数（待深入理解）</h4><pre><code> 题目： 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有值排序之后位于中间的数值。如果数据 流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</code></pre><h4 id="64-滑动窗口中的最大值（待深入理解）"><a href="#64-滑动窗口中的最大值（待深入理解）" class="headerlink" title="64. 滑动窗口中的最大值（待深入理解）"></a>64. 滑动窗口中的最大值（待深入理解）</h4><pre><code> 题目： 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的 大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下 6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2 ,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 思路： 使用队列的方式模拟</code></pre><h4 id="65-矩阵中的路径（待深入理解）"><a href="#65-矩阵中的路径（待深入理解）" class="headerlink" title="65. 矩阵中的路径（待深入理解）"></a>65. 矩阵中的路径（待深入理解）</h4><pre><code> 题目： 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每 一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子 。例如 a b c e s f c s a d e e 矩阵中包含一条字符串"bcced"的路径，但是矩阵中不包含"abcb"路径，因为字符串的 第一个字符 b 占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</code></pre><h4 id="66-机器人的运动范围（待深入理解）"><a href="#66-机器人的运动范围（待深入理解）" class="headerlink" title="66. 机器人的运动范围（待深入理解）"></a>66. 机器人的运动范围（待深入理解）</h4><pre><code> 题目： 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能 进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是 ，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</code></pre><p>剑指 offer 相关资料可以参考：<br><a href="https://blog.csdn.net/zzl819954692/article/details/79648054">《剑指 offer 题目练习及思路分析》</a><br><a href="https://www.cnblogs.com/wuguanglin/p/code-interview.html">《JS 版剑指 offer》</a><br><a href="https://wiki.jikexueyuan.com/project/for-offer/">《剑指 Offer 学习心得》</a></p><h2 id="相关算法题"><a href="#相关算法题" class="headerlink" title="相关算法题"></a>相关算法题</h2><h4 id="1-明星问题"><a href="#1-明星问题" class="headerlink" title="1. 明星问题"></a>1. 明星问题</h4><pre><code>题目：有 n 个人，其中一个明星和 n-1 个群众，群众都认识明星，明星不认识任何群众，群众和群众之间的认识关系不知道，现有一个函数 foo(A, B)，若 A 认识 B 返回 true，若 A 不认识 B 返回 false，试设计一种算法找出明星，并给出时间复杂度。思路：（1）第一种方法我们可以直接使用双层循环遍历的方式，每一个人都和其他人进行判断，如果一个人谁都不认识，那么他就是明星。    这一种方法的时间复杂度为 O(n^2)。（2）上一种方法没有充分利用题目所给的条件，其实我们每一次比较，都可以排除一个人的可能。比如如果 A 认识 B，那么说明    A 就不会是明星，因此 A 就可以从数组中移除。如果 A 不认识 B，那么说明 B 不可能是明星，因此 B 就可以从数组中移    除。因此每一次判断都能够减少一个可能性，我们只需要从数组从前往后进行遍历，每次移除一个不可能的人，直到数组中只剩    一人为止，那么这个人就是明星。这一种方法的时间复杂度为 O(n)。</code></pre><p>   详细资料可以参考：<br>   <a href="https://www.nowcoder.com/questionTerminal/fd3caff374c945fb9ea5f107016bcd4f">《一个明星和 n-1 个群众》</a></p><h4 id="2-正负数组求和"><a href="#2-正负数组求和" class="headerlink" title="2. 正负数组求和"></a>2. 正负数组求和</h4><pre><code>题目：有两个数组，一个数组里存放的是正整数，另一个数组里存放的是负整数，都是无序的，现在从两个数组里各拿一个，使得它们的和最接近零。思路：（1）首先我们可以对两个数组分别进行排序，正数数组按从小到大排序，负数数组按从大到小排序。排序完成后我们使用两个指针分    别指向两个数组的首部，判断两个指针的和。如果和大于0，则负数指针往后移动一个位置，如果和小于0，则正数指针往后移动    一个位置，每一次记录和的值，和当前保存下来的最小值进行比较。</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>https证书自动续签</title>
      <link href="/My-Blogs/2021/12/20/%E5%AE%89%E5%85%A8/https%E8%AF%81%E4%B9%A6%E8%87%AA%E5%8A%A8%E7%BB%AD%E7%AD%BE/"/>
      <url>/My-Blogs/2021/12/20/%E5%AE%89%E5%85%A8/https%E8%AF%81%E4%B9%A6%E8%87%AA%E5%8A%A8%E7%BB%AD%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="安装说明"><a href="#安装说明" class="headerlink" title="安装说明"></a><a href="https://github.com/acmesh-official/acme.sh/wiki/%E8%AF%B4%E6%98%8E">安装说明</a></h2><h2 id="续签代码"><a href="#续签代码" class="headerlink" title="续签代码"></a>续签代码</h2><pre><code class="BASH">acme.sh --install-cert -d eth2app.com -d test.eth2app.com -d api.eth2app.com -d h5.eth2app.com  -d h5admin.eth2app.com -d rpc.eth2app.com  --key-file       /etc/nginx/ssl/eth2app.com/key.pem  --fullchain-file /etc/nginx/ssl/eth2app.com/cert.pemacme.sh --issue --dns dns_gd -d eth2app.com -d test.eth2app.com -d api.eth2app.com -d h5.eth2app.com -d h5admin.eth2app.com -d rpc.eth2app.com</code></pre><h2 id="DNS-API"><a href="#DNS-API" class="headerlink" title="DNS API"></a><a href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi">DNS API</a></h2><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> 证书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常见问题</title>
      <link href="/My-Blogs/2021/12/18/Git/Git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/My-Blogs/2021/12/18/Git/Git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="git-pull-和-git-fetch-的区别"><a href="#git-pull-和-git-fetch-的区别" class="headerlink" title="git pull 和 git fetch 的区别"></a>git pull 和 git fetch 的区别</h2><pre><code class="BASH">git fetch 只是将远程仓库的变化下载下来，并没有和本地分支合并。git pull 会将远程仓库的变化下载下来，并和当前分支合并。</code></pre><h2 id="git-rebase-和-git-merge-的区别"><a href="#git-rebase-和-git-merge-的区别" class="headerlink" title="git rebase 和 git merge 的区别"></a>git rebase 和 git merge 的区别</h2><pre><code class="BASH">git merge 和 git rebase 都是用于分支合并，关键在 commit 记录的处理上不同。git merge 会新建一个新的 commit 对象，然后两个分支以前的 commit 记录都指向这个新 commit 记录。这种方法会保留之前每个分支的 commit 历史。git rebase 会先找到两个分支的第一个共同的 commit 祖先记录，然后将提取当前分支这之后的所有 commit 记录，然后将这个 commit 记录添加到目标分支的最新提交后面。经过这个合并后，两个分支合并后的 commit 记录就变为了线性的记录了。</code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试总结-JavaScript篇</title>
      <link href="/My-Blogs/2021/12/07/JavaScript/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
      <url>/My-Blogs/2021/12/07/JavaScript/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>本章节是<a href="https://github.com/h5bp/Front-end-Developer-Interview-Questions/blob/master/src/questions/javascript-questions.md">前端开发者面试问题 - JS 部分</a>的参考答案。 欢迎提出 PR 进行建议和指正！</p><a id="more"></a><h2 id="请简述JavaScript中的this。​"><a href="#请简述JavaScript中的this。​" class="headerlink" title="请简述JavaScript中的this。​"></a>请简述JavaScript中的this。​</h2><p>JS 中的<code>this</code>是一个相对复杂的概念，不是简单几句能解释清楚的。粗略地讲，函数的调用方式决定了<code>this</code>的值。我阅读了网上很多关于<code>this</code>的文章，<a href="https://medium.com/@arnav_aggarwal">Arnav Aggrawal</a> 写的比较清楚。this取值符合以下规则：</p><ol><li> 在调用函数时使用new关键字，函数内的this是一个全新的对象。</li><li> 如果<code>apply</code>、<code>call</code>或<code>bind</code>方法用于调用、创建一个函数，函数内的 <code>this</code> 就是作为参数传入这些方法的对象。</li><li> 当函数作为对象里的方法被调用时，函数内的this是调用该函数的对象。比如当<code>obj.method()</code>被调用时，函数内的 <code>this</code> 将绑定到obj对象。</li><li> 如果调用函数不符合上述规则，那么this的值指向全局对象（<code>global object</code>）。浏览器环境下this的值指向window对象，但是在严格模式下(<code>'use strict'</code>)，<code>this</code>的值为<code>undefined</code>。</li><li> 如果符合上述多个规则，则较高的规则（1 号最高，4 号最低）将决定<code>this</code>的值。</li><li> 如果该函数是 ES2015 中的箭头函数，将忽略上面的所有规则，<code>this</code>被设置为它被创建时的上下文。</li></ol><h2 id="Object-is-与原来的比较操作符-“-”、“-”-的区别？"><a href="#Object-is-与原来的比较操作符-“-”、“-”-的区别？" class="headerlink" title="Object.is() 与原来的比较操作符 “===”、“==” 的区别？"></a>Object.is() 与原来的比较操作符 “===”、“==” 的区别？</h2><pre><code class="JS">两等号判等，会在比较时进行类型转换。三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回false）。Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true.Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。</code></pre><h2 id="介绍一下-js-的节流与防抖？"><a href="#介绍一下-js-的节流与防抖？" class="headerlink" title="介绍一下 js 的节流与防抖？"></a>介绍一下 js 的节流与防抖？</h2><pre><code class="JS">// 函数防抖： 在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。// 函数节流： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。// 函数防抖的实现function debounce(fn, wait) {  var timer = null;  return function() {    var context = this,      args = arguments;    // 如果此时存在定时器的话，则取消之前的定时器重新记时    if (timer) {      clearTimeout(timer);      timer = null;    }    // 设置定时器，使事件间隔指定事件后执行    timer = setTimeout(() =&gt; {      fn.apply(context, args);    }, wait);  };}// 函数节流的实现;function throttle(fn, delay) {  var preTime = Date.now();  return function() {    var context = this,      args = arguments,      nowTime = Date.now();    // 如果两次时间间隔超过了指定时间，则执行函数。    if (nowTime - preTime &gt;= delay) {      preTime = Date.now();      return fn.apply(context, args);    }  };}</code></pre><h2 id="escape-encodeURI-encodeURIComponent-有什么区别？"><a href="#escape-encodeURI-encodeURIComponent-有什么区别？" class="headerlink" title="escape,encodeURI,encodeURIComponent 有什么区别？"></a>escape,encodeURI,encodeURIComponent 有什么区别？</h2><pre><code class="JS">encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。</code></pre><h2 id="js-的事件循环是什么？"><a href="#js-的事件循环是什么？" class="headerlink" title="js 的事件循环是什么？"></a>js 的事件循环是什么？</h2><h3 id="相关知识点："><a href="#相关知识点：" class="headerlink" title="相关知识点："></a>相关知识点：</h3><pre><code>  事件队列是一个存储着待执行任务的队列，其中的任务严格按照时间先后顺序执行，排在队头的任务将会率先执行，而排在队尾的任务会最后执行。事件队列每次仅执行一个任务，在该任务执行完毕之后，再执行下一个任务。执行栈则是一个类似于函数调用栈的运行容器，当执行栈为空时，JS 引擎便检查事件队列，如果不为空的话，事件队列便将第一个任务压入执行栈中运行。</code></pre><h3 id="回答："><a href="#回答：" class="headerlink" title="回答："></a>回答：</h3><blockquote><p>因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</p></blockquote><blockquote><p>微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。</p></blockquote><blockquote><p>宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。</p></blockquote><h2 id="js-中的深浅拷贝实现？"><a href="#js-中的深浅拷贝实现？" class="headerlink" title="js 中的深浅拷贝实现？"></a>js 中的深浅拷贝实现？</h2><pre><code class="JS">// 浅拷贝的实现;function shallowCopy(object) {  // 只拷贝对象  if (!object || typeof object !== "object") return;  // 根据 object 的类型判断是新建一个数组还是对象  let newObject = Array.isArray(object) ? [] : {};  // 遍历 object，并且判断是 object 的属性才拷贝  for (let key in object) {    if (object.hasOwnProperty(key)) {      newObject[key] = object[key];    }  }  return newObject;}// 深拷贝的实现;function deepCopy(object) {  if (!object || typeof object !== "object") return object;  let newObject = Array.isArray(object) ? [] : {};  for (let key in object) {    if (object.hasOwnProperty(key)) {      newObject[key] = deepCopy(object[key]);    }  }  return newObject;}</code></pre><h3 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h3><blockquote><p>浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用  Object.assign 和展开运算符来实现。深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。</p></blockquote><h2 id="手写-call、apply-及-bind-函数"><a href="#手写-call、apply-及-bind-函数" class="headerlink" title="手写 call、apply 及 bind 函数"></a>手写 call、apply 及 bind 函数</h2><pre><code class="JS">// call函数实现Function.prototype.myCall = function(context) {  // 判断调用对象  if (typeof this !== "function") {    console.error("type error");  }  // 获取参数  let args = [...arguments].slice(1),    result = null;  // 判断 context 是否传入，如果未传入则设置为 window  context = context || window;  // 将调用函数设为对象的方法  context.fn = this;  // 调用函数  result = context.fn(...args);  // 将属性删除  delete context.fn;  return result;};// apply 函数实现Function.prototype.myApply = function(context) {  // 判断调用对象是否为函数  if (typeof this !== "function") {    throw new TypeError("Error");  }  let result = null;  // 判断 context 是否存在，如果未传入则为 window  context = context || window;  // 将函数设为对象的方法  context.fn = this;  // 调用方法  if (arguments[1]) {    result = context.fn(...arguments[1]);  } else {    result = context.fn();  }  // 将属性删除  delete context.fn;  return result;};// bind 函数实现Function.prototype.myBind = function(context) {  // 判断调用对象是否为函数  if (typeof this !== "function") {    throw new TypeError("Error");  }  // 获取参数  var args = [...arguments].slice(1),    fn = this;  return function Fn() {    // 根据调用方式，传入不同绑定值    return fn.apply(      this instanceof Fn ? this : context,      args.concat(...arguments)    );  };};</code></pre><h2 id="函数柯里化的实现"><a href="#函数柯里化的实现" class="headerlink" title="函数柯里化的实现"></a>函数柯里化的实现</h2><pre><code class="JS">// 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。function curry(fn, args) {  // 获取函数需要的参数长度  let length = fn.length;  args = args || [];  return function() {    let subArgs = args.slice(0);    // 拼接得到现有的所有参数    for (let i = 0; i &lt; arguments.length; i++) {      subArgs.push(arguments[i]);    }    // 判断参数的长度是否已经满足函数所需参数的长度    if (subArgs.length &gt;= length) {      // 如果满足，执行函数      return fn.apply(this, subArgs);    } else {      // 如果不满足，递归返回科里化的函数，等待参数的传入      return curry.call(this, fn, subArgs);    }  };}// es6 实现function curry(fn, ...args) {  return fn.length &lt;= args.length ? fn(...args) : curry.bind(null, fn, ...args);}</code></pre><h2 id="什么是-XSS-攻击？如何防范-XSS-攻击？"><a href="#什么是-XSS-攻击？如何防范-XSS-攻击？" class="headerlink" title="什么是 XSS 攻击？如何防范 XSS 攻击？"></a>什么是 XSS 攻击？如何防范 XSS 攻击？</h2><pre><code>XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。XSS 一般分为存储型、反射型和 DOM 型。存储型指的是恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为 HTML 后返回给了用户，从而导致了恶意代码的执行。反射型指的是攻击者构建了特殊的 URL，当服务器接收到请求后，从 URL 中获取数据，拼接到 HTML 后返回，从而导致了恶意代码的执行。DOM 型指的是攻击者构建了特殊的 URL，用户打开网站后，js 脚本从 URL 中获取数据，从而导致了恶意代码的执行。XSS 攻击的预防可以从两个方面入手，一个是恶意代码提交的时候，一个是浏览器执行恶意代码的时候。对于第一个方面，如果我们对存入数据库的数据都进行的转义处理，但是一个数据可能在多个地方使用，有的地方可能不需要转义，由于我们没有办法判断数据最后的使用场景，所以直接在输入端进行恶意代码的处理，其实是不太可靠的。因此我们可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，我们对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。还有一些方式，比如使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。还可以对一些敏感信息进行保护，比如 cookie 使用 http-only ，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。</code></pre><h2 id="什么是-CSP？"><a href="#什么是-CSP？" class="headerlink" title="什么是 CSP？"></a>什么是 CSP？</h2><pre><code class="HTML">CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 &lt;meta http-equiv="Content-Security-Policy"&gt; &lt;/meta&gt;</code></pre><h2 id="什么是-CSRF-攻击？如何防范-CSRF-攻击？"><a href="#什么是-CSRF-攻击？如何防范-CSRF-攻击？" class="headerlink" title="什么是 CSRF 攻击？如何防范 CSRF 攻击？"></a>什么是 CSRF 攻击？如何防范 CSRF 攻击？</h2><pre><code>CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。CSRF 攻击的本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。一般的 CSRF 攻击类型有三种：第一种是 GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。第二种是 POST 类型的 CSRF 攻击，比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。第三种是链接类型的 CSRF 攻击，比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。CSRF 可以用下面几种方法来防护：第一种是同源检测的方法，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。第二种方法是使用 CSRF Token 来进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。第三种方式使用双重 Cookie 验证的办法，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。第四种方式是使用在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</code></pre><h2 id="什么是-Samesite-Cookie-属性？"><a href="#什么是-Samesite-Cookie-属性？" class="headerlink" title="什么是 Samesite Cookie 属性？"></a>什么是 Samesite Cookie 属性？</h2><pre><code>Samesite Cookie 表示同站 cookie，避免 cookie 被第三方所利用。将 Samesite 设为 strict ，这种称为严格模式，表示这个 cookie 在任何情况下都不可能作为第三方 cookie。将 Samesite 设为 Lax ，这种模式称为宽松模式，如果这个请求是个 GET 请求，并且这个请求改变了当前页面或者打开了新的页面，那么这个 cookie 可以作为第三方 cookie，其余情况下都不能作为第三方 cookie。使用这种方法的缺点是，因为它不支持子域，所以子域没有办法与主域共享登录信息，每次转入子域的网站，都回重新登录。还有一个问题就是它的兼容性不够好。</code></pre><h2 id="什么是点击劫持？如何防范点击劫持？"><a href="#什么是点击劫持？如何防范点击劫持？" class="headerlink" title="什么是点击劫持？如何防范点击劫持？"></a>什么是点击劫持？如何防范点击劫持？</h2><pre><code>点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。我们可以在 http 相应头中设置 X-FRAME-OPTIONS 来防御用 iframe 嵌套的点击劫持攻击。通过不同的值，可以规定页面在特定的一些情况才能作为 iframe 来使用。</code></pre><h2 id="什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？"><a href="#什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？" class="headerlink" title="什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？"></a>什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</h2><pre><code>我对 Virtual DOM 的理解是，首先对我们将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后我们将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。当页面的状态发生改变，我们需要对页面的 DOM 的结构进行调整的时候，我们首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。我认为 Virtual DOM 这种方法对于我们需要有大量的 DOM 操作的时候，能够很好的提高我们的操作效率，通过在操作前确定需要做的最小修改，尽可能的减少 DOM 操作带来的重流和重绘的影响。其实 Virtual DOM 并不一定比我们真实的操作 DOM 要快，这种方法的目的是为了提高我们开发时的可维护性，在任意的情况下，都能保证一个尽量小的性能消耗去进行操作。</code></pre><h2 id="如何比较两个-DOM-树的差异？"><a href="#如何比较两个-DOM-树的差异？" class="headerlink" title="如何比较两个 DOM 树的差异？"></a>如何比较两个 DOM 树的差异？</h2><pre><code>两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)。算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样我们才能够复用老的 DOM 树上的节点。</code></pre><h2 id="URL-和-URI-的区别？"><a href="#URL-和-URI-的区别？" class="headerlink" title="URL 和 URI 的区别？"></a>URL 和 URI 的区别？</h2><pre><code>URI: Uniform Resource Identifier      指的是统一资源标识符URL: Uniform Resource Location        指的是统一资源定位符URN: Universal Resource Name          指的是统一资源名称URI 指的是统一资源标识符，用唯一的标识来确定一个资源，它是一种抽象的定义，也就是说，不管使用什么方法来定义，只要能唯一的标识一个资源，就可以称为 URI。URL 指的是统一资源定位符，URN 指的是统一资源名称。URL 和 URN 是 URI 的子集，URL 可以理解为使用地址来标识资源，URN 可以理解为使用名称来标识资源。</code></pre><h2 id="let-和-const-的注意点？"><a href="#let-和-const-的注意点？" class="headerlink" title="let 和 const 的注意点？"></a>let 和 const 的注意点？</h2><ol><li> 声明的变量只在声明时的代码块内有效</li><li> 不存在声明提升</li><li> 存在暂时性死区，如果在变量声明前使用，会报错</li><li> 不允许重复声明，重复声明会报错</li></ol><h2 id="require-模块引入的查找方式？"><a href="#require-模块引入的查找方式？" class="headerlink" title="require 模块引入的查找方式？"></a>require 模块引入的查找方式？</h2><pre><code>当 Node 遇到 require(X) 时，按下面的顺序处理。（1）如果 X 是内置模块（比如 require('http')）　　a. 返回该模块。　　b. 不再继续执行。（2）如果 X 以 "./" 或者 "/" 或者 "../" 开头　　a. 根据 X 所在的父模块，确定 X 的绝对路径。　　b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。    X    X.js    X.json    X.node　　c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。    X/package.json（main字段）    X/index.js    X/index.json    X/index.node（3）如果 X 不带路径　　a. 根据 X 所在的父模块，确定 X 可能的安装目录。　　b. 依次在每个目录中，将 X 当成文件名或目录名加载。（4）抛出 "not found"</code></pre><h2 id="手写一个-Promise"><a href="#手写一个-Promise" class="headerlink" title="手写一个 Promise"></a>手写一个 Promise</h2><pre><code class="JS">const PENDING = "pending";const RESOLVED = "resolved";const REJECTED = "rejected";function MyPromise(fn) {  // 保存初始化状态  var self = this;  // 初始化状态  this.state = PENDING;  // 用于保存 resolve 或者 rejected 传入的值  this.value = null;  // 用于保存 resolve 的回调函数  this.resolvedCallbacks = [];  // 用于保存 reject 的回调函数  this.rejectedCallbacks = [];  // 状态转变为 resolved 方法  function resolve(value) {    // 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变    if (value instanceof MyPromise) {      return value.then(resolve, reject);    }    // 保证代码的执行顺序为本轮事件循环的末尾    setTimeout(() =&gt; {      // 只有状态为 pending 时才能转变，      if (self.state === PENDING) {        // 修改状态        self.state = RESOLVED;        // 设置传入的值        self.value = value;        // 执行回调函数        self.resolvedCallbacks.forEach(callback =&gt; {          callback(value);        });      }    }, 0);  }  // 状态转变为 rejected 方法  function reject(value) {    // 保证代码的执行顺序为本轮事件循环的末尾    setTimeout(() =&gt; {      // 只有状态为 pending 时才能转变      if (self.state === PENDING) {        // 修改状态        self.state = REJECTED;        // 设置传入的值        self.value = value;        // 执行回调函数        self.rejectedCallbacks.forEach(callback =&gt; {          callback(value);        });      }    }, 0);  }  // 将两个方法传入函数执行  try {    fn(resolve, reject);  } catch (e) {    // 遇到错误时，捕获错误，执行 reject 函数    reject(e);  }}MyPromise.prototype.then = function(onResolved, onRejected) {  // 首先判断两个参数是否为函数类型，因为这两个参数是可选参数  onResolved =    typeof onResolved === "function"      ? onResolved      : function(value) {          return value;        };  onRejected =    typeof onRejected === "function"      ? onRejected      : function(error) {          throw error;        };  // 如果是等待状态，则将函数加入对应列表中  if (this.state === PENDING) {    this.resolvedCallbacks.push(onResolved);    this.rejectedCallbacks.push(onRejected);  }  // 如果状态已经凝固，则直接执行对应状态的函数  if (this.state === RESOLVED) {    onResolved(this.value);  }  if (this.state === REJECTED) {    onRejected(this.value);  }};</code></pre><h2 id="开发中常用的几种-Content-Type-？"><a href="#开发中常用的几种-Content-Type-？" class="headerlink" title="开发中常用的几种 Content-Type ？"></a>开发中常用的几种 Content-Type ？</h2><pre><code>（1）application/x-www-form-urlencoded浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。（2）multipart/form-data该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。（3）application/json告诉服务器消息主体是序列化后的 JSON 字符串。（4）text/xml该种方式主要用来提交 XML 格式的数据。</code></pre><h2 id="如何封装一个-javascript-的类型判断函数？"><a href="#如何封装一个-javascript-的类型判断函数？" class="headerlink" title="如何封装一个 javascript 的类型判断函数？"></a>如何封装一个 javascript 的类型判断函数？</h2><pre><code class="JS">function getType(value) {  // 判断数据是 null 的情况  if (value === null) {    return value + "";  }  // 判断数据是引用类型的情况  if (typeof value === "object") {    let valueClass = Object.prototype.toString.call(value),      type = valueClass.split(" ")[1].split("");    type.pop();    return type.join("").toLowerCase();  } else {    // 判断数据是基本数据类型的情况和函数的情况    return typeof value;  }}</code></pre><h2 id="如何判断一个对象是否为空对象？"><a href="#如何判断一个对象是否为空对象？" class="headerlink" title="如何判断一个对象是否为空对象？"></a>如何判断一个对象是否为空对象？</h2><pre><code class="JS">function checkNullObj(obj) {  return Object.keys(obj).length === 0 &amp;&amp; Object.getOwnPropertySymbols(obj).length === 0;}</code></pre><h2 id="手写一个观察者模式？"><a href="#手写一个观察者模式？" class="headerlink" title="手写一个观察者模式？"></a>手写一个观察者模式？</h2><pre><code class="JS">var events = (function() {  var topics = {};  return {    // 注册监听函数    subscribe: function(topic, handler) {      if (!topics.hasOwnProperty(topic)) {        topics[topic] = [];      }      topics[topic].push(handler);    },    // 发布事件，触发观察者回调事件    publish: function(topic, info) {      if (topics.hasOwnProperty(topic)) {        topics[topic].forEach(function(handler) {          handler(info);        });      }    },    // 移除主题的一个观察者的回调事件    remove: function(topic, handler) {      if (!topics.hasOwnProperty(topic)) return;      var handlerIndex = -1;      topics[topic].forEach(function(item, index) {        if (item === handler) {          handlerIndex = index;        }      });      if (handlerIndex &gt;= 0) {        topics[topic].splice(handlerIndex, 1);      }    },    // 移除主题的所有观察者的回调事件    removeAll: function(topic) {      if (topics.hasOwnProperty(topic)) {        topics[topic] = [];      }    }  };})();</code></pre><h2 id="EventEmitter-实现"><a href="#EventEmitter-实现" class="headerlink" title="EventEmitter 实现"></a>EventEmitter 实现</h2><pre><code class="JS">class EventEmitter {  constructor() {    this.events = {};  }  on(event, callback) {    let callbacks = this.events[event] || [];    callbacks.push(callback);    this.events[event] = callbacks;    return this;  }  off(event, callback) {    let callbacks = this.events[event];    this.events[event] = callbacks &amp;&amp; callbacks.filter(fn =&gt; fn !== callback);    return this;  }  emit(event, ...args) {    let callbacks = this.events[event];    callbacks.forEach(fn =&gt; {      fn(...args);    });    return this;  }  once(event, callback) {    let wrapFun = (...args) =&gt; {      callback(...args);      this.off(event, wrapFun);    };    this.on(event, wrapFun);    return this;  }}</code></pre><h2 id="如何确定页面的可用性时间，什么是-Performance-API？"><a href="#如何确定页面的可用性时间，什么是-Performance-API？" class="headerlink" title="如何确定页面的可用性时间，什么是 Performance API？"></a>如何确定页面的可用性时间，什么是 Performance API？</h2><pre><code>Performance API 用于精确度量、控制、增强浏览器的性能表现。这个 API 为测量网站性能，提供以前没有办法做到的精度。使用 getTime 来计算脚本耗时的缺点，首先，getTime方法（以及 Date 对象的其他方法）都只能精确到毫秒级别（一秒的千分之一），想要得到更小的时间差别就无能为力了。其次，这种写法只能获取代码运行过程中的时间进度，无法知道一些后台事件的时间进度，比如浏览器用了多少时间从服务器加载网页。为了解决这两个不足之处，ECMAScript 5引入“高精度时间戳”这个 API，部署在 performance 对象上。它的精度可以达到1毫秒的千分之一（1秒的百万分之一）。navigationStart：当前浏览器窗口的前一个网页关闭，发生 unload 事件时的 Unix 毫秒时间戳。如果没有前一个网页，则等于 fetchStart 属性。loadEventEnd：返回当前网页 load 事件的回调函数运行结束时的 Unix 毫秒时间戳。如果该事件还没有发生，返回 0。</code></pre><p>根据上面这些属性，可以计算出网页加载各个阶段的耗时。比如，网页加载整个过程的耗时的计算方法如下：</p><pre><code class="JS">var t = performance.timing;var pageLoadTime = t.loadEventEnd - t.navigationStart;</code></pre><p>详细资料可以参考： <a href="http://javascript.ruanyifeng.com/bom/performance.html">《Performance API》</a></p><h2 id="Math-ceil-和-Math-floor"><a href="#Math-ceil-和-Math-floor" class="headerlink" title="Math.ceil 和 Math.floor"></a>Math.ceil 和 Math.floor</h2><pre><code class="JS">Math.ceil() === 向上取整，函数返回一个大于或等于给定数字的最小整数。Math.floor() === 向下取整，函数返回一个小于或等于给定数字的最大整数。</code></pre><h2 id="js-for-循环注意点"><a href="#js-for-循环注意点" class="headerlink" title="js for 循环注意点"></a>js for 循环注意点</h2><pre><code class="JS">for (var i = 0, j = 0; i &lt; 5, j &lt; 9; i++, j++) {  console.log(i, j);}// 当判断语句含有多个语句时，以最后一个判断语句的值为准，因此上面的代码会执行 10 次。// 当判断语句为空时，循环会一直进行。</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试总结-CSS篇</title>
      <link href="/My-Blogs/2021/12/06/css/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
      <url>/My-Blogs/2021/12/06/css/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>本章节是<a href="https://github.com/h5bp/Front-end-Developer-Interview-Questions/blob/master/src/questions/css-questions.md">前端开发者面试问题 - CSS 部分</a>的参考答案。 欢迎提出 PR 进行建议和指正！</p><a id="more"></a><h2 id="有哪些清除浮动的技术，都适用哪些情况？​"><a href="#有哪些清除浮动的技术，都适用哪些情况？​" class="headerlink" title="有哪些清除浮动的技术，都适用哪些情况？​"></a>有哪些清除浮动的技术，都适用哪些情况？​</h2><ul><li>空div方法：<code>&lt;div style="clear:both;"&gt;&lt;/div&gt;</code>。</li><li>Clearfix 方法：上文使用<code>.clearfix</code>类已经提到。</li><li><code>overflow: auto</code>或<code>overflow: hidden</code>方法：上文已经提到。</li><li>在大型项目中，我会使用 Clearfix 方法，在需要的地方使用<code>.clearfix</code>。<br>设置<code>overflow: hidden</code>的方法可能使其子元素显示不完整，当子元素的高度大于父元素时。</li></ul><h2 id="如何解决不同浏览器的样式兼容性问题？​"><a href="#如何解决不同浏览器的样式兼容性问题？​" class="headerlink" title="如何解决不同浏览器的样式兼容性问题？​"></a>如何解决不同浏览器的样式兼容性问题？​</h2><ul><li>在确定问题原因和有问题的浏览器后，使用单独的样式表，仅供出现问题的浏览器加载。这种方法需要使用服务器端渲染。</li><li>使用已经处理好此类问题的库，比如 Bootstrap。</li><li>使用 <code>autoprefixer</code> 自动生成 CSS 属性前缀。<br>使用 <a href="http://meyerweb.com/eric/tools/css/reset/">Reset CSS</a> 或 <a href="https://necolas.github.io/normalize.css/">Normalize.css</a>。</li></ul><h2 id="有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？​"><a href="#有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？​" class="headerlink" title="有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？​"></a>有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？​</h2><ul><li><code>width: 0; height: 0</code>：使元素不占用屏幕上的任何空间，导致不显示它。</li><li><code>position: absolute; left: -99999px</code>： 将它置于屏幕之外。</li><li><code>text-indent: -9999px</code>：这只适用于<code>block</code>元素中的文本。</li><li>Metadata： 例如通过使用 Schema.org，RDF 和 JSON-LD。</li><li>WAI-ARIA：如何增加网页可访问性的 W3C 技术规范。<br>即使 WAI-ARIA 是理想的解决方案，我也会采用<code>绝对定位</code>方法，因为它具有最少的注意事项，适用于大多数元素，而且使用起来非常简单。</li></ul><h2 id="什么情况下，用translate-而不用绝对定位？什么时候，情况相反。​"><a href="#什么情况下，用translate-而不用绝对定位？什么时候，情况相反。​" class="headerlink" title="什么情况下，用translate()而不用绝对定位？什么时候，情况相反。​"></a>什么情况下，用translate()而不用绝对定位？什么时候，情况相反。​</h2><ul><li><code>translate()</code>是<code>transform</code>的一个值。改变<code>transform</code>或<code>opacity</code>不会触发浏览器重新布局（<code>reflow</code>）或重绘（<code>repaint</code>），只会触发复合（<code>compositions</code>）。而改变绝对定位会触发重新布局，进而触发重绘和复合。</li><li><code>transform</code>使浏览器为元素创建一个 GPU 图层，但改变绝对定位会使用到 CPU。 因此<code>translate()</code>更高效，可以缩短平滑动画的绘制时间。</li></ul><p>当使用<code>translate()</code>时，元素仍然占据其原始空间（有点像<code>position：relative</code>），这与改变绝对定位不同。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试总结-HTML篇</title>
      <link href="/My-Blogs/2021/12/06/HTML/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
      <url>/My-Blogs/2021/12/06/HTML/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>本章节是<a href="https://frontendinterviewhandbook.com/zh/html-questions/">前端开发者面试问题 - HTML</a> 部分的参考答案。 欢迎提出 PR 进行建议和指正！</p><a id="more"></a><h2 id="DOCTYPE有什么用？"><a href="#DOCTYPE有什么用？" class="headerlink" title="DOCTYPE有什么用？"></a>DOCTYPE有什么用？</h2><p>在页面开始处添加<code>&lt;!DOCTYPE html&gt;</code>即可。</p><h2 id="如何提供包含多种语言内容的页面？"><a href="#如何提供包含多种语言内容的页面？" class="headerlink" title="如何提供包含多种语言内容的页面？"></a>如何提供包含多种语言内容的页面？</h2><ol><li> HTML 文档还应在<code>&lt;html&gt;</code>标签中声明<code>lang</code>属性，比如<code>&lt;html lang="en"&gt;...&lt;/html&gt;</code></li><li> 客户端向服务器发送 <code>HTTP</code> 请求时，通常会发送有关语言首选项的信息，比如使用<code>Accept-Language</code>请求头</li></ol><h2 id="在设计开发多语言网站时，需要留心哪些事情？"><a href="#在设计开发多语言网站时，需要留心哪些事情？" class="headerlink" title="在设计开发多语言网站时，需要留心哪些事情？"></a>在设计开发多语言网站时，需要留心哪些事情？</h2><ol><li> 引导用户切换到自己的母语，在 HTML 中使用<code>lang</code>属性</li><li> 限制词语或句子的长度</li><li> 不要使用连接的翻译字符串，这样做可能会打乱其他语言的语序，应该为每种语言编写带变量替换的模版字符串。<code>I will travel on {% date %}</code>和<code>{% date %}</code> 我会出发。</li></ol><h2 id="请描述-lt-script-gt-、-lt-script-async-gt-和-lt-script-defer-gt-的区别。"><a href="#请描述-lt-script-gt-、-lt-script-async-gt-和-lt-script-defer-gt-的区别。" class="headerlink" title="请描述<script>、<script async>和<script defer>的区别。"></a>请描述<code>&lt;script&gt;</code>、<code>&lt;script async&gt;</code>和<code>&lt;script defer&gt;</code>的区别。</h2><ol><li> <code>&lt;script&gt;</code> - HTML 解析中断，脚本被提取并立即执行。执行结束后，HTML 解析继续。</li><li> <code>&lt;script async&gt;</code> - 脚本的提取、执行的过程与 HTML 解析过程并行，脚本执行完毕可能在 HTML 解析完毕之前。当脚本与页面上其他脚本独立时，可以使用async，比如用作页面统计分析。</li><li> <code>&lt;script defer&gt;</code> - 脚本仅提取过程与 HTML 解析过程并行，脚本的执行将在 HTML 解析完毕后进行。如果有多个含defer的脚本，脚本的执行顺序将按照在 document 中出现的位置，从上到下顺序执行。</li></ol><p>注意：没有<code>src</code>属性的脚本，<code>async</code>和<code>defer</code>属性会被忽略。</p>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 CURL 上传文件</title>
      <link href="/My-Blogs/2021/06/23/Linux/shell/%E8%AF%B7%E6%B1%82/%E4%BD%BF%E7%94%A8%20CURL%20%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"/>
      <url>/My-Blogs/2021/06/23/Linux/shell/%E8%AF%B7%E6%B1%82/%E4%BD%BF%E7%94%A8%20CURL%20%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>CURL 是一个强大的向服务器发送请求的工具， 尤其是在测试 API 的时候。</p><a id="more"></a><p>很多人像寻常表单一样使用了 <code>-X POST</code> 方式来使用 CURL 去上传文件，但实际上这是错误的。<br>正确的方式是使用 <strong>-F (–form)</strong> 来上传文件，这样才会给请求添加 enctype=<code>"multipart/form-data"</code> 参数。</p><pre><code class="BASH">curl -F 'data=@path/to/local/file’ UPLOAD_ADDRES</code></pre><p>例如， 如果我想向服务器 <code>http://localhost/upload</code> 上传位于<code>/home/petehouston/hello.txt</code>的文件，并将上传的文件的参数命名为 <code>img_avatar</code>, 我可以这样发送请求,</p><pre><code class="BASH">curl -F 'img_avatar=@/home/petehouston/hello.txt' http://localhost/upload</code></pre><h2 id="上传多个文件"><a href="#上传多个文件" class="headerlink" title="上传多个文件"></a>上传多个文件</h2><p>想要同时上传多个文件的话，只需要添加多个 -F 选项就可以了。</p><pre><code class="BASH">curl -F 'fileX=@/path/to/fileX' -F 'fileY=@/path/to/fileY' ... http://localhost/upload</code></pre><h2 id="上传文件数组"><a href="#上传文件数组" class="headerlink" title="上传文件数组"></a>上传文件数组</h2><pre><code class="BASH">curl -F 'files[]=@/path/to/fileX' -F 'files[]=@/path/to/fileY' ... http://localhost/upload</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> curl </tag>
            
            <tag> 上传文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电商-商品设计</title>
      <link href="/My-Blogs/2021/04/26/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%94%B5%E5%95%86-%E5%95%86%E5%93%81%E8%AE%BE%E8%AE%A1/"/>
      <url>/My-Blogs/2021/04/26/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%94%B5%E5%95%86-%E5%95%86%E5%93%81%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>电商数据库设计之商品设计。</p><a id="more"></a><p><img src="/My-Blogs/images/%E7%94%B5%E5%95%86-%E5%95%86%E5%93%81%E8%AE%BE%E8%AE%A1.png"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 电商 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>screen 常用命令</title>
      <link href="/My-Blogs/2021/04/25/Linux/shell/%E7%AA%97%E5%8F%A3/screen%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/My-Blogs/2021/04/25/Linux/shell/%E7%AA%97%E5%8F%A3/screen%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>screen 常用命令介绍</p><a id="more"></a><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><pre><code class="BASH">screen -ls              # 查看所有screenscreen -S &lt;screen-name&gt; # 创建screen，并命名ctr + A, D              # 快捷键，退出当前screenscreen -r &lt;screen-name&gt; # 进入screenscreen -X quit          # 删除screen，但没有指定会话screen -X -S [session you want to kill] quit #删除screen，指定会话screen -wipe            # 清除dead screens</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在nest中使用typeorm-model-generator自动生成实体</title>
      <link href="/My-Blogs/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93/TypeOrm/%E5%9C%A8nest%E4%B8%AD%E4%BD%BF%E7%94%A8typeorm-model-generator%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%AE%9E%E4%BD%93/"/>
      <url>/My-Blogs/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93/TypeOrm/%E5%9C%A8nest%E4%B8%AD%E4%BD%BF%E7%94%A8typeorm-model-generator%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%AE%9E%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<p>总结一下nestjs框架使用typeorm自动生成实体类的方法。可以节省一些开发时间</p><a id="more"></a><ol><li><p><code>npm i -g typeorm-model-generator</code> 或者 <code>yarn global add typeorm-model-generator</code></p></li><li><p>修改项目中的 <code>package.json</code> 文件  </p><pre><code class="json">"scripts": {"db": "rimraf ./src/modules/entities &amp; npx typeorm-model-generator -h 121.36.70.68 -d chat -p 3306 -u root -x 123456 -e mysql -o ./src/modules/entities --noConfig true --ce pascal --cp camel"}</code></pre><ul><li><code>rm -rf entities</code>表示先删除文件夹<code>entities（window下使用 rimraf entities ）</code></li><li><code>npx typeorm-model-generator</code>如果全局安装了就不需要加npx没有全局安装就加上去</li><li><code>-h localhost -d 数据库名字 -p 端口 -u 用户名 -x 密码 -e 数据库类型</code></li><li><code>-o entities</code>表示输出到指定的文件夹</li><li><code>--noConfig true</code>表示不生成<code>ormconfig.json</code>和<code>tsconfig.json</code>文件</li><li><code>--ce pascal</code>表示将类名转换首字母是大写的驼峰命名</li><li><code>--cp camel</code>表示将数据库中的字段比如create_at转换为createAt</li><li><code>-a</code>表示会继承一个<code>BaseEntity</code>的类,根据自己需求加</li></ul></li><li><p> 运行代码 <code>npm run db</code> 或 <code>yarn db</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> nestjs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zip命令的基本使用</title>
      <link href="/My-Blogs/2021/02/22/Linux/shell/%E6%96%87%E4%BB%B6/zip%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/My-Blogs/2021/02/22/Linux/shell/%E6%96%87%E4%BB%B6/zip%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>这是一篇关于zip命令的简单使用</p><a id="more"></a><h2 id="命令简介"><a href="#命令简介" class="headerlink" title="命令简介"></a>命令简介</h2><p>zip 命令可以用来压缩、打包文件。</p><pre><code class="BASH">#Debian/Ubuntu安装apt-get&nbsp;install&nbsp;zip#CentOS安装[root@centos7&nbsp;testdir]#&nbsp;zip-bash:&nbsp;zip:&nbsp;command&nbsp;not&nbsp;found[root@centos7&nbsp;testdir]#&nbsp;yum&nbsp;install&nbsp;zip&nbsp;-y</code></pre><p>zip 命令也可以用来解压缩文件，zip也是一个常用的压缩、解压应用程序，文件经它压缩后会产生一个新以.zip为扩展名的压缩包文件。</p><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><pre><code class="BASH">zip&nbsp;[&nbsp;OPTIONS&nbsp;]&nbsp;[&nbsp;NAME&nbsp;..]</code></pre><h2 id="选项说明"><a href="#选项说明" class="headerlink" title="选项说明"></a>选项说明</h2><pre><code class="BASH">-A  #调整可执行的自动解压缩文件-b&lt;工作目录&gt;  #指定压缩文件的存放目录-c  #给每个被压缩的文件加上注释信息-d  #从压缩文件内删除指定的文件，也可以使用--delete参数-D  #压缩文件内不建立目录名称-f  #更新既有文件，将其它文件一并加入到压缩文件中-F  #修复已损坏的压缩文件-g  #将指定文件压缩至已存在的压缩文件中，不建立新文件-h  #打印帮助信息-i&lt;范本样式&gt;  #只压缩匹配指定条件的文件-m  #将指定文件压缩打包后直接删除原始文件-o  #将压缩文件的属性信息更改成与压缩文件中的最新文件的属性一致-q  #安静模式-r  #递归处理-t&lt;日期时间&gt;  #把压缩文件的日期设成指定的日期-T  #检查备份文件内的每个文件是否正确无误-u  #更新较新的文件到压缩文件内-v  #打印命令执行过程信息或版本信息-x&lt;范本样式&gt;  #压缩时排除符合条件的文件-z  #给压缩文件加上注释信息-&lt;压缩效率&gt;  #指定压缩效率（1~9数字）</code></pre><h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><p>在当前目录下创建压缩文件（自动创建以.zip的文件）</p><pre><code class="BASH">[root@centos7 testdir]# zip mingongge *  adding: cest.txt.gz (stored 0%)  adding: cuttest.txt.gz (stored 0%)  adding: dir/ (stored 0%)  adding: file (stored 0%)  adding: mingongge1.txt.gz (stored 0%)  adding: mingongge2.txt.gz (stored 0%)  adding: mingongge.txt.md5.gz (stored 0%)  adding: sort.cut.txt.gz (stored 0%)</code></pre><p>分割一个大文件</p><pre><code class="BASH">[root@centos7&nbsp;~]#&nbsp;ls&nbsp;-lhtotal&nbsp;22M-rw-------.&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;1.3K&nbsp;Aug&nbsp;20&nbsp;10:39&nbsp;anaconda-ks.cfg-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;140&nbsp;Jan&nbsp;16&nbsp;11:36&nbsp;dos_test.txtdrwxr-xr-x&nbsp;&nbsp;&nbsp;3&nbsp;root&nbsp;root&nbsp;&nbsp;&nbsp;39&nbsp;Aug&nbsp;30&nbsp;03:48&nbsp;goinception-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;13M&nbsp;Aug&nbsp;30&nbsp;03:42&nbsp;goInception-linux-amd64-v1.2.3.tar.gzdrwxr-sr-x&nbsp;&nbsp;11&nbsp;root&nbsp;&nbsp;&nbsp;40&nbsp;4.0K&nbsp;Dec&nbsp;24&nbsp;22:35&nbsp;httpd-2.4.46-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;9.0M&nbsp;Aug&nbsp;&nbsp;5&nbsp;07:32&nbsp;httpd-2.4.46.tar.gz-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;Jan&nbsp;16&nbsp;11:32&nbsp;mingongge.filedrwxr-xr-x&nbsp;&nbsp;&nbsp;3&nbsp;root&nbsp;root&nbsp;&nbsp;192&nbsp;Jan&nbsp;16&nbsp;16:19&nbsp;testdir-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;140&nbsp;Jan&nbsp;16&nbsp;11:32&nbsp;test.txt[root@centos7&nbsp;~]#&nbsp;zip&nbsp;-s&nbsp;4M&nbsp;-r&nbsp;mingongge.zip&nbsp;httpd-2.4.46.tar.gz&nbsp;&nbsp;adding:&nbsp;httpd-2.4.46.tar.gz&nbsp;(deflated&nbsp;0%)[root@centos7&nbsp;~]#&nbsp;ls&nbsp;-lhtotal&nbsp;31M-rw-------.&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;1.3K&nbsp;Aug&nbsp;20&nbsp;10:39&nbsp;anaconda-ks.cfg-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;140&nbsp;Jan&nbsp;16&nbsp;11:36&nbsp;dos_test.txtdrwxr-xr-x&nbsp;&nbsp;&nbsp;3&nbsp;root&nbsp;root&nbsp;&nbsp;&nbsp;39&nbsp;Aug&nbsp;30&nbsp;03:48&nbsp;goinception-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;13M&nbsp;Aug&nbsp;30&nbsp;03:42&nbsp;goInception-linux-amd64-v1.2.3.tar.gzdrwxr-sr-x&nbsp;&nbsp;11&nbsp;root&nbsp;&nbsp;&nbsp;40&nbsp;4.0K&nbsp;Dec&nbsp;24&nbsp;22:35&nbsp;httpd-2.4.46-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;9.0M&nbsp;Aug&nbsp;&nbsp;5&nbsp;07:32&nbsp;httpd-2.4.46.tar.gz-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;Jan&nbsp;16&nbsp;11:32&nbsp;mingongge.file-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;4.0M&nbsp;Jan&nbsp;16&nbsp;16:24&nbsp;mingongge.z01-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;4.0M&nbsp;Jan&nbsp;16&nbsp;16:24&nbsp;mingongge.z02-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;943K&nbsp;Jan&nbsp;16&nbsp;16:24&nbsp;mingongge.zipdrwxr-xr-x&nbsp;&nbsp;&nbsp;3&nbsp;root&nbsp;root&nbsp;&nbsp;192&nbsp;Jan&nbsp;16&nbsp;16:19&nbsp;testdir#从结果可以看出会拆分成三个文件即：4M大小的mingongge.z01、4M大小的mingongge.z02和一个943k的mingongge.zip文件。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tar命令的基本使用</title>
      <link href="/My-Blogs/2021/02/20/Linux/shell/%E6%96%87%E4%BB%B6/tar%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/My-Blogs/2021/02/20/Linux/shell/%E6%96%87%E4%BB%B6/tar%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>这是一篇关于tar命令的简单使用</p><a id="more"></a><h2 id="命令简介"><a href="#命令简介" class="headerlink" title="命令简介"></a>命令简介</h2><p>tar 命令用于打包、压缩与解压压缩包文件。</p><p>tar 命令常常用于打包、压缩某些文件或目录，也可以添加新文件到归档文件中。Tar 代表的是磁带存档，是一种归档的文件格式，早期用于将文件归档到磁带备份存储。现可以用于收集、分发、归档文件，还可以保留文件原有的属性，如：用户和组权限，访问和修改日期以及目录结构。</p><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><pre><code class="BASH">tar&nbsp;[OPTIONS]&nbsp;[FILE]</code></pre><h2 id="选项说明"><a href="#选项说明" class="headerlink" title="选项说明"></a>选项说明</h2><pre><code class="BASH">-A&nbsp;&nbsp;#新增文件到已经存在的归档文件-B&nbsp;&nbsp;#设置区块大小-c&nbsp;&nbsp;#建立新的归档文件-C&nbsp;&nbsp;#将压缩的文件解压到指定的目录下-d&nbsp;&nbsp;#记录文件的差异-x&nbsp;&nbsp;#解压或提取归档文件内容 -t&nbsp;&nbsp;#列出备份文件的内容-z&nbsp;&nbsp;#通过gzip命令来压缩/解压缩文件，文件名一般为&nbsp;xx.tar.gz-Z&nbsp;&nbsp;#通过compress命令处理备份文件-f&nbsp;&nbsp;#指定备份文件-v&nbsp;&nbsp;#显示命令执行过程-r&nbsp;&nbsp;#添加新文件到已经压缩的文件中-u&nbsp;&nbsp;#添加改变了和现有的文件到已经存在的压缩文件-j&nbsp;&nbsp;#通过bzip2命令来压缩/解压缩文件，文件名一般为xx.tar.bz2-v&nbsp;&nbsp;#显示操作过程；-k&nbsp;&nbsp;#保留原有文件不覆盖-m&nbsp;&nbsp;#保留文件不被覆盖-w&nbsp;&nbsp;#确认压缩文件的正确性-p&nbsp;&nbsp;#保留原来的文件权限与属性-P&nbsp;&nbsp;#使用文件名的绝对路径，不删除文件名称前的“/”号-N&nbsp;&nbsp;#只将较指定日期更新的文件保存到备份文件中--exclude=[范本样式]&nbsp;&nbsp;#排除符合范本样式的文件--remove-files&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#归档/压缩之后删除源文件</code></pre><h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><p>常见应用例子</p><pre><code class="BASH">tar&nbsp;-cf&nbsp;mingongge.tar&nbsp;*.jpg#将所有.jpg的文件打包成一个名为mingongge.tar的文件&nbsp;tar&nbsp;-rf&nbsp;mingongge.tar&nbsp;*.gif#将所有.gif的文件增加到mingongge.tar的包里&nbsp;tar&nbsp;-uf&nbsp;mingonggel.tar&nbsp;mingongge.gif#更新mingongge.tar文件中的mingongge.gif文件&nbsp;tar&nbsp;-tf&nbsp;mingongge.tar#列出&nbsp;all.tar&nbsp;包中所有文件tar&nbsp;-cfv&nbsp;mingongge.tar&nbsp;foo&nbsp;bar&nbsp;&nbsp;#将文件foo和bar打包成mingongge.tar文件包，也可以理解成：从这两个文件中去创建这个mingongge.tar文件tar&nbsp;-tvf&nbsp;mingongge.tar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#详细列出mingongge.tar中的所有文件tar&nbsp;-xf&nbsp;mingongge.tar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#从mingongge.tar提取所有文件</code></pre><p>将文件全部打包成tar包</p><pre><code class="BASH">tar&nbsp;-cvf&nbsp;mingongg.tar&nbsp;mingongg.log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#仅打包，不压缩！tar&nbsp;-zcvf&nbsp;mingongg.tar.gz&nbsp;mingongg.log&nbsp;&nbsp;&nbsp;#打包后，以gzip方式压缩tar&nbsp;-jcvf&nbsp;mingongg.tar.bz2&nbsp;mingongg.log&nbsp;&nbsp;#打包后，以bzip2方式压缩</code></pre><p>解压目录</p><pre><code class="BASH">tar&nbsp;-xvf&nbsp;portal-web-v2.0.0.tar&nbsp;--strip-components&nbsp;1&nbsp;&nbsp;-C&nbsp;指定目录#排除目录--strip-components</code></pre><p>将 tar包解压缩</p><pre><code class="BASH">tar&nbsp;-zxvf&nbsp;/opt/soft/test/log.tar.gz</code></pre><p>打包或压缩文件时，排队指定的文件类型</p><pre><code class="BASH">tar&nbsp;-zcf&nbsp;mingongge.tar.gz&nbsp;/etc/&nbsp;/var/&nbsp;--exclude=*.txt</code></pre><p>注意：如果在使用过程中遇到这类错误提示</p><pre><code class="BASH">tar:&nbsp;Removing&nbsp;leading&nbsp;`/`&nbsp;from&nbsp;member&nbsp;names </code></pre><p>原因是tar默认为相对路径，使用绝对路径的话就会报这个错，可以使用-P（大写）参数解决这个问题。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6笔记</title>
      <link href="/My-Blogs/2021/02/07/JavaScript/ES6%E7%AC%94%E8%AE%B0/"/>
      <url>/My-Blogs/2021/02/07/JavaScript/ES6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>总结一些比较需要注意的ES6语法。</p><a id="more"></a><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="TDZ-暂时性死区"><a href="#TDZ-暂时性死区" class="headerlink" title="TDZ(暂时性死区)"></a>TDZ(暂时性死区)</h3><ul><li>当使用let，const声明语句时，还未执行的时候，变量会存入TDZ(暂时性死区)，引用语句时，会抛出错误。</li><li>类声明与let声明类似，不能被提升；真正执行声明语句之前，它们会一直存在于临时死区中。</li></ul><pre><code class="JS">console.log(typeof value); // throw ReferenceError: Cannot access 'value' before initializationlet value = 'string';</code></pre><h3 id="更好的Unicode支持"><a href="#更好的Unicode支持" class="headerlink" title="更好的Unicode支持"></a>更好的Unicode支持</h3><p>以后做字符处理时，优先选择codePoint相关方法， <code>String.fromCodePoint</code> 可以同时处理BMP和非BMP字符，即支持0xFFFF以上的字符解析</p><pre><code class="JS">String.fromCodePoint(97); // aString.fromCharCode(97); // a</code></pre><h3 id="函数形参的默认值"><a href="#函数形参的默认值" class="headerlink" title="函数形参的默认值"></a>函数形参的默认值</h3><p>可以利用以下特性，对入参做些预处理</p><pre><code class="JS">function add(first, second = first) {  return first + second;}</code></pre><h3 id="新增方法"><a href="#新增方法" class="headerlink" title="新增方法"></a>新增方法</h3><p>比起 <code>===</code> 判断两个变量是否一致，Object.is()会更完善，优先使用它</p><pre><code class="JS">console.log(+0 === -0); // trueconsole.log(Object.is(+0, -0)); // falseconsole.log(NaN === NaN); // falseconsole.log(Object.is(NaN, NaN)); // true</code></pre><h3 id="自由属性枚举顺序"><a href="#自由属性枚举顺序" class="headerlink" title="自由属性枚举顺序"></a>自由属性枚举顺序</h3><p><code>Object.getOwnPropertyNames</code> 返回一个数组，它包含了指定对象所有的可枚举或不可枚举的属性名，而 <code>Object.keys</code> 返回一个包含所有给定对象自身可枚举属性名称的数组。</p><pre><code class="JS">var a = {};Object.defineProperties(a, {  one: {    enumerable: true,    value: 1  },  two: {    enumerable: false,    value: 2  },});Object.keys(a); // ["one"]Object.getOwnPropertyNames(a); // ["one", "two"]</code></pre><h3 id="Symbol共享"><a href="#Symbol共享" class="headerlink" title="Symbol共享"></a>Symbol共享</h3><p>如果想创建一个可共享的Symbol，要使用Symbol.for()方法。它只接受一个参数。</p><pre><code class="JS">let uid = Symbo.for('uid');let object = {};object[uid] = '12345';console.log(object[uid]); // "12345"console.log(uid); // "Symbol(uid)"</code></pre><blockquote><p><code>Symbol.for()</code> 方法首先在全局Symbol注册表中搜索键为”uid”的Symbol是否存在，如果存在，直接返回已有的Symbol；否则，创建一个新的Symbol，并使用这个键在Symbol全局注册表中注册，随即返回新创建的Symbol。</p></blockquote><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul><li>Set不允许相同的值存在两个，所以可以使用Set去重，比如<code>[...new Set([1, 3, 1])]</code>; </li><li>在Set集合中，不会对所存值进行强制的类型转换，数字5和字符串“5”可以作为两个独立元素存在。</li><li>add, delete, has类似数组的push、splice、includes。</li><li>在Set存放对象，当对象的引用清除了，也不会释放，调用delete或者clear，还可以使用WeakSet，存放弱引用。</li></ul><h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><ul><li>WeakSet没有Set诸如add, has, delete, forEach, size等方法和属性，也不可迭代</li><li>只适合用来跟踪对象引用。</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li>与Object相比，键值支持对象作为属性，”5”、5将作为不同的key，而Object会调用toString将5转化为字符串，两个键值将冲突。</li><li>set, get, delete, has, clear方法，size属性。</li><li>forEach。</li></ul><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><ul><li>类似WeakSet，Key存放对象的弱引用，当该对象的所有强引用都被清除时，WeakMap中对应的弱引用键及其对应的值也会自动被GC。</li></ul><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul><li>本质就是调用对象的next方法 每次调用next，返回{ value: xxx, done: false }对象，当done为true表示迭代结束。</li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li>类数组对象（具有数值型索引和length属性的对象）。</li><li>定型数组，节省内存，JS数字是以64位浮点格式存储。</li><li>数组缓冲区 ArrayBuffer，类似C语言的<code>malloc</code>分配内存。<code>DataView</code>数据视图，用来操作数组缓存区的数据。</li><li>特定类型视图，Int8Array等。<br><img src="/My-Blogs/images/ES6%E7%AC%94%E8%AE%B0/ES6%E7%AC%94%E8%AE%B0-01.png" alt="img">。</li></ul><h3 id="Promise与异步编程"><a href="#Promise与异步编程" class="headerlink" title="Promise与异步编程"></a>Promise与异步编程</h3><h3 id="代理-Proxy-和反射Reflection"><a href="#代理-Proxy-和反射Reflection" class="headerlink" title="代理(Proxy)和反射Reflection"></a>代理(Proxy)和反射Reflection</h3><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ul><li>不管在import语句中把一个模块写了多少次，该模块将只执行一次。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>deno的初体验</title>
      <link href="/My-Blogs/2021/01/19/Deno/deno%E7%9A%84%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/My-Blogs/2021/01/19/Deno/deno%E7%9A%84%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>这是一篇关于deno初体验文章</p><a id="more"></a><h2 id="Deno-–-小而美的脚本运行时"><a href="#Deno-–-小而美的脚本运行时" class="headerlink" title="Deno – 小而美的脚本运行时"></a><a href="https://deno.land/">Deno</a> – 小而美的脚本运行时</h2><blockquote><p>a simple, modern and secure runtime for JavaScript and TypeScript that uses V8 and is built in Rust。</p></blockquote><p>Dahl（Node.js 的创始人之一）在2017年创建，Rust 语言开发。 <code>deno</code> 音译帝诺，恐龙(dinosaur)的简称，<code>deno</code> 这个名字就是来自 Node 的字母重新组合（Node = no + de），表示”拆除 Node.js”（de = destroy, no = Node.js）。</p><h2 id="创建原由"><a href="#创建原由" class="headerlink" title="创建原由"></a>创建原由</h2><ul><li>Node.js Callback hell。</li><li>原生支持CommonJs，对ES模块不兼容。</li><li>npm(你怕吗)模块管理工具，npm_modules 极其庞杂，还有Dependency Hell，版本重复问题等问题，极难管理。详情可查看<a href="https://juejin.cn/post/6914508615969669127">node_modules 困境</a><br><img src="/My-Blogs/images/deno%E5%88%9D%E4%BD%93%E9%AA%8C-01.jpg" alt="img"></li><li>功能不完整，要学习很多外部工具，诸如webpack，babel，typescript、eslint、prettier……</li></ul><blockquote><p><em>“由于上面这些原因，Ryan Dahl 决定放弃 Node.js，从头写一个替代品，彻底解决这些问题。deno 这个名字就是来自 Node 的字母重新组合（Node = no + de），表示”拆除 Node.js”（de = destroy, no = Node.js）。<br>跟 Node.js 一样，Deno 也是一个服务器运行时，但是支持多种语言，可以直接运行 JavaScript、TypeScript 和 WebAssembly 程序。<br>它内置了 V8 引擎，用来解释 JavaScript。同时，也内置了 tsc 引擎，解释 TypeScript。它使用 Rust 语言开发，由于 Rust 原生支持 WebAssembly，所以它也能直接运行 WebAssembly。它的异步操作不使用 libuv 这个库，而是使用 Rust 语言的 Tokio 库，来实现事件循环（event loop）。”</em>— 出自阮一峰大神《<a href="https://www.ruanyifeng.com/blog/2020/01/deno-intro.html">Deno 运行时入门教程：Node.js 的替代品</a>》</p></blockquote><p><strong>闲言少叙，书归正文，让我们一起来看看Deno的特性吧。</strong></p><h2 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h2><ul><li>服务器运行时，支持多种语言，可直接运行 <code>JavaScript</code>、<code>TypeScript</code> 和 <code>WebAssembly</code> 程序。</li><li>具有安全控制，默认情况下脚本不具有读写权限。如果脚本未授权，就读写文件系统或网络，会报错。</li><li>只有一个可执行文件，所有操作都通过这个文件完成。它支持跨平台（Mac、Linux、Windows）。</li><li>异步操作 一律返回 Promise。</li><li>Deno 支持 Web API，尽量跟浏览器保持一致。<code>window</code>、<code>fetch</code>、<code>webCrypto</code>、<code>worker</code>, 也支持 <code>onload</code>、<code>onunload</code>、<code>addEventListener</code> 等事件操作函数。</li><li>所有模块通过 URL 加载，比如<code>import { bar } from "https://foo.com/bar.ts"</code>（绝对 URL）或<code>import { bar } from './foo/bar.ts'</code>（相对 URL）。本地缓存，有个Cache总目录</li><li>原生支持TypeScript, 内置<a href="https://github.com/microsoft/TypeScript">TypeScript编译器</a>和<a href="https://swc.rs/">swc</a>的Rust库组合实现。</li><li>打包、格式清理、测试、安装、文档生成、linting、脚本编译成可执行文件等一条龙服务。</li></ul><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li>高效且安全</li><li>单文件，兼容浏览器标准，体积小。</li><li>替代脚本</li><li>内存占用少，运行速度比node快。<a href="https://juejin.cn/post/6854573218419474439">从Deno跟Node的性能对比说起</a></li></ul><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><ul><li>缺少集大成框架，满足不了企业级应用开发。</li><li>社区还不完善，第三方库不够丰富。</li><li>缺乏包管理工具，管理起来混乱。</li><li><a href="https://juejin.cn/post/6917830384956899341">网络上一些怀疑的声音</a></li></ul><h3 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a><a href="https://deno.land/manual@v1.7.0/getting_started/command_line_interface">CLI</a></h3><h3 id="permission"><a href="#permission" class="headerlink" title="permission"></a><a href="https://deno.land/manual@v1.7.0/getting_started/permissions">permission</a></h3><h3 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a><a href="https://deno.land/manual@v1.7.0/getting_started/webassembly#webassembly-support">WebAssembly</a></h3><pre><code class="JS">const wasmCode = new Uint8Array([  0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127,  3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0,  5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145,  128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97,  105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0,  65, 42, 11]);const wasmModule = new WebAssembly.Module(wasmCode);const wasmInstance = new WebAssembly.Instance(wasmModule);const main = wasmInstance.exports.main as CallableFunctionconsole.log(main().toString());</code></pre><h3 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h3><ul><li><a href="https://deno.land/x">已支持开源项目</a></li><li><a href="https://deno.land/x/denon@2.4.6">denon</a></li><li><a href="https://deno.land/x/oak@v6.4.2">oak</a> – 类似koa的web框架</li><li><a href="https://deno.land/x/aleph@v0.2.28">Aleph.js</a> – 类似Next.js(React ssr框架)<h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a><a href="https://deno.land/std/">标准库</a></h3><h3 id="兼容node-js"><a href="#兼容node-js" class="headerlink" title="兼容node.js"></a><a href="https://deno.land/std/node">兼容node.js</a></h3></li></ul><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>Shell (Mac, Linux):</p><pre><code class="BASH">curl -fsSL https://deno.land/x/install/install.sh | sh</code></pre><p>PowerShell (Windows):</p><pre><code class="BASH">iwr https://deno.land/x/install/install.ps1 -useb | iex</code></pre><p>Using Homebrew (macOS):</p><pre><code class="BASH">brew install deno</code></pre><h3 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h3><p>Try running a simple program:</p><pre><code class="BASH">deno run https://deno.land/std/examples/welcome.ts</code></pre><p>Or a more complex one:</p><pre><code class="JS">import {  serve} from "https://deno.land/std@0.83.0/http/server.ts";const s = serve({  port: 8000});console.log("http://localhost:8000/");for await (const req of s) {  req.respond({    body: "Hello World\n"  });}</code></pre><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a><a href="https://deno.land/std/">例子</a></h3><h2 id="缓存目录"><a href="#缓存目录" class="headerlink" title="缓存目录"></a>缓存目录</h2><p>以Mac为例，举个🌰 </p><pre><code class="BASH"> $HOME/Library/Caches/Deno#  远程库下载地址deno run https://deno.land/std@0.83.0/examples/welcome.ts# DIRECTORIESgen/: 缓存编译为JavaScript的文件deps/: 缓存导入的远程url的文件  |__ http/: http方式导入的文件  |__ https/: https方式导入的文件# FILESdeno_history.txt: Deno REPL历史记录缓存deno info                                                                               DENO_DIR location: "/Users/lulu/Library/Caches/deno"Remote modules cache: "/Users/lulu/Library/Caches/deno/deps"TypeScript compiler cache: "/Users/lulu/Library/Caches/deno/gen"</code></pre><h3 id="gen"><a href="#gen" class="headerlink" title="gen/"></a>gen/</h3><p><code>$DENO_DIR/gen/</code> 被用来存放 JavaScript 文件，这些文件是从 TypeScript 源码编译来的。这样的编译是必要的，因为 V8 不识别 JS 子集之外的 TypeScript 语法。</p><p>gen/目录下的每一个 JS 文件的文件名是他的 TypeScript 源码的 hash 值。同时 JS 文件也对应一个 .map 为后缀的 source map 文件。</p><p>缓存存在的原因是为了避免在用户没有修改代码的情况下，每次运行时不断的重新编译文件。比如我们有一个 hello-world.ts 文件，他只是包含了代码 console.log(“Hello world”)。在第一次运行时，我们会看到编译信息：</p><pre><code class="BASH">$ deno hello-world.tsCompiling /Users/kevinqian/my-folder/hello-world.tsHello world</code></pre><p>但是在没有修改文件内容的情况下，当你重新运行代码：</p><pre><code class="BASH">$ deno hello-world.tsHello world</code></pre><p>不会再有编译信息的提示。这是因为在这一次运行中，Deno 直接使用了 gen/ 中缓存的版本，而不用再次编译。</p><p>缓存加载和保存的代码，可以从文件 src/deno_dir.rs 中的 DenoDir::load_cache 和 DenoDir::code_cache 中找到。</p><p>如果想要强制 Deno 重新编译你的代码而不是使用缓存的版本，你需要使用 <code>--recompile</code> 标志。</p><h3 id="deps"><a href="#deps" class="headerlink" title="deps/"></a>deps/</h3><p><code>$DENO_DIR/deps</code> 被用来保存远端 url import 获得的文件。根据 url 的模式，他包含了子目录（现在只有http和https），并且保存文件的位置由 URL path 决定。比如，对于下面的的 import（请注意，Deno 要求用户显式地指定扩展名）。</p><pre><code class="JS">import {  serve} from "https://deno.land/x/std/net/http.ts";</code></pre><p>下载的http.ts文件将会被存储在：</p><pre><code class="BASH">$DENO_DIR/deps/https/deno.land/x/std/net/http.ts</code></pre><p>需要注意，除非用户用 <code>--reload</code> 标志运行代码，否则我们的http.ts文件在接下来的运行中不会被重新下载。</p><p>当前（警告：将来可能改变），Deno 会关注从远端下载的文件的内容的 MIME 类型。在文件缺少扩展名或扩展名与内容类型不匹配的情况下，Deno 将创建一个以 .mime 结尾的额外文件，来存储 HTTP 响应头提供的 mime 类型。如果我们下载的文件名是 a.ts，然而响应头里面是 Content-Type: text/javascript，一个包含text/javascript内容的a.ts.mime文件将会在他旁边被创建。由于.mime文件的存在，a.ts 后面将会被当做一个 JavaScript 文件被 import。</p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><pre><code class="BASH">cd /Users/lulu/my-projects/deno-demo &amp;&amp; code .</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Deno的目标不是替代Node，而是Node的一个补充完善方案。<br>目前Deno还处于初步阶段，标准库，兼容性还有待改进，适合脚本，小型应用开发。想要完成一个成熟的大型项目，还需要时间的沉淀。让我们好好期待下，未来的Deno会如何发展？</p>]]></content>
      
      
      <categories>
          
          <category> deno </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deno </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tree命令的基本使用</title>
      <link href="/My-Blogs/2021/01/18/Linux/shell/%E6%96%87%E4%BB%B6/tree%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/My-Blogs/2021/01/18/Linux/shell/%E6%96%87%E4%BB%B6/tree%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>每天学一个 Linux 命令之tree的基本使用</p><a id="more"></a><h2 id="命令简介"><a href="#命令简介" class="headerlink" title="命令简介"></a>命令简介</h2><p>tree 命令的作用是以树形结构显示目录下的内容。</p><p>常用的Linux发行版系统中默认没有这个命令，你需要通过安装才可以使用：</p><pre><code class="BASH">#Centosyum install tree -y#Ubuntusudo apt-get install tree</code></pre><p>安装完成之后就可以正常使用这个tree命令了。</p><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><pre><code class="BASH">tree [选项] [目录]</code></pre><h2 id="选项说明"><a href="#选项说明" class="headerlink" title="选项说明"></a>选项说明</h2><pre><code class="BASH">-a   #显示所有文件-d   #只显示目录（名称）-l   #显示链接文件的原始文件-f   #显示所列出的文件或目录的完整目录路径-i   #不以阶梯的形式显示文件或目录名称-q   #将控制字符以?字符代替，显示文件和目录名称-N   #直接显示文件或目录的名称-p   #显示每个文件的权限信息-u   #显示文件所有者或者uid-g   #显示文件所属组或者gid-s   #显示每个文件的大小信息-h   #以可读的方式显示文件的大小信息-D   #显示最后修改日期-v   #按字母数字正序显示文件-r   #按字母数字倒序显示文件-t   #按最后时间排序显示文件-C   #在文件和目录列表上加上色彩，便于区分文件类型-P pattern    #只显示匹配正则表式的文件或目录名称-I pattern    #与上结果相反</code></pre><h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><pre><code class="BASH">#树形显示当前目录及其子目录下的文件及目录名称[root@centos7&nbsp;testdir]#&nbsp;tree.├──&nbsp;dir│&nbsp;&nbsp;&nbsp;├──&nbsp;test2.txt~│&nbsp;&nbsp;&nbsp;├──&nbsp;test3.txt│&nbsp;&nbsp;&nbsp;└──&nbsp;test3.txt.bak├──&nbsp;test2.txt└──&nbsp;test2.txt~1&nbsp;directory,&nbsp;5&nbsp;files#只显示目录名称[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-d.└──&nbsp;dir1&nbsp;directory#显示目录及文件的权限信息[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-p.├──&nbsp;[drwxr-xr-x]&nbsp;&nbsp;dir│&nbsp;&nbsp;&nbsp;├──&nbsp;[-rw-r--r--]&nbsp;&nbsp;test2.txt~│&nbsp;&nbsp;&nbsp;├──&nbsp;[-rw-r--r--]&nbsp;&nbsp;test3.txt│&nbsp;&nbsp;&nbsp;└──&nbsp;[-rw-r--r--]&nbsp;&nbsp;test3.txt.bak├──&nbsp;[-rw-r--r--]&nbsp;&nbsp;test2.txt└──&nbsp;[-rw-r--r--]&nbsp;&nbsp;test2.txt~1&nbsp;directory,&nbsp;5&nbsp;files#显示几层信息2代表2层（向下）[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-L&nbsp;2.├──&nbsp;dir│&nbsp;&nbsp;&nbsp;├──&nbsp;test2.txt~│&nbsp;&nbsp;&nbsp;├──&nbsp;test3.txt│&nbsp;&nbsp;&nbsp;└──&nbsp;test3.txt.bak├──&nbsp;test2.txt└──&nbsp;test2.txt~1&nbsp;directory,&nbsp;5&nbsp;files[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-L&nbsp;1.├──&nbsp;dir├──&nbsp;test2.txt└──&nbsp;test2.txt~1&nbsp;directory,&nbsp;2&nbsp;files</code></pre><p>-C 显示各种文件类型，以颜色区分</p><p><img src="/My-Blogs/images/tree%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-01.png" alt="img"></p><pre><code class="BASH">#显示文件和目录的所有者[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-u.├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;cp&nbsp;-&gt;&nbsp;/usr/bin/cp├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;dir│??&nbsp;├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test2.txt~│??&nbsp;├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test3.txt│??&nbsp;└──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test3.txt.bak├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test2.txt└──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test2.txt~1&nbsp;directory,&nbsp;6&nbsp;files#显示文件和目录的所属组[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-g.├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;cp&nbsp;-&gt;&nbsp;/usr/bin/cp├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;dir│??&nbsp;├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test2.txt~│??&nbsp;├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test3.txt│??&nbsp;└──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test3.txt.bak├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test2.txt└──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test2.txt~1&nbsp;directory,&nbsp;6&nbsp;files#不按树形形式显示文件和目录[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-i.cp&nbsp;-&gt;&nbsp;/usr/bin/cpdirtest2.txt~test3.txttest3.txt.baktest2.txttest2.txt~1&nbsp;directory,&nbsp;6&nbsp;files[root@centos7&nbsp;testdir]#&nbsp;tree.├──&nbsp;cp&nbsp;-&gt;&nbsp;/usr/bin/cp├──&nbsp;dir│&nbsp;&nbsp;&nbsp;├──&nbsp;test2.txt~│&nbsp;&nbsp;&nbsp;├──&nbsp;test3.txt│&nbsp;&nbsp;&nbsp;└──&nbsp;test3.txt.bak├──&nbsp;test2.txt└──&nbsp;test2.txt~1&nbsp;directory,&nbsp;6&nbsp;files#显示文件和目录的完整路径[root@centos7&nbsp;testdir]#&nbsp;pwd/root/testdir[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-f.├──&nbsp;./cp&nbsp;-&gt;&nbsp;/usr/bin/cp├──&nbsp;./dir│&nbsp;&nbsp;&nbsp;├──&nbsp;./dir/test2.txt~│&nbsp;&nbsp;&nbsp;├──&nbsp;./dir/test3.txt│&nbsp;&nbsp;&nbsp;└──&nbsp;./dir/test3.txt.bak├──&nbsp;./test2.txt└──&nbsp;./test2.txt~1&nbsp;directory,&nbsp;6&nbsp;files[root@centos7&nbsp;~]#&nbsp;tree&nbsp;-f&nbsp;./testdir/./testdir├──&nbsp;./testdir/cp&nbsp;-&gt;&nbsp;/usr/bin/cp├──&nbsp;./testdir/dir│&nbsp;&nbsp;&nbsp;├──&nbsp;./testdir/dir/test2.txt~│&nbsp;&nbsp;&nbsp;├──&nbsp;./testdir/dir/test3.txt│&nbsp;&nbsp;&nbsp;└──&nbsp;./testdir/dir/test3.txt.bak├──&nbsp;./testdir/test2.txt└──&nbsp;./testdir/test2.txt~1&nbsp;directory,&nbsp;6&nbsp;files</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Explain使用分析</title>
      <link href="/My-Blogs/2021/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/Explain%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"/>
      <url>/My-Blogs/2021/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/Explain%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.<br>EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:</p><a id="more"></a><pre><code class="SQL">EXPLAIN SELECT * from user_info WHERE  id &lt; 300;</code></pre><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:</p><pre><code class="SQL">CREATE TABLE `user_info` (  `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,  `name` VARCHAR(50) NOT NULL DEFAULT '',  `age`  INT(11)              DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `name_index` (`name`))  ENGINE = InnoDB  DEFAULT CHARSET = utf8</code></pre><pre><code class="SQL">CREATE TABLE `order_info` (  `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,  `user_id`      BIGINT(20)           DEFAULT NULL,  `product_name` VARCHAR(50) NOT NULL DEFAULT '',  `productor`    VARCHAR(30)          DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`))  ENGINE = InnoDB  DEFAULT CHARSET = utf8</code></pre><h2 id="EXPLAIN-输出格式"><a href="#EXPLAIN-输出格式" class="headerlink" title="EXPLAIN 输出格式"></a>EXPLAIN 输出格式</h2><p>EXPLAIN 命令的输出内容大致如下:</p><pre><code class="SQL">mysql&gt; explain select * from user_info where id = 2\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)</code></pre><p>各列的含义如下:</p><ul><li><p><code>id</code>: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</p></li><li><p><code>select_type</code>: SELECT 查询的类型.</p></li><li><p><code>table</code>: 查询的是哪个表</p></li><li><p><code>partitions</code>: 匹配的分区</p></li><li><p><code>type</code>: join 类型</p></li><li><p><code>possible_keys</code>: 此次查询中可能选用的索引</p></li><li><p><code>key</code>: 此次查询中确切使用到的索引.</p></li><li><p><code>ref</code>: 哪个字段或常数与 key 一起被使用</p></li><li><p><code>rows</code>: 显示此查询一共扫描了多少行. 这个是一个估计值.</p></li><li><p><code>filtered</code>: 表示此查询条件所过滤的数据的百分比</p></li><li><p><code>extra</code>: 额外的信息</p></li></ul><p>接下来我们来重点看一下比较重要的几个字段.</p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p><code>select_type</code> 表示了查询的类型, 它的常用取值有:</p><ul><li><p>SIMPLE, 表示此查询不包含 UNION 查询或子查询</p></li><li><p>PRIMARY, 表示此查询是最外层的查询</p></li><li><p>UNION, 表示此查询是 UNION 的第二或随后的查询</p></li><li><p>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询</p></li><li><p>UNION RESULT, UNION 的结果</p></li><li><p>SUBQUERY, 子查询中的第一个 SELECT</p></li><li><p>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</p></li></ul><p>最常见的查询类别应该是 <code>SIMPLE</code> 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 <code>SIMPLE</code> 类型, 例如:</p><pre><code class="SQL">mysql&gt; explain select * from user_info where id = 2\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)</code></pre><p>如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:</p><pre><code class="SQL">mysql&gt; EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3))    -&gt; UNION    -&gt; (SELECT * FROM user_info WHERE id IN (3, 4, 5));+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+| id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+|  1 | PRIMARY      | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     ||  2 | UNION        | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     || NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+3 rows in set, 1 warning (0.00 sec)</code></pre><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>表示查询涉及的表或衍生表</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p><code>type</code> 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 <code>type</code> 字段, 我们判断此次查询是 <code>全表扫描</code> 还是 <code>索引扫描</code> 等.</p><p><strong>type 常用类型</strong><br>type 常用的取值有:</p><p><code>system</code> : 表中只有一条数据. 这个类型是特殊的 <code>const</code> 类型.</p><p><code>const</code> : 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. <code>const</code> 查询速度非常快, 因为它仅仅读取一次即可.<br>例如下面的这个查询, 它使用了主键索引, 因此 <code>type</code> 就是 <code>const</code> 类型的.</p><pre><code class="SQL">mysql&gt; explain select * from user_info where id = 2\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)</code></pre><ul><li><code>eq_ref</code>: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:</li></ul><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: indexpossible_keys: user_product_detail_index          key: user_product_detail_index      key_len: 314          ref: NULL         rows: 9     filtered: 100.00        Extra: Using where; Using index*************************** 2. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: eq_refpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: test.order_info.user_id         rows: 1     filtered: 100.00        Extra: NULL2 rows in set, 1 warning (0.00 sec)</code></pre><ul><li><code>ref</code>: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 <code>最左前缀</code> 规则索引的查询.</li></ul><p>例如下面这个例子中, 就使用到了 <code>ref</code> 类型的查询:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: const         rows: 1     filtered: 100.00        Extra: NULL*************************** 2. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: refpossible_keys: user_product_detail_index          key: user_product_detail_index      key_len: 9          ref: const         rows: 1     filtered: 100.00        Extra: Using index2 rows in set, 1 warning (0.01 sec)</code></pre><ul><li><code>range</code>: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.</li></ul><p>当 <code>type</code> 是 <code>range</code> 时, 那么 EXPLAIN 输出的 <code>ref</code> 字段为 NULL, 并且 <code>key_len</code> 字段是此次查询中使用到的索引的最长的那个.</p><p>例如下面的例子就是一个范围查询:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT *    -&gt;         FROM user_info    -&gt;         WHERE id BETWEEN 2 AND 8 \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: rangepossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: NULL         rows: 7     filtered: 100.00        Extra: Using where1 row in set, 1 warning (0.00 sec)</code></pre><ul><li><code>index</code>: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.</li></ul><p><code>index</code> 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 <code>Using index</code> .</p><p>例如:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT name FROM  user_info \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: indexpossible_keys: NULL          key: name_index      key_len: 152          ref: NULL         rows: 10     filtered: 100.00        Extra: Using index1 row in set, 1 warning (0.00 sec)</code></pre><p>上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 <code>index</code> , 并且 Extra 的值是 <code>Using index</code> .</p><ul><li><code>ALL</code>: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.</li></ul><p>下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT age FROM  user_info WHERE age = 20 \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 10     filtered: 10.00        Extra: Using where1 row in set, 1 warning (0.00 sec)</code></pre><p><strong>type 类型的性能比较</strong></p><p>通常来说, 不同的 type 类型的性能关系如下:</p><p> <code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code></p><p><code>ALL</code> 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.</p><p>而 <code>index</code> 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.</p><p>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</p><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p><code>possible_keys</code> 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 <code>possible_keys</code> 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 <code>key</code> 字段决定.</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>此字段是 MySQL 在当前查询时所真正使用到的索引.</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.<br>key_len 的计算规则如下:</p><ul><li><p>字符串</p><ul><li><p>char(n): n 字节长度</p></li><li><p>varchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.</p></li></ul></li><li><p>数值类型:</p><ul><li><p>TINYINT: 1字节</p></li><li><p>SMALLINT: 2字节</p></li><li><p>MEDIUMINT: 3字节</p></li><li><p>INT: 4字节</p></li><li><p>BIGINT: 8字节</p></li><li><p>时间类型</p></li><li><p>DATE: 3字节</p></li><li><p>TIMESTAMP: 4字节</p></li><li><p>DATETIME: 8字节</p></li><li><p>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.</p></li></ul></li></ul><p>我们来举两个简单的栗子:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id &lt; 3 AND product_name = 'p1' AND productor = 'WHH' \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: rangepossible_keys: user_product_detail_index          key: user_product_detail_index      key_len: 9          ref: NULL         rows: 5     filtered: 11.11        Extra: Using where; Using index1 row in set, 1 warning (0.00 sec)</code></pre><p>上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 <code>order_info</code> 有一个联合索引:</p><pre><code class="SQL">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</code></pre><p>不过此查询语句 <code>WHERE user_id &lt; 3 AND product_name = 'p1' AND productor = 'WHH'</code> 中, 因为先进行 user_id 的范围查询, 而根据 <code>最左前缀匹配</code> 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 <code>user_id</code> , 因此在 <code>EXPLAIN</code> 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 <code>BIGINT(20) NOT NULL DEFAULT '0'</code> , 则 key_length 应该是8.</p><p>上面因为 <code>最左前缀匹配</code> 原则, 我们的查询仅仅使用到了联合索引的 <code>user_id</code> 字段, 因此效率不算高.</p><p>接下来我们来看下一个例子:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = 'p1' \G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: refpossible_keys: user_product_detail_index          key: user_product_detail_index      key_len: 161          ref: const,const         rows: 2     filtered: 100.00        Extra: Using index1 row in set, 1 warning (0.00 sec)</code></pre><p>这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 <code>WHERE user_id = 1 AND product_name = 'p1'</code> 中, 仅仅使用到了联合索引中的前两个字段, 因此 <code>keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</code></p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p><code>rows</code> 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br>这个值非常直观显示 SQL 的效率好坏, 原则上 <code>rows</code> 越少越好.</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p><code>EXplain</code> 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p><ul><li><code>Using filesort</code></li></ul><p>当 Extra 中有 <code>Using filesort</code> 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 <code>Using filesort</code> , 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</p><p>例如下面的例子:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY product_name \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: indexpossible_keys: NULL          key: user_product_detail_index      key_len: 253          ref: NULL         rows: 9     filtered: 100.00        Extra: Using index; Using filesort1 row in set, 1 warning (0.00 sec)</code></pre><p>我们的索引是</p><pre><code class="SQL">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</code></pre><p>但是上面的查询中根据 <code>product_name</code> 来排序, 因此不能使用索引进行优化, 进而会产生 <code>Using filesort</code> .<br>如果我们将排序依据改为 <code>ORDER BY user_id, product_name</code> , 那么就不会出现 <code>Using filesort</code> 了. 例如:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: indexpossible_keys: NULL          key: user_product_detail_index      key_len: 253          ref: NULL         rows: 9     filtered: 100.00        Extra: Using index1 row in set, 1 warning (0.00 sec)</code></pre><ul><li><p><code>Using index</code> “覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</p></li><li><p><code>Using temporary</code> 查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>db操作常见问题</title>
      <link href="/My-Blogs/2021/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/My-Blogs/2021/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>总结了一些db操作的常见问题，让我们一起来看看吧</p><a id="more"></a><h2 id="联合索引问题"><a href="#联合索引问题" class="headerlink" title="联合索引问题"></a>联合索引问题</h2><ol><li> 在imo后台群唤醒活动中，用户数据表多达几千万，大数据这边，并未针对业务场景建立有效覆盖索引，导致后台SQL慢查询告警上千次，针对业务场景，提出以下优化，新增key1，key2索引覆盖，后台where条件严格按照stats_day，activelevel，categeory_id，cc顺序查询。</li><li> 按照MySQL联合索引最左匹配原则，比如A-B-C联合索引，则针对A，A-B，A-B-C查询有效，而A-C，B-C，B，C则无效，where条件最好根据索引顺序进行</li><li> 如果搜索条件过于复杂混乱，建议先与产品沟通清楚，确定好如何建立索引，严格把控搜索条件（从界面上）</li><li> 以下为用户数据表（千万级别）</li></ol><pre><code class="SQL">CREATE TABLE `xx_push_activelevel_categeory_day` (  `stats_day` date NOT NULL DEFAULT '2019-01-01',  `cc` varchar(10) NOT NULL DEFAULT '',  `activelevel` varchar(30) NOT NULL DEFAULT 'unknown',  `categeory_id` varchar(50) NOT NULL DEFAULT 'unknown',  `groupid` char(30) NOT NULL DEFAULT 'unknown',  `role` varchar(15) NOT NULL DEFAULT 'unknown',  `uid` varchar(25) NOT NULL DEFAULT '',  PRIMARY KEY (`role`,`activelevel`,`categeory_id`,`cc`,`uid`,`groupid`,`stats_day`),  KEY `role` (`role`,`activelevel`,`categeory_id`),  KEY `key1` (`stats_day`,`activelevel`,`categeory_id`,`cc`,`role`),  KEY `key2` (`stats_day`,`activelevel`,`categeory_id`,`cc`),  KEY `actl` (`activelevel`),  KEY `agid` (`categeory_id`),  KEY `cc` (`cc`)) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4/*!50100 PARTITION BY RANGE (TO_DAYS(stats_day))(PARTITION pd20200609 VALUES LESS THAN (737951) ENGINE = MyISAM, PARTITION pd20200610 VALUES LESS THAN (737952) ENGINE = MyISAM, PARTITION pd20200611 VALUES LESS THAN (737953) ENGINE = MyISAM) */;</code></pre><h2 id="主键偏移问题"><a href="#主键偏移问题" class="headerlink" title="主键偏移问题"></a>主键偏移问题</h2><ol><li> 在单表大数据量的情况下，使用索引并不是唯一选择，当SQL分页查询，offset达到一定量(大概20w以上？)以后，就会出现慢查询现象，是由于MySQL根据索引查出一定量数据之后，会根据offset抛弃之前的数据</li><li> 这意味着前20w数据的查询都是无用的，费力不讨好</li><li> 可以采用主键id(INT, BIGINT类型)偏移，INT类型查询天生就有优势，又是主键索引，可以做到一部到位</li><li> where条件最后，加上id排序，记录上一次的查询数据最后一条id，下一次查询作为偏移量，从而跳过前面无用的数据，再开始进行索引查询</li><li> 以下是某个项目的例子（仅供参考）</li></ol><pre><code class="SQL">SELECT id, stats_day, cc, activelevel, categeory_id, groupid, role, uid FROM xx_push_activelevel_categeory_day AS biggroupPushCategeoryWHERE biggroupPushCategeory.id &gt; 200000 AND biggroupPushCategeory.stats_day = '2020-07-01 00:00:00' AND biggroupPushCategeory.activelevel = 'gtype_unactive_2' AND biggroupPushCategeory.categeory_id = 'categeory_mems_less_300' AND biggroupPushCategeory.cc = 'PK'ORDER BY biggroupPushCategeory.id ASC LIMIT 500;</code></pre><h2 id="结果集过滤问题"><a href="#结果集过滤问题" class="headerlink" title="结果集过滤问题"></a>结果集过滤问题</h2><ol><li> 接上一个问题，当我们结合主键偏移+索引【KEY <code>sacc</code> (<code>stats_day</code>,<code>activelevel</code>,<code>categeory_id</code>,<code>cc</code>)】搜索的时候，SQL这边优先根据索引过滤结果集，根据上面那条sql，我们可能会过滤出一个大结果集，而且结果集并不保证id有序</li><li> 这时候我们需要重新修改索引键，加上主键id，例如KEY <code>sacci</code> (<code>stats_day</code>,<code>activelevel</code>,<code>categeory_id</code>,<code>cc</code>,<code>id</code>)，当我们进行索引查询取500行时，可以根据id&gt;20000，直接命中500行并返回，不需要重新排序，也不会返回之前sacc索引的所有结果集</li><li> 以下是优化前和优化后的对比图，性能提高了几十倍</li></ol><h3 id="优化前"><a href="#优化前" class="headerlink" title="优化前"></a>优化前</h3><p><img src="/My-Blogs/images/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-01.png" alt="优化前"></p><h3 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h3><p><img src="/My-Blogs/images/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-02.png" alt="优化后"></p><h2 id="where条件顺序问题"><a href="#where条件顺序问题" class="headerlink" title="where条件顺序问题"></a>where条件顺序问题</h2><ol><li> 接上一个问题，我们已经创建索引KEY <code>sacci</code> (<code>stats_day</code>,<code>activelevel</code>,<code>categeory_id</code>,<code>cc</code>,<code>id</code>)，如果我们把id放在最前，或者最后，会对查询的效率有影响吗？答案是没有。</li><li> SQL执行是会被进行一系列预处理，让查询优化器选择最优的查询计划，所以where条件的先后关系不是优化器选择规则的一条，当然前提是你的where条件数量与索引一致，如果where条件少于索引数量，会根据最左原则优先查询。</li><li> 总的来说，唯一会影响的就是where条件和索引的比对，以及跟order by等，跟先后顺序无关。</li><li> 引申开来说，如果对ABC三个字段建立联合索引，一般来说，在创建索引时，根据区分度原则，尽量让A能够排除更多记录而不是B或C，在查询时，根据索引前缀匹配原则，尽可能让A条件精确，B其次，C看着办。</li><li> 以下是id前后对比图</li></ol><p><img src="/My-Blogs/images/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-03.png" alt="alt"></p><p><img src="/My-Blogs/images/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-04.png" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PRPL模式加快Web应用加载</title>
      <link href="/My-Blogs/2021/01/08/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/"/>
      <url>/My-Blogs/2021/01/08/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>PRPL 是一种用于结构化和交付 Web 应用程序和渐进式 Web 应用（PWA）的模式，重点在于改进应用的交付和启动性能。这个模式包含一组步骤，以实现快速、可靠、高效的加载：</p><a id="more"></a><ul><li><p><code>Push</code>, 推送初始路由所需的所有资源，并且只推送这些资源，以确保它们尽早可用。</p></li><li><p><code>Render</code>, 在加载其他资源之前，渲染初始路由并使其具备交互能力。</p></li><li><p><code>Pre-cache</code>, 预缓存用户可能访问的其他路由的资源，从而在恶劣的网络条件下尽可能提高对后续请求的响应能力和弹性。</p></li><li><p><code>Lazy-load</code>, 当用户请求时，按需延迟加载路由；关键路由的资源应立即从缓存中加载，而相对不常用的资源可以根据请求从网络获取。</p></li></ul><blockquote><p>注意：PRPL模式是由Polymer团队于2016年首次引入的，但已被证明适用于其他许多技术栈。</p></blockquote><p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-01.png" alt="img"></p><center>PRPL 模式加载顺序</center><p>服务器和服务 Worker 一起为非活动路由预缓存资源。当用户切换路由时，应用会延迟加载尚未缓存的所有必需资源，并创建所需的视图。</p><p>Twitter.com 自 2017 年以来就在生产中使用 PRPL 模式了。下面我们可以看到，他们对关键脚本使用了粒度代码拆分，并使用 <code>&lt;linkrel=preload&gt;</code> 推送脚本以尽快让脚本可用：</p><p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-02.png" alt="img"></p><br><center style="margin-top: 20px">PRPL 模式：预加载关键脚本</center><br><p>其他路由会按需延迟加载。Twitter 在整个用户体验部分中会按需提供 40 多个块。Twitter 还使用服务 Workers 对其他路由进行（离线）资产预缓存，以提高对后续导航操作的响应能力：</p><br><p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-03.png" alt="img"></p><br><center style="margin-top: 20px">PRPL 模式：离线缓存资源</center><br><p>他们的应用程序外壳程序（骨架 UI）也是离线缓存的，就算用户通过缓慢或不稳定的网络连接加载站点，也会立即加载它们：</p><p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-04.png" alt="img"></p><center>PRPL 模式：应用程序外壳</center><h2 id="为什么选择-PRPL？"><a href="#为什么选择-PRPL？" class="headerlink" title="为什么选择 PRPL？"></a>为什么选择 PRPL？</h2><p>应用使用 PRPL 构建是为了达到可靠、快速和引人入胜的目的。除了这些基本目标，PRPL 还旨在：</p><ul><li><p><strong>改善应用的交互就绪水平</strong>。为了做到这一点，在第一个视图渲染并具备交互能力之前，不会向浏览器发送多余的资源。</p></li><li><p><strong>提高应用的缓存效率，尤其是长期缓存效率</strong>。为了做到这一点，资源会以很细的粒度向浏览器发送。当资源被解绑或松散地打包时，对代码的每次更改给缓存的负面影响也会减少。</p></li><li><p><strong>降低开发和部署的复杂性</strong>。为了做到这一点，这种模式使用应用的隐式依赖图将每个入口点精确映射到所需的资源集，从而减少或消除了手动管理打包和交付的需求。</p></li></ul><h2 id="PRPL-应包含哪些技术？"><a href="#PRPL-应包含哪些技术？" class="headerlink" title="PRPL 应包含哪些技术？"></a>PRPL 应包含哪些技术？</h2><p>PRPL 是一种能以各种方式实现的概念模式，但是通过以下现代 Web 特性的某种组合，可以最轻松有效地实现 PRPL：</p><ul><li><p>像JavaScript Modules这样的现代模块系统，使工具可以轻松构造完整的依赖图；</p></li><li><p>服务Workers，为后续的应用视图预缓存（“安装”）资源（进而支持离线优先架构）</p></li><li><p>预加载，用于尽快交付所需资源。你还可以使用预加载链接头，这些头可以被协作服务器拦截并升级为HTTP/2 Server Push（详情可见<a href="https://www.smashingmagazine.com/2017/04/guide-http2-server-push/">原文</a>）。一定要记住，尽管Push功能强大，但它也面临着许多已知的挑战；不过PRPL使用服务Worker可以避免过度推送的问题（仅针对初始负载使用push）。</p></li></ul><h2 id="如何实现-PRPL-模式？"><a href="#如何实现-PRPL-模式？" class="headerlink" title="如何实现 PRPL 模式？"></a>如何实现 PRPL 模式？</h2><p>PRPL 的很大一部分理念是对 JS 打包思维的颠覆，并在提供资源时拆分成尽可能接近编写资源时的粒度（至少拆分成独立的功能模块）。那么如何实现细粒度呢？</p><h3 id="基于路由或基于组件的代码拆分和延迟加载"><a href="#基于路由或基于组件的代码拆分和延迟加载" class="headerlink" title="基于路由或基于组件的代码拆分和延迟加载"></a>基于路由或基于组件的代码拆分和延迟加载</h3><p>你正在将事物编写为组件。也许你正在使用 ES 模块。对于 Webpack，我们使用动态导入和代码拆分，将你的代码库拆分为按需加载的块。</p><br><p>Next.js 和 Nuxt.js 之类的元框架会默认实现基于路由的代码拆分。如果你使用的是 create-react-app 之类的工具链样板，则需要借助 React Router 之类的路由器进行动态导入，才能将基于路由或基于组件的代码拆分添加到你的应用程序中。</p><br><p>对于 PRPL 的 push/preload 部分，Webpack 还支持将 preload 作为魔术注释来预加载关键脚本。</p><br><h3 id="预缓存"><a href="#预缓存" class="headerlink" title="预缓存"></a>预缓存</h3><p>可以使用服务 worker 预缓存剩余的路由。另一种常见的做法是，利用 Workbox 之类的服务 worker 库来简化为应用程序预缓存路由和块的过程。</p><br><h2 id="PRPL-使用何种应用程序结构？"><a href="#PRPL-使用何种应用程序结构？" class="headerlink" title="PRPL 使用何种应用程序结构？"></a>PRPL 使用何种应用程序结构？</h2><p>PRPL 鼓励采用以下结构的单页应用（SPA）架构：</p><br><ul><li><p>从每个有效路由提供的应用程序的主入口点。</p></li><li><p>这个文件应该很小，因为它将通过不同的URL提供，因此会被多次缓存。入口点中的所有资源URL都必须是绝对的，因为它可以从非顶级URL提供。</p></li><li><p>外壳（app-shell），其中包括顶级应用逻辑、router等。</p></li><li><p>延迟加载的应用片段。</p></li><li><p>可以代表特定视图代码的片段，或其他可以延迟加载的代码（例如，主应用的一些部分在第一次绘制时并不需要，比如说菜单，直到用户与应用交互时才显示）。外壳负责根据需要动态导入这些片段。</p></li></ul><p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-05.png" alt="img"></p><center style="margin: 20px 0 20px 0; ">应用外壳骨架模式</center><p>应用应根据需要调用动态导入以延迟加载片段。例如，当用户更改为新路由时，它将导入与该路由关联的片段。这可能会向服务器发起新请求，或者只是从缓存中加载资源。</p><br><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>除了针对 PWA 的基本目标和标准之外，PRPL 还尽量针对以下方面做了优化：</p><br><ul><li><p>尽量减少交互的准备工作——特别是在首次使用时（无论入口点如何）。</p></li><li><p>尽量提升缓存效率，尤其是更新不断发布后的长期缓存效率。</p></li><li><p>简化开发和部署。</p></li></ul><p>自 2016 年诞生以来，PRPL 模式已获得了大规模使用，值得你在优化应用加载时考虑。</p><p>原文链接：<a href="https://addyosmani.com/blog/the-prpl-pattern/">https://addyosmani.com/blog/the-prpl-pattern/</a></p>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈登录</title>
      <link href="/My-Blogs/2021/01/08/%E5%AE%89%E5%85%A8/%E8%B0%88%E8%B0%88%E7%99%BB%E5%BD%95/"/>
      <url>/My-Blogs/2021/01/08/%E5%AE%89%E5%85%A8/%E8%B0%88%E8%B0%88%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="一、Cookie与Session"><a href="#一、Cookie与Session" class="headerlink" title="一、Cookie与Session"></a>一、Cookie与Session</h3><p>HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行保存。因为无法管理用户状态，对于要登录的页面，每次跳转新页面时都需要再次登录。</p><a id="more"></a><p>于是引入了Cookie来管理用户状态：</p><p>① 首先客户端发起不带Cookie信息的登录请求</p><p>② 服务端接收到请求，验证用户数据正确后，添加响应头Set-Cookie</p><p>③ 客户端收到响应报文后，检查到响应头Set-Cookie，在本地保存Cookie</p><p>④ 之后每次向该域发起请求时，自动添加请求头Cookie，发送给服务端</p><p>⑤ 服务端获取请求头Cookie，根据Cookie的值，就可以判断出用户是否登录</p><p>但是Cookie极容易被篡改和伪造，于是产生了Session，Session将用户信息保存在服务端，那么Session是如何管理用户状态的呢？</p><p>① 首先客户端发起不带Cookie信息的登录请求</p><p>② 服务端接收到请求，检查到没有携带口令，验证用户密码正确后生成Session，将用户信息保存在Session，设置响应头Set-Cookie，通常是将Session ID作为口令值</p><p>③ 客户端检查到Set-Cookie响应头，在本地保存Cookie信息</p><p>④ 之后每次发起请求时，自动在请求头Cookie中携带口令，发送给服务端</p><p>⑤ 服务端获取Cookie携带的口令值，找到对应的Session，就可以判断用户状态</p><h3 id="二、如何让Session口令值更安全"><a href="#二、如何让Session口令值更安全" class="headerlink" title="二、如何让Session口令值更安全"></a>二、如何让Session口令值更安全</h3><p>虽然口令值由服务端生成，用户不容易伪造，But nothing is impossible；而且口令值存在客户端，就有可能被盗用。一旦口令值被伪造或盗用，攻击者就可以伪装成用户访问服务端的数据。</p><p>那么如何让Session口令值更安全呢？</p><p>① 将客户端的某些独有信息+口令值作为原值，对其进行签名</p><p>② 将口令值拼接签名返回给客户端，将Cookie设置为HttpOnly（禁止用户通过脚本来获取和更改Cookie）</p><p>③ 服务端再次收到请求，取客户端信息与口令值签名，与客户端携带的签名对比，不相等，说明请求不合法</p><p>这样的话：</p><p>① 即使攻击者知道了口令值，由于不知道密钥，无法伪造签名</p><p>② 即使攻击者通过某种方式得到了真实的口令值和签名，但是由于攻击者的客户端信息不一样，发送到服务端后，会得到不一样的签名，签名校验不能通过</p><h3 id="三、多系统的复杂性"><a href="#三、多系统的复杂性" class="headerlink" title="三、多系统的复杂性"></a>三、多系统的复杂性</h3><p>web系统由早期的单系统发展成多系统组成的应用群，面对如此众多的系统，用户难道要一个个登录、再一个个注销吗？</p><p>系统复杂性应该由系统内部承担，而不是用户。无论web系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问web系统的整个应用群与访问单个系统一样，只要登录/注销一次就够了。</p><p><img src="/My-Blogs/images/%E8%B0%88%E8%B0%88%E7%99%BB%E5%BD%95-01.png"></p><p>因为Cookie不允许跨域，早期多系统登录采用将Cookie种在顶级域名下的方式，来实现Cookie共享。这种方式的局限在于：</p><p>① 应用群各系统的域名得统一</p><p>② 应用群各系统的web服务端使用的技术要相同，比如Session口令值以及它的签名</p><p>方式要相同，要不Session口令值不同，无法维持会话</p><p>因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录。</p><h3 id="四、单点登录"><a href="#四、单点登录" class="headerlink" title="四、单点登录"></a>四、单点登录</h3><p>单点登录全称Single Sign On（简称SSO），是指在多系统应用群中登录一个系统，便可在其它所有系统中得到授权而无需再次登录。包括单点登录与单点注销两部分：</p><h4 id="1、单点登录"><a href="#1、单点登录" class="headerlink" title="1、单点登录"></a>1、单点登录</h4><p>　    相比于单系统登录，SSO需要一个独立的认证中心，只有认证中心能接受用户的用    户名密码等安全信息，其它系统不提供登录入口，只接受认证中心的间接授权。</p><p>通常SSO认证中心验证用户数据没问题后，会创建授权Token，分发给各个子系统。子系统拿到Token，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。这个过程，也就是单点登录的原理。</p><p><img src="/My-Blogs/images/%E8%B0%88%E8%B0%88%E7%99%BB%E5%BD%95-02.png"></p><p>例如：</p><p>    用户访问系统1，系统1发现用户未登录，跳转至SSO认证中心，并将自己的地址作为参数</p><p>    SSO认证中心发现用户未登录，将用户引导至登录页面</p><p>    用户输入用户名密码提交登录申请</p><p>    SSO认证中心校验用户信息，创建用户与SSO认证中心之间的会话，称为全局会话，同时创建授权Token</p><p>    SSO认证中心带着Token跳转回最初的请求地址（系统1）</p><p>    系统1拿到Token，去SSO认证中心校验Token是否有效</p><p>    SSO认证中心校验Token，返回有效，注册系统1</p><p>    系统1使用该Token创建与用户的会话，称为局部会话，返回受保护资源</p><p>    用户访问系统2的受保护资源</p><p>    系统2发现用户未登录，跳转至SSO认证中心，并将自己的地址作为参数</p><p>    SSO认证中心发现用户已登录，跳转回系统2的地址，并附上令牌</p><p>    系统2拿到令牌，去SSO认证中心校验令牌是否有效</p><p>    SSO认证中心校验令牌，返回有效，注册系统2</p><p>    系统2使用该令牌创建与用户的局部会话，返回受保护资源</p><p>用户登录成功之后，会与SSO认证中心及各个子系统建立会话，用户与SSO认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过SSO认证中心，全局会话与局部会话有如下约束关系：</p><p>① 局部会话存在，全局会话一定存在</p><p>② 全局会话存在，局部会话不一定存在</p><p>③ 全局会话销毁，局部会话必须销毁</p><p>2、单点注销</p><p>单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁。</p><p><img src="/My-Blogs/images/%E8%B0%88%E8%B0%88%E7%99%BB%E5%BD%95-03.png"></p><p>    用户向系统1发起注销请求</p><p>    系统1根据用户与系统1建立的会话拿到Token，向SSO认证中心发起注销请求</p><p>    SSO认证中心校验Token有效，销毁全局会话，同时取出所有用此Token注册的系统地址</p><p>    SSO认证中心向所有注册系统发起注销请求</p><p>    各注册系统接收SSO认证中心的注销请求，销毁局部会话</p><p>    SSO认证中心引导用户至登录页面</p><h3 id="五、登录安全防范"><a href="#五、登录安全防范" class="headerlink" title="五、登录安全防范"></a>五、登录安全防范</h3><p>1、CSRF攻击</p><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的登录凭证，绕过后台的用户验证，达到冒充用户对被攻击网站执行某项操作的目的。</p><p>一个典型的CSRF攻击有着如下的流程：</p><p>① 受害者登录网站a，并保留了登录凭证Cookie</p><p>② 攻击者引诱受害者访问网站b，它向网站a的服务器发送了一个跨站请求，该请求会默认携带网站a的Cookie</p><p>③ 网站a的服务器接收到请求后，对请求进行验证，确认是受害者的凭证，误以为是受害者自己发送的请求，以受害者的名义执行某个操作</p><p>④ 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让网站a执行了攻击者自己定义的操作</p><p>CSRF通常发生在第三方域名，由于浏览器同源策略的限制，攻击者不能获取到受害者的Cookie信息，只是冒用。针对这2点，我们可以制定相应的防护策略：</p><p>1）同源检测</p><p>服务器通过解析Origin 或Referer这两个请求头，确定请求的来源域，如果请求来自外域，直接阻止。</p><p>缺点：在部分情况下，攻击者可以隐藏甚至修改自己请求的Referer；会误伤一些正常请求，比如通过搜索结果跳转的页面请求。</p><p>2）Samesite Cookie</p><p>为了从源头上解决CSRF攻击，Google起草了一份草案来改进HTTP协议，即为响应头Set-Cookie新增Samesite属性：</p><p>Strict：任何情况下都不可能作为第三方Cookie，其它网站发起的任意请求都不会携带上该Cookie，包括搜索页面。</p><p>Lax：用户在不同网站之间通过链接跳转不受影响；但假如这个请求是从其它网站发起的请求，或者页面跳转是通过表单POST提交触发的，则Cookie也不会携带发送。</p><p>缺点：目前还并不成熟，其应用场景有待观望。</p><p>3）双重Cookie</p><p>①     在用户访问网站页面时，向请求域名注入两个Cookie，一个是原本要注入的Cookie，一个比如随机字符串</p><p>② 前端向后端发起请求时，取出随机字符串，添加到URL参数或请求头中</p><p>③ 后端验证携带的随机数与Cookie中的随机数是否一致，不一致则拒绝请求</p><p>缺点：难以做到子域名隔离，认证Cookie必须被种在顶级域名下，每个子域才可以访问；如果某个子域存在XSS漏洞，攻击者将这个认证Cookie修改为自己配置的Cookie；攻击者直接使用自己配置的Cookie发起CSRF攻击。</p><p>4）CSRF Token</p><p>CSRF攻击者无法直接窃取到用户的Cookie，仅仅是冒用；而CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户的请求。</p><p>① 服务器生成登录Cookie时，同时生成Token和Token签名的2个Cookie</p><p>② 前端向后端发起请求时，将Token添加到URL参数或请求头中</p><p>③ 后端收到请求，首先验证参数与Token相不相同，不相同则中止请求；然后校验签名，不相同则中止请求。因为攻击者不知道密钥，使用Token签名可以防止Cookie被篡改和伪造。</p><p>缺点：每个请求都需要携带Token，且需要服务端对每个请求进行校验。所以一般只对包含敏感数据的请求做此处理。</p><p>2、短信防刷</p><p>短信轰炸是指攻击者利用从各个网站上找到的发送动态短信的URL和前端输入的被攻击者的手机号码，发送HTTP请求，每次请求给用户发送一个动态短信。</p><p>危害：增加公司的运营成本，因为短信是需要计费的；被攻击者大量被动接收非自身请求的短信，造成无法正常使用移动运营商业务；给公司形象造成极大影响，因为一般短信会带公司签名。</p><p>常见防范手段：</p><p>    短信发送间隔设置</p><p>    发送量限制</p><p>    图文验证码</p><p>    触发流程限制</p><h3 id="六、全球部署问题"><a href="#六、全球部署问题" class="headerlink" title="六、全球部署问题"></a>六、全球部署问题</h3><p>Session存在内存里随着用户的增多会导致内存溢出，且不能跨进程、跨机器共享，且重启进程后会导致Session丢失，所以Session通常会存在第三方缓存，比如Redis里。</p><p>Redis全球部署带来的问题在于，已登录的用户再次请求时，如果请求定位到不同集群的Redis，会导致登录状态失效。</p><p>解决方案：</p><p>    不同集群Redis数据同步</p><p>    保证相同集群的Web服务请求同一集群的Redis</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> 登录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh的基本用法</title>
      <link href="/My-Blogs/2021/01/08/%E5%8D%8F%E8%AE%AE/ssh/ssh%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/My-Blogs/2021/01/08/%E5%8D%8F%E8%AE%AE/ssh/ssh%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><code>SSH</code>，我们经常操作远程服务器的时候，都会用到这个命令，但是他除了登录服务器还有很多作用，下面我们一起来了解下吧</p><a id="more"></a><h2 id="ssh登录服务器命令"><a href="#ssh登录服务器命令" class="headerlink" title="ssh登录服务器命令"></a>ssh登录服务器命令</h2><pre><code class="BASH">ssh hostname</code></pre><p>上面命令中， <code>hostname</code> 是主机名，它可以是域名，也可能是 IP 地址或局域网内部的主机名。不指定用户名的情况下，将使用客户端的当前用户名，作为远程服务器的登录用户名。</p><p>如果要指定用户名，可以采用下面的语法。</p><pre><code class="BASH">ssh user@hostname</code></pre><p>上面的命令中，用户名和主机名写在一起了，之间使用 <code>@</code> 分隔。</p><p>指定用户名，可以使用 <code>ssh</code> 和 <code>-l</code> 参数</p><pre><code class="BASH">ssh -l username host</code></pre><p>ssh 默认连接服务器的 <code>22</code> 端口， <code>-p</code> 参数可以指定其他端口</p><pre><code class="BASH">ssh -p 8821 hostname</code></pre><h2 id="ssh执行远程命令"><a href="#ssh执行远程命令" class="headerlink" title="ssh执行远程命令"></a>ssh执行远程命令</h2><p>将命令直接写在 <code>ssh</code> 命令的后面</p><pre><code class="BASH">ssh username@hostname command</code></pre><p>上面的命令会使得 SSH 在登录成功后，立刻在远程主机上执行命令 <code>command</code> 。</p><p>例子</p><pre><code class="BASH">ssh foo@server.example.com cat /etc/hosts</code></pre><p>上面的命令会在登录成功后，立即远程执行命令 <code>cat /etc/hosts</code> 。</p><h2 id="ssh命令行配置项"><a href="#ssh命令行配置项" class="headerlink" title="ssh命令行配置项"></a>ssh命令行配置项</h2><h3 id="c-参数指定加密算法。"><a href="#c-参数指定加密算法。" class="headerlink" title="-c 参数指定加密算法。"></a><code>-c</code> 参数指定加密算法。</h3><pre><code class="BASH">$ ssh -c blowfish,3des server.example.com# 或者$ ssh -c blowfish -c 3des server.example.com</code></pre><p>上面命令指定使用加密算法 <code>blowfish</code> 或 <code>3des</code></p><h3 id="C-参数表示压缩数据传输"><a href="#C-参数表示压缩数据传输" class="headerlink" title="-C 参数表示压缩数据传输"></a><code>-C</code> 参数表示压缩数据传输</h3><pre><code class="BASH">ssh -C server.example.com</code></pre><h3 id="d-参数设置打印的-debug-信息级别，数值越高，输出的内容越详细。"><a href="#d-参数设置打印的-debug-信息级别，数值越高，输出的内容越详细。" class="headerlink" title="-d 参数设置打印的 debug 信息级别，数值越高，输出的内容越详细。"></a><code>-d</code> 参数设置打印的 debug 信息级别，数值越高，输出的内容越详细。</h3><pre><code class="BASH">ssh –d 1 foo.com</code></pre><h3 id="D-参数指定本机的-Socks-监听端口"><a href="#D-参数指定本机的-Socks-监听端口" class="headerlink" title="-D 参数指定本机的 Socks 监听端口"></a><code>-D</code> 参数指定本机的 Socks 监听端口</h3><blockquote><p>该端口收到的请求，都将转发到远程的 SSH 主机，又称动态端口转发</p></blockquote><pre><code class="BASH"> ssh -D 1080 server</code></pre><p>上面命令将本机 1080 端口收到的请求，都转发到服务器 <code>server</code></p><h3 id="f-参数表示-SSH-连接在后台运行"><a href="#f-参数表示-SSH-连接在后台运行" class="headerlink" title="-f 参数表示 SSH 连接在后台运行"></a><code>-f</code> 参数表示 SSH 连接在后台运行</h3><h3 id="F-参数指定配置文件"><a href="#F-参数指定配置文件" class="headerlink" title="-F 参数指定配置文件"></a><code>-F</code> 参数指定配置文件</h3><pre><code class="BASH">ssh -F /usr/local/ssh/other_config</code></pre><p>上面命令指定使用配置文件 <code>other_config</code></p><h3 id="i-参数用于指定私钥"><a href="#i-参数用于指定私钥" class="headerlink" title="-i 参数用于指定私钥"></a><code>-i</code> 参数用于指定私钥</h3><blockquote><p>意为“identity_file”，默认值为~/.ssh/id_dsa。注意，对应的公钥必须存放到服务器</p></blockquote><pre><code class="BASH">ssh -i my-key server.example.com</code></pre><h3 id="l-参数指定远程登录的账户名"><a href="#l-参数指定远程登录的账户名" class="headerlink" title="-l 参数指定远程登录的账户名"></a><code>-l</code> 参数指定远程登录的账户名</h3><pre><code class="BASH">$ ssh -l sally server.example.com# 等同于$ ssh sally@server.example.com</code></pre><h3 id="L-参数设置本地端口转发"><a href="#L-参数设置本地端口转发" class="headerlink" title="-L 参数设置本地端口转发"></a><code>-L</code> 参数设置本地端口转发</h3><pre><code class="BASH">ssh  -L 9999:targetServer:80 user@remoteserver</code></pre><p>上面命令中，所有发向本地 <code>9999</code> 端口的请求，都会经过 <code>remoteserver</code> 发往 <code>targetServer</code> 的 <code>80</code> 端口，这就相当于直接连上了 <code>targetServer</code> 的 <code>80</code> 端口</p><h3 id="m-参数指定校验数据完整性的算法"><a href="#m-参数指定校验数据完整性的算法" class="headerlink" title="-m 参数指定校验数据完整性的算法"></a><code>-m</code> 参数指定校验数据完整性的算法</h3><pre><code class="BASH">ssh -m hmac-sha1,hmac-md5 server.example.com</code></pre><p>上面命令指定数据校验算法为 <code>hmac-sha1</code> 或 <code>hmac-md5</code></p><h3 id="o-参数用来指定一个配置命令"><a href="#o-参数用来指定一个配置命令" class="headerlink" title="-o 参数用来指定一个配置命令"></a><code>-o</code> 参数用来指定一个配置命令</h3><pre><code class="BASH">ssh -o "Keyword Value"</code></pre><p>举例来说，配置文件里面有如下内容。</p><pre><code class="BASH">User sallyPort 220</code></pre><p>通过 <code>-o</code> 参数，可以把上面两个配置命令从命令行传入。</p><pre><code class="BASH">ssh -o "User sally" -o "Port 220" server.example.com</code></pre><p>使用等号时，配置命令可以不用写在引号里面，但是等号前后不能有空格</p><pre><code class="BASH">ssh -o User=sally -o Port=220 server.example.com</code></pre><h3 id="p-参数指定-SSH-客户端连接的服务器端口"><a href="#p-参数指定-SSH-客户端连接的服务器端口" class="headerlink" title="-p 参数指定 SSH 客户端连接的服务器端口"></a><code>-p</code> 参数指定 SSH 客户端连接的服务器端口</h3><pre><code class="BASH">ssh -p 2035 server.example.com</code></pre><p>上面命令连接服务器的2035端口</p><h3 id="q-参数表示安静模式（quiet），不向用户输出任何警告信息"><a href="#q-参数表示安静模式（quiet），不向用户输出任何警告信息" class="headerlink" title="-q 参数表示安静模式（quiet），不向用户输出任何警告信息"></a><code>-q</code> 参数表示安静模式（quiet），不向用户输出任何警告信息</h3><pre><code class="BASH">ssh –q foo.comroot’s password:</code></pre><p>上面命令使用 <code>-q</code> 参数，只输出要求用户输入密码的提示</p><h3 id="R-参数指定远程端口转发"><a href="#R-参数指定远程端口转发" class="headerlink" title="-R 参数指定远程端口转发"></a><code>-R</code> 参数指定远程端口转发</h3><pre><code class="BASH">ssh -R 9999:targetServer:902 local</code></pre><p>上面命令需在跳板服务器执行，指定本地计算机 <code>local</code> 监听自己的 9999 端口，所有发向这个端口的请求，都会转向 targetServer 的 902 端口</p><h3 id="t-参数在-ssh-直接运行远端命令时，提供一个互动式-Shell"><a href="#t-参数在-ssh-直接运行远端命令时，提供一个互动式-Shell" class="headerlink" title="-t 参数在 ssh 直接运行远端命令时，提供一个互动式 Shell"></a><code>-t</code> 参数在 ssh 直接运行远端命令时，提供一个互动式 Shell</h3><pre><code class="BASH">ssh -t server.example.com emacs</code></pre><h3 id="v-参数显示详细信息"><a href="#v-参数显示详细信息" class="headerlink" title="-v 参数显示详细信息"></a><code>-v</code> 参数显示详细信息</h3><pre><code class="BASH">ssh -v server.example.com</code></pre><p><code>-v</code> 可以重复多次，表示信息的详细程度，比如 <code>-vv</code> 和 <code>-vvv</code></p><pre><code class="BASH">$ ssh -vvv server.example.com# 或者$ ssh -v -v -v server.example.com</code></pre><p>上面命令会输出最详细的连接信息</p><h3 id="V-参数输出-ssh-客户端的版本"><a href="#V-参数输出-ssh-客户端的版本" class="headerlink" title="-V 参数输出 ssh 客户端的版本"></a><code>-V</code> 参数输出 ssh 客户端的版本</h3><pre><code class="BASH">$ ssh –Vssh: SSH Secure Shell 3.2.3 (non-commercial version) on i686-pc-linux-gnu</code></pre><p>上面命令输出本机 ssh 客户端版本是 <code>SSH Secure Shell 3.2.3</code></p><h3 id="X-参数表示打开-X-窗口转发"><a href="#X-参数表示打开-X-窗口转发" class="headerlink" title="-X 参数表示打开 X 窗口转发"></a><code>-X</code> 参数表示打开 X 窗口转发</h3><pre><code class="BASH">ssh -X server.example.com</code></pre><h3 id="1-2参数指定使用-SSH1-SSH2-协议。"><a href="#1-2参数指定使用-SSH1-SSH2-协议。" class="headerlink" title="-1, -2参数指定使用 SSH1, SSH2 协议。"></a>-1, -2参数指定使用 SSH1, SSH2 协议。</h3><pre><code class="BASH">ssh -2 server.example.com</code></pre><h3 id="4-指定使用-IPv4-协议，这是默认值"><a href="#4-指定使用-IPv4-协议，这是默认值" class="headerlink" title="-4 指定使用 IPv4 协议，这是默认值"></a><code>-4</code> 指定使用 IPv4 协议，这是默认值</h3><pre><code class="BASH">ssh -4 server.example.com</code></pre><h3 id="6-指定使用-IPv6-协议"><a href="#6-指定使用-IPv6-协议" class="headerlink" title="-6 指定使用 IPv6 协议"></a><code>-6</code> 指定使用 IPv6 协议</h3><pre><code class="BASH">ssh -6 server.example.com</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务缓存原理与最佳实践</title>
      <link href="/My-Blogs/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E7%BC%93%E5%AD%98/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/My-Blogs/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E7%BC%93%E5%AD%98/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>文章主要介绍了分布式架构里的微服务缓存原理与最佳实践，下面让我们来一起看看吧</p><a id="more"></a><h2 id="为什么需要缓存？"><a href="#为什么需要缓存？" class="headerlink" title="为什么需要缓存？"></a>为什么需要缓存？</h2><ol><li><p> 程序存储在 <code>disk</code> 中</p></li><li><p> 程序是运行在 <code>RAM</code> 之中，也就是我们所说的 <code>main memory</code></p></li><li><p> 程序的计算逻辑在 <code>CPU</code> 中执行</p></li></ol><p>来看一个最简单的例子： <code>a = a + 1</code></p><ol><li><p> <code>load x:</code></p></li><li><p> <code>x0 = x0 + 1</code></p></li><li><p> <code>load x0 -&gt; RAM</code></p></li></ol><p><img src="/My-Blogs/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-01.png" alt="img"></p><p>上面提到了3种存储介质。我们都知道，三类的读写速度和成本成反比，所以我们在克服速度问题上需要引入一个 中间层。这个中间层，需要高速存取的速度，但是成本可接受。于是乎, <code>Cache</code> 被引入</p><p><img src="/My-Blogs/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-02.png" alt="img"></p><p>而在计算机系统中，有两种默认缓存：</p><p>CPU 里面的末级缓存，即 <code>LLC</code> 。缓存内存中的数据</p><p>内存中的高速页缓存，即 <code>page cache</code> 。缓存磁盘中的数据</p><h2 id="缓存读写策略"><a href="#缓存读写策略" class="headerlink" title="缓存读写策略"></a>缓存读写策略</h2><p>引入 <code>Cache</code> 之后，我们继续来看看操作缓存会发生什么。因为存在存取速度的差异「而且差异很大」，从而在操作数据时，延迟或程序失败等都会导致缓存和实际存储层数据不一致。</p><p>我们就以标准的 <code>Cache+DB</code> 来看看经典读写策略和应用场景。</p><h3 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache Aside"></a>Cache Aside</h3><p>先来考虑一种最简单的业务场景，比如用户表: <code>userId</code> : 用户id, <code>phone</code> : 用户电话token, <code>avtoar</code> : 用户头像url，缓存中我们用 <code>phone</code> 作为key存储用户头像。当用户修改头像url该如何做？</p><p>更新DB数据，再更新 <code>Cache</code> 数据</p><p>更新 DB 数据，再删除 <code>Cache</code> 数据</p><p>首先 变更数据库 和 变更缓存 是两个独立的操作，而我们并没有对操作做任何的并发控制。那么当两个线程并发更新它们的时候，就会因为写入顺序的不同造成数据不一致。</p><p>所以更好的方案是 <code>2</code> :</p><p>更新数据时不更新缓存，而是直接删除缓存</p><p>后续的请求发现缓存缺失，回去查询 <code>DB</code> ，并将结果 <code>load cache</code></p><p><img src="/My-Blogs/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-03.png" alt="img"></p><p>这个策略就是我们使用缓存最常见的策略: <code>Cache Aside</code> 。这个策略数据以数据库中的数据为准，缓存中的数据是按需加载的，分为读策略和写策略。</p><p>但是可见的问题也就出现了：频繁的读写操作会导致 <code>Cache</code> 反复地替换，缓存命中率降低。当然如果在业务中对命中率有监控报警时，可以考虑以下方案：</p><ol><li><p> 更新数据时同时更新缓存，但是在更新缓存前加一个 分布式锁。这样同一时间只有一个线程操作缓存，解决了并发问题。同时在后续读请求中时读到最新的缓存，解决了不一致的问题。</p></li><li><p> 更新数据时同时更新缓存，但是给缓存一个较短的 <code>TTL</code>。</p></li></ol><p>当然除了这个策略，在计算机体系还有其他几种经典的缓存策略，它们也有各自适用的使用场景。</p><h3 id="Write-Through"><a href="#Write-Through" class="headerlink" title="Write Through"></a>Write Through</h3><p>先查询写入数据key是否击中缓存，如果在 -&gt; 更新缓存，同时缓存组件同步数据至DB；不存在，则触发 ·。</p><p>而一般 · 有两种方式：</p><p><code>Write Allocate</code> ：写时直接分配 <code>Cache line</code></p><p><code>No-write allocate</code> ：写时不写入缓存，直接写入DB，return</p><p>在 <code>Write Through</code> 中，一般采取 <code>No-write allocate</code> 。因为其实无论哪种，最终数据都会持久化到DB中，省去一步缓存的写入，提升写性能。而缓存由 <code>Read Through</code> 写入缓存。</p><p><img src="/My-Blogs/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-04.png" alt="img"></p><p>这个策略的核心原则：<strong>用户只与缓存打交道，由缓存组件和DB通信，写入或者读取数据</strong>。在一些本地进程缓存组件可以考虑这种策略。</p><h3 id="Write-Back"><a href="#Write-Back" class="headerlink" title="Write Back"></a>Write Back</h3><p>相信你也看出上述方案的缺陷：写数据时缓存和数据库同步，但是我们知道这两块存储介质的速度差几个数量级，对写入性能是有很大影响。那我们是否异步更新数据库？</p><p><code>Write back</code> 就是在写数据时只更新该 Cache Line 对应的数据，并把该行标记为 Dirty。在读数据时或是在缓存满时换出「缓存替换策略」时，将 Dirty 写入存储。</p><p>需要注意的是：在 <code>Write Miss</code> 情况下，采取的是 <code>Write Allocate</code> ，即写入存储同时写入缓存，这样我们在之后的写请求只需要更新缓存。</p><p><img src="/My-Blogs/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-05.png" alt="img"></p><blockquote><p><code>async purge</code> 此类概念其实存在计算机体系中。 <code>Mysql</code> 中刷脏页，本质都是尽可能防止随机写，统一写磁盘时机。</p></blockquote><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><code>Redis</code> 是一个独立的系统软件，和我们写的业务程序是两个软件。当我们部署了Redis 实例后，它只会被动地等待客户端发送请求，然后再进行处理。所以，如果应用程序想要使用 Redis 缓存，我们就要在程序中增加相应的缓存操作代码。所以我们也把 <code>Redis</code> 称为 <strong>旁路缓存</strong>，也就是说：读取缓存、读取数据库和更新缓存的操作都需要在应用程序中来完成。</p><p>而作为缓存的 <code>Redis</code> ，同样需要面临常见的问题：</p><ul><li><p>缓存的容量终究有限</p></li><li><p>上游并发请求冲击</p></li><li><p>缓存与后端存储数据一致性</p></li></ul><h3 id="替换策略"><a href="#替换策略" class="headerlink" title="替换策略"></a>替换策略</h3><p>一般来说，缓存对于选定的被淘汰数据，会根据其是干净数据还是脏数据，选择直接删除还是写回数据库。但是，在 Redis 中，被淘汰数据无论干净与否都会被删除，所以，这是我们在使用 Redis 缓存时要特别注意的：当数据修改成为脏数据时，需要在数据库中也把数据修改过来。</p><p>所以不管替换策略是什么，脏数据有可能在换入换出中丢失。那我们在产生脏数据就应该删除缓存，而不是更新缓存，一切数据应该以数据库为准。这也很好理解，缓存写入应该交给读请求来完成；写请求尽可能保证数据一致性。</p><p>至于替换策略有哪些，网上已经有很多文章归纳之间的优劣，这里就不再赘述。</p><h2 id="缓存和存储更新顺序"><a href="#缓存和存储更新顺序" class="headerlink" title="缓存和存储更新顺序"></a>缓存和存储更新顺序</h2><p>这是开发中常见纠结问题：<strong>到底是先删除缓存还是先更新存储</strong>？</p><blockquote><p>情况一：先删除缓存，再更新存储；</p><ul><li>A 删除缓存，更新存储时网络延迟</li><li>B 读请求，发现缓存缺失，读存储 -&gt; 此时读到旧数据</li></ul></blockquote><p>这样会产生两个问题：</p><ul><li>B 读取旧值</li><li>B 同时读请求会把旧值写入缓存，导致后续读请求读到旧值</li></ul><p>既然是缓存可能是旧值，那就不管删除。有一个并不优雅的解决方案：<strong>在写请求更新完存储值以后</strong>， <code>sleep()</code> <strong>一小段时间，再进行一次缓存删除操作</strong>。</p><p><code>sleep</code> 是为了确保读请求结束，写请求可以删除读请求造成的缓存脏数据，当然也要考虑到 redis 主从同步的耗时。不过还是要根据实际业务而定。</p><p>这个方案会在第一次删除缓存值后，延迟一段时间再次进行删除，被称为： <code>延迟双删</code> 。</p><blockquote><p>情况二：先更新数据库值，再删除缓存值：</p><ul><li>A 删除存储值，但是删除缓存网络延迟</li><li>B 读请求时，缓存击中，就直接返回旧值</li></ul></blockquote><p>这种情况对业务的影响较小，而绝大多数缓存组件都是采取此种更新顺序，满足最终一致性要求。</p><blockquote><p>情况三：新用户注册，直接写入数据库，同时缓存中肯定没有。如果程序此时读从库，由于主从延迟，导致读取不到用户数据。</p></blockquote><p>这种情况就需要针对 Insert 这种操作：插入新数据入数据库同时写缓存。使得后续读请求可以直接读缓存，同时因为是刚插入的新数据，在一段时间修改的可能性不大。</p><p><strong>以上方案在复杂的情况或多或少都有潜在问题，需要贴合业务做具体的修改。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 分布式架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式架构 </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构三高总结</title>
      <link href="/My-Blogs/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E6%A6%82%E5%BF%B5/%E6%9E%B6%E6%9E%84%E4%B8%89%E9%AB%98%E6%80%BB%E7%BB%93/"/>
      <url>/My-Blogs/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E6%A6%82%E5%BF%B5/%E6%9E%B6%E6%9E%84%E4%B8%89%E9%AB%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>针对高性能、高可用、高扩展3个方面，罗列出需要注意的点。</p><a id="more"></a><h3 id="一、高性能的实践方案"><a href="#一、高性能的实践方案" class="headerlink" title="一、高性能的实践方案"></a>一、高性能的实践方案</h3><p>1、集群部署，通过负载均衡减轻单机压力。</p><p>2、多级缓存，包括静态数据使用CDN、本地缓存、分布式缓存等，以及对缓存场景中的热点key、缓存穿透、缓存并发、数据一致性等问题的处理。</p><p>3、分库分表和索引优化，以及借助搜索引擎解决复杂查询问题。</p><p>4、考虑数据库的使用，比如<code>HBase</code>、<code>TiDB</code>等，但是团队必须熟悉这些组件，且有较强的运维能力。</p><p>5、异步化，将次要流程通过多线程、<code>MQ</code>、甚至延时任务进行异步处理。</p><p>6、限流，需要先考虑业务是否允许限流（比如秒杀场景是允许的），包括前端限流、<code>Nginx</code>接入层的限流、服务端的限流。</p><p>7、对流量进行削峰填谷，通过<code>MQ</code>承接流量。</p><p>8、并发处理，通过多线程将串行逻辑并行化。</p><p>9、预计算，比如抢红包场景，可以提前计算好红包金额缓存起来，发红包时直接使用即可。</p><p>10、缓存预热，通过异步任务提前预热数据到本地缓存或者分布式缓存中。</p><p>11、减少IO次数，比如数据库和缓存的批量读写、<code>RPC</code>的批量接口支持、或者通过冗余数据的方式干掉<code>RPC</code>调用。</p><p>12、减少IO时的数据包大小，包括采用轻量级的通信协议、合适的数据结构、去掉接口中的多余字段、减少缓存key的大小、压缩缓存value等。</p><p>13、程序逻辑优化，比如将大概率阻断执行流程的判断逻辑前置、For循环的计算逻辑优化，或者采用更高效的算法。</p><p>14、各种池化技术的使用和池大小的设置，包括<code>HTTP</code>请求池、线程池（考虑<code>CPU密集型</code>还是<code>IO密集型</code>设置核心参数）、数据库和<code>Redis</code>连接池等。</p><p>15、<code>JVM</code>优化，包括新生代和老年代的大小、GC算法的选择等，尽可能减少GC频率和耗时。</p><p>16、锁选择，读多写少的场景用乐观锁，或者考虑通过分段锁的方式减少锁冲突。</p><p>上述方案无外乎从计算和 IO 两个维度考虑所有可能的优化点，需要有配套的监控系统实时了解当前的性能表现，并支撑你进行性能瓶颈分析，然后再遵循二八原则，抓主要矛盾进行优化。</p><h3 id="二、高可用的实践方案"><a href="#二、高可用的实践方案" class="headerlink" title="二、高可用的实践方案"></a>二、高可用的实践方案</h3><p>1、对等节点的故障转移，Nginx和服务治理框架均支持一个节点失败后访问另一个节点。</p><p>2、非对等节点的故障转移，通过心跳检测并实施主备切换（比如<code>redis</code>的哨兵模式或者集群模式、MySQL的主从切换等）。</p><p>3、接口层面的超时设置、重试策略和幂等设计。</p><p>4、降级处理：保证核心服务，牺牲非核心服务，必要时进行熔断；或者核心链路出问题时，有备选链路。</p><p>5、限流处理：对超过系统处理能力的请求直接拒绝或者返回错误码。</p><p>6、MQ场景的消息可靠性保证，包括<code>producer</code>端的重试机制、<code>broker</code>侧的持久化、<code>consumer</code>端的ack机制等。</p><p>7、灰度发布，能支持按机器维度进行小流量部署，观察系统日志和业务指标，等运行平稳后再推全量。</p><p>8、监控报警：全方位的监控体系，包括最基础的CPU、内存、磁盘、网络的监控，以及Web服务器、JVM、数据库、各类中间件的监控和业务指标的监控。</p><p>9、灾备演练：类似当前的“混沌工程”，对系统进行一些破坏性手段，观察局部故障是否会引起可用性问题。</p><p>高可用的方案主要从冗余、取舍、系统运维3个方向考虑，同时需要有配套的值班机制和故障处理流程，当出现线上问题时，可及时跟进处理。</p><h3 id="三、高扩展的实践方案"><a href="#三、高扩展的实践方案" class="headerlink" title="三、高扩展的实践方案"></a>三、高扩展的实践方案</h3><p>1、合理的分层架构：比如上面谈到的互联网最常见的分层架构，另外还能进一步按照数据访问层、业务逻辑层对微服务做更细粒度的分层（但是需要评估性能，会存在网络多一跳的情况）。</p><p>2、存储层的拆分：按照业务维度做垂直拆分、按照数据特征维度进一步做水平拆分（分库分表）。</p><p>3、业务层的拆分：最常见的是按照业务维度拆（比如电商场景的商品服务、订单服务等），也可以按照核心接口和非核心接口拆，还可以按照请求源拆（比如To C和To B，APP和H5）。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>幂等性与分布式锁</title>
      <link href="/My-Blogs/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E6%A6%82%E5%BF%B5/%E5%B9%82%E7%AD%89%E6%80%A7%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/My-Blogs/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E6%A6%82%E5%BF%B5/%E5%B9%82%E7%AD%89%E6%80%A7%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是幂等性"><a href="#1-什么是幂等性" class="headerlink" title="1. 什么是幂等性"></a>1. 什么是幂等性</h3><p><code>幂等性</code> 就是指：一个幂等操作任其执行多次所产生的影响均与一次执行的影响相同。用数学的概念表达是这样的: <code>f(f(x)) = f(x)</code> . 就像 <code>nx1 = n</code> 一样， x1 就是一个幂等操作。无论是乘以多少次结果都一样。</p><a id="more"></a><h3 id="2-常见的幂等性问题"><a href="#2-常见的幂等性问题" class="headerlink" title="2. 常见的幂等性问题"></a>2. 常见的幂等性问题</h3><blockquote><p>幂等性问题经常会是由网络问题引起的，还有重复操作引起的。</p></blockquote><p><strong>场景一：比如点赞功能，一个用户只能对同一片文章点赞一次，重复点赞提示已经点过赞了。</strong></p><p>示例代码：</p><pre><code class="JAVA">public void like(Article article,User user) {    //检查是否点过赞    if (checkIsLike(article,user)) {        //点过赞了        throw new ApiException(CodeEnums.SYSTEM_ERR);    } else {        //保存点赞        saveLike(article,user);    }}</code></pre><p>看上去好像没有什么问题，保存点赞之前已经检查过是否点赞了，理论上同一个人不会对同一篇文章重复点赞。但实际不是这样的。因为网络请求不是排队进来的，而是一窝蜂涌进来的。</p><p>某些时候，用户网络不好，可能很短的时间内点击了多次，由于网络传输问题，这些请求可能会同时来到我们的服务器。</p><ul><li><strong>第一个请求 checkIsLike（） 返回 false ， 正在执行 saveLike() 操作，还没来的及提交事务</strong> </li><li><strong>第二个请求过来了 ，checkIsLike（） 返回 也是 false , 并去 执行了 saveLike() 操作</strong></li></ul><p>这样子，就造成了一个用户同时对一篇文章进行了多次点赞操作。</p><p>这就是典型的幂等性问题， 操作了一次和操作了两次结果不一样，因为你多点了一次赞，按照幂等性原则 不管你点击了多少次结果都一样，只点了一次赞。</p><p>很多场景都是这样造成的，比如用户重复下单，重复评论，重复提交表单等。</p><p>那怎么解决呢？假设网络的请求是排队进来的就不会出现这个问题了。</p><p>于是我们可以改成这样：</p><pre><code class="JAVA">public synchronized void like(Article article,User user) {    //检查是否点过赞    if (checkIsLike(article,user)) {        //点过赞了        throw new ApiException(CodeEnums.SYSTEM_ERR);    } else {        //保存点赞        saveLike(article,user);    }}</code></pre><p><code>synchronized</code> 同步锁 这样我们的请求就会乖乖的排队进来了。</p><p>PS: 这样做是效率比较低的做法，不建议这么做，只是举例子，<code>synchronized</code> 也不适合分布式集群场景。</p><p><strong>场景二 ： 第三方回调</strong></p><p>我们系统经常需要和第三方系统打交道，比如微信充值，支付宝充值什么的，微信和支付宝常常会以回调你的接口通知你支付结果。为了保证你能收到回调，往往可能会回调多次。</p><p>有时候我们也为了保证数据的准确性会有个定时器去查询支付结果未知的流水，并执行响应的处理。<br>如果定时器的轮询和回调刚好是在同时进行，这可能又出BUG了, 又进行了两次重复操作。</p><p>那么问题来了：假设我是一个充值操作， 回调回来的时候 ，会做业务处理，成功了给用户账户加钱。这是后就要保证幂等性了， 假设微信同一笔交易给你回调了两次，如果你给用户充值了两次，这显然不合理(我是老板肯定扣你工资)，所以要保证 不管微信回调你多少次 ，同一笔交易你只能给用户充一次钱。这就幂等性</p><h3 id="解决幂等性问题方案"><a href="#解决幂等性问题方案" class="headerlink" title="解决幂等性问题方案"></a>解决幂等性问题方案</h3><ul><li>synchronized 适合单机应用，不追求性能 ，不追求并发。</li><li>分布式锁 但是往往我们的应用是分布式的集群，并且很讲究性能，并发，所以我们需要用到 分布式锁 来解决这个问题。</li></ul><p>Redis 分布式锁：</p><pre><code class="JAVA">/*** setNx**  @param key*  @param value*  @return*/public Boolean setNx(String key,Object value) {    return redisTemplate.opsForValue().setIfAbsent(key,value);}/***  @param key 锁*  @param waitTime 等待时间  毫秒*  @param expireTime 超时时间  毫秒*  @return*/public Boolean lock(String key,long waitTime,long expireTime) {    String vlaue =  UUIDUtil.mongoObjectId();    Boolean flag = setNx(key,vlaue);    //尝试获取锁  成功返回    if (flag) {        redisTemplate.expire(key,expireTime,TimeUnit.MILLISECONDS);        return flag;    } else {        //失败        //现在时间        long newTime =  System.currentTimeMillis();        //等待过期时间        long loseTime = newTime + waitTime;        //不断尝试获取锁成功返回        while (System.currentTimeMillis()  &lt; loseTime) {            Boolean testFlag = setNx(key,vlaue);            if (testFlag) {                redisTemplate.expire(key,expireTime,TimeUnit.MILLISECONDS);                return testFlag;            }            //休眠100毫秒            try {                Thread.sleep(100);            }            catch (InterruptedException e) {                e.printStackTrace();            }        }    }    return false;}/***  @param key*  @return*/public Boolean lock(String key) {    return lock(key,1000L,60  *  1000L);}/***  @param key*/public void unLock(String key) {    remove(key);}</code></pre><p>利用Redis 分布式锁 我们的代码可以改成这样：</p><pre><code class="JAVA">public void like(Article article,User user) {    String key =  "key:like"  + article.getId()  +  ":"  + user.getUserId();    //  等待锁的时间  0  ，  过期时间  一分钟防止死锁    Boolean flag = redisService.lock(key,0,60  *  1000L);    if(!flag) {        //获取锁失败  说明前面的请求已经获取了锁        throw new ApiException(CodeEnums.SYSTEM_ERR);    }    //检查是否点过赞    if (checkIsLike(article,user)) {        //点过赞了        throw new ApiException(CodeEnums.SYSTEM_ERR);    } else {        //保存点赞        saveLike(article,user);    }    //删除锁    redisService.unLock(key);}</code></pre><p>key 的设计也很讲究：</p><p>数据不冲突的两个业务场景，key不能冲突，不同人的key也不一样，不同的文章Key也不一样。</p><p>根据场景业务设定。</p><p><strong>一个原则： 尽可能的缩小key的范围。</strong> 这样才能增强我们的并发。</p><p>首先我们先获取锁，获取锁成功 执行完操作，保存数据 ，删除锁。获取不到锁返回失败。设置过期时间是为了防止‘死锁’，比如机器获取到了 锁，没有设置过期时间，但是他死机了，没有删除释放锁。</p><ul><li>版本号控制CAS 算法： CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。这个比较繁杂，有兴趣的大家可以去看看。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何学习分布式系统(转载)</title>
      <link href="/My-Blogs/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E6%96%87%E7%AB%A0/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F(%E8%BD%AC%E8%BD%BD)/"/>
      <url>/My-Blogs/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E6%96%87%E7%AB%A0/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F(%E8%BD%AC%E8%BD%BD)/</url>
      
        <content type="html"><![CDATA[<p>学习一个知识之前，我觉得比较好的方式是先理解它的来龙去脉：即这个知识产生的过程，它解决了什么问题，它是怎么样解决的并且它带来了哪些问题，这样我们才能比较好的抓到它的脉络和关键点，不会一开始就迷失在细节中。</p><p>所以，我们要解决的第一个问题是：<strong>分布式系统解决了什么问题？</strong></p><a id="more"></a><p><strong>第一个</strong>是单机性能瓶颈导致的成本问题，由于摩尔定律失效，廉价 PC 机性能的瓶颈无法继续突破，小型机和大型机能提高更高的单机性能，但是成本太大高，一般的公司很难承受；</p><p><strong>第二个</strong>是用户量和数据量爆炸性的增大导致的成本问题，进入互联网时代，用户量爆炸性的增大，用户产生的数据量也在爆炸性的增大，但是单个用户或者单条数据的价值其实比软件时代（比如银行用户）的价值是只低不高，所以必须寻找更经济的方案；</p><p><strong>第三个</strong>是业务高可用的要求，对于互联网的产品来说，都要求 7 * 24 小时提供服务，无法容忍停止服务等故障，而要提供高可用的服务，唯一的方式就是增加冗余来完成，这样就算单机系统可以支撑的服务，因为高可用的要求，也会变成一个分布式系统。</p><p>基于上面的三个原因可以看出，在互联网时代，单机系统是无法解决成本和高可用问题的，但是这两个问题对几乎对所有的公司来说都是非常关键的问题，所以，从单机系统到分布式系统是无法避免的技术大潮流。</p><p>那么，分布式系统是怎么来解决单机系统面临的成本和高可用问题呢？其实想法很简单，就是将一些廉价的 PC 机通过网络连接起来，共同完成工作，并且在系统中提供冗余来解决高可用的问题。我们来看分布式系统的定义：<strong>分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统</strong>。在定义中，我们可用看出，分布式系统它通过多工作节点来解决单机系统面临的成本和可用性问题，但是它引入了对分布式系统内部工作节点的协调问题。</p><p>掌握一个知识需要理解它的前因后果，对于分布式系统来说，前因是「分布式系统解决了什么问题」，后果是「它是怎么做内部工作节点的协调」，所以我们要解决的第二个问题是：分布式系统是怎么做内部工作节点协调的？</p><p>先从简单的情况入手，对于分布式计算（无状态）的情况，系统内部的协调需要做哪些工作：</p><h3 id="1、怎么样找到服务？"><a href="#1、怎么样找到服务？" class="headerlink" title="1、怎么样找到服务？"></a>1、怎么样找到服务？</h3><p>在分布式系统内部，会有不同的服务（角色），服务 A 怎么找到服务 B 是需要解决的问题，一般来说服务注册与发现机制是常用的思路，所以可以了解一下服务注册发现机制实现原理，并且可以思考服务注册发现是选择做成 AP 还是 CP 系统更合理；</p><h3 id="2、怎么样找到实例？"><a href="#2、怎么样找到实例？" class="headerlink" title="2、怎么样找到实例？"></a>2、怎么样找到实例？</h3><p>找到服务后，当前的请求应该选择发往服务的哪一个实例呢？一般来说，如果同一个服务的实例都是完全对等的（无状态），那么按负载均衡策略来处理就足够（轮询、权重、hash、一致性hash，fair等各种策略的适用场景）；如果同一个服务的实例不是对等的（有状态），那么需要通过路由服务（元数据服务等）先确定当前要访问的请求数据做哪一个实例上，然后再进行访问。</p><h3 id="3、怎么样避免雪崩？"><a href="#3、怎么样避免雪崩？" class="headerlink" title="3、怎么样避免雪崩？"></a>3、怎么样避免雪崩？</h3><p>系统雪崩是指故障的由于正反馈循序导致不断扩大规则的故障。一次雪崩通常是由于整个系统中一个很小的部分出现故障于引发，进而导致系统其它部分也出现故障。比如系统中某一个服务的一个实例出现故障，导致负载均衡将该实例摘除而引起其它实例负载升高，最终导致该服务的所有实例像多米诺骨牌一样一个一个全部出现故障。</p><p>避免雪崩总体的策略比较简单，只要是两个思路，一个是快速失败和降级机制（熔断、降级、限流等），通过快速减少系统负载来避免雪崩的发生；另一个为弹性扩容机制，通过快速增加系统的服务能力来避免雪崩的发生。这个根据不同的场景可以做不同的选择，或者两个策略都使用。</p><p>一般来说，快速失败会导致部分的请求失败，如果分布式系统内部对一致性要求很高的话，快速失败会带来系统数据不一致的问题，弹性扩容会是一个比较好的选择，但是弹性扩容的实现成本和响应时间比快速失败要大得多。</p><h3 id="4、怎么样监控告警？"><a href="#4、怎么样监控告警？" class="headerlink" title="4、怎么样监控告警？"></a>4、怎么样监控告警？</h3><p>对于一个分布式系统，如果我们不能很清楚地了解内部的状态，那么高可用是没有办法完全保障的，所以对分布式系统的监控（比如接口的时延和可用性等信息），分布式追踪 Trace，模拟故障的混沌工程，以及相关的告警等机制是一定要完善的；</p><p>接下来我们再来看分布式存储（有状态）的内部的协调是怎么做的，同时，前面介绍的分布式计算的协调方式在分布式存储中同样适用，就不再重复了：</p><h3 id="5、CAP-及其相关理论与衡权："><a href="#5、CAP-及其相关理论与衡权：" class="headerlink" title="5、CAP 及其相关理论与衡权："></a>5、CAP 及其相关理论与衡权：</h3><p>ACID、BASE 和 CAP 理论，了解这三个主题，推荐这一篇文章以及文章后面相关的参考文献：<a href="https://link.zhihu.com/?target=https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed/">英文版本</a>，<a href="https://link.zhihu.com/?target=https://www.infoq.cn/article/cap-twelve-years-later-how-the-rules-have-changed/">中文版本</a></p><h3 id="6、怎么样做数据分片："><a href="#6、怎么样做数据分片：" class="headerlink" title="6、怎么样做数据分片："></a>6、怎么样做数据分片：</h3><p>单机的存储能力是不可能存储所有的数据的，所以需要解决怎么将数据按一定的规则分别存储到不同的机器上，目前使用比较多的方案为: <code>Hash</code> 和 <code>Region</code> 分片策略，可以了解一下它们的优缺点和各自的应用场景；</p><h3 id="7、怎么样做数据复制："><a href="#7、怎么样做数据复制：" class="headerlink" title="7、怎么样做数据复制："></a>7、怎么样做数据复制：</h3><p>为了满足系统的高可用要求，需要对数据做冗余处理，目前的方案主要为：中心化方案（主从复制、一致性协议比如 <code>Raft</code> 和 <code>Paxos</code> 等）和 去中心化的方案（<code>Quorum</code> 和 <code>Vector Clock</code>）了解一下它们的优缺点和各自的应用场景，以及对系统外部表现出来的数据一致性级别（线性一致性、顺序一致性、最终一致性等）；</p><h3 id="8、怎么样做分布式事务："><a href="#8、怎么样做分布式事务：" class="headerlink" title="8、怎么样做分布式事务："></a>8、怎么样做分布式事务：</h3><p>对于分布式系统来说，要实现事务，首先需要一个对并发事务进行排序的能力，这样在事务冲突的时候，确认哪个事务提供成功，哪个事务提交失败。</p><p>对于单机系统来说这个完全不说问题，简单的通过时间戳加序号的方式就可以实现，但是对于分布式系统来说，系统中机器的时间不能完全同步，并且单台机器序号也没用全局意义，按上面的方式说不行的。</p><p>不过整个系统选一台机器按单机的模式生产事务ID是可以的，同城多中心和短距离的异地多中心都没有问题，不过想做成全球分布式系统的话，那么每一次事务都要去一个节点去获取事务ID的成本太高（比如中国杭州到美国东部的RTT为200+ms），Google 的 Spanner 是通过 GPS 和 原子钟实现 <code>TrueTime</code> API 来解决这个问题从而实现全球分布式数据库的。</p><p>有了事务ID后，通过 <code>2PC</code> 或者 <code>3PC</code> 协议来实现分布式事务的原子性，其他部分和单机事务差别不大，就不再细说来。</p><p>到这里，对分布式系统脉络上有了基本的概念，接下来开始进入细节学习阶段，这也是非常幸苦的阶段，对于分布式系统的理解深入与否，对细节的深入度是很重要的评价指标，毕竟魔鬼在细节。这里可以往两个方面进行系统的学习：</p><ol><li><p> 从实践出发，研究目前比较常用的分布式系统的设计，HDFS 或者 GFS（分布式文件系统）、Kafka 和 Pulsar（分布式消息队列），Redis Cluster 和 Codis（分布式缓存），MySQL 的分库分表（传统关系型数据库的分布式方案），MongoDB 的 Replica Set 和 Sharing机制集（NoSQL数据库），TiDB（NewSQL），以及一些微服务框架 等；</p></li><li><p> 从理论出发，研究分布式相关的论文，这里推荐一本书「 Designing Data-Intensive Applications」（中文版本：数据密集型应用系统设计），先整体看书，对比较感兴趣的章节，再读一读该章节中涉及到的相关参考文献。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式架构 </tag>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何构建一个完善的活动平台</title>
      <link href="/My-Blogs/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E6%96%87%E7%AB%A0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/"/>
      <url>/My-Blogs/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E6%96%87%E7%AB%A0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><blockquote><p>即是将页面的某一部分独立出来，将这一部分的用黑盒的形式全部封装到一个组件内，暴露出一些属性供外部组件传入值</p></blockquote><a id="more"></a><h3 id="白话解释"><a href="#白话解释" class="headerlink" title="白话解释"></a>白话解释</h3><blockquote><p>执行一段‘组件脚本’后，可以写“非法”HTML标签（指代组件实例），并在标签内绑定数据，该标签（组件）会根据自身逻辑，渲染出相关视图。</p></blockquote><h3 id="如下图"><a href="#如下图" class="headerlink" title="如下图"></a>如下图</h3><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-01.png"></p><br><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h3 id="一段不堪回首的经历😭"><a href="#一段不堪回首的经历😭" class="headerlink" title="一段不堪回首的经历😭"></a>一段不堪回首的经历😭</h3><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-02.png" alt="不堪回首"></p><br><h3 id="需求上线流程图"><a href="#需求上线流程图" class="headerlink" title="需求上线流程图"></a>需求上线流程图</h3><p><strong>特征：</strong></p><ol><li> 参与人员多。</li><li> 上线周期长。</li></ol><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-03.png" alt="img"></p><br><h3 id="可视化平台设想"><a href="#可视化平台设想" class="headerlink" title="可视化平台设想"></a>可视化平台设想</h3><p><strong>特征：</strong></p><ol><li> 设计、开发协作，提供通用、规范UI组件。</li><li> 用户创建活动，选择需要的组件，编辑组件数据。</li><li> 保存，预览，发布，访问。</li></ol><br><p><strong>如下图👇</strong><br><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-04.png" alt="img"></p><br><h3 id="上线流程图设想"><a href="#上线流程图设想" class="headerlink" title="上线流程图设想"></a>上线流程图设想</h3><p><strong>特征：</strong></p><ol><li> 人员少：仅运营1人。</li><li> 上线快：小时级周期。</li></ol><br><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-05.png" alt="img"></p><br><h3 id="平台启动前思考🤔"><a href="#平台启动前思考🤔" class="headerlink" title="平台启动前思考🤔"></a>平台启动前思考🤔</h3><p><code>组件开发</code>：<br>平台的组件数量应该无限制，组件之间独立，组件与平台解耦，做到动态加载、编辑组件。</p><p><code>配置平台</code>：<br>对外的核心交互，配置平台负责可视化创建页面，选择组件，编辑数据。</p><p><code>页面渲染</code>：<br>平台的最终产物，保存活动配置后，渲染页应该仅加载本活动涉及的组件。</p><p><code>总结</code>：<br>组件开发模块：负责产出页面的基本单元——组件。<br>配置平台模块：负责可视化创建，编辑活动页。<br>页面渲染模块：负责呈现活动视图。</p><br><h1 id="平台实现"><a href="#平台实现" class="headerlink" title="平台实现"></a>平台实现</h1><h3 id="组件开发架构图"><a href="#组件开发架构图" class="headerlink" title="组件开发架构图"></a>组件开发架构图</h3><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-06.png" alt="img"></p><br><h3 id="组件开发环境"><a href="#组件开发环境" class="headerlink" title="组件开发环境"></a>组件开发环境</h3><p><strong>组件开发：</strong></p><ol><li> 提供集中式开发、管理组件的项目环境。</li><li> 支持命令式创建、调试、编译、校验、发布组件。</li></ol><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-07.png" alt="img"></p><br><h3 id="再来说下组件形态"><a href="#再来说下组件形态" class="headerlink" title="再来说下组件形态"></a>再来说下组件形态</h3><ol><li> 一段可执行JS脚本——组件本身。</li><li> 一份XLSX文件——多地区语言配置。</li><li> 一份JSON文件——可编辑属性申明。</li></ol><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-08.png" alt="img"></p><br><h3 id="组件发布"><a href="#组件发布" class="headerlink" title="组件发布"></a>组件发布</h3><blockquote><p>命令式发布，相关字段被完善，注册入库。</p></blockquote><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-09.png" alt="img"></p><br><h1 id="平台实现-1"><a href="#平台实现-1" class="headerlink" title="平台实现"></a>平台实现</h1><h3 id="页面配置一览"><a href="#页面配置一览" class="headerlink" title="页面配置一览"></a>页面配置一览</h3><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-10.png" alt="img"></p><br><h3 id="页面配置-编辑"><a href="#页面配置-编辑" class="headerlink" title="页面配置-编辑"></a>页面配置-编辑</h3><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-11.png" alt="img"></p><br><h3 id="页面配置-发布"><a href="#页面配置-发布" class="headerlink" title="页面配置-发布"></a>页面配置-发布</h3><p><strong>发布流程</strong></p><ol><li> 将组件、配置打包。</li><li> 打包文件推至CDN。</li></ol><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-12.png" alt="img"></p><br><h3 id="页面渲染-解析"><a href="#页面渲染-解析" class="headerlink" title="页面渲染-解析"></a>页面渲染-解析</h3><ol><li> 加载CDN配置文件。</li><li> 遍历Render组件并传入该组件配置</li></ol><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-13.png" alt="img"></p><br><h3 id="页面渲染-监控"><a href="#页面渲染-监控" class="headerlink" title="页面渲染-监控"></a>页面渲染-监控</h3><ol><li> 异常监控+告警。</li><li> 页面性能监控+告警。</li><li> 用户行为监控。</li></ol><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-14.png" alt="img"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>组件开发</code>：关键数据有JS, JSON, XLSX。</li><li><code>页面配置</code>：选择组件，编辑组件，保存配置。</li><li><code>页面渲染</code>：逐个渲染组件并传入配置，页面监控。</li></ul><br><h1 id="实现细节总结"><a href="#实现细节总结" class="headerlink" title="实现细节总结"></a>实现细节总结</h1><ul><li><code>组件编辑面板</code>: 根据组件JSON配置，展开编辑面板。</li><li><code>组件通信</code>: 将发射、接收的事件、方法名申明，添加事件监听并调用暴露方法。</li><li><code>组件嵌套</code>: 配置中父子关系链。</li><li><code>多语言</code>: 汇总各组件多语言文件，集中处理成包，再以Hash ID分发。</li><li><code>主题色</code>: 规范视觉UI的色值占位，一套主题即一套词典。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式架构 </tag>
            
            <tag> 活动平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>easywebpack项目添加svg处理</title>
      <link href="/My-Blogs/2021/01/08/webpack/easywebpack/easywebpack%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0svg%E5%A4%84%E7%90%86/"/>
      <url>/My-Blogs/2021/01/08/webpack/easywebpack/easywebpack%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0svg%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>比如查看webpack最终的loader： <code>easywebpack print test -n module.rules</code></p><a id="more"></a><p>easywebpack配置svg-sprite-loader的配置：</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><blockquote><p>去除默认svg处理，并添加svg-sprite-loader配置</p></blockquote><pre><code class="JS">loaders: {  urlimage: {    test: /\.(png|jpe?g|gif)(\?.*)?$/, // 默认的url-loader在将svg也处理了，需要去掉  },  svg: {    test: /\.svg$/,    loader: 'svg-sprite-loader',    options: {      symbolId: 'icon-[name]',    },    include: resolve('app/web/asset/svg'),  },}</code></pre><p>网上关于<a href="https://juejin.cn/post/6854573215646875655">svg-sprite-loader</a>的介绍</p>]]></content>
      
      
      <categories>
          
          <category> easywebpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> svg </tag>
            
            <tag> webpack </tag>
            
            <tag> 基础构建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Vue3新特性</title>
      <link href="/My-Blogs/2021/01/08/vue/vue3/%E6%B5%85%E8%B0%88Vue3%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/My-Blogs/2021/01/08/vue/vue3/%E6%B5%85%E8%B0%88Vue3%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>Vue3的<a href="https://github.com/vuejs/vue-next">release版本</a>终于发布了，新的Vue3在语法以及底层都进行了全新的重构，带来了更快的运行速度，更小的构建包，更友好的编程规范。</p><a id="more"></a><h2 id="更快"><a href="#更快" class="headerlink" title="更快"></a>更快</h2><p>传统的虚拟dom算法：</p><p>组件patch的时候，需要重新创建整个vdom树，然后遍历整棵树进行diff，update…</p><p>更快的虚拟dom算法，源自编译模板时给予更多的运行时提示：</p><ol><li> 编译模板时对动态内容进行patch标记，告诉patch算法只关注被标记的动态部分</li></ol><p><img src="/My-Blogs/images/%E6%B5%85%E8%B0%88Vue3%E6%96%B0%E7%89%B9%E6%80%A7-01.png"></p><ol><li> 对静态内容进行静态提升（变量提升），只在页面初始化时创建并渲染一次，其余时候不再渲染</li></ol><p><img src="/My-Blogs/images/%E6%B5%85%E8%B0%88Vue3%E6%96%B0%E7%89%B9%E6%80%A7-02.png"></p><ol><li> 对事件监听函数进行缓存，防止内联监听函数带来的副作用</li></ol><p>开启缓存前：</p><p><img src="/My-Blogs/images/%E6%B5%85%E8%B0%88Vue3%E6%96%B0%E7%89%B9%E6%80%A7-03.png"></p><p>开启缓存后：</p><p><img src="/My-Blogs/images/%E6%B5%85%E8%B0%88Vue3%E6%96%B0%E7%89%B9%E6%80%A7-04.png"></p><p>……</p><p>从在线模板编译器中编辑并查看新变化 =&gt;<a href="https://vue-next-template-explorer.netlify.app/">模板编译器</a></p><h2 id="更小"><a href="#更小" class="headerlink" title="更小"></a>更小</h2><h3 id="全局API的使用"><a href="#全局API的使用" class="headerlink" title="全局API的使用"></a>全局API的使用</h3><p>全局 API 现在只能作为 ES 模块构建的命名导出进行访问。</p><h4 id="Vue2的使用方式"><a href="#Vue2的使用方式" class="headerlink" title="Vue2的使用方式"></a>Vue2的使用方式</h4><p>Vue.nextTick（this.$nextTick）、Vue.set、Vue.delete …</p><h4 id="Vue3的使用方式"><a href="#Vue3的使用方式" class="headerlink" title="Vue3的使用方式"></a>Vue3的使用方式</h4><p>import { nextTick, set, delete, … } from ‘vue’; </p><p>nextTick(() =&gt; {// dosomething});<br>……</p><h3 id="内部组件与helper的使用"><a href="#内部组件与helper的使用" class="headerlink" title="内部组件与helper的使用"></a>内部组件与helper的使用</h3><p>当在模板中使用到transtion组件、keepAlive组件、 …</p><p>经complier编译后，生成</p><p>import { transtion, keepAlive, … } from ‘vue’</p><p>当在模板中使用到v-show、v-model…</p><p>complier编译后，生成</p><p>import { vShow, vModel … } from ‘vue’</p><p>意味着只有在应用程序实际使用了某个API或者组件的时候才会导入它。没有使用到的功能代码将不会出现在最终的构建包中。框架体积进一步缩小。</p><h2 id="更友好？"><a href="#更友好？" class="headerlink" title="更友好？"></a>更友好？</h2><h4 id="VUE2组件现存的缺陷"><a href="#VUE2组件现存的缺陷" class="headerlink" title="VUE2组件现存的缺陷"></a>VUE2组件现存的缺陷</h4><ol><li><p> 组件越来越大，可读性和可维护性越来越差。根本原因在于Vue使用的option API：必须按配置(options)来组织代码，你需要把一个功能的实现分布在各个配置里：data，computed，watcher，methods，但是在某些情况下按功能来组织代码更合理。如果要在一个很大的组件中修改一个功能，就要跳到各个属性找，如果组件里面还用了mixins，还得跳文件看</p></li><li><p>mixins无法特别好的在多个组件中复用同一段代码  </p><p> mixins有什么问题？<br> 可读性太差，得跳到mixins所在的文件中才能知道它到底有什么<br> 不同的mixins容易冲突<br> 复用其他同伴的mixins的时候，有些代码不合自己的预期，但是不能随意更改</p></li><li><p> 对typeScript的支持有限</p></li></ol><h4 id="使用componsition-API"><a href="#使用componsition-API" class="headerlink" title="使用componsition API"></a>使用componsition API</h4><p>什么时候使用componsition API？</p><p><img src="/My-Blogs/images/%E6%B5%85%E8%B0%88Vue3%E6%96%B0%E7%89%B9%E6%80%A7-05.png"></p><ol><li> 如果你有一个很大的组件，想要按功能来聚合代码。</li><li> 如果你想要复用组件的一部分代码。</li><li> 如果你想要更好地支持typeScript</li></ol><pre><code class="JS">import useFeature1 from '../use/useFeature1';import useFeature2 from '../use/useFeature2';export default {  setup() {    const {      data1,      data2,      method1,      computed1,      ...    } = useFeature1();    const {      data3,      data4,      method2,      computed2,      ...    } = useFeature2();    // do something    return {      data1,      data2,      method1,      ...    };  }}</code></pre><p>上面这段代码是compsition API的一种示例，它做到了：按功能组织代码，想要修改某个业务逻辑时，不需要满大街找散布各地的数据和方法了，响应式属性与组件解耦，自由控制需要成为响应式的以及需要暴露给模板的属性。</p><p>setup内的代码只依赖于传入的参数和全局引入的Vue API，而不是特殊修改过的 <code>this</code> 。所以只需要导出你想要复用的功能函数。甚至可以导出整个 <code>setup</code> 函数去实现“类似”继承的效果。</p><h4 id="两种创建响应式属性的API"><a href="#两种创建响应式属性的API" class="headerlink" title="两种创建响应式属性的API"></a>两种创建响应式属性的API</h4><h5 id="ref-为传入的值封装一个响应式对象，通过value属性访问与设置对象的值"><a href="#ref-为传入的值封装一个响应式对象，通过value属性访问与设置对象的值" class="headerlink" title="ref: 为传入的值封装一个响应式对象，通过value属性访问与设置对象的值"></a>ref: 为传入的值封装一个响应式对象，通过value属性访问与设置对象的值</h5><pre><code class="JS">setup() {  const capacity = ref(3);  const attending = ref(['tim', 'Bob', 'Joe']);  watch(capacity, () =&gt; {    console.log('capacity changed!');  });  watch(attending, () =&gt; {    console.log('attending changed!');  });  onMounted(() =&gt; {    capacity.value += 1; // capacity changed!    attending.value[0] = 'Jack'; // ?    // 通过ref封装的响应式对象无法进行深层监听  });  return {    capacity  };}</code></pre><h5 id="reactive-让传入的对象成为响应式对象"><a href="#reactive-让传入的对象成为响应式对象" class="headerlink" title="reactive: 让传入的对象成为响应式对象"></a>reactive: 让传入的对象成为响应式对象</h5><pre><code class="JS">setup() {  const event = reactive({    capacity: 3,    attending: ['tim', 'Bob', 'Joe'],  });  watch(event, () =&gt; {    console.log('something changed!');  });  onMounted(() =&gt; {    event.attending[0] = 'Jack'; // something changed!  });  return {    event  };}</code></pre><p>Vue3的响应式监听的实现方式与Vue2有很大不同，并挣脱了Vue2中无法监听动态增加对象属性与数组元素直接赋值的束缚。</p><p>点这里查看<a href="https://github.com/LaiTaoGDUT/learnVue3/blob/master/public/reactive.html">简略版本的新响应式监听实现</a></p><h4 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h4><h5 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h5><pre><code class="JS">setup() {  const capacity = ref(3);  const attending = ref(['tim', 'Bob', 'Joe']);  const stop = watchEffect(() =&gt; {    console.log(capacity.value + attending.value.length);  })  onMounted(() =&gt; {    capacity.value += 1; // 7  });  return {    capacity,    attending,    stop  };}stop(); // 停止监听</code></pre><p><a href="https://vue3js.cn/docs/zh/api/">更多API请参考官方文档</a></p><h4 id="compisition-API的下一步"><a href="#compisition-API的下一步" class="headerlink" title="compisition API的下一步"></a>compisition API的下一步</h4><h5 id="现存的缺点"><a href="#现存的缺点" class="headerlink" title="现存的缺点"></a>现存的缺点</h5><ol><li> ref和reactive太像了，初上手时很难决定到底用哪个。</li><li> 没有了options的限制，一不小心就可能会写出比使用option API更加臃肿难读的代码</li><li> 使用Composition API时，需要区分哪些值或者对象是响应式的，哪些不是。</li><li> 阅读或者修改ref会有点麻烦，因为必须通过<code>.value</code>才能实现。</li><li> 一旦组件需要使用的数据多起来，import和return语句就会很冗长。</li></ol><h5 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h5><p><a href="https://github.com/vuejs/rfcs/pull/222">New script setup and ref sugar</a></p><p>前阵子，Vue3.0提出了两个新提案，分别为script-setup提案与ref-suger提案</p><p>对于以下源代码：</p><pre><code class="HTML">&lt;script&gt;  import {    ref  } from 'vue'  export default {    setup() {      const count = ref(1)      const inc = () =&gt; {        count.value++      }      return {        count,        inc      }    }  }&lt;/script&gt;</code></pre><p><strong>使用script-setup 提案，将 options.setup 提取到代码顶层，所有顶层声明默认导出为模板使用</strong></p><pre><code class="HTML">&lt;script setup&gt;  import {    ref  } from 'vue'  const count = ref(0)  const inc = () =&gt; {    count.value++  }&lt;/script&gt;</code></pre><p><strong>使用ref-sugar 提案，将 ref.value 的写法，做进一步简化，放弃<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/label">标记语句</a>的普通语法，将其作为ref声明的语法糖。</strong></p><pre><code class="HTML">&lt;script setup&gt;  ref: count = 1  const inc = () =&gt; {    count++  }  // 通过添加$前缀来访问响应式对象  console.log($count.value)&lt;/script&gt;</code></pre><p>这是Vue3带来的小改进还是大挑战 ？</p><h2 id="其他变化"><a href="#其他变化" class="headerlink" title="其他变化"></a>其他变化</h2><h4 id="不再支持keyCode修饰"><a href="#不再支持keyCode修饰" class="headerlink" title="不再支持keyCode修饰"></a>不再支持keyCode修饰</h4><pre><code class="HTML">&lt;input v-on:keyup.13="handleEnter"&gt;&lt;/input&gt;</code></pre><p>替换为</p><pre><code class="HTML">&lt;input v-on:keyup:enter="handleEnter"&gt;&lt;/input&gt;</code></pre><h4 id="过渡类名变更"><a href="#过渡类名变更" class="headerlink" title="过渡类名变更"></a>过渡类名变更</h4><p>.v-enter =&gt; .v-enter-from</p><p>.v-leave =&gt; .v-leave-from</p><h4 id="v-model变更"><a href="#v-model变更" class="headerlink" title="v-model变更"></a>v-model变更</h4><p>可使用多个v-model, 不再需要.sync修饰符来进行双向绑定了</p><pre><code class="HTML">&lt;ChildComponent v-model:title="pageTitle" /&gt;</code></pre><p>相当于</p><pre><code class="HTML">&lt;ChildComponent :title="pageTitle" @update:title="pageTitle = $event" /&gt;</code></pre><h4 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h4><p>Vue认为$ on，$ off 和 $once 实例方法不应该由它来提供，因此Vue3将它们移除了</p><p>过滤器filters被移除了，需要使用计算属性或方法来代替</p><p>新增Suspence组件 =&gt; 组件loading完成前显示后备内容</p><p>新增teleport组件（portal） =&gt; 允许传送组件内容到根节点以外的任何地方<br>…</p>]]></content>
      
      
      <categories>
          
          <category> vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis缓存的三大问题及其解决方案</title>
      <link href="/My-Blogs/2021/01/08/Redis/%E3%80%90Redis%E3%80%91%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/My-Blogs/2021/01/08/Redis/%E3%80%90Redis%E3%80%91%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>Redis经常用于系统中的缓存，这样可以解决目前IO设备无法满足互联网应用海量的读写请求的问题。</p><a id="more"></a><h2 id="一、缓存穿透"><a href="#一、缓存穿透" class="headerlink" title="一、缓存穿透"></a>一、缓存穿透</h2><p>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起id为-1的数据或者特别大的不存在的数据。有可能是黑客利用漏洞攻击从而去压垮应用的数据库。</p><h3 id="1-常见解决方案"><a href="#1-常见解决方案" class="headerlink" title="1. 常见解决方案"></a>1. 常见解决方案</h3><p>对于缓存穿透问题，常见的解决方案有以下三种：</p><ul><li>验证拦截：接口层进行校验，如鉴定用户权限，对ID之类的字段做基础的校验，如id&lt;=0的字段直接拦截；</li><li>缓存空数据：当数据库查询到的数据为空时，也将这条数据进行缓存，但缓存的有效性设置得要较短，以免影响正常数据的缓存；</li></ul><pre><code class="JAVA">public Student getStudentsByID(Long id) {    // 从Redis中获取学生信息    Student student = redisTemplate.opsForValue()        .get(String.valueOf(id));    if (student != null) {        return student;    }    // 从数据库查询学生信息，并存入Redis    student = studentDao.selectByStudentId(id);    if (student != null) {        redisTemplate.opsForValue()            .set(String.valueOf(id), student, 60, TimeUnit.MINUTES);    } else {        // 即使不存在，也将其存入缓存中        redisTemplate.opsForValue()            .set(String.valueOf(id), null, 60, TimeUnit.SECONDS);    }    return student;}</code></pre><ul><li>使用布隆过滤器：布隆过滤器是一种比较独特数据结构，有一定的误差。当它指定一个数据存在时，它不一定存在，但是当它指定一个数据不存在时，那么它一定是不存在的。</li></ul><h3 id="2-布隆过滤器"><a href="#2-布隆过滤器" class="headerlink" title="2. 布隆过滤器"></a>2. 布隆过滤器</h3><p>布隆过滤器是一种比较特殊的数据结构，有点类似与HashMap，在业务中我们可能会通过使用HashMap来判断一个值是否存在，它可以在<code>O(1)</code>时间复杂度内返回结果，效率极高，但是受限于存储容量，如果可能需要去判断的值超过亿级别，那么HashMap所占的内存就很可观了。<br>而<code>BloomFilter</code>解决这个问题的方案很简单。首先用多个bit位去代替HashMap中的数组，这样的话储存空间就下来了，之后就是对 Key 进行多次哈希，将 Key 哈希后的值所对应的 bit 位置为1。<br>当判断一个元素是否存在时，就去判断这个值哈希出来的比特位是否都为1，如果都为1，那么可能存在，也可能不存在（如下图F）。但是如果有一个bit位不为1，那么这个Key就肯定不存在。</p><p><img src="/My-Blogs/images/%E3%80%90Redis%E3%80%91%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-01.png" alt="img"></p><br><p>注意：<code>BloomFilter</code>并不支持删除操作，只支持添加操作。这一点很容易理解，因为你如果要删除数据，就得将对应的bit位置为0，但是你这个Key对应的bit位可能其他的Key也对应着。</p><h3 id="3-缓存空数据与布隆过滤器的比较"><a href="#3-缓存空数据与布隆过滤器的比较" class="headerlink" title="3. 缓存空数据与布隆过滤器的比较"></a>3. 缓存空数据与布隆过滤器的比较</h3><p>上面对这两种方案都进行了简单的介绍，缓存空数据与布隆过滤器都能有效解决缓存穿透问题，但使用场景有着些许不同；</p><ul><li>当一些恶意攻击查询查询的key各不相同，而且数量巨多，此时缓存空数据不是一个好的解决方案。因为它需要存储所有的Key，内存空间占用高。并且在这种情况下，很多key可能只用一次，所以存储下来没有意义。所以对于这种情况而言，使用布隆过滤器是个不错的选择；</li><li>而对与空数据的Key数量有限、Key重复请求效率较高的场景而言，可以选择缓存空数据的方案。</li></ul><h2 id="二、缓存击穿"><a href="#二、缓存击穿" class="headerlink" title="二、缓存击穿"></a>二、缓存击穿</h2><p>缓存击穿是指当前热点数据存储到期时，多个线程同时并发访问热点数据。因为缓存刚过期，所有并发请求都会到数据库中查询数据。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>将热点数据设置为永不过期；</li><li>加互斥锁：互斥锁可以控制查询数据库的线程访问，但这种方案会导致系统的吞吐量下降，需要根据实际情况使用。</li></ul><pre><code class="JAVA">public String get(key) {    String value = redis.get(key);    if (value == null) { // 代表缓存值过期        // 设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db        if (redis.setnx(key_mutex, 1, 3 * 60) == 1) {  // 代表设置成功            value = db.get(key);            redis.set(key, value, expire_secs);            redis.del(key_mutex);        } else {  // 这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可            sleep(50);            get(key);  // 重试        }    } else {        return value;          }}</code></pre><h2 id="三、缓存雪崩"><a href="#三、缓存雪崩" class="headerlink" title="三、缓存雪崩"></a>三、缓存雪崩</h2><p>缓存雪崩发生有几种情况，比如大量缓存集中在或者缓存同时在大范围中失效，出现了大量请求去访问数据库，从而导致CPU和内存过载，甚至停机。</p><p>一个简单的雪崩过程：</p><ol><li> Redis 集群产生了大面积故障；</li><li> 缓存失败，此时仍有大量请求去访问 Redis 缓存服务器；</li><li> 在大量 Redis 请求失败后，这些请求将会去访问数据库；</li><li> 由于应用的设计依赖于数据库和 Redis 服务，很快就会造成服务器集群的雪崩，最终导致整个系统的瘫痪。</li></ol><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>【事前】高可用缓存：高可用缓存是防止出现整个缓存故障。即使个别节点，机器甚至机房都关闭，系统仍然可以提供服务，Redis 哨兵(Sentinel) 和 Redis 集群(Cluster) 都可以做到高可用；</li><li>【事中】缓存降级（临时支持）：当访问次数急剧增加导致服务出现问题时，我们如何确保服务仍然可用。在国内使用比较多的是 Hystrix，它通过熔断、降级、限流三个手段来降低雪崩发生后的损失。只要确保数据库不死，系统总可以响应请求，每年的春节 12306 我们不都是这么过来的吗？只要还可以响应起码还有抢到票的机会；</li><li>【事后】Redis备份和快速预热：Redis数据备份和恢复、快速缓存预热。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWA在likee业务线的实践</title>
      <link href="/My-Blogs/2021/01/08/PWA/PWA%E5%9C%A8likee%E4%B8%9A%E5%8A%A1%E7%BA%BF%E7%9A%84%E5%AE%9E%E8%B7%B5/"/>
      <url>/My-Blogs/2021/01/08/PWA/PWA%E5%9C%A8likee%E4%B8%9A%E5%8A%A1%E7%BA%BF%E7%9A%84%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是PWA？"><a href="#1-什么是PWA？" class="headerlink" title="1. 什么是PWA？"></a>1. 什么是PWA？</h2><p>PWA（Progressive web apps，渐进式 Web 应用）运用现代的 Web API 以及传统的渐进式增强策略来创建跨平台 Web 应用程序。</p><a id="more"></a><p>如何理解渐进式？</p><ul><li>  渐进式构建。构成 PWA 的标准都来自 Web 技术，它们都是浏览器提供的、向下兼容的、没有额外运行时代价的技术。因此可以把任何现有的框架开发的 Web 页面改造成 PWA，不需要完全重构现有代码，可以逐步地迁移和改善。</li><li>  渐进式增强。浏览器厂商会逐步提供对 PWA 相关api的支持，现代浏览器的用户会逐步受益，但不会为使用旧版浏览器的用户破坏任何内容。</li></ul><h2 id="2-PWA能做什么？"><a href="#2-PWA能做什么？" class="headerlink" title="2. PWA能做什么？"></a>2. PWA能做什么？</h2><ul><li><p>  安装添加桌面图标</p></li><li><p>  提供前端网络代理</p></li><li><p>  利用cache api对response进行缓存</p></li><li><p>发送push通知  </p><p>  接收服务端推送</p></li></ul><h2 id="3-PWA的工作原理"><a href="#3-PWA的工作原理" class="headerlink" title="3. PWA的工作原理"></a>3. PWA的工作原理</h2><p>PWA实现上述功能，依赖于service worker提供的能力。</p><p>service worker是web worker的一种，是运行在独立线程中的js代码。一个service worker的完整生命周期如下图所示。</p><p><img src="/My-Blogs/images/PWA%E5%9C%A8likee%E4%B8%9A%E5%8A%A1%E7%BA%BF%E7%9A%84%E5%AE%9E%E8%B7%B5-01.png"></p><p>通常遵循以下基本步骤来使用 service worker：</p><ul><li><p>  service worker URL 通过 serviceWorkerContainer.register() 来获取和注册。</p></li><li><p>  如果注册成功，service worker 就在 ServiceWorkerGlobalScope 环境中运行； 这是一个特殊类型的 worker 上下文运行环境，与主运行线程（执行脚本）相独立，同时也没有访问 DOM 的能力。</p></li><li><p>service worker 现在可以处理事件了。  </p><p>  受 service worker 控制的页面打开后会尝试去安装 service worker。最先发送给 service worker 的事件是安装事件。</p></li><li><p>  当 oninstall 事件的处理程序执行完毕后，可以认为 service worker 安装完成了。</p></li><li><p>  下一步是激活。当 service worker 安装完成后，会接收到一个激活事件(activate event)。onactivate 主要用途是清理先前版本的service worker 脚本中使用的资源。</p></li><li><p>  service worker 现在可以控制页面了，但仅是在 register() 成功后的打开的页面。</p></li></ul><p>示例代码如下：</p><pre><code class="JS">navigator.serviceWorker.register(opts.url).then(function(registration) {  console.log("Service worker successfully registered.");})</code></pre><h2 id="4-处理业务需要封装的基本方法"><a href="#4-处理业务需要封装的基本方法" class="headerlink" title="4. 处理业务需要封装的基本方法"></a>4. 处理业务需要封装的基本方法</h2><p>为了处理业务，我们对service worker相关的基本方法进行了封装</p><p>主线程js封装如下：</p><pre><code class="JS">/** * service worker sdk *  * @param {string} opts.url [required] sw文件地址 * @param {function} opts.onReady [optional] sw注册成功 * @param {function} opts.onBeforeInstallPrompt [optional] 未安装pwa事件触发 * @param {function} opts.onClickInstallPrompt [optional] 点击安装确认弹窗 * @param {function} opts.onInstalled [optional] pwa安装成功时触发 * @param {function} opts.onNotificationPermission [optional] 点击通知授权确认弹窗 *  */export function SWSdk(opts) {  /**   * 初始化sw   */  /**   * sw注册成功   */  /**   * 未安装pwa事件触发   */  /**   * pwa安装成功时触发   */  /**   * 弹出安装确认弹窗   */  /**   * 监听sw事件   */  /**   * 触发sw事件   */  /**   * 弹出通知授权确认弹窗   */  /**   * 发送一条通知   */  /**   * 缓存资源   */  /**   * 删除缓存资源   */}</code></pre><p>sw线程js封装如下：</p><pre><code class="JS">/** * SW *  * @param {string} opts. CACHE_NAME [optional] 缓存命名空间，建议每个应用独立命名 * @param {number} opts.tickTime [optional] 每个tick的时间间隔，单位ms，默认1000 * @param {function} opts.onTick [optional] 每个时间间隔调用一次 * @param {function} opts.onProxy [optional] 代理网络请求 * @param {function} opts.onInstall [optional] 安装事件的回调 * @param {function} opts.onActivate [optional] 激活事件的回调 * @param {function} opts.onPush [optional] 收到服务端事件的回调 * @param {function} opts.notificationOnClick [optional] 点击push通知的回调 */var SW = function(opts) {  /**   * 初始化sw   */  /**   * 监听窗口事件   */  /**   * 触发窗口事件   */  /**   * 设置cache   */  /**   * 获取cache   */  /**   * 发送一条通知   */};</code></pre><p>对service worker api的封装，使我们可以更加集中精力处理业务。</p><p>封装的基本方法有：</p><blockquote><p>a. 线程间通讯。主线程和service worker线程之间需要频繁的通信，因此需要封装比较友好的通信方法</p></blockquote><p>主线程：</p><pre><code class="JS">/** * 监听sw事件 *  * @param {string} eventName [required] 事件名称 * @param {function} handler [required] 处理函数 */this.on = function(eventName, handler) {  this.eventListener.push({    eventName: eventName,    handler: handler  })};/** * 触发sw事件 *  * @param {string} eventName [required] 事件名称 * @param {any} payload [optional] 传递的数据 */this.emit = function(eventName, payload) {  const data = {    eventName: eventName,    payload: payload  };  try {    if (navigator.serviceWorker.controller) {      navigator.serviceWorker.controller.postMessage(data);    } else {      navigator.serviceWorker.addEventListener("controllerchange", () =&gt; {        navigator.serviceWorker.controller.postMessage(data);      });    }  } catch (err) {    console.error(err);  }}</code></pre><p>service worker线程：</p><pre><code class="JS">/** * 监听窗口事件 *  * @param {string} eventName [required] 事件名称 * @param {function} handler [required] 处理函数 */this.on = function(eventName, handler) {  this.eventListener.push({    eventName: eventName,    handler: handler  })};/** * 触发窗口事件 *  * @param {string} eventName [required] 事件名称 * @param {any} payload [optional] 传递的数据 */this.emit = function(eventName, payload) {  clients.matchAll({    type: 'window',    includeUncontrolled: true  }).then(function(matchClient) {    matchClient.forEach(function(client) {      client.postMessage({        eventName: eventName,        payload: payload      });    })  });};</code></pre><blockquote><p>b. 本地存储。在service worker 线程中，我们无法使用cookie，localStorage和sessionStorage，我们只能使用cache api或者indexDB作为存储key-value数据的载体。</p></blockquote><pre><code class="JS">/** * 设置cache *  * @param {string} key cache的key * @param {any} value cache的值 */this.setCache = function(key, value) {  try {    return caches.open(this.CACHE_NAME).then(function(cache) {      return cache.put(key, new Response(value));    })  } catch (err) {    const that = this;    return new Promise(function(resolve) {      if (!that.cacheStorage[that.CACHE_NAME]) {        that.cacheStorage[that.CACHE_NAME] = {};      }      that.cacheStorage[that.CACHE_NAME][key] = value;      resolve();    })  }};/** * 获取cache *  * @param {string} key cache的key */this.getCache = function(key) {  try {    return caches.open(this.CACHE_NAME).then(function(cache) {      return cache.match(key);    }).then(function(response) {      return response ? response.text() : '';    })  } catch (err) {    const that = this;    return new Promise(function(resolve) {      resolve(new String(that.cacheStorage[that.CACHE_NAME][key]));    })  }};</code></pre><p>cache api无法直接保存key-value键值对数据，只能保存url-response对数据，我们这里使用了一些小技巧，使它可以存储key-value型数据</p><blockquote><p>c. 通知</p></blockquote><p>主线程申请授权</p><pre><code class="JS">/** * 弹出通知授权确认弹窗 */this.requestNotificationPermission = function() {  Notification.requestPermission().then((result) =&gt; {    that.onNotificationPermission.bind(that)(result);  });};</code></pre><p>service worker线程发送通知</p><pre><code class="JS">/** * 发送一条通知 *  * @param {object} params [required] * @param {string} params.title [required] 标题 * @param {string} params.desc [optional] 描述 * @param {string} params.icon [optional] 图标 * @param {any} params.data [optional] 传递参数 * @param {string} params.url [optional] 点击跳转地址 */this.showNotification = function(params) {  try {    self.registration.showNotification(params.title, {      body: params.desc,      icon: params.icon,      image: params.image,      data: Object.assign({        url: params.url      }, params.data)    })  } catch (err) {    console.log(err);  }};</code></pre><h2 id="5-业务需求及对策"><a href="#5-业务需求及对策" class="headerlink" title="5. 业务需求及对策"></a>5. 业务需求及对策</h2><p>此小节内容太多，不详细展开，有兴趣可以私聊</p><blockquote><p>a. 安装桌面快捷方式</p></blockquote><ul><li>  未安装事件</li><li>  弹出询问安装弹窗api</li></ul><blockquote><p>b. 本地推送通知</p></blockquote><ul><li>  询问授权通知api</li><li>  发送通知</li></ul><blockquote><p>c. sw内埋点</p></blockquote><ul><li>  Fetch api</li><li>  请求数据构造</li></ul><blockquote><p>d. 拉活桌面pwa</p></blockquote><ul><li>  需要安装google play服务</li><li>  需要由不同域的页面发起重定向跳转</li><li>  与pwa同域的链接均可拉活pwa，且pwa展示跳转链接，而非start_url中配置的链接</li><li>  中转页策略</li></ul><blockquote><p>e. 视频预加载</p></blockquote><ul><li>  使用cache api</li></ul><blockquote><p>f. 识别用户访问的是web页面还是桌面pwa</p></blockquote><ul><li>  桌面入口拉活</li><li>  链接拉活</li></ul><h2 id="6-遇到的问题"><a href="#6-遇到的问题" class="headerlink" title="6. 遇到的问题"></a>6. 遇到的问题</h2><blockquote><p>a. 兼容问题</p></blockquote><p>pwa的兼容性是比较差的，几乎每个api都有兼容问题，需要对不同的设备做适配。这些兼容问题很多是查看线上统计数据后才发现的</p><blockquote><p>b. 数据统计</p></blockquote><p>为了统计pwa转化效果，我们需要识别用户访问的是web页面还是桌面的pwa，然而，我们只能统计到桌面图标打开的用户和链接拉活的pwa用户，对于push拉活，第三方app拉活的场景，我们是无法识别的。</p>]]></content>
      
      
      <categories>
          
          <category> PWA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Libuv线程池如何提高nodejs性能</title>
      <link href="/My-Blogs/2021/01/08/NodeJs/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Libuv%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98NodeJs%E6%80%A7%E8%83%BD/"/>
      <url>/My-Blogs/2021/01/08/NodeJs/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Libuv%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98NodeJs%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>如何提高NodeJS性能？下面我们来介绍一种方式，一起看看吧</p><a id="more"></a><h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><a href="https://hackernoon.com/how-libuv-thread-pool-can-boost-your-node-js-performance-bel3tyf">原文链接</a></h3><h3 id="Libuv线程池"><a href="#Libuv线程池" class="headerlink" title="Libuv线程池"></a>Libuv线程池</h3><p>Libuv启动一个包含4个线程的线程池，用于将同步操作卸载到该线程池。为此，Libuv确保同步任务不会不必要地阻止我们的应用程序。</p><p>在这里，我们将利用设置来更好地适应我们的计算机或将应用程序部署到的虚拟机的规格。这是因为我们被允许将4个线程的默认值更改为最多1024个线程。我们通过设置UV_THREADPOOL_SIZE Node变量来实现。</p><p>物理与逻辑CPU内核</p><p>为了更好地了解将UV_THREADPOOL_SIZE设置为什么，我们首先需要了解我们的计算机正在运行多少个逻辑核心。如果以我的MacBook Pro为例，它运行的是6个物理CPU内核（英特尔）。</p><p>但是，这些内核具有超线程，这意味着每个内核可以同时运行2个操作。因此，我们将具有超线程的1个物理核心视为2个逻辑核心。就我而言，我的MacBook Pro运行12个逻辑核心。</p><h3 id="如何提高Node-JS性能"><a href="#如何提高Node-JS性能" class="headerlink" title="如何提高Node JS性能"></a>如何提高Node JS性能</h3><p>建议将 <code>UV_THREADPOOL_SIZE</code> 设置为计算机正在运行的逻辑核心数。就我而言，我将线程池大小设置为12。</p><p>将大小设置为除硬件正在运行的逻辑内核之外的任何值都没有意义，实际上可能会导致性能降低。</p><h3 id="如何检查逻辑核心"><a href="#如何检查逻辑核心" class="headerlink" title="如何检查逻辑核心"></a>如何检查逻辑核心</h3><p>部署时，最后要做的是手动设置UV_THREADPOOL_SIZE，因为您的应用程序可能在具有不同机器规格的多个环境中运行。因此，我们需要一种在相关环境中启动应用程序后动态设置线程池大小的方法。</p><p>好消息是，这很简单，但必须谨慎对待。为此，请将以下代码添加到Node应用程序的根JS文件的顶部：</p><pre><code class="JavaScript">const OS = require('os')process.env.UV_THREADPOOL_SIZE = OS.cpus().length</code></pre><p>该OS模块是原产于节点JS。它具有一个函数cpus（），该函数返回计算机正在运行的逻辑内核的总数。很好的是，如果您的CPU内核没有超线程，则此函数将只返回物理cpu内核的数量，这是完美的。</p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx配置小结</title>
      <link href="/My-Blogs/2021/01/08/nginx/Nginx%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93/"/>
      <url>/My-Blogs/2021/01/08/nginx/Nginx%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>nginx配置有哪些变量？匹配规则又有哪些？让我们一起看看吧</p><a id="more"></a><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><pre><code class="NGINX">$args ： 这个变量等于请求行中的参数，同$query_string$content_length ： 请求头中的Content-length字段$content_type ： 请求头中的Content-Type字段$document_root ： 当前请求在root指令中指定的值$host ： 请求主机头字段，否则为服务器名称$http_user_agent ： 客户端agent信息$http_cookie ： 客户端cookie信息$limit_rate ： 这个变量可以限制连接速率$request_method ： 客户端请求的动作，通常为GET或POST$remote_addr ： 客户端的IP地址$remote_port ： 客户端的端口$remote_user ： 已经经过Auth Basic Module验证的用户名$request_filename ： 当前请求的文件路径，由root或alias指令与URI请求生成$scheme ： HTTP方法（如http，https）$server_protocol ： 请求使用的协议，通常是HTTP/1.0或HTTP/1.1$server_addr ： 服务器地址，在完成一次系统调用后可以确定这个值$server_name ： 服务器名称$server_port ： 请求到达服务器的端口号$request_uri ： 包含请求参数的原始URI，不包含主机名，如/foo/bar.php?arg=baz$uri ： 不带请求参数的当前URI，$uri不包含主机名，如/foo/bar.html$document_uri ： 与$uri相同</code></pre><p>假设请求为<a href="http://www.qq.com:8080/a/b/c.php?v=1111%EF%BC%8C%E5%88%99">http://www.qq.com:8080/a/b/c.php?v=1111，则</a></p><pre><code class="NGINX">$host：www.qq.com$server_port：8080$request_uri：/a/b/c.php?v=111$document_uri：/a/b/c.php$document_root：/var/www/html$request_filename：/var/www/html/a/b/c.php</code></pre><h2 id="主机名（server-name）匹配"><a href="#主机名（server-name）匹配" class="headerlink" title="主机名（server_name）匹配"></a>主机名（server_name）匹配</h2><p>从上到下的优先级为从高到低</p><ol><li> 明确的<code>server_name</code>名称，如<code>www.qq.com</code></li><li> 前缀通配符，如<code>*.qq.com</code>或<code>. qq.com</code></li><li> 后缀通配符，如<code>www.qq.*</code></li><li> 正则表达式，如<code>~[a-z]+\.qq\.com</code></li></ol><h2 id="Location查找规则"><a href="#Location查找规则" class="headerlink" title="Location查找规则"></a>Location查找规则</h2><p>从上到下的优先级为从高到低</p><ol><li> 等号类型，精确匹配，如location = / {}</li><li> ^<del>类型，前缀匹配，不支持正则，如location ^</del> /user {}</li><li> <del>和</del>*类型，正则匹配，<del>区分大小写，</del>*不区分大小写，如location ~ ^/user {}</li><li> 常规字符串匹配类型，如location / {}或location /user {}</li></ol><h2 id="Try-files规则"><a href="#Try-files规则" class="headerlink" title="Try_files规则"></a>Try_files规则</h2><p>try_files $uri $uri/ /index.php<br>假设请求为<code>http://www.qq.com/test</code>，则<code>$uri</code>为<code>test</code></p><p>查找<code>/$root/test</code>文件<br>查找<code>/$root/test/</code>目录<br>发起<code>/index.php</code>的内部“子请求”</p><h2 id="Rewrite规则"><a href="#Rewrite规则" class="headerlink" title="Rewrite规则"></a>Rewrite规则</h2><p>rewrite ^/images/(.*).(png|jpg|gif)$ /images?name=$1.$4 last;</p><p>上面的<code>rewrite</code>规则会将文件名改写到参数中</p><ul><li>last : 相当于<code>Apache</code>的[L]标记，表示完成<code>rewrite</code></li><li>break : 停止执行当前虚拟主机的后续<code>rewrite</code>指令集</li><li>redirect : 返回302临时重定向，地址栏会显示跳转后的地址</li><li>permanent : 返回301永久重定向，地址栏会显示跳转后的地址</li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>例子如下</p><pre><code class="NGINX">upstream backend1 {    server backend1.qq.com weight=5;    server 127.0.0.1:8080 max_fails=3 fail_timeout=30s;    server unix:/tmp/backend3 backup;}upstream backend2 {    ip_hash;    server backend1.qq.com;    server backend2.qq.com;    server backend3.qq.com down;    server backend4.qq.com;}server {    location / {        proxy_pass http://backend1;    }    location /api {        proxy_pass http://backend2;    }}</code></pre><h2 id="查看一个实例"><a href="#查看一个实例" class="headerlink" title="查看一个实例"></a>查看一个实例</h2><p>下面是一个 <code>laravel</code>框架<code>Nginx</code>配置的例子，听过这堂课终于了解了下面的原理。</p><pre><code class="NGINX">server {    listen 80 default_server;    listen [::]:80 default_server ipv6only=on;    # 设定网站根目录    root /var/www/laravel/public;    # 网站默认首页    index index.php index.html index.htm;    # 服务器名称，server_domain_or_IP 请替换为自己设置的名称或者 IP 地址    server_name server_domain_or_IP;    # 修改为 Laravel 转发规则，否则PHP无法获取$_GET信息，提示404错误    location / {        try_files $uri $uri/ /index.php?$query_string;    }    # PHP 支持    location ~ \.php$ {        try_files $uri /index.php =404;        fastcgi_split_path_info ^(.+\.php)(/.+)$;        fastcgi_pass unix:/var/run/php5-fpm.sock;        fastcgi_index index.php;        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;        include fastcgi_params;    }}</code></pre><p>我们主要关注两个<code>location</code>，假设地址是<code>http://www.qq.com/user/info</code>，会匹配到如下<code>location</code></p><pre><code class="NGINX">location / {    try_files $uri $uri/ /index.php?$query_string;}</code></pre><p>由于<code>$uri</code>和<code>$uri/</code>是不存在的，所以会走<code>/index.php?$query_string</code>，这时候会发起一个内部“子请求”，“子请求”会重新匹配<code>location</code>，然后匹配到如下<code>location</code></p><pre><code class="NGINX">location ~ \.php$ {    try_files $uri /index.php =404;    fastcgi_split_path_info ^(.+\.php)(/.+)$;    fastcgi_pass unix:/var/run/php5-fpm.sock;    fastcgi_index index.php;    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;    include fastcgi_params;}</code></pre><p>这样请求就会发送到<code>fastcgi</code>去做处理。</p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> devops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx代理proxy pass配置去除前缀问题</title>
      <link href="/My-Blogs/2021/01/08/nginx/Nginx%E4%BB%A3%E7%90%86proxy%20pass%E9%85%8D%E7%BD%AE%E5%8E%BB%E9%99%A4%E5%89%8D%E7%BC%80%E9%97%AE%E9%A2%98/"/>
      <url>/My-Blogs/2021/01/08/nginx/Nginx%E4%BB%A3%E7%90%86proxy%20pass%E9%85%8D%E7%BD%AE%E5%8E%BB%E9%99%A4%E5%89%8D%E7%BC%80%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>设置反向代理的时候，有时候程序会拿不到URL后面的path部分，这是为什么呢？让我们一起来看看吧</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用Nginx做代理的时候，可以简单的直接把请求原封不动的转发给下一个服务。</p><p>比如，访问abc.com/appv2/a/b.html, 要求转发到localhost:8088/appv2/a/b.html</p><p>简单配置如下：</p><pre><code class="nginx">upstream one {  server localhost:8088 weight=5;}server {    listen              80;    server_name         abc.com;    access_log  "pipe:rollback /data/log/nginx/access.log interval=1d baknum=7 maxsize=1G"  main;    location / {        proxy_set_header Host $host;        proxy_set_header  X-Real-IP        $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;        proxy_set_header X-NginX-Proxy true;        proxy_pass http://one;    }}</code></pre><p>即，设置 <code>proxy_pass</code> 即可。请求只会替换域名。</p><p>但很多时候，我们需要根据url的前缀转发到不同的服务。</p><p>比如</p><p>abc.com/user/profile.html 转发到 用户服务localhost:8089/profile.html</p><p>abc.com/order/details.html 转发到 订单服务 localhost:8090/details.html</p><p>即，url的前缀对下游的服务是不需要的，除非下游服务添加context-path, 但很多时候我们并不喜欢加这个。如果Nginx转发的时候，把这个前缀去掉就好了。</p><h3 id="一个种方案是proxy-pass后面加根路径"><a href="#一个种方案是proxy-pass后面加根路径" class="headerlink" title="一个种方案是proxy_pass后面加根路径 / ."></a>一个种方案是proxy_pass后面加根路径 <code>/</code> .</h3><pre><code class="nginx">server {    listen              80;    server_name         abc.com;    access_log  "pipe:rollback /data/log/nginx/access.log interval=1d baknum=7 maxsize=1G"  main;    location ^~/user/ {        proxy_set_header Host $host;        proxy_set_header  X-Real-IP        $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;        proxy_set_header X-NginX-Proxy true;        proxy_pass http://user/;    }    location ^~/order/ {        proxy_set_header Host $host;        proxy_set_header  X-Real-IP        $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;        proxy_set_header X-NginX-Proxy true;        proxy_pass http://order/;    }}</code></pre><p><code>^~/user/</code> 表示匹配前缀是 <code>user</code> 的请求，proxy_pass的结尾有/， 则会把 <code>/user/*</code> 后面的路径直接拼接到后面，即移除user.</p><h3 id="另一种方案是使用-rewrite"><a href="#另一种方案是使用-rewrite" class="headerlink" title="另一种方案是使用 rewrite"></a>另一种方案是使用 <code>rewrite</code></h3><pre><code class="nginx">upstream user {  server localhost:8089 weight=5;}upstream order {  server localhost:8090 weight=5;}server {    listen              80;    server_name         abc.com;    access_log  "pipe:rollback /data/log/nginx/access.log interval=1d baknum=7 maxsize=1G"  main;    location ^~/user/ {        proxy_set_header Host $host;        proxy_set_header  X-Real-IP        $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;        proxy_set_header X-NginX-Proxy true;        rewrite ^/user/(.*)$ /$1 break;        proxy_pass http://user;    }    location ^~/order/ {        proxy_set_header Host $host;        proxy_set_header  X-Real-IP        $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;        proxy_set_header X-NginX-Proxy true;        rewrite ^/order/(.*)$ /$1 break;        proxy_pass http://order;    }}</code></pre><p>注意到proxy_pass结尾没有 <code>/</code> , <code>rewrite</code> 重写了url。</p><p>关于rewrite</p><pre><code class="nginx">syntax: rewrite regex replacement [flag]Default: —Context: server, location, if</code></pre>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> devops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx location匹配规则</title>
      <link href="/My-Blogs/2021/01/08/nginx/Nginx%20location%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/"/>
      <url>/My-Blogs/2021/01/08/nginx/Nginx%20location%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>location的匹配规则有哪些呢？让我们来一起看看吧</p><a id="more"></a><h3 id="url匹配规则"><a href="#url匹配规则" class="headerlink" title="url匹配规则"></a>url匹配规则</h3><pre><code class="nginx">location [=|~|~*|^~|@] /uri/ {  ...} </code></pre><ul><li><code>=</code> : 表示精确匹配后面的url</li><li><code>~</code> : 表示正则匹配，但是区分大小写</li><li><code>~*</code> : 正则匹配，不区分大小写</li><li><code>^~</code> : 表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录</li><li><code>@</code> : “@” 定义一个命名的 location，使用在内部定向时，例如 error_page</li></ul><p>上述匹配规则的优先匹配顺序：</p><ol><li> = 前缀的指令严格匹配这个查询。如果找到，停止搜索；</li><li> 所有剩下的常规字符串，最长的匹配。如果这个匹配使用 ^~ 前缀，搜索停止；</li><li> 正则表达式，在配置文件中定义的顺序；</li><li> 如果第 3 条规则产生匹配的话，结果被使用。否则，使用第 2 条规则的结果。</li></ol><h3 id="目标地址处理规则"><a href="#目标地址处理规则" class="headerlink" title="目标地址处理规则"></a>目标地址处理规则</h3><p>匹配到uri后，接下来要代理到目标服务地址。</p><pre><code class="NGINX">upstream api_server {  server 10.0.101.62:8081;  server 10.0.101.61:8082;}location / {        rewrite ^(.*)$ http://10.0.101.62:8000/my-module$1 break;}location ^~ /my-module/ {    root   /data/my-module/dist;    rewrite ^/my-module/(.*)$  /$1 break;    index  index.html index.htm;}location /my-module/api {    proxy_pass  http://api_server;    proxy_set_header Host $host;    proxy_set_header  X-Real-IP        $remote_addr;    proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;    proxy_set_header  your-custome-header    "myHeader";    proxy_set_header X-NginX-Proxy true;}</code></pre><p>上述配置，默认访问 <code>/</code> 会重定向到 <code>/my-module</code> , 然后直接返回 <code>/data/my-module/dist</code> 下的html等静态文件。</p><p>访问 <code>/my-module/api</code> 则会代理到我们api服务器地址，是一个默认的round-robin负载均衡配置。</p><p>下面是访问localhost的日志, 访问首页一共进行了2次重定向。</p><pre><code class="PHP">Request URL: http://10.0.101.62:8000/Request Method: GETStatus Code: 302 Moved TemporarilyLocation: http://10.0.101.62:8000/flash/Request URL: http://10.0.101.62:8000/flash/Request Method: GETStatus Code: 302 Moved TemporarilyLocation: http://10.0.101.62:8000/flash/index.htmlRequest URL: http://10.0.101.62:8000/flash/index.htmlRequest Method: GETStatus Code: 304 Not Modified</code></pre><h3 id="alias与root的区别"><a href="#alias与root的区别" class="headerlink" title="alias与root的区别"></a>alias与root的区别</h3><blockquote><p>root 实际访问文件路径会拼接URL中的路径</p><p>alias 实际访问文件路径不会拼接URL中的路径</p></blockquote><p>示例如下：</p><pre><code class="NGINX">location ^~ /sta/ {     alias /usr/local/nginx/html/static/;  }</code></pre><p>请求：<code>http://test.com/sta/sta1.html</code><br>实际访问：<code>/usr/local/nginx/html/static/sta1.html</code> 文件</p><pre><code class="NGINX">location ^~ /tea/ {     root /usr/local/nginx/html/;  }</code></pre><p>请求： <code>http://test.com/tea/tea1.html</code></p><p>实际访问： <code>/usr/local/nginx/html/tea/tea1.html</code> 文件</p><p>显然，第二次重定向是不需要的，本意是访问/flash/的时候，直接访问对应目录下的html静态文件。 但因为root拼接flash导致找不到对应文件，要重写url，去掉flash这个模块前缀，使用了 <code>rewrite</code> , 而 <code>rewrite</code> 会返回302重定向。</p><p>接下来，我们修改 <code>root</code> 为 <code>alias</code></p><pre><code class="NGINX">location ^~ /flash/ {    alias   /data/flash/dist/;    #rewrite ^/flash/(.*)$  /$1 break;    index  index.html index.htm;}</code></pre><p>直接重定向1次后返回html</p><pre><code class="PHP">Request URL: http://10.0.101.62:8000/Request Method: GETStatus Code: 302 Moved TemporarilyRequest URL: http://10.0.101.62:8000/flash/Request Method: GETStatus Code: 200 OK (from disk cache)</code></pre><h3 id="last-和-break关键字的区别"><a href="#last-和-break关键字的区别" class="headerlink" title="last 和 break关键字的区别"></a>last 和 break关键字的区别</h3><p>只用到了break，即匹配到此处后不会继续跳。</p><h3 id="permanent-和-redirect关键字的区别"><a href="#permanent-和-redirect关键字的区别" class="headerlink" title="permanent 和 redirect关键字的区别"></a>permanent 和 redirect关键字的区别</h3><ul><li>rewrite … permanent 永久性重定向，请求日志中的状态码为301</li><li>rewrite … redirect 临时重定向，请求日志中的状态码为302</li></ul><p>我们常用的 <code>80</code> 端口转 <code>443</code> ，即http转https的一种配置方案为</p><pre><code class="NGINX">server {    listen 80;    server_name demo.com;    rewrite ^(.*)$ https://${server_name}$1 permanent; }</code></pre><p>会返回301永久重定向到对应的https：</p><pre><code class="PHP">Request URL: http://demo.com/flash/index.htmlRequest Method: GETStatus Code: 301 Moved PermanentlyLocation: https://demo/flash/index.html</code></pre><h3 id="一些使用场景"><a href="#一些使用场景" class="headerlink" title="一些使用场景"></a>一些使用场景</h3><p>上述demo差不多就是我平时用的前后端分离的代理配置方案。下面是一些遇到过的场景。</p><p>配置一个静态文件下载服务，我们下面软件会经常看到index /的页面。</p><pre><code class="NGINX">server {        listen       8888;        #端口        server_name  _;   #服务名        charset utf-8,gbk;        root    /data/download;  #显示的根索引目录        autoindex on;             #开启索引功能        autoindex_exact_size off; # 关闭计算文件确切大小（单位bytes），只显示大概大小（单位kb、mb、gb）        autoindex_localtime on;   # 显示本机时间而非 GMT 时间}</code></pre><p>配置http重定向到https</p><pre><code class="NGINX">server {    listen 80;    server_name demo.com;    rewrite ^(.*)$ https://${server_name}$1 permanent; }server {    listen       443;    server_name  demo.com;    charset utf-8;    location / {       alias   /data/web;       index  index.html index.htm;    }}</code></pre><p>配置静态前端页面</p><pre><code class="NGINX">location / {    alias   /data/web;    index  index.html index.htm;}</code></pre><p>配置反向代理, 比如我们访问<a href="http://demo.com/api/aaa/bbb%EF%BC%8C%E6%88%91%E4%BB%AC%E6%83%B3%E8%A6%81%E4%BB%A3%E7%90%86%E5%88%B0http://api.com/api/aaa/bbb">http://demo.com/api/aaa/bbb，我们想要代理到http://api.com/api/aaa/bbb</a>, 只切换了域名，uri相同。</p><pre><code class="NGINX">upstream api_server {  server 10.0.101.62:8081;  server 10.0.101.61:8082;}location /api {    proxy_pass  http://api_server;    proxy_set_header Host $host;    proxy_set_header  X-Real-IP        $remote_addr;    proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;    proxy_set_header  your-custome-header    "myHeader";    proxy_set_header X-NginX-Proxy true;}</code></pre><p>配置反向代理时，移除前缀。比如我们的服务<a href="http://demo.com/users/aaa/bbb">http://demo.com/users/aaa/bbb</a>, 我们想要代理到<a href="http://users.com/aaa/bbb%EF%BC%8C%E5%8D%B3%E5%88%87%E6%8D%A2%E5%9F%9F%E5%90%8D%E7%9A%84%E5%90%8C%E6%97%B6%EF%BC%8C%E5%8E%BB%E6%8E%89users%E5%89%8D%E7%BC%80%E3%80%82%E5%8C%BA%E5%88%AB%E6%98%AFproxy_pass">http://users.com/aaa/bbb，即切换域名的同时，去掉users前缀。区别是proxy_pass</a> 结尾的 <code>/</code> .</p><pre><code class="NGINX">location ^~/users/ {    proxy_set_header Host $host;    proxy_set_header  X-Real-IP        $remote_addr;    proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;    proxy_set_header X-NginX-Proxy true;    proxy_pass http://users.com/;}</code></pre><p>反向代理时，想要自定义修改uri。使用rewrite正则修改。</p><pre><code class="NGINX"># 修改uri，去掉了flash的前缀，$1表示正则匹配到的字符串内容。location ^~ /flash/ {    root   /data/flash/dist/;    rewrite ^/flash/(.*)$  /$1 break;    index  index.html index.htm;}# 修改uri, 重新代理到新的地址location ^~/order/ {    proxy_set_header Host $host;    proxy_set_header  X-Real-IP        $remote_addr;    proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;    proxy_set_header X-NginX-Proxy true;    rewrite ^/order/(.*)$ /$1 break;    proxy_pass http://order;}</code></pre><p>代理跨域, 比如bing每日一图，不支持我们ajax获取图片地址，我们可以自己写一个支持的接口。</p><p><a href="http://101.200.218.760/proxy/bing/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1">http://101.200.218.760/proxy/bing/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1</a></p><p>代理对象为：</p><p><a href="https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1">https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1</a></p><pre><code class="NGINX">location ^~/proxy/bing/ {    add_header 'Access-Control-Allow-Origin' 'http://localhost:8088';    add_header 'Cache-Control' 'public, max-age=604800';    add_header 'Access-Control-Allow-Credentials' 'true';    add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';    rewrite ^/proxy/bing/(.*)$ /$1 break;    proxy_pass https://cn.bing.com/; }</code></pre><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><ul><li><a href="https://www.cnblogs.com/duhuo/p/8323812.html">https://www.cnblogs.com/duhuo/p/8323812.html</a></li><li><a href="https://www.cnblogs.com/woshimrf/p/nginx-proxy-rewrite-url.html">https://www.cnblogs.com/woshimrf/p/nginx-proxy-rewrite-url.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> devops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx的负载均衡实例，均衡策略，session保持方案</title>
      <link href="/My-Blogs/2021/01/08/nginx/Nginx%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E4%BE%8B%EF%BC%8C%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%EF%BC%8Csession%E4%BF%9D%E6%8C%81%E6%96%B9%E6%A1%88/"/>
      <url>/My-Blogs/2021/01/08/nginx/Nginx%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E4%BE%8B%EF%BC%8C%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%EF%BC%8Csession%E4%BF%9D%E6%8C%81%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>负载均衡定义：代理服务器将接收的请求均衡的分发到各服务器中<br>负载均衡作用：主要解决网络拥塞问题，提高服务器响应速度，服务就近提供，达到更好的访问质量，减少后台服务器并发压力。</p><a id="more"></a><h2 id="负载均衡的配置实例"><a href="#负载均衡的配置实例" class="headerlink" title="负载均衡的配置实例"></a>负载均衡的配置实例</h2><p>可访问的服务有两个：</p><ul><li><a href="http://172.16.25.44:8080/rsbi">http://172.16.25.44:8080/rsbi</a></li><li><a href="http://192.168.1.138:8080/rsbi">http://192.168.1.138:8080/rsbi</a></li></ul><p>nginx.conf完整配置如下：</p><pre><code class="NGINX">#user &nbsp;nobody;worker_processes &nbsp;1;events {&nbsp; &nbsp; worker_connections &nbsp;1024;}http {&nbsp; &nbsp; &nbsp; &nbsp; include &nbsp; &nbsp; &nbsp; mime.types;&nbsp; &nbsp; &nbsp; &nbsp; default_type &nbsp;application/octet-stream;&nbsp; &nbsp; &nbsp; &nbsp; sendfile &nbsp; &nbsp; &nbsp; &nbsp;on;&nbsp; &nbsp; &nbsp; &nbsp; keepalive_timeout &nbsp;65;&nbsp; &nbsp; &nbsp; &nbsp; #此处定义常量xd-projec&nbsp; &nbsp; &nbsp; &nbsp; upstream xd-project{&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #注意 此处的server只能是ip:port 不能有任何多余的http或者项目名称&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; server 172.16.25.44:8080;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; server &nbsp;192.168.1.138:8080;&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; server{&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; listen 8081;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; server_name &nbsp;localhost;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; location / {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #此处使用上面定义常量xd-projec&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proxy_pass http://xd-project;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; location ~ .* {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proxy_pass http://xd-project;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proxy_set_header Host $http_host;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proxy_set_header X-Real-IP $remote_addr;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error_page &nbsp; 500 502 503 504 &nbsp;/50x.html;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; location = /50x.html {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root &nbsp; html;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; include servers/*;}</code></pre><p>说明：上面的均衡方式是轮询，即nginx的默认负载均衡方式</p><h2 id="nginx的负载均衡策略及其适用场景"><a href="#nginx的负载均衡策略及其适用场景" class="headerlink" title="nginx的负载均衡策略及其适用场景"></a>nginx的负载均衡策略及其适用场景</h2><h3 id="1-轮询（默认）"><a href="#1-轮询（默认）" class="headerlink" title="1.  轮询（默认）"></a>1.  轮询（默认）</h3><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。主要用于大量请求场景中环节服务端的压力。<br>配置实例：</p><pre><code class="NGINX">upstream xd-project{        #注意 此处的server只能是ip:port 不能有任何多余的http或者项目名称        server 172.16.25.44:8080;        server  192.168.1.138:8080;} </code></pre><h3 id="2-weight"><a href="#2-weight" class="headerlink" title="2.  weight"></a>2.  weight</h3><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。<br>配置实例</p><pre><code class="NGINX">upstream xd-project{  #注意 此处的server只能是ip:port 不能有任何多余的http或者项目名称  server 172.16.25.44:8080 weight=1;  server  192.168.1.138:8080 weight=2;}</code></pre><p>说明：假设有三次访问，因为weight的值，会有一次落在172.16.25.44:8080，两次落在192.168.1.138:8080<br>应用场景：后端服务器性能不均的情况</p><h3 id="3-ip-hash"><a href="#3-ip-hash" class="headerlink" title="3.  ip_hash"></a>3.  ip_hash</h3><p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。<br>配置实例：</p><pre><code class="NGINX">upstream xd-project{        ip_hash;        server 172.16.25.44:8080;        server  192.168.1.138:8080;}</code></pre><p>应用场景：当你服务端的一个特定url路径会被同一个用户连续访问时，如果负载均衡策略还是轮询的话，那该用户的多次访问会被打到各台服务器上，这显然并不高效（会建立多次http链接等问题）。甚至考虑一种极端情况，用户需要分片上传文件到服务器下，然后再由服务器将分片合并，这时如果用户的请求到达了不同的服务器，那么分片将存储于不同的服务器目录中，导致无法将分片合并。</p><h3 id="4-url-hash（第三方）"><a href="#4-url-hash（第三方）" class="headerlink" title="4.  url_hash（第三方）"></a>4.  url_hash（第三方）</h3><p>每个请求按访问url的hash结果分配，这样每个url请求固定访问一个后端服务器。<br>配置实例：</p><pre><code class="NGINX">upstream xd-project{        hash $request_uri;        server 172.16.25.44:8080;        server  192.168.1.138:8080;}</code></pre><p>应用场景：<br>一般来讲，要用到urlhash，是要配合缓存命中来使用。举一个我遇到的实例：有一个服务器集群A，需要对外提供文件下载，由于文件上传量巨大，没法存储到服务器磁盘中，所以用到了第三方云存储来做文件存储。服务器集群A收到客户端请求之后，需要从云存储中下载文件然后返回，为了省去不必要的网络带宽和下载耗时，在服务器集群A上做了一层临时缓存（缓存一个月）。由于是服务器集群，所以同一个资源多次请求，可能会到达不同的服务器上，导致不必要的多次下载，缓存命中率不高，以及一些资源时间的浪费。在此类场景下，为了使得缓存命中率提高，很适合使用url_hash策略，同一个url（也就是同一个资源请求）会到达同一台机器，一旦缓存住了资源，再此收到请求，就可以从缓存中读取，既减少了带宽，也减少的下载时间。</p><h3 id="5-fair（第三方）"><a href="#5-fair（第三方）" class="headerlink" title="5.  fair（第三方）"></a>5.  fair（第三方）</h3><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><h2 id="负载均衡session会话保持方法"><a href="#负载均衡session会话保持方法" class="headerlink" title="负载均衡session会话保持方法"></a>负载均衡session会话保持方法</h2><p>负载均衡时，为了保证同一用户session会被分配到同一台服务器上，可以使用以下方法：</p><ol><li> 使用cookie</li></ol><p>将用户的session存入cookie里，当用户分配到不同的服务器时，先判断服务器是否存在该用户的session，如果没有就先把cookie里面的sessoin存入该服务器，实现session会话保持。缺点是存入cookie有安全隐患。</p><ol start="2"><li> 使用缓存</li></ol><p>利用memcache，redis等缓存分布式的特点，可以将所有服务器产生的session存入同一台服务器的缓存中，实现session共享。这样安全性比较高，而且从内存中读取session比从文件中读取速度快。</p><ol start="3"><li> 使用ip_hash</li></ol><p>如果是nginx服务器的负载均衡，可以在upstream里设置ip_hash，每个请求按访问ip的hash结果分配，映射到固定某一台的服务器。缺点是可能导致负载不均衡。</p><h2 id="upstream中的down和backup"><a href="#upstream中的down和backup" class="headerlink" title="upstream中的down和backup"></a>upstream中的down和backup</h2><p><img src="/My-Blogs/images/Nginx%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E4%BE%8B%EF%BC%8C%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%EF%BC%8Csession%E4%BF%9D%E6%8C%81%E6%96%B9%E6%A1%88-01.png" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> devops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim基础篇——快速移动</title>
      <link href="/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/vim%E5%BF%AB%E9%80%9F%E7%A7%BB%E5%8A%A8/"/>
      <url>/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/vim%E5%BF%AB%E9%80%9F%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>最初使用Vim时，初学者经常会感到不适应，因为它的移动方式和一般的编辑器差别很大。但是Vim的魅力就在于，当你学会Vim的移动方式后，你能迅速的把光标移动到你想要的位置。</p><p>本文介绍Vim中的移动方式：Vim中熟练的移动并不是指用hjkl移动，当你越熟练的掌握vim的移动方式，你会越少的使用hjkl移动方式。</p><a id="more"></a><blockquote><p>hjkl are the tip of the top of the iceberg and very rarely used, at least in my case.</p></blockquote><br><h3 id="1、行内移动"><a href="#1、行内移动" class="headerlink" title="1、行内移动"></a>1、行内移动</h3><blockquote><p>Test: This is a line with example text </p></blockquote><br><h4 id="最基础的移动方式是w-e-b-ge"><a href="#最基础的移动方式是w-e-b-ge" class="headerlink" title="最基础的移动方式是w/e/b/ge"></a>最基础的移动方式是w/e/b/ge</h4><br><p>w是向前移动到下一个单词的第一个位置，大写的W表示只使用空格作为分隔</p><br><pre><code class="BASH">" * 代表了光标的初始位置" 每个字母代表了如果按下这个键会跳转的位置Test: This is a line with example text*   w w    w  w w    w    w       w*     W    W  W W    W    W       W</code></pre><p>w前面可以加上数字，表示w命令重复几次，比如3w等同于按下三次w</p><p>e是向前跳动到下一个【单词的末尾】，这意味着如果当前光标在单词的中间，按下e会跳转到当前单词的末尾。大写的E表示只使用空格作为分隔</p><pre><code class="BASH">" * 代表了光标的初始位置" 每个字母代表了如果按下这个键会跳转的位置Test: This is a line with example text*  ee    e  e e    e    e       e    e*   E    E  E E    E    E       E    E </code></pre><p>b是向后移动到上一个【单词的开头】，这意味着如果当前光标在单词的中间，按下b会跳转到当前单词的开头。大写的B表示只使用空格作为分隔</p><pre><code class="BASH">" * 代表了光标的初始位置" 每个字母代表了如果按下这个键会跳转的位置Test: This is a line with example textb   b b    b  b b    b    b       b *B     B    B  B B    B    B       B *</code></pre><p>ge是向后移动到上一个【单词的末尾】。大写的gE表示只使用空格作为分隔</p><pre><code class="BASH">" * 代表了光标的初始位置" 每个字母代表了如果按下这个键会跳转的位置" &amp; 表示按下gETest: This is a line with example text  ee    e  e e    e    e       e   *   &amp;    &amp;  &amp; &amp;    &amp;    &amp;       &amp;   * </code></pre><blockquote><p>Notice：w/e/b/ge都是可以跨行移动的！</p></blockquote><br><h4 id="快速移动到行的开始和结束"><a href="#快速移动到行的开始和结束" class="headerlink" title="快速移动到行的开始和结束"></a>快速移动到行的开始和结束</h4><br><pre><code class="BASH">$ 移动到行的末尾0 移动到行的开头^ 移动到第一个非空白字符g_ 移动到最后一个非空白字符</code></pre><br><blockquote><p>0不能使用数字参数；但是$可以，$等同于1$，2$表示移动到下一行的末尾，同理3$…</p></blockquote><br><h4 id="行内移动到特定字符"><a href="#行内移动到特定字符" class="headerlink" title="行内移动到特定字符"></a>行内移动到特定字符</h4><br><p>【f+字符】表示移动到行内当前光标后面的第一个这个字符</p><p>【t+字符】表示移动到行内当前光标后的的第一个这个字符的前一个位置</p><p>【F+字符】为【f+字符】的反向</p><p>【T+字符】为【t+字符】的反向</p><br><blockquote><p>这种移动方式不能跨行</p></blockquote><br><pre><code class="BASH">" * 代表了光标的初始位置" 每个字母代表了如果按下这个键会跳转的位置" &amp; 表示按下fe" ! 表示按下teTest: This is a line with example text*&amp;                 &amp;      &amp;     &amp;  &amp; +               !</code></pre><br><p>注意到一个奇怪的现象，在第二行操作中，按下te会定位到line中的e，光标会移动到e的前一个字符n，如果再一次按下te，会定位到line中的e，光标会移动到e的前一个字符n，也就是说光标不会移动。</p><br><p>这样就告诉我们：连续按下两次【t+字符】和按下一次到达的位置一定是一样的。</p><blockquote><p>f/t/F/T均可以接受数字参数，3fe相当于按下三次fe</p></blockquote><p>事实上，重复操作有另一种方式：【; 】代表了重复查找字符，【, 】是【; 】的反向：</p><blockquote><p>【fe; 】等同于【fefe】等同于【2fe】【fe, 】等同于【feFe】</p></blockquote><br><h3 id="2、行间移动"><a href="#2、行间移动" class="headerlink" title="2、行间移动"></a>2、行间移动</h3><br><h4 id="滚动屏幕"><a href="#滚动屏幕" class="headerlink" title="滚动屏幕"></a>滚动屏幕</h4><pre><code class="BASH">&lt;Ctrl-b&gt; 向下移动一个屏幕&lt;Ctrl-f&gt; 向上移动一个屏幕&lt;Ctrl-u&gt; 向下移动半个屏幕&lt;Ctrl-d&gt; 向上移动半个屏幕</code></pre><h4 id="文件位置移动"><a href="#文件位置移动" class="headerlink" title="文件位置移动"></a>文件位置移动</h4><br><p>【数字+G】表示移动到文件的特定行</p><p>比如30G表示移动到第三十行</p><p>gg表示移动到文件的第一行</p><p>G表示移动到文件的最后一行</p><br><h3 id="3、其他移动方式"><a href="#3、其他移动方式" class="headerlink" title="3、其他移动方式"></a>3、其他移动方式</h3><br><p>【%】：找到当前光标 下或者之后 的第一个括号，并移动到它匹配的括号的位置</p><blockquote><p>括号包括：</p></blockquote><p>([{}])<br>/* */<br>#if, #ifdef, #else, #elif, #endif</p><br><pre><code class="BASH">" * 代表了光标的初始位置" 每个字母代表了如果按下这个键会跳转的位置int f(1, g(2, 3))*              %   %          *     *      %       % *</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sftp命令基本使用</title>
      <link href="/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/sftp%E5%91%BD%E4%BB%A4%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/sftp%E5%91%BD%E4%BB%A4%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><code>sftp</code> 是 SSH 提供的一个客户端应用程序，主要用来安全地访问 FTP。因为 FTP 是不加密协议，很不安全，<code>sftp</code>就相当于将 FTP 放入了 SSH。</p><a id="more"></a><p>下面的命令连接 FTP 主机</p><pre><code class="BASH">sftp username@hostname</code></pre><p>执行上面的命令，会要求输入 FTP 的密码。密码验证成功以后，就会出现 FTP 的提示符<code>sftp&gt;</code>，下面是一个例子。</p><pre><code class="BASH">sftp USER@penguin.example.comUSER@penguin.example.com's password:Connected to penguin.example.com.sftp&gt;</code></pre><p>FTP 的提示符下面，就可以输入各种 FTP 命令了，这部分完全跟传统的 FTP 用法完全一样。</p><ul><li><code>ls [directory]</code>: 列出一个远程目录的内容。如果没有指定目标目录，则默认列出当前目录。</li><li><code>cd directory</code>: 从当前目录改到指定目录。</li><li><code>mkdir directory</code>: 创建一个远程目录。</li><li><code>rmdir path</code>: 删除一个远程目录。</li><li><code>put localfile [remotefile]</code>: 本地文件传输到远程主机。</li><li><code>get remotefile [localfile]</code>: 远程文件传输到本地。</li><li><code>help</code>: 显示帮助信息。</li><li><code>bye</code>: 退出 sftp。</li><li><code>quit</code>: 退出 sftp。</li><li><code>exit</code>: 退出 sftp。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scp命令的基本使用</title>
      <link href="/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/scp%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/scp%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><code>scp</code> 是 secure copy 的缩写，相当于 <code>cp</code> 命令 + SSH。它的底层是 SSH 协议，默认端口是22，相当于先使用 <code>ssh</code> 命令登录远程主机，然后再执行拷贝操作</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>scp</code> 主要用于以下三种复制操作。</p><ul><li>本地复制到远程。</li><li>远程复制到本地。</li><li>两个远程系统之间的复制。</li></ul><p>使用 <code>scp</code> 传输数据时，文件和密码都是加密的，不会泄漏敏感信息。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><code>scp</code> 的语法类似 <code>cp</code> 的语法。</p><pre><code class="BASH">scp source destination</code></pre><p>上面命令中， <code>source</code> 是文件当前的位置， <code>destination</code> 是文件所要复制到的位置。它们都可以包含用户名和主机名。</p><pre><code class="BASH">scp user@host:foo.txt bar.txt</code></pre><p>上面命令将远程主机（ <code>user@host</code> ）用户主目录下的 <code>foo.txt</code> ，复制为本机当前目录的 <code>bar.txt</code> 。可以看到，主机与文件之间要使用冒号（ <code>:</code> ）分隔。</p><p><code>scp</code> 会先用 SSH 登录到远程主机，然后在加密连接之中复制文件。客户端发起连接后，会提示用户输入密码，这部分是跟 SSH 的用法一致的。</p><p>用户名和主机名都是可以省略的。用户名的默认值是本机的当前用户名，主机名默认为当前主机。注意， <code>scp</code> 会使用 SSH 客户端的配置文件 <code>.ssh/config</code> ，如果配置文件里面定义了主机的别名，这里也可以使用别名连接。</p><p><code>scp</code> 支持一次复制多个文件。</p><pre><code class="BASH">scp source1 source2 destination</code></pre><p>上面命令会将 <code>source1</code> 和 <code>source2</code> 两个文件，复制到 <code>destination</code> 。</p><p>注意，如果所要复制的文件，在目标位置已经存在同名文件， <code>scp</code> 会在没有警告的情况下覆盖同名文件。</p><h2 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h2><h3 id="本地文件复制到远程"><a href="#本地文件复制到远程" class="headerlink" title="本地文件复制到远程"></a>本地文件复制到远程</h3><p>复制本机文件到远程系统的用法如下。</p><pre><code class="BASH"># 语法$ scp SourceFile user@host:directory/TargetFile# 示例$ scp file.txt remote_username@10.10.0.2:/remote/directory</code></pre><p>下面是复制整个目录的例子。</p><pre><code class="BASH"># 将本机的 documents 目录拷贝到远程主机，# 会在远程主机创建 documents 目录$ scp -r documents username@server_ip:/path_to_remote_directory# 将本机整个目录拷贝到远程目录下$ scp -r localmachine/path_to_the_directory username@server_ip:/path_to_remote_directory/# 将本机目录下的所有内容拷贝到远程目录下$ scp -r localmachine/path_to_the_directory/* username@server_ip:/path_to_remote_directory/</code></pre><h3 id="远程文件复制到本地"><a href="#远程文件复制到本地" class="headerlink" title="远程文件复制到本地"></a>远程文件复制到本地</h3><p>从远程主机复制文件到本地的用法如下。</p><pre><code class="BASH"># 语法$ scp user@host:directory/SourceFile TargetFile# 示例$ scp remote_username@10.10.0.2:/remote/file.txt /local/directory</code></pre><p>下面是复制整个目录的例子。</p><pre><code class="BASH"># 拷贝一个远程目录到本机目录下$ scp -r username@server_ip:/path_to_remote_directory local-machine/path_to_the_directory/# 拷贝远程目录下的所有内容，到本机目录下$ scp -r username@server_ip:/path_to_remote_directory/* local-machine/path_to_the_directory/$ scp -r user@host:directory/SourceFolder TargetFolder</code></pre><h3 id="两个远程系统之间的复制"><a href="#两个远程系统之间的复制" class="headerlink" title="两个远程系统之间的复制"></a>两个远程系统之间的复制</h3><p>本机发出指令，从远程主机 A 拷贝到远程主机 B 的用法如下。</p><pre><code class="BASH"># 语法$ scp user@host1:directory/SourceFile user@host2:directory/SourceFile# 示例$ scp user1@host1.com:/files/file.txt user2@host2.com:/files</code></pre><p>系统将提示你输入两个远程帐户的密码。数据将直接从一个远程主机传输到另一个远程主机。</p><h2 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h2><h3 id="c"><a href="#c" class="headerlink" title="-c"></a>-c</h3><p><code>-c</code>参数用来指定文件拷贝数据传输的加密算法</p><pre><code class="BASH">scp -c blowfish some_file your_username@remotehost.edu:~</code></pre><p>上面代码指定加密算法为 <code>blowfish</code> 。</p><h3 id="C"><a href="#C" class="headerlink" title="-C"></a>-C</h3><p><code>-C</code> 参数表示是否在传输时压缩文件。</p><pre><code class="BASH">scp -c blowfish -C local_file your_username@remotehost.edu:~</code></pre><h3 id="F"><a href="#F" class="headerlink" title="-F"></a>-F</h3><p><code>-F</code> 参数用来指定 ssh_config 文件，供 ssh 使用。</p><pre><code class="BASH">scp -F /home/pungki/proxy_ssh_config Label.pdf root@172.20.10.8:/root</code></pre><h3 id="i"><a href="#i" class="headerlink" title="-i"></a>-i</h3><p><code>-i</code> 参数用来指定密钥。</p><pre><code class="BASH">scp -vCq -i private_key.pem ~/test.txt root@192.168.1.3:/some/path/test.txt</code></pre><h3 id="l"><a href="#l" class="headerlink" title="-l"></a>-l</h3><p><code>-l</code> 参数用来限制传输数据的带宽速率，单位是 Kbit/sec。对于多人分享的带宽，这个参数可以留出一部分带宽供其他人使用。</p><pre><code class="BASH">scp -l 80 yourusername@yourserver:/home/yourusername/* .</code></pre><p>上面代码中， <code>scp</code> 命令占用的带宽限制为每秒 80K 比特位，即每秒 10K 字节。</p><h3 id="p"><a href="#p" class="headerlink" title="-p"></a>-p</h3><p><code>-p</code> 参数用来保留修改时间（modification time）、访问时间（access time）、文件状态（mode）等原始文件的信息。</p><pre><code class="BASH">scp -p ~/test.txt root@192.168.1.3:/some/path/test.txt</code></pre><h3 id="P"><a href="#P" class="headerlink" title="-P"></a>-P</h3><p><code>-P</code> 参数用来指定远程主机的 SSH 端口。如果远程主机使用默认端口22，可以不用指定，否则需要用-P参数在命令中指定。</p><pre><code class="BASH">scp -P 2222 user@host:directory/SourceFile TargetFile</code></pre><h3 id="q"><a href="#q" class="headerlink" title="-q"></a>-q</h3><p><code>-q</code> 参数用来关闭显示拷贝的进度条。</p><pre><code class="BASH">scp -q Label.pdf mrarianto@202.x.x.x:.</code></pre><h3 id="r"><a href="#r" class="headerlink" title="-r"></a>-r</h3><p><code>-r</code> 参数表示是否以递归方式复制目录。</p><h3 id="v"><a href="#v" class="headerlink" title="-v"></a>-v</h3><p><code>-v</code> 参数用来显示详细的输出。</p><pre><code class="BASH">scp -v ~/test.txt root@192.168.1.3:/root/help2356.txt</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rsync的基本使用</title>
      <link href="/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/rsync%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/rsync%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><code>rsync</code> 可以用于本地计算机的两个目录之间的同步。下面就用本地同步举例，顺便讲解 <code>rsync</code> 几个主要参数的用法。</p><a id="more"></a><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="r-参数"><a href="#r-参数" class="headerlink" title="-r 参数"></a><code>-r</code> 参数</h3><p>本机使用 <code>rsync</code> 命令时，可以作为 <code>cp</code> 和 <code>mv</code> 命令的替代方法，将源目录拷贝到目标目录。</p><pre><code class="BASH">rsync -r source destination</code></pre><p>上面命令中， <code>-r</code> 表示递归，即包含子目录。注意， <code>-r</code> 是必须的，否则 rsync 运行不会成功。 <code>source</code> 目录表示源目录， <code>destination</code> 表示目标目录。上面命令执行以后，目标目录下就会出现 <code>destination/source</code> 这个子目录</p><p>如果有多个文件或目录需要同步，可以写成下面这样</p><pre><code class="BASH">rsync -r source1 source2 destination</code></pre><p>上面命令中， <code>source1</code> 、 <code>source2</code> 都会被同步到 <code>destination</code> 目录</p><h3 id="a-参数"><a href="#a-参数" class="headerlink" title="-a 参数"></a><code>-a</code> 参数</h3><p><code>-a</code> 参数可以替代 <code>-r</code> ，除了可以递归同步以外，还可以同步元信息（比如修改时间、权限等）。由于 rsync 默认使用文件大小和修改时间决定文件是否需要更新，所以 <code>-a</code> 比 <code>-r</code> 更有用。下面的用法才是常见的写法</p><pre><code class="BASH">rsync -a source destination</code></pre><p>目标目录 <code>destination</code> 如果不存在，rsync 会自动创建。执行上面的命令后，源目录 <code>source</code> 被完整地复制到了目标目录 <code>destination</code> 下面，即形成了 <code>destination/source</code> 的目录结构。</p><p>如果只想同步源目录 <code>source</code> 里面的内容到目标目录 <code>destination</code> ，则需要在源目录后面加上斜杠.</p><pre><code class="BASH">rsync -a source/ destination</code></pre><p>上面命令执行后， <code>source</code> 目录里面的内容，就都被复制到了 <code>destination</code> 目录里面，并不会在 <code>destination</code> 下面创建一个 <code>source</code> 子目录。</p><h3 id="n-参数"><a href="#n-参数" class="headerlink" title="-n 参数"></a><code>-n</code> 参数</h3><p>如果不确定 rsync 执行后会产生什么结果，可以先用-n或–dry-run参数模拟执行的结果</p><pre><code class="BASH">rsync -anv source/ destination</code></pre><p>上面命令中， <code>-n</code> 参数模拟命令执行的结果，并不真的执行命令。 <code>-v</code> 参数则是将结果输出到终端，这样就可以看到哪些内容会被同步</p><h3 id="–delete参数"><a href="#–delete参数" class="headerlink" title="–delete参数"></a>–delete参数</h3><p>默认情况下，rsync 只确保源目录的所有内容（明确排除的文件除外）都复制到目标目录。它不会使两个目录保持相同，并且不会删除文件。如果要使得目标目录成为源目录的镜像副本，则必须使用–delete参数，这将删除只存在于目标目录、不存在于源目录的文件。</p><pre><code class="BASH">rsync -av --delete source/ destination</code></pre><p>上面命令中， <code>--delete</code> 参数会使得 <code>destination</code> 成为 <code>source</code> 的一个镜像</p><h3 id="–exclude参数"><a href="#–exclude参数" class="headerlink" title="–exclude参数"></a>–exclude参数</h3><p>有时，我们希望同步时排除某些文件或目录，这时可以用–exclude参数指定排除模式</p><pre><code class="BASH">$ rsync -av --exclude='*.txt' source/ destination# 或者$ rsync -av --exclude '*.txt' source/ destination</code></pre><p>上面命令排除了所有 TXT 文件。</p><p>注意，rsync 会同步以“点”开头的隐藏文件，如果要排除隐藏文件，可以这样写 <code>--exclude=".*"</code> 。</p><p>如果要排除某个目录里面的所有文件，但不希望排除目录本身，可以写成下面这样。</p><pre><code class="BASH">$ rsync -av --exclude 'dir1/*' source/ destination</code></pre><p>多个排除模式，可以用多个 <code>--exclude</code> 参数</p><pre><code class="BASH">rsync -av --exclude 'file1.txt' --exclude 'dir1/*' source/ destination</code></pre><p>多个排除模式也可以利用 Bash 的大扩号的扩展功能，只用一个 <code>--exclude</code> 参数</p><pre><code class="BASH">rsync -av --exclude={'file1.txt','dir1/*'} source/ destination</code></pre><p>如果排除模式很多，可以将它们写入一个文件，每个模式一行，然后用 <code>--exclude-from</code> 参数指定这个文件。</p><pre><code class="BASH">rsync -av --exclude-from='exclude-file.txt' source/ destination</code></pre><h3 id="–include参数"><a href="#–include参数" class="headerlink" title="–include参数"></a>–include参数</h3><p><code>--include</code> 参数用来指定必须同步的文件模式，往往与 <code>--exclude</code> 结合使用</p><pre><code class="BASH">rsync -av --include="*.txt" --exclude='*' source/ destination</code></pre><p>上面命令指定同步时，排除所有文件，但是会包括 TXT 文件</p><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><h3 id="SSH-协议"><a href="#SSH-协议" class="headerlink" title="SSH 协议"></a>SSH 协议</h3><p>rsync 除了支持本地两个目录之间的同步，也支持远程同步。它可以将本地内容，同步到远程服务器</p><pre><code class="BASH">rsync -av source/ username@remote_host:destination</code></pre><p>也可以将远程内容同步到本地</p><pre><code class="BASH">rsync -av username@remote_host:source/ destination</code></pre><p>rsync 默认使用 SSH 进行远程登录和数据传输。</p><p>由于早期 rsync 不使用 SSH 协议，需要用 <code>-e</code> 参数指定协议，后来才改的。所以，下面 <code>-e ssh</code> 可以省略</p><pre><code class="BASH">rsync -av -e ssh source/ user@remote_host:/destination</code></pre><p>但是，如果 ssh 命令有附加的参数，则必须使用 <code>-e</code> 参数指定所要执行的 SSH 命令</p><pre><code class="BASH">rsync -av -e 'ssh -p 2234' source/ user@remote_host:/destination</code></pre><p>上面命令中， <code>-e</code> 参数指定 SSH 使用2234端口</p><h3 id="rsync-协议"><a href="#rsync-协议" class="headerlink" title="rsync 协议"></a>rsync 协议</h3><p>除了使用 SSH，如果另一台服务器安装并运行了 rsync 守护程序，则也可以用 <code>rsync://</code> 协议（默认端口873）进行传输。具体写法是服务器与目标目录之间使用双冒号分隔 <code>::</code></p><pre><code class="BASH">rsync -av source/ 192.168.122.32::module/destination</code></pre><p>注意，上面地址中的 <code>module</code> 并不是实际路径名，而是 rsync 守护程序指定的一个资源名，由管理员分配。</p><p>如果想知道 rsync 守护程序分配的所有 module 列表，可以执行下面命令。</p><pre><code class="BASH">rsync rsync://192.168.122.32</code></pre><p>rsync 协议除了使用双冒号，也可以直接用rsync://协议指定地址。</p><pre><code class="BASH">rsync -av source/ rsync://192.168.122.32/module/destination</code></pre><h2 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h2><p>rsync 的最大特点就是它可以完成增量备份，也就是默认只复制有变动的文件。</p><p>除了源目录与目标目录直接比较，rsync 还支持使用基准目录，即将源目录与基准目录之间变动的部分，同步到目标目录。</p><p>具体做法是，第一次同步是全量备份，所有文件在基准目录里面同步一份。以后每一次同步都是增量备份，只同步源目录与基准目录之间有变动的部分，将这部分保存在一个新的目标目录。这个新的目标目录之中，也是包含所有文件，但实际上，只有那些变动过的文件是存在于该目录，其他没有变动的文件都是指向基准目录文件的硬链接。</p><p><code>--link-dest</code> 参数用来指定同步时的基准目录</p><pre><code class="BASH">rsync -a --delete --link-dest /compare/path /source/path /target/path</code></pre><p>上面命令中， <code>--link-dest</code> 参数指定基准目录 <code>/compare/path</code> ，然后源目录 <code>/source/path</code> 跟基准目录进行比较，找出变动的文件，将它们拷贝到目标目录 <code>/target/path</code> 。那些没变动的文件则会生成硬链接。这个命令的第一次备份时是全量备份，后面就都是增量备份了</p><p>下面是一个脚本示例，备份用户的主目录。</p><pre><code class="BASH">#!/bin/bash# A script to perform incremental backups using rsyncset -o errexitset -o nounsetset -o pipefailreadonly SOURCE_DIR="${HOME}"readonly BACKUP_DIR="/mnt/data/backups"readonly DATETIME="$(date '+%Y-%m-%d_%H:%M:%S')"readonly BACKUP_PATH="${BACKUP_DIR}/${DATETIME}"readonly LATEST_LINK="${BACKUP_DIR}/latest"mkdir -p "${BACKUP_DIR}"rsync -av --delete \  "${SOURCE_DIR}/" \  --link-dest "${LATEST_LINK}" \  --exclude=".cache" \  "${BACKUP_PATH}"rm -rf "${LATEST_LINK}"ln -s "${BACKUP_PATH}" "${LATEST_LINK}"</code></pre><p>上面脚本中，每一次同步都会生成一个新目录 <code>${BACKUP_DIR}/${DATETIME}</code> ，并将软链接 <code>${BACKUP_DIR}/latest</code> 指向这个目录。下一次备份时，就将 <code>${BACKUP_DIR}/latest</code> 作为基准目录，生成新的备份目录。最后，再将软链接 <code>${BACKUP_DIR}/latest</code> 指向新的备份目录</p><h2 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h2><p><code>-a</code> 、 <code>--archive</code> 参数表示存档模式，保存所有的元数据，比如修改时间（modification time）、权限、所有者等，并且软链接也会同步过去。</p><p><code>--append</code> 参数指定文件接着上次中断的地方，继续传输。</p><p><code>--append-verify</code> 参数跟 <code>--append</code> 参数类似，但会对传输完成后的文件进行一次校验。如果校验失败，将重新发送整个文件。</p><p><code>-b</code> 、 <code>--backup</code> 参数指定在删除或更新目标目录已经存在的文件时，将该文件更名后进行备份，默认行为是删除。更名规则是添加由 <code>--suffix</code> 参数指定的文件后缀名，默认是~。</p><p><code>--backup-dir</code> 参数指定文件备份时存放的目录，比如 <code>--backup-dir=/path/to/backups</code> 。</p><p><code>--bwlimit</code> 参数指定带宽限制，默认单位是 KB/s，比如 <code>--bwlimit=100</code> 。</p><p><code>-c</code> 、 <code>--checksum</code> 参数改变rsync的校验方式。默认情况下，rsync 只检查文件的大小和最后修改日期是否发生变化，如果发生变化，就重新传输；使用这个参数以后，则通过判断文件内容的校验和，决定是否重新传输。</p><p><code>--delete</code> 参数删除只存在于目标目录、不存在于源目标的文件，即保证目标目录是源目标的镜像。</p><p><code>-e</code> 参数指定使用 SSH 协议传输数据。</p><p><code>--exclude</code> 参数指定排除不进行同步的文件，比如 <code>--exclude="*.iso"</code> 。</p><p><code>--exclude-from</code> 参数指定一个本地文件，里面是需要排除的文件模式，每个模式一行。</p><p><code>--existing</code> 、 <code>--ignore-non-existing</code> 参数表示不同步目标目录中不存在的文件和目录。</p><p><code>-h</code> 参数表示以人类可读的格式输出。</p><p><code>-h</code> 、 <code>--help</code> 参数返回帮助信息。</p><p><code>-i</code> 参数表示输出源目录与目标目录之间文件差异的详细情况。</p><p><code>--ignore-existing</code> 参数表示只要该文件在目标目录中已经存在，就跳过去，不再同步这些文件。</p><p><code>--include</code> 参数指定同步时要包括的文件，一般与 <code>--exclude</code> 结合使用。</p><p><code>--link-dest</code> 参数指定增量备份的基准目录。</p><p><code>-m</code> 参数指定不同步空目录。</p><p><code>--max-size</code> 参数设置传输的最大文件的大小限制，比如不超过200KB（ <code>--max-size='200k'</code> ）。</p><p><code>--min-size</code> 参数设置传输的最小文件的大小限制，比如不小于10KB（ <code>--min-size=10k</code> ）。</p><p><code>-n</code> 参数或 <code>--dry-run</code> 参数模拟将要执行的操作，而并不真的执行。配合 <code>-v</code> 参数使用，可以看到哪些内容会被同步过去。</p><p><code>-P</code> 参数是 <code>--progress</code> 和 <code>--partial</code> 这两个参数的结合。</p><p><code>--partial</code> 参数允许恢复中断的传输。不使用该参数时，rsync会删除传输到一半被打断的文件；使用该参数后，传输到一半的文件也会同步到目标目录，下次同步时再恢复中断的传输。一般需要与 <code>--append</code> 或 <code>--append-verify</code> 配合使用。</p><p><code>--partial-dir</code> 参数指定将传输到一半的文件保存到一个临时目录，比如 <code>--partial-dir=.rsync-partial</code> 。一般需要与 <code>--append</code> 或 <code>--append-verify</code> 配合使用。</p><p><code>--progress</code> 参数表示显示进展。</p><p><code>-r</code> 参数表示递归，即包含子目录。</p><p><code>--remove-source-files</code> 参数表示传输成功后，删除发送方的文件。</p><p><code>--size-only</code> 参数表示只同步大小有变化的文件，不考虑文件修改时间的差异。</p><p><code>--suffix</code> 参数指定文件名备份时，对文件名添加的后缀，默认是~。</p><p><code>-u</code> 、 <code>--update</code> 参数表示同步时跳过目标目录中修改时间更新的文件，即不同步这些有更新的时间戳的文件。</p><p><code>-v</code> 参数表示输出细节。 <code>-vv</code> 表示输出更详细的信息， <code>-vvv</code> 表示输出最详细的信息。</p><p><code>--version</code> 参数返回 <code>rsync</code> 的版本。</p><p><code>-z</code> 参数指定同步时压缩数据</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.digitalocean.com/community/tutorials/how-to-use-rsync-to-sync-local-and-remote-directories-on-a-vps">How To Use Rsync to Sync Local and Remote Directories on a VPS</a>, Justin Ellingwood</li><li><a href="https://www.howtoforge.com/mirroring_with_rsync">Mirror Your Web Site With rsync</a>, Falko Timme</li><li><a href="https://linuxconfig.org/examples-on-how-to-use-rsync-for-local-and-remote-data-backups-and-synchonization">Examples on how to use Rsync</a>, Egidio Docile</li><li><a href="https://linuxconfig.org/how-to-create-incremental-backups-using-rsync-on-linux">How to create incremental backups using rsync on Linux</a>, Egidio Docile</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>awk统计文本中同一数据出现的次数排序</title>
      <link href="/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/awk%E7%BB%9F%E8%AE%A1%E6%96%87%E6%9C%AC%E4%B8%AD%E5%90%8C%E4%B8%80%E6%95%B0%E6%8D%AE%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <url>/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/awk%E7%BB%9F%E8%AE%A1%E6%96%87%E6%9C%AC%E4%B8%AD%E5%90%8C%E4%B8%80%E6%95%B0%E6%8D%AE%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>突然发现awk原来可以统计同一数据在要处理的文件中所出现的次数. 原来的时候 为了分析数据还自己写程序, 哎, 无语, 当时还以为自己多强, 手工分析不过来的东西写程序处理. 现在想来实在是年少轻狂. 解决问题嘛, 不讲究方式, 只要快速 高效的完成任务就OK了.</p><a id="more"></a><p>好, 今天小试牛刀统计了一下passwd文件中shell部分重复的shell名和出现的次数, 看命令:</p><pre><code class="BASH">$awk -F: '{a[$7]++}END{for (i in a) print i" "a[i]}' /etc/passwd/bin/false 13/bin/sh 18/bin/bash 2/usr/sbin/nologin 1/bin/sync 1</code></pre><h3 id="解说一下"><a href="#解说一下" class="headerlink" title="解说一下"></a>解说一下</h3><ul><li>-F: 以: 分割字段</li><li>a[7]++定义了个名称为a的数组7]++定义了个名称为a的数组7在passwd文件中是shell名，在这里是数组索引.awk的数据- 索引可以是是字符类型这点真 是太帅了.</li><li>for (i in a) print i” “a[i]</li><li>用for循环取出数据来, 这时候i取的时下标, a[i]是里面存储的数据</li><li>是$7出现的次数, 狠!</li><li>郁闷了, 这办法太强了, 以后再遇到问题还是先baidu, 再google然后再自己动手吧!</li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>后来发现，如果awk玩得不咋熟悉的话，用命令组合也可以实现同样的功能</p><pre><code class="BASH"> awk -F: '{print $7}'|sort|uniq -c /etc/passwd</code></pre><p><strong>快速统计日志文件里点击量前十位的URL</strong></p><p>关于shell命令，网上流传着很多奇技淫巧，比如说快速统计日志文件里点击量前十位的URL：</p><pre><code class="BASH">awk ‘{print $7}’ /path/to/log | sort | uniq -c | sort -nr | head -n 10</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>awk命令的基本使用</title>
      <link href="/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/awk%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/awk%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Awk  pattern scanning and processing language，对文本和数据进行处理。</p><p>awk 是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输(stdin)、一个或多个文件，或其它命令的输出。它在命令行中使用，但更多是作为脚本来使用。awk有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。</p><a id="more"></a><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><pre><code class="BASH">awk&nbsp;[options]&nbsp;'scripts'&nbsp;var=value&nbsp;filename</code></pre><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><pre><code class="BASH">-F&nbsp;指定分隔符（可以是字符串或正则表达式）-f&nbsp;从脚本文件中读取awk命令-v&nbsp;var=value&nbsp;赋值变量，将外部变量传递给awk</code></pre><h2 id="脚本基本结构"><a href="#脚本基本结构" class="headerlink" title="脚本基本结构"></a>脚本基本结构</h2><pre><code class="BASH">awk&nbsp;'BEGIN{&nbsp;print&nbsp;"start"&nbsp;}&nbsp;pattern{&nbsp;commands&nbsp;}&nbsp;END{&nbsp;print&nbsp;"end"&nbsp;}'&nbsp;filename</code></pre><p>一个awk脚本通常由BEGIN语句+模式匹配+END语句三部分组成, 这三部分都是可选项.</p><p>工作原理:</p><ul><li>第一步执行BEGIN 语句</li><li>第二步从文件或标准输入读取一行，然后再执行pattern语句，逐行扫描文件到文件全部被读取</li><li>第三步执行END语句</li></ul><p>实例展示:</p><pre><code class="BASH">echo&nbsp;"hello&nbsp;"&nbsp;|&nbsp;awk&nbsp;'BEGIN{&nbsp;print&nbsp;"welcome"&nbsp;}&nbsp;END{&nbsp;print&nbsp;"2017-08-08"&nbsp;}'welcome2017-08-08echo&nbsp;-e&nbsp;"hello"&nbsp;|&nbsp;awk&nbsp;'BEGIN{&nbsp;print&nbsp;"welcome"&nbsp;}&nbsp;{print}&nbsp;END{&nbsp;print&nbsp;"2017-08-08"&nbsp;}'welcomehello2017-08-08#不加print参数时默认只打印当前的行echo|awk&nbsp;'{&nbsp;a="hello";&nbsp;b="nihao";&nbsp;c="mingongge";&nbsp;print&nbsp;a,b,c;&nbsp;}'hello&nbsp;nihao&nbsp;mingongge#使用print以逗号分隔时，打印则是以空格分界echo|awk&nbsp;'{&nbsp;a="mgg";&nbsp;b="mingg";&nbsp;c="mingongge";&nbsp;print&nbsp;a"&nbsp;is&nbsp;"b"&nbsp;or&nbsp;"c;&nbsp;}'mgg&nbsp;is&nbsp;mingg&nbsp;or&nbsp;mingongge#awk的print语句中双引号其实就是个拼接作用</code></pre><h2 id="Awk的变量"><a href="#Awk的变量" class="headerlink" title="Awk的变量"></a>Awk的变量</h2><h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h3><pre><code class="BASH">$0&nbsp;&nbsp;&nbsp;#当前记录$1~$n&nbsp;#当前记录的第N个字段FS&nbsp;&nbsp;&nbsp;#输入字段分隔符（-F相同作用）默认空格RS&nbsp;&nbsp;&nbsp;#输入记录分割符，默认换行符NF&nbsp;&nbsp;&nbsp;#字段个数就是列 NR&nbsp;&nbsp;&nbsp;#记录数，就是行号，默认从1开始OFS&nbsp;&nbsp;#输出字段分隔符，默认空格ORS&nbsp;&nbsp;#输出记录分割符，默认换行符 </code></pre><p>外部变量</p><pre><code class="BASH">[mingongge@&nbsp;~]#a=100[mingongge@&nbsp;~]#b=100[mingongge@&nbsp;~]#echo&nbsp;|awk&nbsp;'{print&nbsp;v1*v2&nbsp;}'&nbsp;v1=$a&nbsp;v2=$b10000</code></pre><h2 id="Awk运算与判断"><a href="#Awk运算与判断" class="headerlink" title="Awk运算与判断"></a>Awk运算与判断</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><pre><code class="BASH">+&nbsp;-&nbsp;加减*&nbsp;/&nbsp;&amp;&nbsp;乘&nbsp;除&nbsp;求余^&nbsp;*&nbsp;&nbsp;求幂++&nbsp;--&nbsp;增加或减少，作为前缀或后缀</code></pre><pre><code class="BASH">[mingongge@&nbsp;~]#awk&nbsp;'BEGIN{a="b";print&nbsp;a,a++,a--,++a;}'b&nbsp;0&nbsp;1&nbsp;1[mingongge@&nbsp;~]#awk&nbsp;'BEGIN{a="0";print&nbsp;a,a++,a--,++a;}'0&nbsp;0&nbsp;1&nbsp;1[mingongge@&nbsp;~]#awk&nbsp;'BEGIN{a="0";print&nbsp;a,a++,--a,++a;}'0&nbsp;0&nbsp;0&nbsp;1#和其它编程语言一样，所有用作算术运算符进行操作，操作数自动转为数值，所有非数值都变为0</code></pre><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><pre><code class="BASH">=&nbsp;+=&nbsp;-=&nbsp;*=&nbsp;/=&nbsp;%=&nbsp;^=&nbsp;**=</code></pre><h3 id="正则运算符"><a href="#正则运算符" class="headerlink" title="正则运算符"></a>正则运算符</h3><pre><code class="BASH">~&nbsp;!~&nbsp;&nbsp;匹配正则表达式/不匹配正则表达式</code></pre><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><pre><code class="BASH">||&nbsp;&nbsp;&amp;&amp;&nbsp;&nbsp;逻辑或&nbsp;&nbsp;逻辑与</code></pre><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><pre><code class="BASH">&lt;&nbsp;&lt;=&nbsp;&gt;&nbsp;&gt;=&nbsp;!=&nbsp;= </code></pre><h3 id="其它运算符"><a href="#其它运算符" class="headerlink" title="其它运算符"></a>其它运算符</h3><pre><code class="BASH">$&nbsp;&nbsp;&nbsp;字段引用&nbsp;空格&nbsp;字符串链接符?:&nbsp;&nbsp;&nbsp;三目运算符ln&nbsp;&nbsp;&nbsp;数组中是否存在某键值</code></pre><h2 id="Awk正则"><a href="#Awk正则" class="headerlink" title="Awk正则"></a>Awk正则</h2><pre><code class="BASH">^&nbsp;&nbsp;&nbsp;&nbsp;行首定位符$&nbsp;&nbsp;&nbsp;&nbsp;行尾定位符.&nbsp;&nbsp;&nbsp;&nbsp;匹配任意单个字符*&nbsp;&nbsp;&nbsp;&nbsp;匹配0个或多个前导字符（包括回车）+&nbsp;&nbsp;&nbsp;&nbsp;匹配1个或多个前导字符?&nbsp;&nbsp;&nbsp;&nbsp;匹配0个或1个前导字符&nbsp;[]&nbsp;&nbsp;&nbsp;匹配指定字符组内的任意一个字符/^[ab][^]&nbsp;&nbsp;匹配不在指定字符组内的任意一个字符()&nbsp;&nbsp;&nbsp;子表达式|&nbsp;&nbsp;&nbsp;&nbsp;或者&nbsp;&nbsp;&nbsp;&nbsp;转义符~,!~&nbsp;匹配或不匹配的条件语句x{m}&nbsp;x字符重复m次x{m,}&nbsp;x字符至少重复m次X{m,n}&nbsp;x字符至少重复m次但不起过n次（需指定参数-posix或--re-interval）</code></pre><h2 id="Awk实例介绍"><a href="#Awk实例介绍" class="headerlink" title="Awk实例介绍"></a>Awk实例介绍</h2><pre><code class="BASH">awk&nbsp;–F&nbsp;:&nbsp;‘{print&nbsp;$2}’&nbsp;datafile#以:分隔打印第二列awk&nbsp;–F&nbsp;:&nbsp;‘/^Dan/{print&nbsp;$2}’&nbsp;datafile#以:分隔打印以Dan开头行的第二列内容awk&nbsp;–F&nbsp;:&nbsp;‘/^[CE]/{print&nbsp;$1}’&nbsp;datafile&nbsp;#打印以C或E开头行的第一列awk&nbsp;–F&nbsp;:&nbsp;‘{if(length($1)&nbsp;==&nbsp;4)&nbsp;print&nbsp;$1}’&nbsp;datafile&nbsp;#打印以:分隔且长度为4字符的第一列内容awk&nbsp;–F&nbsp;:&nbsp;‘/[916]/{print&nbsp;$1}’&nbsp;datafile#匹配916的行以:分隔打印第一列awk&nbsp;-F&nbsp;:&nbsp;'/^Vinh/{print&nbsp;"a"$5}'&nbsp;2.txt#显示以Dan开头行并在第五列前加上aawk&nbsp;–F&nbsp;:&nbsp;‘{print&nbsp;$2”,”$1}’&nbsp;&nbsp;datafile#打印第二列第一列并以,分隔awk&nbsp;-F&nbsp;:&nbsp;'($5&nbsp;==&nbsp;68900)&nbsp;{print&nbsp;$1}'&nbsp;2.txt#以:分隔打印第五列是68900的行第一列 awk&nbsp;-F&nbsp;:&nbsp;'{if(length($1)&nbsp;==&nbsp;11)&nbsp;print&nbsp;$1}'&nbsp;2.txt#打印以:分隔且长度为4字符的第一列内容awk&nbsp;-F&nbsp;:&nbsp;'$1~/Tommy&nbsp;Savage/&nbsp;{print&nbsp;$5}'&nbsp;2.txtawk&nbsp;-F&nbsp;:&nbsp;'($1&nbsp;==&nbsp;"Tommy&nbsp;Savage")&nbsp;{print&nbsp;$5}'&nbsp;2.txt#打印以:分隔且第一列为Tommy&nbsp;Savage的第五列内容ll&nbsp;|awk&nbsp;'BEGIN&nbsp;{size=0;}&nbsp;{size=size+$5;}&nbsp;END{print&nbsp;"[end]size&nbsp;is&nbsp;",size}'#统计目录个的文件所有的字节数awk&nbsp;'BEGIN{size=0;}&nbsp;{size=size+$5;}&nbsp;END{print&nbsp;"[end]size&nbsp;is&nbsp;",size/1024/1024,"M"}'&nbsp;#以M为单位显示目录下的所有字节数awk&nbsp;'BEGIN{a=10;a+=10;print&nbsp;a}'20&nbsp;#a+10等价于&nbsp;a=a+10echo|awk&nbsp;'BEGIN{a="100testaaa"}a~/test/{print&nbsp;"ok"}'&nbsp;#正则匹配a&nbsp;是否有test字符，成立打印okawk&nbsp;'BEGIN{a="b";print&nbsp;a=="b"?"ok":"err"}'okawk&nbsp;'BEGIN{a="b";print&nbsp;a=="c"?"ok":"err"}'err#三目运算符?:awk&nbsp;'/root/{print&nbsp;$0}'&nbsp;passwd&nbsp;#匹配所有包含root的行awk&nbsp;-F:&nbsp;'$5~/root/{print&nbsp;$0}'&nbsp;passwd&nbsp;#&nbsp;以分号作为分隔符，匹配第5个字段是root的行ifconfig&nbsp;eth0|awk&nbsp;'BEGIN{FS="[[:space:]:]+"}&nbsp;NR==2{print&nbsp;$4}'#打印IP地址awk&nbsp;'{print&nbsp;toupper($0)}'&nbsp;test.txt#toupper是awk内置函数，将所小写字母转换成大写</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cron基本的使用</title>
      <link href="/My-Blogs/2021/01/08/Linux/shell/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/cron%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/My-Blogs/2021/01/08/Linux/shell/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/cron%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>先来看一张图</p><a id="more"></a><p><img src="/My-Blogs/images/cron%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-01.png"></p><pre><code class="BASH">#编辑crontab任务vim /etc/crontab# 启动crontabsudo /etc/init.d/cron start#停止crontabsudo /etc/init.d/cron stop#重启crontabsudo /etc/init.d/cron restart#重载/etc/crontab配置sudo /etc/init.d/cron reload# 强制重载/etc/crontab配置sudo /etc/init.d/cron force-reload# 查看crontab服务状态sudo /etc/init.d/cron status# 查看crontab运行记录tail -f /var/log/cron.log# 查看最近十行crontab运行记录tail -n /var/log/cron.log</code></pre><h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><h3 id="crontab不运行"><a href="#crontab不运行" class="headerlink" title="crontab不运行"></a>crontab不运行</h3><ol><li> 查看配置是否正确 比如有没’等特殊符号 时间设置是否有错</li><li> 查看crontab服务状态</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes 组件介绍</title>
      <link href="/My-Blogs/2021/01/08/k8s/Kubernetes%E7%BB%84%E4%BB%B6/"/>
      <url>/My-Blogs/2021/01/08/k8s/Kubernetes%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Kubernetes-组件"><a href="#Kubernetes-组件" class="headerlink" title="Kubernetes 组件"></a>Kubernetes 组件</h2><a id="more"></a><p><strong>Kubernetes 集群由代表控制平面的组件和一组称为节点的机器组成。</strong></p><p>当你部署完 Kubernetes, 即拥有了一个完整的集群。</p><p>一个 Kubernetes 集群包含 集群由一组被称作节点的机器组成。这些节点上运行 Kubernetes 所管理的容器化应用。集群具有至少一个工作节点。</p><p>工作节点托管作为应用负载的组件的 Pod 。控制平面管理集群中的工作节点和 Pod 。 为集群提供故障转移和高可用性，这些控制平面一般跨多主机运行，集群跨多个节点运行。</p><p>本文档概述了交付正常运行的 Kubernetes 集群所需的各种组件。</p><p>这张图表展示了包含所有相互关联组件的 Kubernetes 集群。</p><p>![Kubernetes 组件](/images/Kubernetes 组件-01.svg)</p><h3 id="控制平面组件（Control-Plane-Components）"><a href="#控制平面组件（Control-Plane-Components）" class="headerlink" title="控制平面组件（Control Plane Components）"></a>控制平面组件（Control Plane Components）<a href="#control-plane-components"></a></h3><p>控制平面的组件对集群做出全局决策(比如调度)，以及检测和响应集群事件（例如，当不满足部署的 <code>replicas</code> 字段时，启动新的 <a href="/docs/concepts/workloads/pods/pod-overview/">pod</a>）。</p><p>控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件，并且不会在此计算机上运行用户容器。 请参阅<a href="/zh/docs/setup/production-environment/tools/kubeadm/high-availability/">构建高可用性集群</a> 中对于多主机 VM 的设置示例。</p><h4 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver<a href="#kube-apiserver"></a></h4><p>API 服务器是 Kubernetes <a href="/zh/docs/reference/glossary/?all=true#term-control-plane">控制面</a>的组件， 该组件公开了 Kubernetes API。 API 服务器是 Kubernetes 控制面的前端。</p><p>Kubernetes API 服务器的主要实现是 <a href="/zh/docs/reference/command-line-tools-reference/kube-apiserver/">kube-apiserver</a>。 kube-apiserver 设计上考虑了水平伸缩，也就是说，它可通过部署多个实例进行伸缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。</p><h4 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd<a href="#etcd"></a></h4><p>etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。</p><p>您的 Kubernetes 集群的 etcd 数据库通常需要有个备份计划。</p><p>要了解 etcd 更深层次的信息，请参考 <a href="https://etcd.io/docs/">etcd 文档</a>。</p><h4 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler<a href="#kube-scheduler"></a></h4><p>主节点上的组件，该组件监视那些新创建的未指定运行节点的 Pod，并选择节点让 Pod 在上面运行。</p><p>调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。</p><h4 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager<a href="#kube-controller-manager"></a></h4><p>在主节点上运行 <a href="/zh/docs/concepts/architecture/controller/">控制器</a> 的组件。</p><p>从逻辑上讲，每个<a href="/zh/docs/concepts/architecture/controller/">控制器</a>都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。</p><p>这些控制器包括:</p><ul><li>  节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应。</li><li>  副本控制器（Replication Controller）: 负责为系统中的每个副本控制器对象维护正确数量的 Pod。</li><li>  端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)。</li><li>  服务帐户和令牌控制器（Service Account &amp; Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌.</li></ul><h4 id="cloud-controller-manager"><a href="#cloud-controller-manager" class="headerlink" title="cloud-controller-manager"></a>cloud-controller-manager<a href="#cloud-controller-manager"></a></h4><p>云控制器管理器是指嵌入特定云的控制逻辑的 <a href="/zh/docs/reference/glossary/?all=true#term-control-plane">控制平面</a>组件。 云控制器管理器允许您链接聚合到云提供商的应用编程接口中， 并分离出相互作用的组件与您的集群交互的组件。</p><p><code>cloud-controller-manager</code> 仅运行特定于云平台的控制回路。 如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的环境中不需要云控制器管理器。</p><p>与 <code>kube-controller-manager</code> 类似， <code>cloud-controller-manager</code> 将若干逻辑上独立的 控制回路组合到同一个可执行文件中，供你以同一进程的方式运行。 你可以对其执行水平扩容（运行不止一个副本）以提升性能或者增强容错能力。</p><p>下面的控制器都包含对云平台驱动的依赖：</p><ul><li>  节点控制器（Node Controller）: 用于在节点终止响应后检查云提供商以确定节点是否已被删除</li><li>  路由控制器（Route Controller）: 用于在底层云基础架构中设置路由</li><li>  服务控制器（Service Controller）: 用于创建、更新和删除云提供商负载均衡器</li></ul><h3 id="Node-组件"><a href="#Node-组件" class="headerlink" title="Node 组件"></a>Node 组件<a href="#node-components"></a></h3><p>节点组件在每个节点上运行，维护运行的 Pod 并提供 Kubernetes 运行环境。</p><h4 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet<a href="#kubelet"></a></h4><p>一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。</p><p>kubelet 接收一组通过各类机制提供给它的 PodSpecs，确保这些 PodSpecs 中描述的容器处于运行状态且健康。kubelet 不会管理不是由 Kubernetes 创建的容器。</p><h4 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy<a href="#kube-proxy"></a></h4><p><a href="/zh/docs/reference/command-line-tools-reference/kube-proxy/">kube-proxy</a> 是集群中每个节点上运行的网络代理， 实现 Kubernetes <a href="/zh/docs/concepts/services-networking/service/">服务（Service）</a> 概念的一部分。</p><p>kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p><p>如果操作系统提供了数据包过滤层并可用的话，kube-proxy 会通过它来实现网络规则。否则， kube-proxy 仅转发流量本身。</p><h4 id="容器运行时（Container-Runtime）"><a href="#容器运行时（Container-Runtime）" class="headerlink" title="容器运行时（Container Runtime）"></a>容器运行时（Container Runtime）<a href="#container-runtime"></a></h4><p>容器运行环境是负责运行容器的软件。</p><p>Kubernetes 支持多个容器运行环境: <a href="/zh/docs/reference/kubectl/docker-cli-to-kubectl/">Docker</a>、 <a href="https://containerd.io/docs/">containerd</a>、<a href="https://cri-o.io/#what-is-cri-o">CRI-O</a> 以及任何实现 <a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md">Kubernetes CRI (容器运行环境接口)</a>。</p><h3 id="插件（Addons）"><a href="#插件（Addons）" class="headerlink" title="插件（Addons）"></a>插件（Addons）<a href="#addons"></a></h3><p>插件使用 Kubernetes 资源（<a href="/zh/docs/concepts/workloads/controllers/daemonset/">DaemonSet</a>、 <a href="/zh/docs/concepts/workloads/controllers/deployment/">Deployment</a>等）实现集群功能。 因为这些插件提供集群级别的功能，插件中命名空间域的资源属于 <code>kube-system</code> 命名空间。</p><p>下面描述众多插件中的几种。有关可用插件的完整列表，请参见 <a href="/zh/docs/concepts/cluster-administration/addons/">插件（Addons）</a>。</p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS<a href="#dns"></a></h4><p>尽管其他插件都并非严格意义上的必需组件，但几乎所有 Kubernetes 集群都应该 有<a href="/zh/docs/concepts/services-networking/dns-pod-service/">集群 DNS</a>， 因为很多示例都需要 DNS 服务。</p><p>集群 DNS 是一个 DNS 服务器，和环境中的其他 DNS 服务器一起工作，它为 Kubernetes 服务提供 DNS 记录。</p><p>Kubernetes 启动的容器自动将此 DNS 服务器包含在其 DNS 搜索列表中。</p><h4 id="Web-界面（仪表盘）"><a href="#Web-界面（仪表盘）" class="headerlink" title="Web 界面（仪表盘）"></a>Web 界面（仪表盘）<a href="#web-%E7%95%8C%E9%9D%A2-%E4%BB%AA%E8%A1%A8%E7%9B%98"></a></h4><p><a href="/zh/docs/tasks/access-application-cluster/web-ui-dashboard/">Dashboard</a> 是Kubernetes 集群的通用的、基于 Web 的用户界面。 它使用户可以管理集群中运行的应用程序以及集群本身并进行故障排除。</p><h4 id="容器资源监控"><a href="#容器资源监控" class="headerlink" title="容器资源监控"></a>容器资源监控<a href="#%E5%AE%B9%E5%99%A8%E8%B5%84%E6%BA%90%E7%9B%91%E6%8E%A7"></a></h4><p><a href="/zh/docs/tasks/debug-application-cluster/resource-usage-monitoring/">容器资源监控</a> 将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中，并提供用于浏览这些数据的界面。</p><h4 id="集群层面日志"><a href="#集群层面日志" class="headerlink" title="集群层面日志"></a>集群层面日志<a href="#%E9%9B%86%E7%BE%A4%E5%B1%82%E9%9D%A2%E6%97%A5%E5%BF%97"></a></h4><p><a href="/zh/docs/concepts/cluster-administration/logging/">集群层面日志</a> 机制负责将容器的日志数据 保存到一个集中的日志存储中，该存储能够提供搜索和浏览接口。</p>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七张图了解k8s内部的架构</title>
      <link href="/My-Blogs/2021/01/08/k8s/%E4%B8%83%E5%BC%A0%E5%9B%BE%E4%BA%86%E8%A7%A3k8s%E5%86%85%E9%83%A8%E7%9A%84%E6%9E%B6%E6%9E%84/"/>
      <url>/My-Blogs/2021/01/08/k8s/%E4%B8%83%E5%BC%A0%E5%9B%BE%E4%BA%86%E8%A7%A3k8s%E5%86%85%E9%83%A8%E7%9A%84%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>七张图，带你走进k8s的世界</p><a id="more"></a><h3 id="Kubernetes架构和组成"><a href="#Kubernetes架构和组成" class="headerlink" title="Kubernetes架构和组成"></a>Kubernetes架构和组成</h3><p><code>Kubernetes</code> 具有去中心化的架构，不会线性处理任务。它基于声明性模型运行并实现”所需状态”的概念。下面这些步骤说明了 <code>Kubernetes</code> 的基本过程:</p><ul><li>管理员创建应用程序的所需状态并将其放入清单文件manifest.yml中。</li><li>使用CLI或提供的用户界面将清单文件提供给 <code>Kubernetes API Server</code>。 <code>Kubernetes</code>的默认命令行工具称为kubectl。</li><li><code>Kubernetes</code>将清单文件（描述了应用程序的期望状态）存储在称为键值存储（etcd）的数据库中。</li><li><code>Kubernetes</code>随后在集群内的所有相关应用程序上实现所需的状态。</li><li><code>Kubernetes</code>持续监控集群的元素，以确保应用程序的当前状态不会与所需状态有所不同。</li></ul><p><img src="/My-Blogs/images/%E4%B8%83%E5%BC%A0%E5%9B%BE%E4%BA%86%E8%A7%A3k8s%E5%86%85%E9%83%A8%E7%9A%84%E6%9E%B6%E6%9E%84-01.png" alt="image"></p><h3 id="主节点"><a href="#主节点" class="headerlink" title="主节点"></a>主节点</h3><p><code>Kubernetes</code> 的主节点通过API从CLI（命令行界面）或UI（用户界面）接收输入。这些是你提供给 <code>Kubernetes</code> 的命令。</p><p>你可以定义想要让 <code>Kubernetes</code> 维护的Pod，副本集和Service。例如，要使用的容器镜像，要公开的端口以及要运行的Pod副本数量。还可以为该集群中运行的应用程序提供”所需状态”的参数。</p><p><img src="/My-Blogs/images/%E4%B8%83%E5%BC%A0%E5%9B%BE%E4%BA%86%E8%A7%A3k8s%E5%86%85%E9%83%A8%E7%9A%84%E6%9E%B6%E6%9E%84-02.png" alt="image"></p><h4 id="API-Server"><a href="#API-Server" class="headerlink" title="API Server"></a>API Server</h4><p>API Server是Kubernetes控制程序的前端，也是用户唯一可以直接进行交互的Kubernetes组件，内部系统组件以及外部用户组件均通过相同的API进行通信。</p><h4 id="键值存储etcd"><a href="#键值存储etcd" class="headerlink" title="键值存储etcd"></a>键值存储etcd</h4><p>键值存储（也称为etcd）是Kubernetes用来备份所有集群数据的数据库。它存储集群的整个配置和状态。主节点查询etcd以检索节点，容器和容器的状态参数。</p><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><p>控制器的作用是从API Server获得所需状态。它检查要控制的节点的当前状态，确定是否与所需状态存在任何差异，并解决它们（如果有）。</p><h4 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h4><p>调度程序会监视来自API Server的新请求，并将其分配给运行状况良好的节点。它对节点的质量进行排名，并将Pod部署到最适合的节点。如果没有合适的节点，则将Pod置于挂起状态，直到出现合适的节点。</p><blockquote><p>注意：最好不要在主节点上运行用户应用程序。让Kubernetes主节点可以完全专注于管理集群。</p></blockquote><h3 id="工作节点"><a href="#工作节点" class="headerlink" title="工作节点"></a>工作节点</h3><p>工作节点监听API Server发送过来的新的工作分配；他们会执行分配给他们的工作，然后将结果报告给Kubernetes主节点。</p><p><img src="/My-Blogs/images/%E4%B8%83%E5%BC%A0%E5%9B%BE%E4%BA%86%E8%A7%A3k8s%E5%86%85%E9%83%A8%E7%9A%84%E6%9E%B6%E6%9E%84-03.png" alt="image"></p><h4 id="Kubelet"><a href="#Kubelet" class="headerlink" title="Kubelet"></a>Kubelet</h4><p>kubelet在群集中的每个节点上运行。它是Kubernetes内部的主要代理。通过安装kubelet，节点的CPU，RAM和存储成为所处集群的一部分。它监视从API Server发送来的任务，执行任务，并报告给主节点。它还会监视Pod，如果Pod不能完全正常运行，则会向控制程序报告。然后，基于该信息，主服务器可以决定如何分配任务和资源以达到所需状态。</p><h4 id="Container-Runtime"><a href="#Container-Runtime" class="headerlink" title="Container Runtime"></a>Container Runtime</h4><p>容器运行时从容器镜像库中拉取镜像，然后启动和停止容器。容器运行时由第三方软件或插件（例如Docker）担当。</p><h4 id="Kube-proxy"><a href="#Kube-proxy" class="headerlink" title="Kube-proxy"></a>Kube-proxy</h4><p>kube-proxy确保每个节点都获得其IP地址，实现本地iptables和规则以处理路由和流量负载均衡。</p><h4 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h4><p>在Kubernetes中，Pod是调度的最小元素。没有它，容器就不能成为集群的一部分。如果你需要扩展应用程序，则只能通过添加或删除Pod来实现。</p><p>Pod是Kubernetes中一个抽象化概念，由一个或多个容器组合在一起得共享资源。根据资源的可用性，主节点会把Pod调度到特定工作节点上，并与容器运行时协调以启动容器。</p><p><img src="/My-Blogs/images/%E4%B8%83%E5%BC%A0%E5%9B%BE%E4%BA%86%E8%A7%A3k8s%E5%86%85%E9%83%A8%E7%9A%84%E6%9E%B6%E6%9E%84-04.png" alt="image"></p><p>在Pod意外无法执行任务的情况下，Kubernetes不会尝试修复它们。相反，它会在其位置创建并启动一个新Pod。这个新Pod是原来的副本，除了DNS和IP地址都和以前的Pod一样。此功能对开发人员设计应用程序的方式产生了深远的影响。</p><p>由于Kubernetes架构的灵活性，不再需要将应用程序绑定到Pod的特定实例。取而代之的是，需要对应用程序进行设计，以便在集群内任何位置创建的全新Pod可以无缝取代旧Pod。Kubernetes会使用Service来协助此过程。</p><h3 id="Kubernetes-Service"><a href="#Kubernetes-Service" class="headerlink" title="Kubernetes Service"></a>Kubernetes Service</h3><p>Pod不是恒定的。 Kubernetes提供的最佳功能之一是无法正常运行的Pod会自动被新的Pod取代。</p><p>但是，这些新的Pod具有一组不同的IP。这可能导致处理问题，并且由于IP不再匹配，IP流失。如果无人看管，此属性将使吊舱高度不可靠。</p><p>为了将稳定的IP地址和DNS名称引入到不稳定的Pod世界中，Kubernetes引入了Service来提供可靠的网络连接。</p><p>通过控制进出Pod的流量，Service提供了稳定的网络终结点-固定的IP，DNS和端口。有了Service，可以添加或删除任何Pod，而不必担心基本网络信息会改变。</p><h4 id="Service是怎么工作的"><a href="#Service是怎么工作的" class="headerlink" title="Service是怎么工作的"></a>Service是怎么工作的</h4><p>Pod通过称为标签（Label）和选择器（Selector）的键值对与Service相关联。Service会自动发现带有与选择器匹配的标签的新Pod。</p><p>此过程无缝地将新的Pod添加到Service，同时，从群集中删除已终止的Pod。</p><p>例如，如果所需状态定义了需要一个Pod的三个副本，而运行一个副本的节点发生故障，则当前状态将减少为两个Pod。Kubernetes观察到所需的状态是三个Pod。然后，它会调度一个新副本来代替发生故障的Pod，并将其分配给集群中的另一个节点。</p><p>通过添加或删除容器来更新或缩放应用程序时，同样适用。一旦我们更新了所需状态的定义，Kubernetes就会注意到差异并添加或删除Pod以匹配清单文件manifest.yml里定义的所需状态。Kubernetes控制面板记录，实现和运行后台协调循环，该循环会不断检查环境是否符合用户定义的环境要求</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/My-Blogs/images/%E4%B8%83%E5%BC%A0%E5%9B%BE%E4%BA%86%E8%A7%A3k8s%E5%86%85%E9%83%A8%E7%9A%84%E6%9E%B6%E6%9E%84-05.svg" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊前端大文件上传</title>
      <link href="/My-Blogs/2021/01/08/JavaScript/%E8%81%8A%E8%81%8A%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/My-Blogs/2021/01/08/JavaScript/%E8%81%8A%E8%81%8A%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<p>前端文件上传似乎是个说不完的话题，让我们来总结下目前主要的一些上传方式吧</p><a id="more"></a><h2 id="文件上传的几种方式"><a href="#文件上传的几种方式" class="headerlink" title="文件上传的几种方式"></a>文件上传的几种方式</h2><h3 id="普通表单上传"><a href="#普通表单上传" class="headerlink" title="普通表单上传"></a>普通表单上传</h3><p>使用PHP来展示常规的表单上传是一个不错的选择。首先构建文件上传的表单，并指定表单的提交内容类型为enctype=”multipart/form-data”，表明表单需要上传二进制数据。</p><pre><code class="HTML">&lt;form action="/index.php" method="POST" enctype="multipart/form-data"&gt;  &lt;input type="file" name="myfile"&gt;  &lt;input type="submit"&gt;&lt;/form&gt;</code></pre><p>然后编写index.php上传文件接收代码，使用move_uploaded_file方法即可(php大法好…)</p><pre><code class="PHP">$imgName = 'IMG'.time().'.'.str_replace('image/','',$_FILES["myfile"]['type']);$fileName =  'upload/'.$imgName;// 移动上传文件至指定upload文件夹下，并根据返回值判断操作是否成功if (move_uploaded_file($_FILES['myfile']['tmp_name'], $fileName)){    echo $fileName;}else {    echo "nonn";}</code></pre><p>form表单上传大文件时，很容易遇见服务器超时的问题。通过xhr，前端也可以进行异步上传文件的操作，一般由两个思路。</p><h3 id="文件编码上传"><a href="#文件编码上传" class="headerlink" title="文件编码上传"></a>文件编码上传</h3><p>第一个思路是将文件进行编码，然后在服务端进行解码，之前写过一篇在前端实现图片压缩上传的博客，其主要实现原理就是将图片转换成base64进行传递</p><pre><code class="js">var imgURL = URL.createObjectURL(file);ctx.drawImage(imgURL, 0, 0);// 获取图片的编码，然后将图片当做是一个很长的字符串进行传递var data = canvas.toDataURL("image/jpeg", 0.5); </code></pre><p>在服务端需要做的事情也比较简单，首先解码base64，然后保存图片即可</p><pre><code class="PHP">$imgData = $_REQUEST['imgData'];$base64 = explode(',', $imgData)[1];$img = base64_decode($base64);$url = './test.jpg';if (file_put_contents($url, $img)) {    exit(json_encode(array(        url =&gt; $url    )));}</code></pre><p>base64编码的缺点在于其体积比原图片更大（因为Base64将三个字节转化成四个字节，因此编码后的文本，会比原文本大出三分之一左右），对于体积很大的文件来说，上传和解析的时间会明显增加。</p><p>更多关于base64的知识，可以参考Base64笔记。</p><p>除了进行base64编码，还可以在前端直接读取文件内容后以二进制格式上传</p><pre><code class="JS">// 读取二进制文件function readBinary(text){   var data = new ArrayBuffer(text.length);   var ui8a = new Uint8Array(data, 0);   for (var i = 0; i &lt; text.length; i++){      ui8a[i] = (text.charCodeAt(i) &amp; 0xff);   }   console.log(ui8a)}var reader = new FileReader();reader.onload = function(){      readBinary(this.result) // 读取result或直接上传}// 把从input里读取的文件内容，放到fileReader的result字段里reader.readAsBinaryString(file);</code></pre><h3 id="formData异步上传"><a href="#formData异步上传" class="headerlink" title="formData异步上传"></a>formData异步上传</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/Using_FormData_Objects">FormData</a><br>对象主要用来组装一组用 XMLHttpRequest发送请求的键/值对，可以更加灵活地发送Ajax请求。可以使用FormData来模拟表单提交。</p><pre><code class="JS">let files = e.target.files // 获取input的file对象let formData = new FormData();formData.append('file', file);axios.post(url, formData);</code></pre><p>服务端处理方式与直接form表单请求基本相同。</p><h3 id="iframe无刷新页面"><a href="#iframe无刷新页面" class="headerlink" title="iframe无刷新页面"></a>iframe无刷新页面</h3><p>在低版本的浏览器（如IE）上，xhr是不支持直接上传formdata的，因此只能用form来上传文件，而form提交本身会进行页面跳转，这是因为form表单的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/form">target</a>属性导致的，其取值有</p><ul><li>_self，默认值，在相同的窗口中打开响应页面</li><li>_blank，在新窗口打开</li><li>_parent，在父窗口打开</li><li>_top，在最顶层的窗口打开</li><li>framename，在指定名字的iframe中打开</li></ul><p>如果需要让用户体验异步上传文件的感觉，可以通过framename指定<code>iframe</code>来实现。把form的target属性设置为一个看不见的iframe，那么返回的数据就会被这个iframe接受，因此只有该iframe会被刷新，至于返回结果，也可以通过解析这个iframe内的文本来获取。</p><pre><code class="JS">function upload(){    var now = +new Date()    var id = 'frame' + now    $("body").append(`&lt;iframe  name="${id}" id="${id}" /&gt;`);    var $form = $("#myForm")    $form.attr({        "action": '/index.php',        "method": "post",        "enctype": "multipart/form-data",        "encoding": "multipart/form-data",        "target": id    }).submit()    $("#"+id).on("load", function(){        var content = $(this).contents().find("body").text()        try{            var data = JSON.parse(content)        }catch(e){            console.log(e)        }    })}</code></pre><h2 id="大文件上传"><a href="#大文件上传" class="headerlink" title="大文件上传"></a>大文件上传</h2><p>现在来看看在上面提到的几种上传方式中实现大文件上传会遇见的超时问题，</p><ul><li>表单上传和iframe无刷新页面上传，实际上都是通过form标签进行上传文件，这种方式将整个请求完全交给浏览器处理，当上传大文件时，可能会遇见请求超时的情形</li><li>通过fromData，其实际也是在xhr中封装一组请求参数，用来模拟表单请求，无法避免大文件上传超时的问题</li><li>编码上传，我们可以比较灵活地控制上传的内容</li></ul><p>大文件上传最主要的问题就在于：<strong>在同一个请求中，要上传大量的数据，导致整个过程会比较漫长，且失败后需要重头开始上传</strong>。试想，如果我们将这个请求拆分成多个请求，每个请求的时间就会缩短，且如果某个请求失败，只需要重新发送这一次请求即可，无需从头开始，这样是否可以解决大文件上传的问题呢？</p><p>综合上面的问题，看来大文件上传需要实现下面几个需求</p><ul><li>支持拆分上传请求(即切片)</li><li>支持断点续传</li><li>支持显示上传进度和暂停上传</li></ul><p>接下来让我们依次实现这些功能，看起来最主要的功能应该就是切片了</p><h3 id="文件切片"><a href="#文件切片" class="headerlink" title="文件切片"></a>文件切片</h3><p>参考： <a href="https://blog.csdn.net/baochao95/article/details/52812876">大文件切割上传</a></p><p>编码方式上传中，在前端我们只要先获取文件的二进制内容，然后对其内容进行拆分，最后将每个切片上传到服务端即可。</p><p>在JavaScript中，文件FIle对象是Blob对象的子类，Blob对象包含一个重要的方法<code>slice</code>，通过这个方法，我们就可以对二进制文件进行拆分。</p><p>下面是一个拆分文件的示例</p><pre><code class="JS">function slice(file, piece = 1024 * 1024 * 5) {  let totalSize = file.size; // 文件总大小  let start = 0; // 每次上传的开始字节  let end = start + piece; // 每次上传的结尾字节  let chunks = []  while (start &lt; totalSize) {    // 根据长度截取每次需要上传的数据    // File对象继承自Blob对象，因此包含slice方法    let blob = file.slice(start, end);     chunks.push(blob)    start = end;    end = start + piece;  }  return chunks}</code></pre><p>将文件拆分成<code>piece</code>大小的分块，然后每次请求只需要上传这一个部分的分块即可</p><pre><code class="JS">let file =  document.querySelector("[name=file]").files[0];const LENGTH = 1024 * 1024 * 0.1;let chunks = slice(file, LENGTH); // 首先拆分切片chunks.forEach(chunk=&gt;{  let fd = new FormData();  fd.append("file", chunk);  post('/mkblk.php', fd)})</code></pre><p>服务器接收到这些切片后，再将他们拼接起来就可以了，下面是PHP拼接切片的示例代码</p><pre><code class="JS">$filename = './upload/' . $_POST['filename'];//确定上传的文件名//第一次上传时没有文件，就创建文件，此后上传只需要把数据追加到此文件中if(!file_exists($filename)){    move_uploaded_file($_FILES['file']['tmp_name'],$filename);}else{    file_put_contents($filename,file_get_contents($_FILES['file']['tmp_name']),FILE_APPEND);    echo $filename;}</code></pre><p>测试时记得修改nginx的server配置，否则大文件可能会提示<code>413 Request Entity Too Large</code>的错误。</p><pre><code class="NGINX">server {    // ...    client_max_body_size 50m;}</code></pre><p>上面这种方式来存在一些问题</p><ul><li>无法识别一个切片是属于哪一个切片的，当同时发生多个请求时，追加的文件内容会出错</li><li>切片上传接口是异步的，无法保证服务器接收到的切片是按照请求顺序拼接的<br>因此接下来我们来看看应该如何在服务端还原切片。</li></ul><h3 id="还原切片"><a href="#还原切片" class="headerlink" title="还原切片"></a>还原切片</h3><p>在后端需要将多个相同文件的切片还原成一个文件，上面这种处理切片的做法存在下面几个问题</p><ul><li><p>如何识别多个切片是来自于同一个文件的，这个可以在每个切片请求上传递一个相同文件的<code>context</code>参数</p></li><li><p>如何将多个切片还原成一个文件</p><ul><li>确认所有切片都已上传，这个可以通过客户端在切片全部上传后调用mkfile接口来通知服务端进行拼接</li><li>找到同一个context下的所有切片，确认每个切片的顺序，这个可以在每个切片上标记一个位置索引值</li><li>按顺序拼接切片，还原成文件<br>上面有一个重要的参数，即<code>context</code>，我们需要获取为一个文件的唯一标识，可以通过下面两种方式获取</li></ul></li><li><p>根据文件名、文件长度等基本信息进行拼接，为了避免多个用户上传相同的文件，可以再额外拼接用户信息如uid等保证唯一性</p></li><li><p>根据文件的二进制内容计算文件的hash，这样只要文件内容不一样，则标识也会不一样，缺点在于计算量比较大.</p></li></ul><p>修改上传代码，增加相关参数</p><pre><code class="JS">// 获取context，同一个文件会返回相同的值function createContext(file) {     return file.name + file.length}let file = document.querySelector("[name=file]").files[0];const LENGTH = 1024 * 1024 * 0.1;let chunks = slice(file, LENGTH);// 获取对于同一个文件，获取其的contextlet context = createContext(file);let tasks = [];chunks.forEach((chunk, index) =&gt; {  let fd = new FormData();  fd.append("file", chunk);  // 传递context  fd.append("context", context);  // 传递切片索引值  fd.append("chunk", index + 1);  tasks.push(post("/mkblk.php", fd));});// 所有切片上传完毕后，调用mkfile接口Promise.all(tasks).then(res =&gt; {  let fd = new FormData();  fd.append("context", context);  fd.append("chunks", chunks.length);  post("/mkfile.php", fd).then(res =&gt; {    console.log(res);  });});</code></pre><p>在<code>mkblk.php</code>接口中，我们通过<code>context</code>来保存同一个文件相关的切片</p><pre><code class="PHP">// mkblk.php$context = $_POST['context'];$path = './upload/' . $context;if(!is_dir($path)){    mkdir($path);}// 把同一个文件的切片放在相同的目录下$filename = $path .'/'. $_POST['chunk'];$res = move_uploaded_file($_FILES['file']['tmp_name'],$filename);</code></pre><p>除了上面这种简单通过目录区分切片的方法之外，还可以将切片信息保存在数据库来进行索引。接下来是<code>mkfile.php</code>接口的实现，这个接口会在所有切片上传后调用</p><pre><code class="PHP">// mkfile.php$context = $_POST['context'];$chunks = (int)$_POST['chunks'];//合并后的文件名$filename = './upload/' . $context . '/file.jpg'; for($i = 1; $i &lt;= $chunks; ++$i){    $file = './upload/'.$context. '/' .$i; // 读取单个切块    $content = file_get_contents($file);    if(!file_exists($filename)){        $fd = fopen($filename, "w+");    }else{        $fd = fopen($filename, "a");    }    fwrite($fd, $content); // 将切块合并到一个文件上}echo $filename;</code></pre><p>这样就解决了上面的两个问题：</p><ul><li>识别切片来源</li><li>保证切片拼接顺序</li></ul><h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p>即使将大文件拆分成切片上传，我们仍需等待所有切片上传完毕，在等待过程中，可能发生一系列导致部分切片上传失败的情形，如网络故障、页面关闭等。由于切片未全部上传，因此无法通知服务端合成文件。这种情况下可以通过<strong>断点续传</strong>来进行处理。</p><p>断点续传指的是：可以从已经上传部分开始继续上传未完成的部分，而没有必要从头开始上传，节省上传时间。</p><p>由于整个上传过程是按切片维度进行的，且<code>mkfile</code>接口是在所有切片上传完成后由客户端主动调用的，因此断点续传的实现也十分简单：</p><ul><li>在切片上传成功后，保存已上传的切片信息</li><li>当下次传输相同文件时，遍历切片列表，只选择未上传的切片进行上传</li><li>所有切片上传完毕后，再调用<code>mkfile</code>接口通知服务端进行文件合并</li></ul><p>因此问题就落在了如何保存已上传切片的信息了，保存一般有两种策略</p><ul><li>可以通过locaStorage等方式保存在前端浏览器中，这种方式不依赖于服务端，实现起来也比较方便，缺点在于如果用户清除了本地文件，会导致上传记录丢失</li><li>服务端本身知道哪些切片已经上传，因此可以由服务端额外提供一个根据文件context查询已上传切片的接口，在上传文件前调用该文件的历史上传记录</li></ul><p>下面让我们通过在本地保存已上传切片记录，来实现断点上传的功能</p><pre><code class="JS"> // 获取已上传切片记录function getUploadSliceRecord(context){  let record = localStorage.getItem(context)  if(!record){    return []  }else {    try{      return JSON.parse(record)    }catch(e){}  }}// 保存已上传切片function saveUploadSliceRecord(context, sliceIndex){  let list = getUploadSliceRecord(context)  list.push(sliceIndex)  localStorage.setItem(context, JSON.stringify(list))}</code></pre><p>然后对上传逻辑稍作修改，主要是增加上传前检测是已经上传、上传后保存记录的逻辑</p><pre><code class="JS">let context = createContext(file);// 获取上传记录let record = getUploadSliceRecord(context);let tasks = [];chunks.forEach((chunk, index) =&gt; {  // 已上传的切片则不再重新上传  if(record.includes(index)){    return  }  let fd = new FormData();  fd.append("file", chunk);  fd.append("context", context);  fd.append("chunk", index + 1);  let task = post("/mkblk.php", fd).then(res=&gt;{    // 上传成功后保存已上传切片记录    saveUploadSliceRecord(context, index)    record.push(index)  })  tasks.push(task);});</code></pre><p>此时上传时刷新页面或者关闭浏览器，再次上传相同文件时，之前已经上传成功的切片就不会再重新上传了。</p><p>服务端实现断点续传的逻辑基本相似，只要在<code>getUploadSliceRecord</code>内部调用服务端的查询接口获取已上传切片的记录即可，因此这里不再展开。</p><p>此外断点续传还需要考虑切片过期的情况：如果调用了<code>mkfile</code>接口，则磁盘上的切片内容就可以清除掉了，如果客户端一直不调用<code>mkfile</code>的接口，放任这些切片一直保存在磁盘显然是不可靠的，一般情况下，切片上传都有一段时间的有效期，超过该有效期，就会被清除掉。基于上述原因，断点续传也必须同步切片过期的实现逻辑。</p><h3 id="上传进度和暂停"><a href="#上传进度和暂停" class="headerlink" title="上传进度和暂停"></a>上传进度和暂停</h3><p>通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/upload">xhr.upload</a>中的progress方法可以实现监控每一个切片上传进度。</p><p>上传暂停的实现也比较简单，通过xhr.abort可以取消当前未完成上传切片的上传，实现上传暂停的效果，恢复上传就跟断点续传类似，先获取已上传的切片列表，然后重新发送未上传的切片。</p><p>由于篇幅关系，上传进度和暂停的功能这里就先不实现了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>目前社区已经存在一些成熟的大文件上传解决方案，如<a href="https://github.com/qiniu">七牛SDK</a>，<a href="https://cloud.tencent.com/document/product/266/9239">腾讯云SDK</a>等，也许并不需要我们手动去实现一个简陋的大文件上传库，但是了解其原理还是十分有必要的。</p><p>本文首先整理了前端文件上传的几种方式，然后讨论了大文件上传的几种场景，以及大文件上传需要实现的几个功能</p><p>通过Blob对象的<code>slice</code>方法将文件拆分成切片<br>整理了服务端还原文件所需条件和参数，演示了PHP将切片还原成文件<br>通过保存已上传切片的记录来实现断点续传<br>还留下了一些问题，如：合并文件时避免内存溢出、切片失效策略、上传进度暂停等功能，并没有去深入或一一实现，继续学习吧~</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冷知识之JS篇</title>
      <link href="/My-Blogs/2021/01/08/JavaScript/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BJS%E7%AF%87/"/>
      <url>/My-Blogs/2021/01/08/JavaScript/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BJS%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>关于JavaScript的冷知识又有哪些呢？让我们一起看看吧</p><a id="more"></a><h3 id="浮点数快速向下取整"><a href="#浮点数快速向下取整" class="headerlink" title="浮点数快速向下取整"></a>浮点数快速向下取整</h3><p>JavaScript中是没有整型概念的，但利用好位操作符可以轻松处理，同时获得效率上的提升。</p><br><p>|0和~~是很好的一个例子，使用这两者可以将浮点转成整型且效率方面要比同类的parseInt, Math.round 要快。在处理像素及动画位移等效果的时候会很有用。</p><pre><code class="JavaScript">(12.4 / 4.13) | 0    // =&gt; 3    ~~(12.4 / 4.13)// =&gt; 3</code></pre><h3 id="生成随机字符串"><a href="#生成随机字符串" class="headerlink" title="生成随机字符串"></a>生成随机字符串</h3><p>生成随机字符串，我们第一想到的，可能是先定义一个字符串数组，然后通过随机取数组中的字符进而拼接成一个随机长度的字符串。<br>但是下面还有一个更简单的方法，代码如下：</p><pre><code class="js">function generateRandomAlphaNum(len) {    var rdmString = "";    for (; rdmString.length &lt; len; rdmString += Math.random().toString(36).substr(2));    return rdmString.substr(0, len);}</code></pre><blockquote><p>主要是利用了toString() 方法的特性</p></blockquote><p><img src="/My-Blogs/images/toString.png" alt="image"></p><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>利用copy方法复制Console控制台的变量</p><pre><code class="js">var temp1 = 1111;copy(temp1);</code></pre><h3 id="console-table"><a href="#console-table" class="headerlink" title="console.table"></a>console.table</h3><p>Chrome专属，IE绕道的console方法。可以将JavaScript关联数组以表格形式输出到浏览器console，效果很惊赞，界面很美观。</p><pre><code class="js">//采购情况var data = [{    '品名': '杜雷斯',    '数量': 4}, {    '品名': '冈本',    '数量': 3}];console.table(data);</code></pre><p><img src="/My-Blogs/images/console.table.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Intersection Observer接口实现可视区域渲染</title>
      <link href="/My-Blogs/2021/01/08/JavaScript/%E4%BD%BF%E7%94%A8Intersection%20Observer%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%BA%E5%9F%9F%E6%B8%B2%E6%9F%93/"/>
      <url>/My-Blogs/2021/01/08/JavaScript/%E4%BD%BF%E7%94%A8Intersection%20Observer%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%BA%E5%9F%9F%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API">Intersection Observer</a>大家有了解过么？</p><a id="more"></a><h2 id="使用Intersection-Observer接口实现可视区域渲染"><a href="#使用Intersection-Observer接口实现可视区域渲染" class="headerlink" title="使用Intersection Observer接口实现可视区域渲染"></a>使用Intersection Observer接口实现可视区域渲染</h2><p>由于客户端使用的webview内核在较低配置的Android手机上打开多图页面时出现内存暴涨，无法回收导致客户端崩溃的情况，我们使用Android studio进行分析发现，问题出在了webview的图层渲染引擎。<br>我们发现，随着我们下拉加载越多，图片量增多时，图层渲染<br>Graphics部分内存持续上涨，且不存在回收的情况。因此，这种情况下，使用图片懒加载已经<br>不能解决问题了。<br>经过调研，我们采用了<code>Intersection Observer</code> 实现虚拟渲染的方案，即<br>只在可视区域才进行图片的渲染。</p><h2 id="为什么使用Intersection-Observer-接口"><a href="#为什么使用Intersection-Observer-接口" class="headerlink" title="为什么使用Intersection Observer 接口"></a>为什么使用Intersection Observer 接口</h2><p><code>Intersection Observer</code> API提供了一种异步检测目标元素与祖先元素或viewport相交变化情况的方法（MDN）。<br>换句话说，之前检测元素是否可见，元素与元素是否相交是不容易的，可能的几个方法是基于监听滚动事件，再结合使用元素的宽高属性，以计算元素当前所处位置这种耗性能的方式。前述类型的方法，在监听滚动事件的过程中, 频繁调用Element.getBoundingClientRect方法，会使得浏览器重复多次计算元素的宽高属性。<br>事件监听和调用Element.getBoundingClientRect都是在主线程上运行，这样 可能会阻塞后续js代码的执行，造成性能问题。<br>如果使用<code>Intersection Observer</code>接口，我们不但省去了自己编写代码计算位<br>置的功夫，而且因该接口是异步的，还使得我们在执行该接口进行监测的时候不会阻塞js线程的执行，可以说是一举两得。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><code>Intersection Observer</code> 接口通过观测根元素和目标元素的相对位置，在开发者设定的目标元素与根元素相交触发点<br>触发回调函数，以实现开发者的业务目的。开发者可以设置一些数值来指定目标元素进入到根元素的百分之几时触发回调函数。</p><p><img src="/My-Blogs/images/%E4%BD%BF%E7%94%A8IntersectionObserver%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%BA%E5%9F%9F%E6%B8%B2%E6%9F%93-01.gif" alt="img"></p><p>在上面的gif中，根元素是白色的视窗，目标元素为绿色的小方块。可以看到，当滚动屏幕时，绿色方块逐渐出现在视口中，分别在绿色方块与视口相交比例达到25%, 50%, 75%, 100%时触发了回调函数。<br>当然，我们可以把任意一个目标元素的祖先元素当作根元素，这对于懒加载，视频播放等都有重要的意义。</p><h2 id="怎么使用-Intersection-Observer-API"><a href="#怎么使用-Intersection-Observer-API" class="headerlink" title="怎么使用 Intersection Observer API"></a>怎么使用 Intersection Observer API</h2><p>1、新建一个观察器</p><pre><code class="JS">const callback = (entries) =&gt; {};const options = () =&gt; {};const observer = new IntersectionObserver(callback, options);</code></pre><p>callback 为相交时的处理函数, 每当被观测的元素与指定的根元素或视窗相交时便会被执行。其参数为IntersectionObserverEntry对象，该对象记录了相交时的一些状态信息，如元素的宽高，相交比率<br>等信息。<br>options, 用于指定回调函数执行时被观测元素的的环境。如指定根元素root, 指定被观测元素位于哪个位置时触发相交处理函数rootMargin, 具体可见<a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API">MDN</a></p><p>2、指定相交时的处理函数</p><pre><code class="JS">const callback = (entries) =&gt; {  entries.forEach(entry =&gt; {    if (entry.isIntersecting) { // 当true时，表示被观测元素与指定元素相交了      // 执行你要的操作    }  })}</code></pre><p>3、对目标元素进行观察</p><pre><code class="JS">const ele = document.getElementById('target');observer.observe(ele);</code></pre><p>4、<code>Intersection Observer</code>可用的方法</p><pre><code class="JS">1. observe(ele): 用于开始观察某个指定的目标元素， 观察者可以多次调用此方法对不同的元素进行观测。2. unobserve(ele): 可用来取消对某个元素的观察。3. disconnect(): 使用该方法， 可以取消对所有元素的观测， 即之前通过observer方法观测的元素不再受到观测，相应的处理函数也不会得到执行。</code></pre><h2 id="实现可视区域渲染"><a href="#实现可视区域渲染" class="headerlink" title="实现可视区域渲染"></a>实现可视区域渲染</h2><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>我们把视口当作根元素，将头像容器元素作为目标元素，设定当头像容器的面积出现在视口（即与视口相交）的比例超过50%时， 就触发一次我们的回调函数，离开时也触发我们的回调函数。<br>回调函数的功能为，当相交且目标元素可见时，将头像url地址赋值给头像元素的背景（你也可以用img来实现）url，当离开时则将目标元素的背景url置空，以保证图像渲染层保存的图片仅是目前可视区域的图片，以达到控制图像渲染引擎内存占用的目的。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ol><li> 首先，新建一个观察者</li></ol><pre><code class="JS">let hasInterSection;try {  require('intersection-observer');  hasInterSection = true;} catch (e) {  hasInterSection = false;  console.log(e);}const observer = hasInterSection &amp;&amp; (new IntersectionObserver((entries, options) =&gt; {  entries.forEach(isIntersectHandler);}, {  rootMargin: '0px 0px 0px 0px',  threshold: [0.5],  trackVisibility: true,  delay: 300}));</code></pre><blockquote><p>在新建一个observer之前，先尝试引入intersection-observer插件，这是<code>Intersection Observer</code><br>的polyfill，是为了兼容一些暂时不支持该接口的浏览器。<br>引入后，在新建的观察器中，我们传入了一些配置，在这里，我们根元素就是视口元素，且没有对视口的范围进行扩充（rootMargin: ‘0px 0px 0px 0px’, ）, 如果要对视口的范围进行扩充或缩小，则可以改变rootMargin的值。<br>这里，相交比例达到0.5时，我们才让它显示头像，离开时也是达到0.5才会隐藏头像，关于threshold的理解，mdn有一<br>个很好的例子: <code>threshold</code>.<br>至于我们例子中为什么设置了0.5的比例，主要还是出于业务需要，因为在滚动屏幕过程中，当一个目标元素进入到视口时，如果没有达到50%的比例，则认为还没出现，则不对其头像进行赋值。trackVisibility设置为true，是因为我们有对元素是否可见进行一个判断的需要。回调函数中，我们对entries逐一进行处理，因为observer可以监测多个元素，所以entries是一个数组，需要逐一处理。</p></blockquote><ol start="2"><li> 回调函数的处理函数</li></ol><pre><code class="JS">function isIntersectHandler(entry) {  const target = entry.target;  const isIntersecting = entry.isIntersecting;  if (isIntersecting) {    const src = target.dataset.src;    const ele = target.getElementsByClassName('user-item-thump-icon')[0];    if (src &amp;&amp; entry.isVisible) {      const styleStr = `url(${src}), url("${defaultAvatar}")`;      ele.style.backgroundImage = styleStr;    } else {      ele.style.backgroundImage = '';    }  } else {    const ele = target.getElementsByClassName('user-item-thump-icon')[0];    ele &amp;&amp; (ele.style.backgroundImage = '');  }}</code></pre><blockquote><p>回调函数的处理函数中，我们对单个entry进行处理。首先我们判断元素是否相交（正常来说能触发这个函数的<br>都是已经相交了的），相交的时候则从目标元素的dataset中拿到头像url并判断是否可见，从而赋值到背景url, 以使得头像被渲染。当离开时，则对背景url进行置空操作，使得其不被渲染。</p></blockquote><ol start="3"><li> 开始观察元素</li></ol><pre><code class="JS">mounted() {  observer.observe(this.$refs.thump);}</code></pre><blockquote><p>开始监测后即可对元素的背景url进行自定义的操作了。</p></blockquote><ol start="4"><li> 停止观察元素</li></ol><pre><code class="JS">beforeDestroy() {  observer.unobserve(this.$refs.thump);}</code></pre><h3 id="几个注意点"><a href="#几个注意点" class="headerlink" title="几个注意点"></a>几个注意点</h3><p>虽然监测函数的执行是异步的，但是回调函数的执行是在主线程上。如果回调函数里面处理的逻辑比较复杂，则可能影响js线程的执行，此时建议采用 <code>window.requestIdleCallback</code> 。<br>对于目标元素的visible，受多个因素影响，如opacity, translation等属性都可能影响，具体可参考<a href="https://developers.google.com/web/updates/2019/02/intersectionobserver-v2">google</a>.</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的Blob</title>
      <link href="/My-Blogs/2021/01/08/JavaScript/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Blob/"/>
      <url>/My-Blogs/2021/01/08/JavaScript/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Blob/</url>
      
        <content type="html"><![CDATA[<p>如果你允许用户从你的网站上下载某些文件，那你可能会遇到 Blob 类型。为了实现上述的功能，你可以很容易从网上找到相关的示例，并根据实际需求进行适当的调整。对于部分开发者来说，在完成上述功能之后，他们并不会继续思考 Blob 是什么？</p><a id="more"></a><p>这就导致了一些开发者，还是停留在熟练使用 API 的层面，当遇到比较棘手的问题时，就束手无策。<strong>换句话说，如果当你在熟悉 API 的使用之后，还能继续多问几个为什么，继续探究下去，不仅能加深对知识的理解，还能触类旁通，拓展自己的知识面提高自己。</strong></p><p>好了，如果你想继续了解什么是 Blob，那么就跟上我的脚步，来一个 Blob Web API 探索之旅。还在犹豫什么，Let’s go！</p><p>读完本文你将了解到以下内容：</p><ul><li><p>Blob 是什么</p></li><li><p>Blob API 简介</p></li><li><p>构造函数</p></li><li><p>属性和方法</p></li><li><p>Blob 使用场景</p></li><li><p>分片上传</p></li><li><p>从互联网下载数据</p></li><li><p>Blob 用作 URL</p></li><li><p>Blob 转换为 Base64</p></li><li><p>图片压缩</p></li><li><p>生成 PDF</p></li><li><p>Blob 与 ArrayBuffer 的区别</p></li></ul><h3 id="一、Blob-是什么"><a href="#一、Blob-是什么" class="headerlink" title="一、Blob 是什么"></a><span style="display: none; "></span>一、Blob 是什么<span style="display: none; "></span></h3><p>Blob（Binary Large Object）表示二进制类型的大对象。在数据库管理系统中，将二进制数据存储为一个单一个体的集合。Blob 通常是影像、声音或多媒体文件。<strong>在 JavaScript 中 Blob 类型的对象表示不可变的类似文件对象的原始数据。</strong> 为了更直观的感受 Blob 对象，我们先来使用 Blob 构造函数，创建一个 myBlob 对象，具体如下图所示：</p><p><img src="/My-Blogs/images/blobInfo.webp"></p><p>如你所见，myBlob 对象含有两个属性：size 和 type。其中 <code>size</code> 属性用于表示数据的大小（以字节为单位）， <code>type</code> 是 MIME 类型的字符串。Blob 表示的不一定是 JavaScript 原生格式的数据。比如 <code>File</code> 接口基于 <code>Blob</code> ，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p><h3 id="二、Blob-API-简介"><a href="#二、Blob-API-简介" class="headerlink" title="二、Blob API 简介"></a><span style="display: none; "></span>二、Blob API 简介<span style="display: none; "></span></h3><p><code>Blob</code> 由一个可选的字符串 <code>type</code> （通常是 MIME 类型）和 <code>blobParts</code> 组成：</p><p><img src="/My-Blogs/images/blobInfo2.webp"></p><blockquote><p>MIME（Multipurpose Internet Mail Extensions）多用途互联网邮件扩展类型，是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。</p><p>常见的 MIME 类型有：超文本标记语言文本 .html text/html、PNG图像 .png image/png、普通文本 .txt text/plain 等。</p></blockquote><h4 id="2-1-构造函数"><a href="#2-1-构造函数" class="headerlink" title="2.1 构造函数"></a><span style="display: none; "></span>2.1 构造函数<span style="display: none; "></span></h4><p>Blob 构造函数的语法为：</p><pre><code class="js">var aBlob = new Blob(blobParts, options);</code></pre><p>相关的参数说明如下：</p><ul><li><p>blobParts：它是一个由 ArrayBuffer，ArrayBufferView，Blob，DOMString 等对象构成的数组。DOMStrings 会被编码为 UTF-8。</p></li><li><p>options：一个可选的对象，包含以下两个属性：</p></li><li><p>type —— 默认值为 <code>""</code>，它代表了将会被放入到 blob 中的数组内容的 MIME 类型。</p></li><li><p>endings —— 默认值为 <code>"transparent"</code>，用于指定包含行结束符 <code>\n</code> 的字符串如何被写入。它是以下两个值中的一个：<code>"native"</code>，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 <code>"transparent"</code>，代表会保持 blob 中保存的结束符不变。</p></li></ul><p><strong>示例一：从字符串创建 Blob</strong></p><pre><code class="js">let myBlobParts = ['&lt;html&gt;&lt;h2&gt;Hello&nbsp;Semlinker&lt;/h2&gt;&lt;/html&gt;']; //&nbsp;an&nbsp;array&nbsp;consisting&nbsp;of&nbsp;a&nbsp;single&nbsp;DOMStringlet myBlob = new Blob(myBlobParts, {    type: 'text/html',    endings: "transparent"}); //the&nbsp;blobconsole.log(myBlob.size + "&nbsp;bytes&nbsp;size"); //&nbsp;Output:&nbsp;37&nbsp;bytes&nbsp;sizeconsole.log(myBlob.type + "&nbsp;is&nbsp;the&nbsp;type"); //&nbsp;Output:&nbsp;text/html&nbsp;is&nbsp;the&nbsp;type</code></pre><p><strong>示例二：从类型化数组和字符串创建 Blob</strong></p><pre><code class="js">let hello = new Uint8Array([72, 101, 108, 108, 111]); //&nbsp;二进制格式的&nbsp;"hello"let blob = new Blob([hello, '&nbsp;', 'semlinker'], {    type: 'text/plain'});</code></pre><p>介绍完 Blob 构造函数，接下来我们来分别介绍 Blob 类的属性和方法：</p><p><img src="/My-Blogs/images/blobInfo3.webp"></p><h4 id="2-2-属性"><a href="#2-2-属性" class="headerlink" title="2.2 属性"></a><span style="display: none; "></span>2.2 属性<span style="display: none; "></span></h4><p>前面我们已经知道 Blob 对象包含两个属性：</p><ul><li><p>size（只读）：表示 <code>Blob</code> 对象中所包含数据的大小（以字节为单位）。</p></li><li><p>type（只读）：一个字符串，表明该 <code>Blob</code> 对象所包含数据的 MIME 类型。如果类型未知，则该值为空字符串。</p></li></ul><h4 id="2-3-方法"><a href="#2-3-方法" class="headerlink" title="2.3 方法"></a><span style="display: none; "></span>2.3 方法<span style="display: none; "></span></h4><ul><li><p>slice([start[, end[, contentType]]])：返回一个新的 Blob 对象，包含了源 Blob 对象中指定范围内的数据。</p></li><li><p>stream()：返回一个能读取 blob 内容的 <code>ReadableStream</code>。</p></li><li><p>text()：返回一个 Promise 对象且包含 blob 所有内容的 UTF-8 格式的 <code>USVString</code>。</p></li><li><p>arrayBuffer()：返回一个 Promise 对象且包含 blob 所有内容的二进制格式的 <code>ArrayBuffer</code>。</p></li></ul><p>这里我们需要注意的是，** <code>Blob</code> 对象是不可改变的**。我们不能直接在一个 Blob 中更改数据，但是我们可以对一个 Blob 进行分割，从其中创建新的 Blob 对象，将它们混合到一个新的 Blob 中。这种行为类似于 JavaScript 字符串：我们无法更改字符串中的字符，但可以创建新的更正后的字符串。</p><h3 id="三、Blob-使用场景"><a href="#三、Blob-使用场景" class="headerlink" title="三、Blob 使用场景"></a><span style="display: none; "></span>三、Blob 使用场景<span style="display: none; "></span></h3><h4 id="3-1-分片上传"><a href="#3-1-分片上传" class="headerlink" title="3.1 分片上传"></a><span style="display: none; "></span>3.1 分片上传<span style="display: none; "></span></h4><p>File 对象是特殊类型的 Blob，且可以用在任意的 Blob 类型的上下文中。所以针对大文件传输的场景，我们可以使用 slice 方法对大文件进行切割，然后分片进行上传，具体示例如下：</p><pre><code class="js">const file = new File(["a".repeat(1000000)], "test.txt");const chunkSize = 40000;const url = "https://httpbin.org/post";async function chunkedUpload() {    for (let start = 0; start &lt; file.size; start += chunkSize) {        const chunk = file.slice(start, start + chunkSize + 1);        const fd = new FormData();        fd.append("data", chunk);        await fetch(url, {            method: "post",            body: fd        }).then((res) =&gt; res.text());    }}</code></pre><h4 id="3-2-从互联网下载数据"><a href="#3-2-从互联网下载数据" class="headerlink" title="3.2 从互联网下载数据"></a><span style="display: none; "></span>3.2 从互联网下载数据<span style="display: none; "></span></h4><p>我们可以使用以下方法从互联网上下载数据并将数据存储到 Blob 对象中，比如：</p><pre><code class="js">const downloadBlob = (url, callback) =&gt; {    const xhr = new XMLHttpRequest()    xhr.open('GET', url)    xhr.responseType = 'blob'    xhr.onload = () =&gt; {        callback(xhr.response)    }    xhr.send(null)}</code></pre><p>当然除了使用 <code>XMLHttpRequest</code> API 之外，我们也可以使用 <code>fetch</code> API 来实现以流的方式获取二进制数据。这里我们来看一下如何使用 fetch API 获取线上图片并本地显示，具体实现如下：</p><pre><code class="js">const myImage = document.querySelector('img');const myRequest = new Request('flowers.jpg');fetch(myRequest)    .then(function(response) {        return response.blob();    })    .then(function(myBlob) {        let objectURL = URL.createObjectURL(myBlob);        myImage.src = objectURL;    });</code></pre><p>当 fetch 请求成功的时候，我们调用 response 对象的 <code>blob()</code> 方法，从 response 对象中读取一个 Blob 对象，然后使用 <code>createObjectURL()</code> 方法创建一个 objectURL，然后把它赋值给 <code>img</code> 元素的 <code>src</code> 属性从而显示这张图片。</p><h4 id="3-3-Blob-用作-URL"><a href="#3-3-Blob-用作-URL" class="headerlink" title="3.3 Blob 用作 URL"></a><span style="display: none; "></span>3.3 Blob 用作 URL<span style="display: none; "></span></h4><p>Blob 可以很容易的作为 <code>&lt;a&gt;</code> 、 <code>&lt;img&gt;</code> 或其他标签的 URL，多亏了 <code>type</code> 属性，我们也可以上传/下载 <code>Blob</code> 对象。下面我们将举一个 Blob 文件下载的示例，不过在看具体示例前我们得简单介绍一下 Blob URL。</p><p><strong>1. Blob URL/Object URL</strong></p><p>Blob URL/Object URL 是一种伪协议，允许 Blob 和 File 对象用作图像，下载二进制数据链接等的 URL 源。在浏览器中，我们使用 <code>URL.createObjectURL</code> 方法来创建 Blob URL，该方法接收一个 <code>Blob</code> 对象，并为其创建一个唯一的 URL，其形式为 <code>blob:&lt;origin&gt;/&lt;uuid&gt;</code> ，对应的示例如下：</p><pre><code class="html">blob:https://example.org/40a5fb5a-d56d-4a33-b4e2-0acf6a8e5f641</code></pre><p>浏览器内部为每个通过 <code>URL.createObjectURL</code> 生成的 URL 存储了一个 URL → Blob 映射。因此，此类 URL 较短，但可以访问 <code>Blob</code> 。生成的 URL 仅在当前文档打开的状态下才有效。它允许引用 <code>&lt;img&gt;</code> 、 <code>&lt;a&gt;</code> 中的 <code>Blob</code> ，但如果你访问的 Blob URL 不再存在，则会从浏览器中收到 404 错误。</p><p>上述的 Blob URL 看似很不错，但实际上它也有副作用。虽然存储了 URL → Blob 的映射，但 Blob 本身仍驻留在内存中，浏览器无法释放它。映射在文档卸载时自动清除，因此 Blob 对象随后被释放。</p><p>但是，如果应用程序寿命很长，那不会很快发生。因此，如果我们创建一个 Blob URL，即使不再需要该 Blob，它也会存在内存中。</p><p>针对这个问题，我们可以调用 <code>URL.revokeObjectURL(url)</code> 方法，从内部映射中删除引用，从而允许删除 Blob（如果没有其他引用），并释放内存。接下来，我们来看一下 Blob 文件下载的具体示例。</p><p><strong>2. Blob 文件下载示例</strong></p><p><strong>index.html</strong></p><pre><code class="html">&lt;!DOCTYPE&nbsp;html&gt;&lt;html&gt;&nbsp;&nbsp;&lt;head&gt;&nbsp;&nbsp;&nbsp;    &lt;meta&nbsp;charset="UTF-8"&nbsp; /&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;title&gt;Blob&nbsp;文件下载示例&lt;/title&gt;&nbsp;&nbsp;&lt;/head&gt;&nbsp;&nbsp;&lt;body&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;button&nbsp;id="downloadBtn"&gt;文件下载&lt;/button&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;script&nbsp;src="index.js"&gt;&lt;/script&gt;&nbsp;&nbsp;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>index.js</strong></p><pre><code class="js">const download = (fileName, blob) =&gt; {    const link = document.createElement("a");    link.href = URL.createObjectURL(blob);    link.download = fileName;    link.click();    link.remove();    URL.revokeObjectURL(link.href);};const downloadBtn = document.querySelector("#downloadBtn");downloadBtn.addEventListener("click", (event) =&gt; {    const fileName = "blob.txt";    const myBlob = new Blob(["一文彻底掌握&nbsp;Blob&nbsp;Web&nbsp;API"], {        type: "text/plain"    });    download(fileName, myBlob);});</code></pre><p>在示例中，我们通过调用 Blob 的构造函数来创建类型为 <strong>“text/plain”</strong> 的 Blob 对象，然后通过动态创建 <code>a</code> 标签来实现文件的下载。</p><h4 id="3-4-Blob-转换为-Base64"><a href="#3-4-Blob-转换为-Base64" class="headerlink" title="3.4 Blob 转换为 Base64"></a><span style="display: none; "></span>3.4 Blob 转换为 Base64<span style="display: none; "></span></h4><p><code>URL.createObjectURL</code> 的一个替代方法是，将 <code>Blob</code> 转换为 base64 编码的字符串。<strong>Base64</strong> 是一种基于 64 个可打印字符来表示二进制数据的表示方法，<strong>它常用于在处理文本数据的场合，表示、传输、存储一些二进制数据，包括 MIME 的电子邮件及 XML 的一些复杂数据。</strong></p><p>在 MIME 格式的电子邮件中，base64 可以用来将二进制的字节序列数据编码成 ASCII 字符序列构成的文本。使用时，在传输编码方式中指定 base64。使用的字符包括大小写拉丁字母各 26 个、数字 10 个、加号 + 和斜杠 /，共 64 个字符，等号 = 用来作为后缀用途。</p><p>下面我们来介绍如何在 HTML 中嵌入 base64 编码的图片。在编写 HTML 网页时，对于一些简单图片，通常会选择将图片内容直接内嵌在网页中，从而减少不必要的网络请求，但是图片数据是二进制数据，该怎么嵌入呢？绝大多数现代浏览器都支持一种名为 <code>Data URLs</code> 的特性，允许使用 base64 对图片或其他文件的二进制数据进行编码，将其作为文本字符串嵌入网页中。</p><p>Data URLs 由四个部分组成：前缀（ <code>data:</code> ）、指示数据类型的 MIME 类型、如果非文本则为可选的 <code>base64</code> 标记、数据本身：</p><pre><code class="html">data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</code></pre><p><code>mediatype</code> 是个 MIME 类型的字符串，例如 “ <code>image/jpeg</code> “ 表示 JPEG 图像文件。如果被省略，则默认值为 <code>text/plain;charset=US-ASCII</code> 。如果数据是文本类型，你可以直接将文本嵌入（根据文档类型，使用合适的实体字符或转义字符）。如果是二进制数据，你可以将数据进行 base64 编码之后再进行嵌入。比如嵌入一张图片：</p><pre><code class="html">&lt;img&nbsp;alt="logo"&nbsp;src="data:image /png;base64,iVBORw0KGgoAAAANSUhEUg..."&gt;</code></pre><p><strong>但需要注意的是：如果图片较大，图片的色彩层次比较丰富，则不适合使用这种方式，因为该图片经过 base64 编码后的字符串非常大，会明显增大 HTML 页面的大小，从而影响加载速度。</strong> 除此之外，利用 FileReader API，我们也可以方便的实现图片本地预览功能，具体代码如下：</p><pre><code class="html">&lt;input&nbsp;type="file"&nbsp;accept="image /*"&nbsp;onchange="loadFile(event)"&gt;&lt;img&nbsp;id="output" /&gt;&lt;script&gt;    const loadFile = function(event) {        const reader = new FileReader();        reader.onload = function() {            const output = document.querySelector('output');            output.src = reader.result;        };        reader.readAsDataURL(event.target.files[0]);    };&lt;/script&gt;</code></pre><p>在以上示例中，我们为 file 类型输入框绑定 <code>onchange</code> 事件处理函数 <code>loadFile</code> ，在该函数中，我们创建了一个 FileReader 对象并为该对象绑定 <code>onload</code> 相应的事件处理函数，然后调用 FileReader 对象的 <code>readAsDataURL()</code> 方法，把本地图片对应的 File 对象转换为 Data URL。</p><p>在完成本地图片预览之后，我们可以直接把图片对应的 Data URLs 数据提交到服务器。针对这种情形，服务端需要做一些相关处理，才能正常保存上传的图片，这里以 Express 为例，具体处理代码如下：</p><pre><code class="js">const app = require('express')();app.post('/upload', function(req, res) {    let imgData = req.body.imgData; //&nbsp;获取POST请求中的base64图片数据&nbsp;&nbsp;&nbsp;&nbsp;    let base64Data = imgData.replace(/^data:image\/\w+;base64,/, "");    let dataBuffer = Buffer.from(base64Data, 'base64');    fs.writeFile("image.png", dataBuffer, function(err) {        if (err) {            res.send(err);        } else {            res.send("图片上传成功！");        }    });});</code></pre><p>对于 FileReader 对象来说，除了支持把 Blob/File 对象转换为 Data URL 之外，它还提供了 <code>readAsArrayBuffer()</code> 和 <code>readAsText()</code> 方法，用于把 Blob/File 对象转换为其它的数据格式。这里我们来看个 <code>readAsArrayBuffer()</code> 的使用示例：</p><pre><code class="js">//&nbsp;从&nbsp;blob&nbsp;获取&nbsp;arrayBufferlet fileReader = new FileReader();fileReader.onload = function(event) {    let arrayBuffer = fileReader.result;};fileReader.readAsArrayBuffer(blob);</code></pre><h4 id="3-5-图片压缩"><a href="#3-5-图片压缩" class="headerlink" title="3.5 图片压缩"></a><span style="display: none; "></span>3.5 图片压缩<span style="display: none; "></span></h4><p>在一些场合中，我们希望在上传本地图片时，先对图片进行一定的压缩，然后再提交到服务器，从而减少传输的数据量。在前端要实现图片压缩，我们可以利用 Canvas 对象提供的 <code>toDataURL()</code> 方法，该方法接收 <code>type</code> 和 <code>encoderOptions</code> 两个可选参数。</p><p>其中 <code>type</code> 表示图片格式，默认为 <code>image/png</code> 。而 <code>encoderOptions</code> 用于表示图片的质量，在指定图片格式为 <code>image/jpeg</code> 或 <code>image/webp</code> 的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 <code>0.92</code> ，其他参数会被忽略。</p><p>下面我们来看一下具体如何实现图片压缩：</p><pre><code class="js">//&nbsp;compress.jsconst MAX_WIDTH = 800; //&nbsp;图片最大宽度function compress(base64, quality, mimeType) {    let canvas = document.createElement("canvas");    let img = document.createElement("img");    img.crossOrigin = "anonymous";    return new Promise((resolve, reject) =&gt; {        img.src = base64;        img.onload = () =&gt; {            let targetWidth, targetHeight;            if (img.width &gt; MAX_WIDTH) {                targetWidth = MAX_WIDTH;                targetHeight = (img.height * MAX_WIDTH) / img.width;            } else {                targetWidth = img.width;                targetHeight = img.height;            }            canvas.width = targetWidth;            canvas.height = targetHeight;            let ctx = canvas.getContext("2d");            ctx.clearRect(0, 0, targetWidth, targetHeight); //&nbsp;清除画布&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);            let imageData = canvas.toDataURL(mimeType, quality / 100);            resolve(imageData);        };    });}</code></pre><p>对于返回的 Data URL 格式的图片数据，为了进一步减少传输的数据量，我们可以把它转换为 Blob 对象：</p><pre><code class="js">function dataUrlToBlob(base64, mimeType) {    let bytes = window.atob(base64.split(",")[1]);    let ab = new ArrayBuffer(bytes.length);    let ia = new Uint8Array(ab);    for (let i = 0; i &lt; bytes.length; i++) {        ia[i] = bytes.charCodeAt(i);    }    return new Blob([ia], {        type: mimeType    });}</code></pre><p>在转换完成后，我们就可以压缩后的图片对应的 Blob 对象封装在 FormData 对象中，然后再通过 AJAX 提交到服务器上：</p><pre><code class="js">function uploadFile(url, blob) {    let formData = new FormData();    let request = new XMLHttpRequest();    formData.append("image", blob);    request.open("POST", url, true);    request.send(formData);}</code></pre><p>其实 Canvas 对象除了提供 <code>toDataURL()</code> 方法之外，它还提供了一个 <code>toBlob()</code> 方法，该方法的语法如下：</p><blockquote><p>canvas.toBlob(callback, mimeType, qualityArgument)</p></blockquote><p>和 <code>toDataURL()</code> 方法相比， <code>toBlob()</code> 方法是异步的，因此多了个 <code>callback</code> 参数，这个 <code>callback</code> 回调方法默认的第一个参数就是转换好的 <code>blob</code> 文件信息。</p><p>介绍完上述的内容，我们来看一下本地图片压缩完整的示例：</p><pre><code class="html">&lt;!DOCTYPE&nbsp;html&gt;&lt;html&gt;&nbsp;&nbsp;&lt;head&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;meta&nbsp;charset="UTF-8"&nbsp; /&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;meta&nbsp;name="viewport"&nbsp;content="width=device-width,&nbsp;initial-scale=1.0"&nbsp; /&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;title&gt;本地图片压缩&lt;/title&gt;&nbsp;&nbsp;&lt;/head&gt;&nbsp;&nbsp;&lt;body&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;input&nbsp;type="file"&nbsp;accept="image /*"&nbsp;onchange="loadFile(event)" &nbsp; /&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;script&nbsp;src=". /compress.js"&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;script&gt;        const loadFile = function(event) {            const reader = new FileReader();            reader.onload = async function() {                let compressedDataURL = await compress(                    reader.result,                    90,                    "image/jpeg"                );                let compressedImageBlob = dataUrlToBlob(compressedDataURL);                uploadFile("https://httpbin.org/post", compressedImageBlob);            };            reader.readAsDataURL(event.target.files[0]);        };    &lt;/script&gt;&nbsp;&nbsp;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="3-6-生成-PDF-文档"><a href="#3-6-生成-PDF-文档" class="headerlink" title="3.6 生成 PDF 文档"></a><span style="display: none; "></span>3.6 生成 PDF 文档<span style="display: none; "></span></h4><p>PDF（便携式文件格式，Portable Document Format）是由 Adobe Systems 在 1993 年用于文件交换所发展出的文件格式。在浏览器端，利用一些现成的开源库，比如 jsPDF，我们也可以方便地生成 PDF 文档。</p><pre><code class="html">&lt;!DOCTYPE&nbsp;html&gt;&lt;html&gt;&nbsp;&nbsp;&lt;head&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;meta&nbsp;charset="UTF-8"&nbsp; /&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;meta&nbsp;name="viewport"&nbsp;content="width=device-width,&nbsp;initial-scale=1.0"&nbsp; /&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;title&gt;客户端生成&nbsp;PDF&nbsp;示例&lt;/title&gt;&nbsp;&nbsp;&lt;/head&gt;&nbsp;&nbsp;&lt;body&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;h3&gt;客户端生成&nbsp;PDF&nbsp;示例&lt;/h3&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;script&nbsp;src="https: //unpkg.com/jspdf@latest/dist/jspdf.min.js"&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;script&gt;        (function generatePdf() {            const doc = new jsPDF();            doc.text("Hello&nbsp;semlinker!", 66, 88);            const blob = new Blob([doc.output()], {                type: "application/pdf"            });            blob.text().then((blobAsText) =&gt; {                console.log(blobAsText);            });        })();    &lt;/script&gt;&nbsp;&nbsp;&lt;/body&gt;&lt;/html&gt;</code></pre><p>在以上示例中，我们首先创建 PDF 文档对象，然后调用该对象上的 <code>text()</code> 方法在指定的坐标点上添加 <code>Hello semlinker!</code> 文本，然后我们利用生成的 PDF 内容来创建对应的 Blob 对象，需要注意的是我们设置 Blob 的类型为 <code>application/pdf</code> ，最后我们把 Blob 对象中保存的内容转换为文本并输出到控制台。由于内容较多，这里我们只列出少部分输出结果：</p><pre><code class="js">% PDF - 1.3 % ºß¬ à3 0 obj &lt;&lt; /Type&nbsp;/Page / Parent 1 0 R / Resources 2 0 R / MediaBox[0 0 595.28 841.89] / Contents 4 0 R &gt;&gt; endobj....</code></pre><p>其实 jsPDF 除了支持纯文本之外，它也可以生成带图片的 PDF 文档，比如：</p><pre><code class="js">let imgData = 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/...';let doc = new jsPDF();doc.setFontSize(40);doc.text(35, 25, 'Paranyan&nbsp;loves&nbsp;jsPDF');doc.addImage(imgData, 'JPEG', 15, 40, 180, 160);</code></pre><p>Blob 的应用场景还很多，这里我们就不一一列举了，感兴趣的小伙伴可以自行查阅相关资料。</p><h3 id="四、Blob-与-ArrayBuffer-的区别"><a href="#四、Blob-与-ArrayBuffer-的区别" class="headerlink" title="四、Blob 与 ArrayBuffer 的区别"></a><span style="display: none; "></span>四、Blob 与 ArrayBuffer 的区别<span style="display: none; "></span></h3><p><strong>ArrayBuffer</strong> 对象用于表示通用的，固定长度的原始二进制数据缓冲区。你不能直接操纵 ArrayBuffer 的内容，而是需要创建一个类型化数组对象或 DataView 对象，该对象以特定格式表示缓冲区，并使用该对象读取和写入缓冲区的内容。</p><p><strong>Blob</strong> 类型的对象表示不可变的类似文件对象的原始数据。Blob 表示的不一定是 JavaScript 原生格式的数据。File 接口基于 Blob，继承了Blob 功能并将其扩展为支持用户系统上的文件。</p><h4 id="4-1-Blob-vs-ArrayBuffer"><a href="#4-1-Blob-vs-ArrayBuffer" class="headerlink" title="4.1 Blob vs ArrayBuffer"></a><span style="display: none; "></span>4.1 Blob vs ArrayBuffer<span style="display: none; "></span></h4><ul><li><p>除非你需要使用 ArrayBuffer 提供的写入/编辑的能力，否则 Blob 格式可能是最好的。</p></li><li><p>Blob 对象是不可变的，而 ArrayBuffer 是可以通过 TypedArrays 或 DataView 来操作。</p></li><li><p>ArrayBuffer 是存在内存中的，可以直接操作。而 Blob 可以位于磁盘、高速缓存内存和其他不可用的位置。</p></li><li><p>虽然 Blob 可以直接作为参数传递给其他函数，比如 <code>window.URL.createObjectURL()</code>。但是，你可能仍需要 FileReader 之类的 File API 才能与 Blob 一起使用。</p></li><li><p>Blob 与 ArrayBuffer 对象之间是可以相互转化的：</p></li><li><p>使用 FileReader 的 <code>readAsArrayBuffer()</code> 方法，可以把 Blob 对象转换为 ArrayBuffer 对象；</p></li><li><p>使用 Blob 构造函数，如 <code>new Blob([new Uint8Array(data]);</code>，可以把 ArrayBuffer 对象转换为 Blob 对象。</p></li></ul><p>对于 HTTP 的场景，比如在 AJAX 场景下，<strong>Blob</strong> 和 <strong>ArrayBuffer</strong> 可以通过以下方式来使用：</p><pre><code class="js">function GET(url, callback) {    let xhr = new XMLHttpRequest();    xhr.open('GET', url, true);    xhr.responseType = 'arraybuffer'; //&nbsp;or&nbsp;xhr.responseType&nbsp;=&nbsp;"blob";&nbsp;&nbsp;    xhr.send();    xhr.onload = function(e) {            if (xhr.status != 200) {                alert("Unexpected&nbsp;status&nbsp;code&nbsp;" + xhr.status + "&nbsp;for&nbsp;" + url);                return false;            }            callback(new Uint8Array(xhr.response)); //&nbsp;or&nbsp;new&nbsp;Blob([xhr.response]);&nbsp;&nbsp;};}</code></pre><p>对于 <strong>ArrayBuffer</strong> 和 <strong>Uint8Array</strong> 感兴趣的读者，可以阅读<a href="http://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;mid=2247484317&amp;idx=1&amp;sn=c0b397b6bd5fdfced0c1bebc187a7c0d&amp;chksm=ea47a2c5dd302bd37b285f65dd7a92df8ca1bc213465091e82a28be08ec5808b905e9fb69bec&amp;scene=21#wechat_redirect"><strong>Deno bytes 模块全解析</strong></a>这篇文章。</p><p>了解完上述的内容，相信有的读者可能会觉得意犹未尽。那么，对于 Blob 来说还有哪些内容可以继续深入学习的呢？本人下一步的计划是基于 Deno 的源码，来逐步分析 DenoBlob 的具体实现。当然也会顺便分析一下 <code>URL.createObjectURL()</code> 方法和 <code>revokeObjectURL()</code> 方法的实现。  </p><h3 id="五、参考资源"><a href="#五、参考资源" class="headerlink" title="五、参考资源"></a><span style="display: none; "></span>五、参考资源<span style="display: none; "></span></h3><ul><li><p>MDN - Blob</p></li><li><p>MDN - Data URLs</p></li><li><p>javascript.info - blob</p></li><li><p>flaviocopes - blob</p></li><li><p>arraybuffer-vs-blob</p></li><li><p>javascript-interview-question-what-is-a-blob</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Blob </tag>
            
            <tag> 二进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript模块化演进及原理浅析</title>
      <link href="/My-Blogs/2021/01/08/JavaScript/javascript%E6%A8%A1%E5%9D%97%E5%8C%96%E6%BC%94%E8%BF%9B%E5%8F%8A%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
      <url>/My-Blogs/2021/01/08/JavaScript/javascript%E6%A8%A1%E5%9D%97%E5%8C%96%E6%BC%94%E8%BF%9B%E5%8F%8A%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="模块化解决了什么问题"><a href="#模块化解决了什么问题" class="headerlink" title="模块化解决了什么问题"></a>模块化解决了什么问题</h3><a id="more"></a><p>我们仔细想一下，Javascript编程其实很多时候就是管理变量以及变量赋值这件事，比如把一个value赋值给一个变量，给一个变量加上一个value，或者把两个变量相加的结果赋值给另外一个变量，怎样去管理这些变量对日后如何维护这些代码就显得至关重要。</p><p>在开发中如果我们一次仅需要考虑几个变量，那么工作就会变得很简单。幸运的是，JavsScript有个作用域链来帮助我们解决变量过多的问题，因为作用域链的存在，在一个函数的内部无法访问另外一个函数内部的变量，这样就使得我们在编程的时候只需要关注自己函数内部的那几个变量就可以了，不需要过分去担心其他函数的影响，头发也可以少掉几根。</p><p>但是，很多时候我们不得不跟其他函数共享状态，这时候我们会将这些变量存储在全局（window/global）上，项目小的时候当然问题不大，但是当项目一大，变量一多，通过script引入代码的加载顺序等等问题就开始让后期维护变得很蛋疼，因此人们开始思考如何在没有模块的语言上去实现模块这一件事情。。。</p><h3 id="原始时期"><a href="#原始时期" class="headerlink" title="原始时期"></a>原始时期</h3><h4 id="直接定义依赖"><a href="#直接定义依赖" class="headerlink" title="直接定义依赖"></a>直接定义依赖</h4><pre><code class="js">function a() {}function b() {}</code></pre><p>在原始时期，“模块化”也就是直接定义函数，共享变量，这种做法最明显的缺点就是<strong>污染</strong>了全局变量，变量的重名会导致后面覆盖前面，并且各个模块成员之间看不出有什么直接的关系。</p><h4 id="闭包模块化"><a href="#闭包模块化" class="headerlink" title="闭包模块化"></a>闭包模块化</h4><pre><code class="js">var modules = (fuction(my, $) {    function privateMethod() {        // ...    }    my.moduleProperty = 1;    my.moduleMethod = function() {        //$()....        //privateMethod()...        // ...    };    return my;}(widnow.modules || {}, jQuery))</code></pre><p>通过立即执行函数（IIFE），外部函数无法调用到里面的<strong>privateMethod</strong>，解决了全局变量污染的问题。同时这种模式还可以将一个模块拆分，在闭包内可以调用或继承其他子模块、添加新的方法，新的变量，返回新的模块。但是同时缺点也很明显：</p><ul><li>  为了在模块内部调用其他全局变量，必须<strong>显示注入全局变量</strong>，比如上面注入了jQuery</li><li>  跨文件使用模块时，需要将模块挂载到全局变量上（window）上</li><li>  没有解决如何管理这些模块的问题，各个模块之间的依赖关系需要通过script的引入顺序来保证</li></ul><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>从1999年开始，js模块化的探索都是基于语言层面上的优化，真正的改变要从2009年CommonJS的引入开始，Node采用CommonJS模块规范，每个文件就是一个模块，有自己的作用域，在一个文件里面定义的变量、函数、类都是私有了。</p><pre><code class="js">// package/lib is a dependency we requireconst lib = require('package/lib');// some behaviour for our modulefunction foo() {    lib.log('hello world!');}// export (expose) foo to other modulesexports.foo = foo;</code></pre><h4 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h4><ul><li>  module模块本身，是Module的一个实例</li><li>  exports指向module.exports，可以通过exports向module.exports对象中添加变量</li><li>  require用于加载模块（核心）</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>  所有模块都运行在模块作用域，不会污染全局作用域</li><li>  模块加载的顺序，按照代码中出现的顺序执行（也就是同步）</li><li>  模块输入的值是复制（基础类型为复制，引用类型为值引用），第一次加载结果就被缓存了，之后再加载就直接读取缓存中的结果，如果要让模块再次运行，需要清除缓存。或者直接导出函数，每次调用函数重新计算。</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>由于篇幅有限，这里不讨论require的加载选择路径优先级的判断，也不讨论模块缓存的过程，并假定加载的文件都是js文件，主要实现代码如下<a href="https://github.com/joyent/node/blob/master/lib/module.js">源代码</a></p><pre><code class="js">function Module(id, parent) {    this.id = id;    this.expotrs = {};    this.parent = parent;    if (parent &amp;&amp; parent.children) {        parent.children.push(this);    }    this.fileanme = null;    this.loaded = false;    this.children = [];}// 这里的module是全局变量module.exports = Module;// 通过一个path加载模块，并返回exports属性Module.prototype.require = function(path) {    return Module._load(path, this);}Module._load = function(path, parent) {    const filename = path;    var module = new Module(filename, parent);    // 加载模块    module.load(filename);    // 输出模块的exports属性    return module.exports;}Module.prototype.load = function(filename) {    // 通过磁盘中读取文件    var content = fs.readFileSync(filename, 'utf8');    module._compile(content, filename);    this.loaded = true;}// 模块编译Module.prototype._compile = function(content, filename) {    const self = this;    const args = [self.exports, require, self, filename, dirname];    // 在沙箱中执行代码    return compiledWrapper.apply(self.exports, args);}</code></pre><p>从代码中可以看出，模块加载实质上就是注入了exports，require，module三个全局变量，然后执行模块的源码，最后将模块的exports的变量输入</p><pre><code class="js">(function(exports, require, module, __filename, __dirname) {    // 模块源码});</code></pre><h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><ul><li>  缺少模块封装的能力，CommonJS规范中每个模块都是一个文件，这意味着每个文件只有一个模块。这在服务器上是可行的，但是在浏览器中就不是很友好，浏览器中需要做到尽可能少的发起请求。</li><li>  使用同步的方式加载依赖，在浏览器中由于JS的加载会阻塞渲染，同步加载会导致长时间的白屏，对于用户体验是致命的。</li><li>  CommonJS规范中使用了<strong>export</strong>的对象来暴露模块，可以讲需要导出的变量附加到<strong>export</strong>上，但是要导出一个函数确是能使用<strong>module.export</strong>，这种语法容易让人感到困惑。</li></ul><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>AMD，全称是Asynchronous Module Definition，即异步模块加载机制，它采用异步方式加载模块，模块的加载不影响后面语句的运行，AMD规范定义了一个<strong>define</strong>全局方法用来定义和加载模块</p><pre><code class="js">define(id ? , dependencies ? , factory);</code></pre><ul><li>  id: 模块标识，可以省略</li><li>  dependences：所依赖的模块数组，可以省略</li><li>  factory：模块的实现，或者一个对象</li></ul><p>AMD也使用了使用<strong>require</strong>全局方法来加载模块，但不同于CommonJS，它要求两个参数，dependences是需要前置的依赖，只有所有前置依赖都加载完了才会触发回调函数，dependences的加载是<strong>通过动态创建sciprt和事件监听的方式来异步加载模块</strong>，解决了CommonJS同步加载的问题。</p><pre><code class="js">require([dependence], callback);</code></pre><h4 id="RequireJS使用"><a href="#RequireJS使用" class="headerlink" title="RequireJS使用"></a>RequireJS使用</h4><p>RequireJS 是 AMD 规范的代表之作，基本使用方式如下</p><pre><code class="js">define(['./a', './b'], function(moduleA, moduleB) {    // 依赖前置    moduleA.mehodA();    console.log(moduleB.dataB);    // 导出数据    return {};});</code></pre><h4 id="RequireJS的实现"><a href="#RequireJS的实现" class="headerlink" title="RequireJS的实现"></a>RequireJS的实现</h4><p>这里同样不讨论RequireJS的模块信息配置，缓存的过程，也不考虑各种链接补全的情况，只是简单实现模块的加载调用，以及所有依赖加载完毕触发callback回调的过程</p><blockquote><p>依赖的定义</p></blockquote><pre><code class="js">// 缓存定义的模块const defMap = {}define = (name, deps, callback) =&gt; {    defMap[name] = {        name,        deps,        callback    }}</code></pre><blockquote><p>依赖模块加载与调用</p></blockquote><p>模块加载的时候会首先通过<strong>Modules</strong>构造函数创建一个模块实例，然后调用初始化<strong>init</strong>的方法传入需要加载的依赖跟回调函数</p><pre><code class="js">// 全局require方法req = require = (name, deps, callback) =&gt; {    const mod = new Module(name)    mod.init(deps, callback)}// 模块加载构造函数class Modules {    constructor(name) {        this.name = name        this.depCount = 0        this.deps = []        this.depExports = []        this.callback = null        this.defineFn = () =&gt; {}    }    init(deps, callback) {        this.deps = deps        this.callback = callback        // 判断是否有依赖，有依赖先加载依赖        if (deps.length === 0) {            this.check()        } else {            this.enable()        }    }}</code></pre><p>其中<strong>enable</strong>函数用来遍历依赖，并绑定回调函数<strong>definedFn</strong></p><pre><code class="js">class Module {    ...    // 加载依赖    enabne() {        this.deps.forEach((name, i) =&gt; {            // 记录加载的模块数            this.depCount++            // 实例化依赖模块，绑定回调            const mod = new Module(name)            mod.definedFn = exports =&gt; {                this.depCount--                // 返回的代码，将模块代码存储起来，全部加载完毕后当作变量传递给父模块调用                this.depExports[i] = exports                // 每次返回一个回调都check一下是否所有依赖都加载完了                this.check()            }            // 通过script加载模块            loadModule(name)        })    }}</code></pre><p><strong>loadModule</strong>是源码的核心，通过动态创建scirpt异步加载依赖，加载完之后再循环加载子模块的依赖，直到全部依赖都加载完毕。</p><pre><code class="js">const loadModule = (name, url) =&gt; {    const head = document.getElementsByTagName('head')[0]    const node = document.createElement('script')    node.type = 'text/javascript'    node.async = true    // 设置一个 data 属性，便于依赖加载完毕后拿到模块名     node.setAttribute('data-module', name)    node.addEventListener('load', onScriptLoad, false)    node.src = url    head.appendChild(node)    return node}// 节点绑定的onload事件函数const onScriptLoad = evt =&gt; {    const node = evt.currentTarget    node.removeEventListener('load', onScriptLoad, false)    // 获取模块名    const name = node.getAttribute('data-module')    // 实例化子模块    const mod = new Module(name)    // 从全局变量defMap中获取模块的依赖和回调    const def = defMap[name]    // 循环加载子模块的依赖    mod.init(def.deps, def.callback)}</code></pre><p><strong>check</strong>函数检查依赖是否全部加载完毕了，加载完毕之后执行回调函数。</p><pre><code class="js">class Module {    ...    // 检查依赖是否加载完毕    check() {        // 依赖数小于1，表示依赖全部加载完        if (this.depCount &lt; 1) {            // 触发回调函数，并获取该模块的内容            this.exports = this.callback.apply(null, this.depExports)            // 激活defined回调，表示当前模块加载完成            this.definedFn(exports)        }    }}</code></pre><p>可以看出，RequireJS最核心的原理就是<strong>通过动态加载script并且监听load事件的方式来实现异步加载模块</strong></p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><blockquote><p>概述</p></blockquote><p>相对于AMD的异步加载，CMD更倾向于懒加载，而且CMD的写法跟CommonJS极为相近，只需要在CommonJS外增加一个函数调用即可，如下</p><pre><code class="js">// CMDdefine(function(require, exports, module) {    const $ = require('Jquery')    $('id')})</code></pre><p>AMD规范的代表作品sea.js在模块加载方式上与RequireJS的原理一致，都是<strong>通过动态加载script并且监听load事件的方式来实现异步加载模块</strong>，跟RequireJS的主要区别在与依赖声明跟加载的时机，其中RequireJS在声明的时候先优先加载了。sea.js则使用懒加载，按需加载的方式，只有在require的地方，才会真正加载运行该模块。</p><blockquote><p>sea.js实现原理</p></blockquote><p>sea.js看起来像是很神奇，JS不是异步的吗？但怎么sea.js调用模块看起来像是同步的？原理这里采用了知乎的一段回答<a href="https://www.zhihu.com/question/20342350/answer/14828786">卢勃</a></p><ol><li> 通过回调函数的Function.toString函数，使用正则表达式（后面改成了状态机进行词法分析的方式）来捕捉内部的require字段，找到require(‘jquery’)内部依赖的模块jquery</li><li> 根据配置文件，找到jquery的js文件的实际路径</li><li> 在dom中插入script标签，载入模块指定的js，绑定加载完成的事件，使得加载完成后将js文件绑定到require模块指定的id（这里就是jquery这个字符串）上</li><li> 回调函数内部依赖的js全部加载（暂不调用）完后，调用回调函数</li><li> 当回调函数调用require(‘jquery’)，即执行绑定在’jquery’这个id上的js文件，即刻执行，并将返回值传给$</li></ol><h3 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h3><p>UMD（Universal Module Definnition）通用模块定义模式，主要用来解决CommonJS模式和AMD模式代码不能在服务端跟Web端通用的问题，并同时还支持老式的全局变量规范。</p><pre><code class="js">(function(global, factory) {    typeof exports === 'object' &amp;&amp; typeof module !== 'undefined' ? module.exports = factory() :        typeof define === 'function' &amp;&amp; define.amd ? define(factory) :        (global = global || self, global.myBundle = factory());}(this, (function() {    const main = () =&gt; {        return 'hello world';    };    return main;})))</code></pre><p>上面代码做了3个判断</p><ol><li> 判断<strong>module</strong>是否为一个对象，并且是否存在<strong>module.exports</strong>来判断是否为<strong>CommonJS</strong>规范</li><li> 判断<strong>define</strong>是否为函数，并且是否存在<strong>define.amd</strong>，来判断是否为AMD规范</li><li> 如果以上两种都没有，则为原始的代码规范</li></ol><h3 id="ES-Modules"><a href="#ES-Modules" class="headerlink" title="ES Modules"></a>ES Modules</h3><h4 id="概述跟语法"><a href="#概述跟语法" class="headerlink" title="概述跟语法"></a>概述跟语法</h4><p>相对于CommonJS和AMD两种比较流行的社区模块加载方案，前者主要用于服务器层面，后者主要用于浏览器层面，ES 2015终于在语言标准层面上，实现了模块功能，而且语法更加简洁，更加人性化。</p><p>模块导出只有一个关键字<strong>export</strong>，可以直接导出变量，函数，或者通过大括号直接输出一组变量，更有独特的<strong>default</strong>可以用来直接导出默认值。</p><pre><code class="js">// moduleA// 直接导出某个变量跟函数export const name = 'chen'export function getName() {    return 'chen'}// 可以通过大括号输出一组变量const anotherName = 'nomad'constfunction getAnotherName() {    return 'nomad'}export {    anotherName,    getAnotherName}// 也可以直接导出默认值export default anotherName</code></pre><p>模块导入可以通过<strong>import</strong>命令加载其他JS文件中<strong>export</strong>的变量，同样可以同时导入其他文件中的默认值<strong>default</strong>（如果存在）跟其他变量</p><pre><code class="js">import defaultName, {    name,    getName,    anotherName,    getAnotherName} from './moduleA'</code></pre><p>具体语法包括导入变量的改名，导入并同时导出的复合写法等就不再赘述，具体可以查看网上的教程。</p><h4 id="CommonJS跟ES-Modules的差异"><a href="#CommonJS跟ES-Modules的差异" class="headerlink" title="CommonJS跟ES Modules的差异"></a>CommonJS跟ES Modules的差异</h4><p>CommonJS模块的<strong>require</strong>是同步加载模块，而ESM 会对静态代码分析，即在代码编译时进行模块的加载，在运行时之前就已经确定了依赖关系（可解决循环引用的问题，后面原理部分有解释）</p><p>CommonJS模块输入的是值拷贝（基础类型为复制，引用类型为值引用）</p><pre><code class="js">// CommonJS// ModuleAconst obj = {    a: 1}let b = 1setTimeout(() =&gt; {    obj.a++    b++});exports.obj = obj;exports.b = b;// ModuleBconst {    obj,    b} = require('./moduleA');console.log(`a: ${obj.a}`);console.log(`b: ${b}`);setTimeout(() =&gt; {    console.log(`a: ${obj.a}`);    console.log(`b: ${b}`);}, 100);// result// a: 1// b: 1// a: 2// b: 1</code></pre><p>ESM模块是动态引用，变量不会被缓存，而是成为一个指向加载模块的引用，只有真正取值的时候才会进行计算取值</p><pre><code class="js">// ESM// moduleAconst obj = {    a: 1}let b = 1setTimeout(() =&gt; {    obj.a++    b++});export {    obj,    b}// moduleBimport {    obj,    b} from './moduleA.mjs';console.log(`a: ${obj.a}`);console.log(`b: ${b}`);setTimeout(() =&gt; {    console.log(`a: ${obj.a}`);    console.log(`b: ${b}`);}, 100);// result// a: 1// b: 1// a: 2// b: 2</code></pre><h4 id="ESM加载的过程"><a href="#ESM加载的过程" class="headerlink" title="ESM加载的过程"></a>ESM加载的过程</h4><ol><li> 构造（Construction）：找到文件下载，并解析成模块记录（module record）</li><li> 实例化（Instantiation）：把所有<strong>export</strong>的变量放入到内存中（暂时不求值），然后把相关<strong>export</strong>跟<strong>import</strong>都指向同一个内存区域</li><li> 求值（Evaluation）：运行代码，把得到值放到指向的内存区域</li></ol><blockquote><p>构造（Construction）</p></blockquote><p>从入口文件开始，并通过代码解析（module specifiers）找到入口文件所依赖的模块，一步一步找到其他模块，并将所有模块解析成模块记录（module record），并缓存到<strong>module map</strong>中，遇到不同文件获取相同依赖，都会直接在<strong>module map</strong>缓存中获取，注意这里并不是要把所有模块的依赖关系全部解析完再开始下一步，因为浏览器一次性下载这么多文件会跟CommonJS一样阻塞主线程。所以这也就是为什么<strong>ESM spec</strong>要把3个加载过程区分开执行的原因。</p><p><img src="/My-Blogs/images/module_record.png" alt="image"></p><blockquote><p>实例化（Instantiation）</p></blockquote><p>实例化的过程就是将代码导出的变量一一指向内存。JS引擎通过<strong>优先深度后序遍历</strong>遍历整个模块关系图，即从依赖关系的最后一个模块（没有引入其他模块）开始实例化，并将所有模块导出的变量绑定在内存上，然后再将<strong>所有模块导入变量绑定到与导出变量同一个内存区域</strong>。所以一旦导出值发生变化，导入值也会变化。这也是ESM导出的是<strong>值引用</strong>的原理。同样也<strong>解决了循环调用</strong>的问题，为什么CommonJS无法解决循环调用的详细解释请查看<a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/">图解ES Modules</a></p><p><img src="/My-Blogs/images/module_bindings.png" alt="image"></p><blockquote><p>求值（Evaluation）</p></blockquote><p>求值步骤相对简单，只要运行代码把计算出来的值填入之前记录的内存地址就可以了，这里就不展开说明了。</p><h4 id="附录：参考-翻译"><a href="#附录：参考-翻译" class="headerlink" title="附录：参考/翻译"></a>附录：参考/翻译</h4><ul><li>  <a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/">ES modules: A cartoon deep-dive</a></li><li>  <a href="https://blog.shenfq.com/2019/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%89%8D%E4%B8%96/">前端模块化的前世</a></li><li>  <a href="http://www.ruanyifeng.com/blog/2015/05/require.html">require源码解读</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冷知识之HTML篇</title>
      <link href="/My-Blogs/2021/01/08/HTML/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BHTML%E7%AF%87/"/>
      <url>/My-Blogs/2021/01/08/HTML/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BHTML%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>这期让我们来看看关于HTML的冷知识都有哪些吧~</p><a id="more"></a><h3 id="浏览器秒变编辑器"><a href="#浏览器秒变编辑器" class="headerlink" title="浏览器秒变编辑器"></a>浏览器秒变编辑器</h3><p>这个还是在浏览器地址栏上面做文章，将以下代码复制粘贴到浏览器地址栏，运行后浏览器就变成了一个原始简单的编辑器，和window自带的notepad差不多，长见识了吧，话不多说，我们来试试。</p><pre><code class="JavaScript">data: text / html, &lt; html contenteditable &gt;</code></pre><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BHTML%E7%AF%87-01.png" alt="image"></p><blockquote><p>归根结底多亏了HTML5中新加的contenteditable属性，当元素指定了该属性后，元素的内容成为可编辑状态。</p></blockquote><p>同理，在控制台执行以下代码，同样可以将整个页面变得可以编辑。</p><blockquote><p>document.body.contentEditable=’true’; </p></blockquote><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BHTML%E7%AF%87-02.png" alt="image"></p><h3 id="实时编写样式的输入框"><a href="#实时编写样式的输入框" class="headerlink" title="实时编写样式的输入框"></a>实时编写样式的输入框</h3><br><p>同理，也是利用了HTML5中的contenteditable属性，巧妙的在body增加一个可编辑的style标签。</p><br><pre><code class="html">&lt;body&gt;  &lt;style style="display:block; position: fixed;" contentEditable&gt;    body {      background: red;    }  &lt;/style&gt;&lt;/body&gt;</code></pre><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BHTML%E7%AF%87-03.png" alt="image"></p><br><h3 id="利用a标签解析url"><a href="#利用a标签解析url" class="headerlink" title="利用a标签解析url"></a>利用a标签解析url</h3><br><p>很多时候我们有从一个URL中提取域名，查询关键字，变量参数值等的需要, 然而处理 url 字符串是比较麻烦的，可以使用 a 标签自动解析 url。</p><br><p>主要方法就是在JS中创建一个a标签，然后将需要处理的URL赋值给我们新创建的a标签的href属性，然后就可以得到我们想要的东西了。</p><br><pre><code class="javascript">var a = document.createElement('a');a.href = 'https://juejin.cn/user/2796746682939054/posts';console.log(a.host);</code></pre><br><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BHTML%E7%AF%87-04.png" alt="image"></p><br><p>利用这一方法，稍微进行封装一下，就可以得到一个非常实用的工具函数了，下面提供一个网上常见的封装示例。</p><pre><code class="javascript">function urlParse(url, key) {  var a = document.createElement('a')  a.href = url  var result = {    href: url,    protocol: a.protocol.replace(':', ''),    port: a.port,    query: a.search,    params: (function() {      var ret = {},        centArr,        seg = a.search.replace(/^\?/, '').replace(/^\?/, '').split('&amp;')      for (i = 0, len = seg.length; i &lt; len; i++) {        if (!seg[i]) {          continue        }        centArr = seg[i].split('=')        ret[centArr[0]] = centArr[1]      }      return ret    }()),    hash: a.hash,    file: (a.pathname.match(/\/([^\/?#]+)$/i) || [, ''])[1],    path: a.pathname.replace(/^([^\/])/, '/$1'),    relative: (a.href.match(/tps?:\/\/[^\/]+(.+)/) || [, ''])[1],    segments: a.pathname.replace(/^\//, '').split('/')  }  a = null  return key ? result[key] : result}</code></pre><br><blockquote><p>H5 有新的 API URL 也可以快速的处理一个链接</p></blockquote><br><pre><code class="JavaScript">var url = new URL('https://www.baidu.com/')url.hash  ...</code></pre>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> 冷知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单介绍2020Google开发者大会web亮点</title>
      <link href="/My-Blogs/2021/01/08/Google/%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D2020Google%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9Aweb%E4%BA%AE%E7%82%B9/"/>
      <url>/My-Blogs/2021/01/08/Google/%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D2020Google%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9Aweb%E4%BA%AE%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="sameSite"><a href="#sameSite" class="headerlink" title="sameSite"></a>sameSite</h3><blockquote><p>Chrome 51 开始，浏览器的 Cookie 新增加了一个SameSite属性，用来防止 CSRF 攻击和用户追踪，分为Strict ，Lax，None</p></blockquote><ul><li><code>Strict</code>最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie</li></ul><p><strong>这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态</strong></p><ul><li><code>Lax</code>规则稍稍放宽，允许同站请求发送Cookie，但大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。</li><li><code>None</code>允许跨站请求，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效</li></ul><table><thead><tr><th>sameSite</th><th>HTTP → HTTPS</th><th>HTTPS → HTTP</th></tr></thead><tbody><tr><td>SameSite=Strict</td><td>⛔ Blocked</td><td>⛔ Blocked</td></tr><tr><td>SameSite=Lax</td><td>✓ Allowed</td><td>✓ Allowed</td></tr><tr><td>SameSite=None; Secure</td><td>✓ Allowed</td><td>⛔ Blocked</td></tr></tbody></table><p><a href="https://web.dev/schemeful-samesite/">查看更多信息</a></p><h3 id="User-Agent-Client-Hints-UA-CH"><a href="#User-Agent-Client-Hints-UA-CH" class="headerlink" title="User-Agent Client Hints(UA-CH)"></a>User-Agent Client Hints(UA-CH)</h3><blockquote><p>从Chrome 85开始，正式发布</p></blockquote><table><thead><tr><th>⬇️ ResponseAccept-CH</th><th>⬆️ Requestheader</th><th>⬆️ RequestExample value</th><th>Description</th></tr></thead><tbody><tr><td>UA</td><td>Sec-CH-UA</td><td>“Chromium”; v=”84”, “Google Chrome”; v=”84”</td><td>List of browser brands and their significant version.</td></tr><tr><td>UA-Mobile</td><td>Sec-CH-UA-Mobile</td><td>?1</td><td>Boolean indicating if the browser is on a mobile device (?1&nbsp;for true) or not (?0&nbsp;for false).</td></tr><tr><td>UA-Full-Version</td><td>Sec-CH-UA-Full-Version</td><td>“84.0.4143.2”</td><td>The complete version for the browser.</td></tr><tr><td>UA-Platform</td><td>Sec-CH-UA-Platform</td><td>“Android”</td><td>The platform for the device, usually the operating system (OS).</td></tr><tr><td>UA-Platform-Version</td><td>Sec-CH-UA-Platform-Version</td><td>“10”</td><td>The version for the platform or OS.</td></tr><tr><td>UA-Arch</td><td>Sec-CH-UA-Arch</td><td>“ARM64”</td><td>The underlying architecture for the device. While this may not be relevant to displaying the page, the site may want to offer a download which defaults to the right format.</td></tr><tr><td>UA-Model</td><td>Sec-CH-UA-Model</td><td>“Pixel 3”</td><td>The device model.</td></tr></tbody></table><h3 id="JavaScript-API"><a href="#JavaScript-API" class="headerlink" title="JavaScript API"></a>JavaScript API</h3><p>Alongside the headers, the User-Agent can also be accessed in JavaScript via navigator.userAgentData. The default Sec-CH-UA and Sec-CH-UA-Mobile header information can be accessed via the brands and mobile properties, respectively:</p><pre><code class="JavaScript">// Log the brand dataconsole.log(navigator.userAgentData.brands);// output[{    brand: 'Chromium',    version: '84',  },  {    brand: 'Google Chrome',    version: '84',  },];// Log the mobile indicatorconsole.log(navigator.userAgentData.mobile);// outputfalse;</code></pre><p><a href="https://web.dev/user-agent-client-hints/">查看更多信息</a></p><h2 id="CSS布局"><a href="#CSS布局" class="headerlink" title="CSS布局"></a>CSS布局</h2><blockquote><p>介绍了一些grid新特性</p></blockquote><h3 id="强居中"><a href="#强居中" class="headerlink" title="强居中"></a>强居中</h3><img src="https://user-images.githubusercontent.com/5030910/100298195-71db5c00-2fcb-11eb-89a2-f4e5ed8a4e8d.png" align="center"><h3 id="三段式布局"><a href="#三段式布局" class="headerlink" title="三段式布局"></a>三段式布局</h3><img src="https://user-images.githubusercontent.com/5030910/100298209-7a339700-2fcb-11eb-95df-49fff7c11a46.png" align="center"><h3 id="经典布局"><a href="#经典布局" class="headerlink" title="经典布局"></a>经典布局</h3><img src="https://user-images.githubusercontent.com/5030910/100298312-c8e13100-2fcb-11eb-8631-d0aba105fa86.png" align="center"><p><a href="http://1linelayouts.glitch.me/">查看更多实例</a></p><p><strong>思考：优化运营后台页面，自适应布局？</strong></p><h2 id="搜索（高级SEO）"><a href="#搜索（高级SEO）" class="headerlink" title="搜索（高级SEO）"></a>搜索（高级SEO）</h2><blockquote><p>利用结构化数据获取 Google 搜索的自然流量</p></blockquote><h3 id="构建富媒体搜索数据，助力Bigo海外电商，直播，imoJobs等业务"><a href="#构建富媒体搜索数据，助力Bigo海外电商，直播，imoJobs等业务" class="headerlink" title="构建富媒体搜索数据，助力Bigo海外电商，直播，imoJobs等业务"></a>构建富媒体搜索数据，助力Bigo海外电商，直播，imoJobs等业务</h3><ul><li><p><strong><a href="https://developers.google.com/search/docs/data-types/product">电商</a></strong></p><img src="https://user-images.githubusercontent.com/5030910/100297927-bfa39480-2fca-11eb-8df7-99606a72f2cf.png" align="center"></li><li><p><strong><a href="https://developers.google.com/search/docs/data-types/video">直播</a></strong></p></li></ul><p><img src="https://user-images.githubusercontent.com/5030910/100444919-3a61d200-30e7-11eb-9fdb-bcf3f609608b.png" alt="image"></p><ul><li><p><strong><a href="https://developers.google.com/search/docs/data-types/job-posting">imojobs</a></strong></p><img src="https://user-images.githubusercontent.com/5030910/100225858-cfcf5b80-2f59-11eb-81fd-ecb766bfc198.png" align="center"></li></ul><p><a href="https://search.google.com/test/rich-results">测试地址</a></p><h3 id="下面是一个购物信息汇总网站页面示例"><a href="#下面是一个购物信息汇总网站页面示例" class="headerlink" title="下面是一个购物信息汇总网站页面示例"></a>下面是一个购物信息汇总网站页面示例</h3><pre><code class="html"> &lt;html&gt; &lt;head&gt;   &lt;title&gt;Executive Anvil&lt;/title&gt; &lt;/head&gt; &lt;body&gt;   &lt;div&gt;     &lt;div itemtype="http://schema.org/Product" itemscope&gt;       &lt;meta itemprop="mpn" content="925872" /&gt;       &lt;meta itemprop="name" content="Executive Anvil" /&gt;       &lt;link itemprop="image" href="https://example.com/photos/16x9/photo.jpg" /&gt;       &lt;link itemprop="image" href="https://example.com/photos/4x3/photo.jpg" /&gt;       &lt;link itemprop="image" href="https://example.com/photos/1x1/photo.jpg" /&gt;       &lt;meta itemprop="description" content="Sleeker than ACME's Classic Anvil, the Executive Anvil is perfect for the business traveler looking for something to drop from a height." /&gt;       &lt;div itemprop="offers" itemtype="http://schema.org/AggregateOffer" itemscope&gt;         &lt;meta itemprop="lowPrice" content="119.99" /&gt;         &lt;meta itemprop="highPrice" content="199.99" /&gt;         &lt;meta itemprop="offerCount" content="6" /&gt;         &lt;meta itemprop="priceCurrency" content="USD" /&gt;       &lt;/div&gt;       &lt;div itemprop="aggregateRating" itemtype="http://schema.org/AggregateRating" itemscope&gt;         &lt;meta itemprop="reviewCount" content="89" /&gt;         &lt;meta itemprop="ratingValue" content="4.4" /&gt;       &lt;/div&gt;       &lt;div itemprop="review" itemtype="http://schema.org/Review" itemscope&gt;         &lt;div itemprop="author" itemtype="http://schema.org/Person" itemscope&gt;           &lt;meta itemprop="name" content="Fred Benson" /&gt;         &lt;/div&gt;         &lt;div itemprop="reviewRating" itemtype="http://schema.org/Rating" itemscope&gt;           &lt;meta itemprop="ratingValue" content="4" /&gt;           &lt;meta itemprop="bestRating" content="5" /&gt;         &lt;/div&gt;       &lt;/div&gt;       &lt;meta itemprop="sku" content="0446310786" /&gt;       &lt;div itemprop="brand" itemtype="http://schema.org/Brand" itemscope&gt;         &lt;meta itemprop="name" content="ACME" /&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;</code></pre><p><strong>思考：可以利用Node+CDN服务搭建富媒体HTML直出平台，优化SEO？</strong></p><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><h3 id="PageSpeed-Insights-PSI"><a href="#PageSpeed-Insights-PSI" class="headerlink" title=" PageSpeed Insights(PSI)"></a><a href="https://developers.google.com/speed/pagespeed/insights/"> PageSpeed Insights(PSI)</a></h3><blockquote><p>PSI 作为一款专注于改进网页性能的开发者工具</p></blockquote><p><strong>它主要具有以下两个优势：</strong></p><ul><li>真实的网页运行速度。这是 PSI 2.0 中的新功能，PSI 结合 Chrome 用户体验报告中的数据，向开发者展示他们的网页的实际性能，这一点对于开发者来说是很有价值的。那么，PSI 则成为了用户获得真实的网页运行速度的窗口。</li><li>优化建议。根据一些常用的网页性能优化规则(如避免过多的重定向)，PSI 会基于该网页的优化空间为用户提供一些网页优化建议。</li></ul><h3 id="Puppeteer"><a href="#Puppeteer" class="headerlink" title="Puppeteer"></a><a href="https://github.com/puppeteer/puppeteer">Puppeteer</a></h3><blockquote><p>Nodejs工具库，它提供了高级的JavaScript API 来通过DevTools控制 Chromium与其他浏览器</p></blockquote><p><strong>Puppeteer能做什么？</strong></p><ul><li>生成页面的屏幕截图和PDF。</li><li>爬取SPA（单页应用程序）并生成预渲染的内容（即“ SSR”（服务器端渲染））。</li><li>高级爬虫，可以爬取大量异步渲染内容的网页。</li><li>自动进行表单提交，UI测试，键盘输入，模拟时区，改变深色主题等。</li><li>创建最新的自动化测试环境。使用最新的JavaScript和浏览器功能，直接在最新版本的Chrome中运行测试。</li><li>捕获站点的时间线跟踪，以帮助诊断性能问题。</li><li>测试Chrome扩展程序。</li></ul><p><strong>example.js</strong></p><pre><code class="js">const puppeteer = require('puppeteer');(async () =&gt; {  const browser = await puppeteer.launch();  const page = await browser.newPage();  await page.goto('https://example.com');  await page.screenshot({    path: 'example.png'  });  await browser.close();})();</code></pre><blockquote><p>node example.js</p></blockquote><p><strong>最新进展介绍</strong></p> <img src="https://user-images.githubusercontent.com/5030910/100229116-aebd3980-2f5e-11eb-8c5b-e85159a427d7.png " width="500" align="center"><p><strong>思考：可以构建Serveless服务，搭建FaaS平台，助力前端服务和运营服务？</strong></p><h3 id="Web-Vitals"><a href="#Web-Vitals" class="headerlink" title="Web Vitals"></a>Web Vitals</h3><blockquote><p>什么是 Web Vitals ，Google 给的定义是一个良好网站的基本指标 (Essential metrics for a healthy site)，为什么还要再定义一个新的指标集，原因是过去要衡量一个好的网站，需要使用的指标太多，推出 Web Vitals 是简化这个学习的曲线，站主只要观注 Web Vitals 指标表现即可。</p></blockquote><h4 id="三大指标"><a href="#三大指标" class="headerlink" title="三大指标"></a>三大指标</h4><p><img src="https://user-images.githubusercontent.com/5030910/100299467-bf0cfd00-2fce-11eb-972f-48b4b8c60a3c.png" alt="image"></p><p>使用<a href="https://github.com/GoogleChrome/web-vitals">web-vitals</a>库，测量每个指标就像调用单个函数一样简单（有关完整用法和 API详细信息，请参阅文档 ）：</p><pre><code class="js">import {  getCLS,  getFID,  getLCP} from 'web-vitals';function sendToAnalytics(metric) {  const body = JSON.stringify(metric);  // Use `navigator.sendBeacon()` if available, falling back to `fetch()`.  (navigator.sendBeacon &amp;&amp; navigator.sendBeacon('/analytics', body)) ||  fetch('/analytics', {    body,    method: 'POST',    keepalive: true  });}getCLS(sendToAnalytics);getFID(sendToAnalytics);getLCP(sendToAnalytics);</code></pre><table><thead><tr><th>Platform</th><th>LCP</th><th>FID</th><th>CLS</th></tr></thead><tbody><tr><td><a href="https://developers.google.com/web/tools/chrome-user-experience-report">Chrome User Experience Report</a></td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td><a href="https://developers.google.com/speed/pagespeed/insights/">PageSpeed Insights</a></td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td><a href="https://support.google.com/webmasters/answer/9205520">Search Console (Core Web Vitals report)</a></td><td>✔</td><td>✔</td><td>✔</td></tr></tbody></table><p><strong>思考：利用Web Vitals结合puppeteer，搭建网页自动化测试平台，爬虫工具？</strong></p><h2 id="Chrome相关（DevTools，Lighthouse）"><a href="#Chrome相关（DevTools，Lighthouse）" class="headerlink" title="Chrome相关（DevTools，Lighthouse）"></a>Chrome相关（DevTools，Lighthouse）</h2><h3 id="支持CSS-in-JS框架的样式编辑"><a href="#支持CSS-in-JS框架的样式编辑" class="headerlink" title="支持CSS-in-JS框架的样式编辑"></a><a href="https://developers.google.com/web/updates/images/2020/06/css-in-js.mp4">支持CSS-in-JS框架的样式编辑</a></h3><p><img src="https://user-images.githubusercontent.com/5030910/100299322-60e01a00-2fce-11eb-96b6-a37621b3180a.png" alt="image"></p><h3 id="模拟时区"><a href="#模拟时区" class="headerlink" title="模拟时区"></a>模拟时区</h3><p><img src="https://user-images.githubusercontent.com/5030910/100299410-92f17c00-2fce-11eb-8447-6eb810ec5a8d.png" alt="image"></p><h3 id="媒体面板"><a href="#媒体面板" class="headerlink" title="媒体面板"></a>媒体面板</h3><p><img src="https://user-images.githubusercontent.com/5030910/100299683-35a9fa80-2fcf-11eb-9a67-cf3927b48199.png" alt="image"></p><h3 id="一键修复文字的色彩对比"><a href="#一键修复文字的色彩对比" class="headerlink" title="一键修复文字的色彩对比"></a>一键修复文字的色彩对比</h3><p><img src="https://user-images.githubusercontent.com/5030910/100299746-638f3f00-2fcf-11eb-9e12-0e2a7017c6a9.png" alt="image"></p><h3 id="利用Lighthouse-生成性能报告"><a href="#利用Lighthouse-生成性能报告" class="headerlink" title="利用Lighthouse 生成性能报告"></a>利用Lighthouse 生成性能报告</h3><p><img src="https://user-images.githubusercontent.com/5030910/100299914-d0a2d480-2fcf-11eb-8500-a0fdc33c45c0.png" alt="image"></p><p><strong><a href="https://developers.google.com/web/updates">更多内容查看这里</a></strong></p><h2 id="PWA与WebPush"><a href="#PWA与WebPush" class="headerlink" title="PWA与WebPush"></a>PWA与WebPush</h2><h3 id="利用PWA解决以下问题"><a href="#利用PWA解决以下问题" class="headerlink" title="利用PWA解决以下问题"></a>利用PWA解决以下问题</h3><p><img src="https://user-images.githubusercontent.com/5030910/100417600-3cfb0200-30bc-11eb-8c5b-16148406d95c.png" alt="image"></p><h3 id="WebPush流程图"><a href="#WebPush流程图" class="headerlink" title="WebPush流程图"></a>WebPush流程图</h3><p><strong>授权流程</strong></p><p><img src="https://user-images.githubusercontent.com/5030910/100417630-50a66880-30bc-11eb-8ecc-2199dab3dc11.png" alt="Web push授权流程"></p><p><strong>通知流程</strong></p><p><img src="https://user-images.githubusercontent.com/5030910/100417986-eb06ac00-30bc-11eb-9ecf-6b3dd9b5a69e.png" alt="image"></p><p><strong>代码实现</strong></p><p><img src="https://user-images.githubusercontent.com/5030910/100418090-17bac380-30bd-11eb-8ca5-6fe9c18deddd.png" alt="image"></p><p><strong>成果</strong></p><p><img src="https://user-images.githubusercontent.com/5030910/100418205-505a9d00-30bd-11eb-9bda-9e12c38f60f1.png" alt="image"></p><p><strong>思考：利用Node，搭建PWA构建平台，助力海外电商业务，将营销推广类活动页封装成PWA</strong></p><h2 id="TensorFlow-js"><a href="#TensorFlow-js" class="headerlink" title="TensorFlow.js"></a>TensorFlow.js</h2><h3 id="来分享一个有意思的场景"><a href="#来分享一个有意思的场景" class="headerlink" title="来分享一个有意思的场景"></a>来分享一个有意思的场景</h3><p><strong><a href="https://blog.tensorflow.org/2020/09/bringing-mona-lisa-effect-to-life-tensorflow-js.html">交互式《蒙娜丽莎》画像</a></strong></p><blockquote><p>传说中，不管你从哪个角度看《蒙娜丽莎》画像，都会感到画像中的女子在看着你。TensorFlow 的官方博客，演示怎么用 TensorFlow.js，制作一个交互式的《蒙娜丽莎》画像，摄像头捕捉观看者的角度，然后自动改变画像的眼神。</p></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/202009/bg2020092603.jpg" alt="image"></p><p><img src="https://www.wangbase.com/blogimg/asset/202009/bg2020092604.jpg" alt="image"></p><h3 id="利用TensorFlow-Privacy-检查隐私保护措施"><a href="#利用TensorFlow-Privacy-检查隐私保护措施" class="headerlink" title="利用TensorFlow Privacy 检查隐私保护措施"></a>利用TensorFlow Privacy 检查隐私保护措施</h3><p><img src="https://user-images.githubusercontent.com/5030910/100418941-851b2400-30be-11eb-98cf-af0d5dbb1a5f.png" alt="image"></p><p><img src="https://user-images.githubusercontent.com/5030910/100419020-a3811f80-30be-11eb-9237-c33f9de6b58a.png" alt="image"></p><p><img src="https://user-images.githubusercontent.com/5030910/100419041-ada31e00-30be-11eb-88cd-0c5f8b2c89bd.png" alt="image"></p><p><strong>思考：或许可以利用Node+TensorFlow，对于用户上传的图片进行二次处理？</strong></p><ul><li><p><a href="https://www.tensorflow.org/js/?hl=zh_cn">官网</a></p></li><li><p><a href="https://www.icourse163.org/learn/youdao-1460578162?tid=1461280442#/learn/content">入门课程</a></p></li><li><p><a href="https://flutter.dev/web">Flutter Web</a></p></li><li><p><a href="https://space.bilibili.com/64169458/channel/detail?cid=156180">视频集合链接</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Google </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git远程操作详解【转载】</title>
      <link href="/My-Blogs/2021/01/08/Git/Git%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91/"/>
      <url>/My-Blogs/2021/01/08/Git/Git%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>Git有很多优势，其中之一就是远程操作非常简便。本文详细介绍5个Git命令，它们的概念和用法，理解了这些内容，你就会完全掌握Git远程操作。</p><a id="more"></a><pre><code class="BASH">git clonegit remotegit fetchgit pullgit push</code></pre><p>本文针对初级用户，从最简单的讲起，但是需要读者对Git的基本用法有所了解。同时，本文覆盖了上面5个命令的几乎所有的常用用法，所以对于熟练用户也有参考价值。</p><h3 id="一、git-clone"><a href="#一、git-clone" class="headerlink" title="一、git clone"></a>一、git clone</h3><p>远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。</p><pre><code class="BASH">$ git clone &amp;lt;版本库的网址&amp;gt;</code></pre><p>比如，克隆jQuery的版本库。</p><pre><code class="BASH">$ git clone https://github.com/jquery/jquery.git</code></pre><p>该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。</p><pre><code class="BASH">$ git clone &amp;lt;版本库的网址&amp;gt; &amp;lt;本地目录名&amp;gt;</code></pre><p>git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。</p><pre><code class="BASH">$ git clone http[s]://example.com/path/to/repo.git/$ git clone ssh://example.com/path/to/repo.git/$ git clone git://example.com/path/to/repo.git/$ git clone /opt/git/project.git $ git clone file:///opt/git/project.git$ git clone ftp[s]://example.com/path/to/repo.git/$ git clone rsync://example.com/path/to/repo.git/</code></pre><p>SSH协议还有另一种写法。</p><pre><code class="BASH">$ git clone [user@]example.com:path/to/repo.git/</code></pre><p>通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考官方文档。</p><h3 id="二、git-remote"><a href="#二、git-remote" class="headerlink" title="二、git remote"></a>二、git remote</h3><p>为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。</p><p>不带选项的时候，git remote命令列出所有远程主机。</p><pre><code class="BASH">$ git remote origin</code></pre><p>使用-v选项，可以参看远程主机的网址。</p><pre><code class="BASH">$ git remote -vorigin  git@github.com:jquery/jquery.git (fetch)origin  git@github.com:jquery/jquery.git (push)</code></pre><p>上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。</p><p>克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。</p><pre><code class="BASH">$ git clone -o jQuery https://github.com/jquery/jquery.git$ git remote</code></pre><p>jQuery</p><p>上面命令表示，克隆的时候，指定远程主机叫做jQuery。</p><pre><code class="BASH">git remote show命令加上主机名，可以查看该主机的详细信息。$ git remote show &lt;主机名&gt;git remote add命令用于添加远程主机。$ git remote add &lt;主机名&gt; &lt;网址&gt;git remote rm命令用于删除远程主机。$ git remote rm &lt;主机名&gt;git remote rename命令用于远程主机的改名。$ git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</code></pre><h3 id="三、git-fetch"><a href="#三、git-fetch" class="headerlink" title="三、git fetch"></a>三、git fetch</h3><p>一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。</p><pre><code class="BASH">$ git fetch &lt;远程主机名&gt;</code></pre><p>上面命令将某个远程主机的更新，全部取回本地。</p><p><code>git fetch</code> 命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。</p><p>默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。</p><pre><code class="BASH">$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;</code></pre><p>比如，取回origin主机的master分支。</p><pre><code class="BASH">$ git fetch origin master</code></pre><p>所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。</p><p>git branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。</p><pre><code class="BASH">$ git branch -rorigin/master$ git branch -a* master  remotes/origin/master</code></pre><p>上面命令表示，本地主机的当前分支是master，远程分支是origin/master。</p><p>取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。</p><pre><code class="BASH">$ git checkout -b newBrach origin/master</code></pre><p>上面命令表示，在origin/master的基础上，创建一个新分支。</p><p>此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。</p><pre><code class="BASH">$ git pull origin next:master</code></pre><p>上面命令表示在当前分支上，合并origin/master。</p><h3 id="四、git-pull"><a href="#四、git-pull" class="headerlink" title="四、git pull"></a>四、git pull</h3><p>git pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。</p><pre><code class="BASH">$ git pull &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;</code></pre><p>比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。</p><pre><code class="BASH">$ git pull origin next:master</code></pre><p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p><pre><code class="BASH">$ git pull origin next</code></pre><p>上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。</p><pre><code class="BASH">$ git fetch origin$ git merge origin/next</code></pre><p>在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。</p><p>Git也允许手动建立追踪关系。</p><pre><code class="BASH">git branch --set-upstream master origin/next</code></pre><p>上面命令指定master分支追踪origin/next分支。</p><p>如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。</p><pre><code class="BASH">$ git pull origin</code></pre><p>上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”（remote-tracking branch）进行合并。</p><p>如果当前分支只有一个追踪分支，连远程主机名都可以省略。</p><pre><code class="BASH">$ git pull</code></pre><p>上面命令表示，当前分支自动与唯一一个追踪分支进行合并。</p><p>如果合并需要采用rebase模式，可以使用–rebase选项。</p><pre><code class="BASH">$ git pull --rebase &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;</code></pre><p>如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。</p><p>但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。</p><pre><code class="BASH">$ git pull -p等同于下面的命令$ git fetch --prune origin $ git fetch -p</code></pre><h3 id="五、git-push"><a href="#五、git-push" class="headerlink" title="五、git push"></a>五、git push</h3><p>git push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。</p><pre><code class="BASH">$ git push &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名&amp;gt;:&amp;lt;远程分支名&amp;gt;</code></pre><p>注意，分支推送顺序的写法是&lt; 来源地&gt; :&lt; 目的地&gt; ，所以git pull是&lt; 远程分支&gt; :&lt; 本地分支&gt; ，而git push是&lt; 本地分支&gt; :&lt; 远程分支&gt; 。</p><p>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</p><pre><code class="BASH">$ git push origin master</code></pre><p>上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。</p><p>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p><pre><code class="BASH">$ git push origin :master等同于$ git push origin --delete master</code></pre><p>上面命令表示删除origin主机的master分支。</p><p>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</p><pre><code class="BASH">$ git push origin</code></pre><p>上面命令表示，将当前分支推送到origin主机的对应分支。</p><p>如果当前分支只有一个追踪分支，那么主机名都可以省略。</p><pre><code class="BASH">$ git push</code></pre><p>如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。</p><pre><code class="BASH">$ git push -u origin master</code></pre><p>上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。</p><p>不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。</p><pre><code class="BASH">$ git config --global push.default matching或者$ git config --global push.default simple</code></pre><p>还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用–all选项。</p><pre><code class="BASH">$ git push --all origin</code></pre><p>上面命令表示，将所有本地分支都推送到origin主机。</p><p>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用–force选项。</p><pre><code class="BASH">$ git push --force origin</code></pre><p>上面命令使用–force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用–force选项。</p><p>最后，git push不会推送标签（tag），除非使用–tags选项。</p><pre><code class="BASH">$ git push origin --tags</code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git回滚操作</title>
      <link href="/My-Blogs/2021/01/08/Git/git%E5%9B%9E%E6%BB%9A%E6%93%8D%E4%BD%9C/"/>
      <url>/My-Blogs/2021/01/08/Git/git%E5%9B%9E%E6%BB%9A%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>我们都知道万一提交错了代码，想要删除又想准确无误怎么办呢？下面介绍两种方式，看是否有适合你的呢</p><a id="more"></a><h2 id="git删除指定commit"><a href="#git删除指定commit" class="headerlink" title="git删除指定commit"></a>git删除指定commit</h2><ol><li> 使用git log 命令，查看已提交的记录。例如红色圈出的commit是本次要删除的commit。</li></ol><p><img src="/My-Blogs/images/git%E5%9B%9E%E6%BB%9A%E6%93%8D%E4%BD%9C-01.png"></p><br><ol start="2"><li><p> 先找到此次提交之前的一次提交的commit 1d6b81b138f89735265900b94fcd1ec39375e7b4</p></li><li><p> 执行git rebase -i 1d6b81b138f89735265900b94fcd1ec39375e7b4，弹出如下页面（不包含当前commit）：</p></li></ol><p><img src="/My-Blogs/images/git%E5%9B%9E%E6%BB%9A%E6%93%8D%E4%BD%9C-02.png"></p><br><p>按字母I键进入编辑模式，将需要删除的commit的pick改为drop，然后按esc退出编辑，：wq保存</p><p><img src="/My-Blogs/images/git%E5%9B%9E%E6%BB%9A%E6%93%8D%E4%BD%9C-03.png"></p><br><ol start="4"><li> 再次执行git log命令，查看已提交记录，之前红色圈出的commit记录已被删除。</li></ol><p><img src="/My-Blogs/images/git%E5%9B%9E%E6%BB%9A%E6%93%8D%E4%BD%9C-04.png"></p><p><strong>PS：以上方法不适用特定merge提交删除</strong></p><h2 id="优雅撤销中间某次merge提交"><a href="#优雅撤销中间某次merge提交" class="headerlink" title="优雅撤销中间某次merge提交"></a>优雅撤销中间某次merge提交</h2><pre><code class="BASH">git revert commit_id//如果commit_id是merge节点的话,-m是指定具体哪个提交点git revert commit_id -m 1//接着就是解决冲突git add -Agit commit -m ".."git revert commit_id -m 2//接着就是解决冲突git add -Agit commit -m ".."git push</code></pre><p>其中<code>git revert commit_id -m 数字</code>是针对，<code>merge</code>提交点的操作。<br>如果是普通的提交点，直接用rebase即可，不需要这么麻烦。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eslint使用规则</title>
      <link href="/My-Blogs/2021/01/08/eslint/%E5%85%B3%E4%BA%8Eeslint%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99%EF%BC%8C%E5%92%8C%E5%90%84%E7%A7%8D%E6%8A%A5%E9%94%99%E5%BA%94%E5%AF%B9%E4%B9%A6%E5%86%99%E8%A7%84%E5%88%99/"/>
      <url>/My-Blogs/2021/01/08/eslint/%E5%85%B3%E4%BA%8Eeslint%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99%EF%BC%8C%E5%92%8C%E5%90%84%E7%A7%8D%E6%8A%A5%E9%94%99%E5%BA%94%E5%AF%B9%E4%B9%A6%E5%86%99%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>整理了一些eslint常用规则，欢迎大家评阅</p><a id="more"></a><p><strong>为了方便查看和使用所以进行了整理，以下。</strong></p><blockquote><p>0=”off” 1=”warn” 2=”error”</p></blockquote><pre><code class="js">"no-alert": 0,//禁止使用alert confirm prompt"no-array-constructor": 2,//禁止使用数组构造器"no-bitwise": 0,//禁止使用按位运算符"no-caller": 1,//禁止使用arguments.caller或arguments.callee"no-catch-shadow": 2,//禁止catch子句参数与外部作用域变量同名"no-class-assign": 2,//禁止给类赋值"no-cond-assign": 2,//禁止在条件表达式中使用赋值语句"no-console": 2,//禁止使用console"no-const-assign": 2,//禁止修改const声明的变量"no-constant-condition": 2,//禁止在条件中使用常量表达式 if(true) if(1)"no-continue": 0,//禁止使用continue"no-control-regex": 2,//禁止在正则表达式中使用控制字符"no-debugger": 2,//禁止使用debugger"no-delete-var": 2,//不能对var声明的变量使用delete操作符"no-div-regex": 1,//不能使用看起来像除法的正则表达式/=foo/"no-dupe-keys": 2,//在创建对象字面量时不允许键重复 {a:1,a:1}"no-dupe-args": 2,//函数参数不能重复"no-duplicate-case": 2,//switch中的case标签不能重复"no-else-return": 2,//如果if语句里面有return,后面不能跟else语句"no-empty": 2,//块语句中的内容不能为空"no-empty-character-class": 2,//正则表达式中的[]内容不能为空"no-empty-label": 2,//禁止使用空label"no-eq-null": 2,//禁止对null使用==或!=运算符"no-eval": 1,//禁止使用eval"no-ex-assign": 2,//禁止给catch语句中的异常参数赋值"no-extend-native": 2,//禁止扩展native对象"no-extra-bind": 2,//禁止不必要的函数绑定"no-extra-boolean-cast": 2,//禁止不必要的bool转换"no-extra-parens": 2,//禁止非必要的括号"no-extra-semi": 2,//禁止多余的冒号"no-fallthrough": 1,//禁止switch穿透"no-floating-decimal": 2,//禁止省略浮点数中的0 .5 3."no-func-assign": 2,//禁止重复的函数声明"no-implicit-coercion": 1,//禁止隐式转换"no-implied-eval": 2,//禁止使用隐式eval"no-inline-comments": 0,//禁止行内备注"no-inner-declarations": [2, "functions"],//禁止在块语句中使用声明（变量或函数）"no-invalid-regexp": 2,//禁止无效的正则表达式"no-invalid-this": 2,//禁止无效的this，只能用在构造器，类，对象字面量"no-irregular-whitespace": 2,//不能有不规则的空格"no-iterator": 2,//禁止使用__iterator__ 属性"no-label-var": 2,//label名不能与var声明的变量名相同"no-labels": 2,//禁止标签声明"no-lone-blocks": 2,//禁止不必要的嵌套块"no-lonely-if": 2,//禁止else语句内只有if语句"no-loop-func": 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）"no-mixed-requires": [0, false],//声明时不能混用声明类型"no-mixed-spaces-and-tabs": [2, false],//禁止混用tab和空格"linebreak-style": [0, "windows"],//换行风格"no-multi-spaces": 1,//不能用多余的空格"no-multi-str": 2,//字符串不能用\换行"no-multiple-empty-lines": [1, {"max": 2}],//空行最多不能超过2行"no-native-reassign": 2,//不能重写native对象"no-negated-in-lhs": 2,//in 操作符的左边不能有!"no-nested-ternary": 0,//禁止使用嵌套的三目运算"no-new": 1,//禁止在使用new构造一个实例后不赋值"no-new-func": 1,//禁止使用new Function"no-new-object": 2,//禁止使用new Object()"no-new-require": 2,//禁止使用new require"no-new-wrappers": 2,//禁止使用new创建包装实例，new String new Boolean new Number"no-obj-calls": 2,//不能调用内置的全局对象，比如Math() JSON()"no-octal": 2,//禁止使用八进制数字"no-octal-escape": 2,//禁止使用八进制转义序列"no-param-reassign": 2,//禁止给参数重新赋值"no-path-concat": 0,//node中不能使用__dirname或__filename做路径拼接"no-plusplus": 0,//禁止使用++，--"no-process-env": 0,//禁止使用process.env"no-process-exit": 0,//禁止使用process.exit()"no-proto": 2,//禁止使用__proto__属性"no-redeclare": 2,//禁止重复声明变量"no-regex-spaces": 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/"no-restricted-modules": 0,//如果禁用了指定模块，使用就会报错"no-return-assign": 1,//return 语句中不能有赋值表达式"no-script-url": 0,//禁止使用javascript:void(0)"no-self-compare": 2,//不能比较自身"no-sequences": 0,//禁止使用逗号运算符"no-shadow": 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名"no-shadow-restricted-names": 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用"no-spaced-func": 2,//函数调用时 函数名与()之间不能有空格"no-sparse-arrays": 2,//禁止稀疏数组， [1,,2]"no-sync": 0,//nodejs 禁止同步方法"no-ternary": 0,//禁止使用三目运算符"no-trailing-spaces": 1,//一行结束后面不要有空格"no-this-before-super": 0,//在调用super()之前不能使用this或super"no-throw-literal": 2,//禁止抛出字面量错误 throw "error";"no-undef": 1,//不能有未定义的变量"no-undef-init": 2,//变量初始化时不能直接给它赋值为undefined"no-undefined": 2,//不能使用undefined"no-unexpected-multiline": 2,//避免多行表达式"no-underscore-dangle": 1,//标识符不能以_开头或结尾"no-unneeded-ternary": 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;"no-unreachable": 2,//不能有无法执行的代码"no-unused-expressions": 2,//禁止无用的表达式"no-unused-vars": [2, {"vars": "all", "args": "after-used"}],//不能有声明后未被使用的变量或参数"no-use-before-define": 2,//未定义前不能使用"no-useless-call": 2,//禁止不必要的call和apply"no-void": 2,//禁用void操作符"no-var": 0,//禁用var，用let和const代替"no-warning-comments": [1, { "terms": ["todo", "fixme", "xxx"], "location": "start" }],//不能有警告备注"no-with": 2,//禁用with"array-bracket-spacing": [2, "never"],//是否允许非空数组里面有多余的空格"arrow-parens": 0,//箭头函数用小括号括起来"arrow-spacing": 0,//=&gt;的前/后括号"accessor-pairs": 0,//在对象中使用getter/setter"block-scoped-var": 0,//块语句中使用var"brace-style": [1, "1tbs"],//大括号风格"callback-return": 1,//避免多次调用回调什么的"camelcase": 2,//强制驼峰法命名"comma-dangle": [2, "never"],//对象字面量项尾不能有逗号"comma-spacing": 0,//逗号前后的空格"comma-style": [2, "last"],//逗号风格，换行时在行首还是行尾"complexity": [0, 11],//循环复杂度"computed-property-spacing": [0, "never"],//是否允许计算后的键名什么的"consistent-return": 0,//return 后面是否允许省略"consistent-this": [2, "that"],//this别名"constructor-super": 0,//非派生类不能调用super，派生类必须调用super"curly": [2, "all"],//必须使用 if(){} 中的{}"default-case": 2,//switch语句最后必须有default"dot-location": 0,//对象访问符的位置，换行的时候在行首还是行尾"dot-notation": [0, { "allowKeywords": true }],//避免不必要的方括号"eol-last": 0,//文件以单一的换行符结束"eqeqeq": 2,//必须使用全等"func-names": 0,//函数表达式必须有名字"func-style": [0, "declaration"],//函数风格，规定只能使用函数声明/函数表达式"generator-star-spacing": 0,//生成器函数*的前后空格"guard-for-in": 0,//for in循环要用if语句过滤"handle-callback-err": 0,//nodejs 处理错误"id-length": 0,//变量名长度"indent": [2, 4],//缩进风格"init-declarations": 0,//声明时必须赋初值"key-spacing": [0, { "beforeColon": false, "afterColon": true }],//对象字面量中冒号的前后空格"lines-around-comment": 0,//行前/行后备注"max-depth": [0, 4],//嵌套块深度"max-len": [0, 80, 4],//字符串最大长度"max-nested-callbacks": [0, 2],//回调嵌套深度"max-params": [0, 3],//函数最多只能有3个参数"max-statements": [0, 10],//函数内最多有几个声明"new-cap": 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用"new-parens": 2,//new时必须加小括号"newline-after-var": 2,//变量声明后是否需要空一行"object-curly-spacing": [0, "never"],//大括号内是否允许不必要的空格"object-shorthand": 0,//强制对象字面量缩写语法"one-var": 1,//连续声明"operator-assignment": [0, "always"],//赋值运算符 += -=什么的"operator-linebreak": [2, "after"],//换行时运算符在行尾还是行首"padded-blocks": 0,//块语句内行首行尾是否要空行"prefer-const": 0,//首选const"prefer-spread": 0,//首选展开运算"prefer-reflect": 0,//首选Reflect的方法"quotes": [1, "single"],//引号类型 `` "" ''"quote-props":[2, "always"],//对象字面量中的属性名是否强制双引号"radix": 2,//parseInt必须指定第二个参数"id-match": 0,//命名检测"require-yield": 0,//生成器函数必须有yield"semi": [2, "always"],//语句强制分号结尾"semi-spacing": [0, {"before": false, "after": true}],//分号前后空格"sort-vars": 0,//变量声明时排序"space-after-keywords": [0, "always"],//关键字后面是否要空一格"space-before-blocks": [0, "always"],//不以新行开始的块{前面要不要有空格"space-before-function-paren": [0, "always"],//函数定义时括号前面要不要有空格"space-in-parens": [0, "never"],//小括号里面要不要有空格"space-infix-ops": 0,//中缀操作符周围要不要有空格"space-return-throw-case": 2,//return throw case后面要不要加空格"space-unary-ops": [0, { "words": true, "nonwords": false }],//一元运算符的前/后要不要加空格"spaced-comment": 0,//注释风格不要有空格什么的"strict": 2,//使用严格模式"use-isnan": 2,//禁止比较时使用NaN，只能用isNaN()"valid-jsdoc": 0,//jsdoc规则"valid-typeof": 2,//必须使用合法的typeof的值"vars-on-top": 2,//var必须放在作用域顶部"wrap-iife": [2, "inside"],//立即执行函数表达式的小括号风格"wrap-regex": 0,//正则表达式字面量用小括号包起来"yoda": [2, "never"]//禁止尤达条件</code></pre>]]></content>
      
      
      <categories>
          
          <category> eslint </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eslint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时序分析场景</title>
      <link href="/My-Blogs/2021/01/08/Elasticsearch/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90%E5%9C%BA%E6%99%AF/"/>
      <url>/My-Blogs/2021/01/08/Elasticsearch/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>时序数据是按时间顺序记录设备、系统状态变化的数据。典型的时序数据有传统的服务器监控指标数据、应用系统性能监控数据、智能硬件、工业物联网传感器数据等。</p><p>早在2017年我们也基于ES进行了时序分析场景的探索。时序分析场景具有高并发写入、低查询时延、多维分析的特点。</p><p>由于ES具有集群扩展、批量写入、读写带路由、数据分片等能力，目前已实现线上单集群最大规模达到600+ 节点、1000w/s的写入吞吐、单条曲线或单个时间线的查询延时可控制在10ms。</p><p>ES提供灵活、多维度的统计分析能力，实现查看监控按照地域、业务模块等灵活的进行统计分析。另外，ES支持列存储、高压缩比、副本数按需调整等能力，可实现较低存储成本。最后时序数据也可通过Kibana组件轻松实现可视化。</p><p><img src="/My-Blogs/images/%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90%E5%9C%BA%E6%99%AF-01.jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
            <tag> 应用场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志实时分析场景</title>
      <link href="/My-Blogs/2021/01/08/Elasticsearch/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E6%97%A5%E5%BF%97%E5%AE%9E%E6%97%B6%E5%88%86%E6%9E%90%E5%9C%BA%E6%99%AF/"/>
      <url>/My-Blogs/2021/01/08/Elasticsearch/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E6%97%A5%E5%BF%97%E5%AE%9E%E6%97%B6%E5%88%86%E6%9E%90%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>日志是互联网行业基础广泛的数据形式。典型日志有用来定位业务问题的运营日志，如慢日志、异常日志；用来分析用户行为的业务日志，如用户的点击、访问日志；以及安全行为分析的审计日志等。</p><p>Elastic生态提供了完整的日志解决方案。通过简单部署，即可搭建一个完整的日志实时分析服务。ES生态完美的解决了日志实时分析场景需求，这也是近几年ES快速发展的一个重要原因。</p><p>日志从产生到可访问一般在10s级，相比于传统大数据解决方案的几十分钟、小时级时效性非常高。</p><p>ES底层支持倒排索引、列存储等数据结构，使得在日志场景可以利用ES非常灵活的搜索分析能力。通过ES交互式分析能力，即使在万亿级日志的情况下，日志搜索响应时间也是秒级。</p><p>日志处理的基本流程包含：日志采集-&gt; 数据清洗-&gt; 存储-&gt; 可视化分析。ElasticStack通过完整的日志解决方案，帮助用户完成对日志处理全链路管理。</p><p><img src="/My-Blogs/images/%E6%97%A5%E5%BF%97%E5%AE%9E%E6%97%B6%E5%88%86%E6%9E%90%E5%9C%BA%E6%99%AF-01.jpeg"></p><p>其中：</p><ul><li>日志采集：通过轻量级日志采集组件FileBeat实时读取业务日志文件，发送数据至下游组件如Logstash。</li><li> 文本解析：利用正则解析等机制，将日志文本数据转换成结构化数据。可使用独立的Logstash服务或Elasticsearch内置的轻量级数据处理模块IngestPipe-line，完成数据清洗和转换。</li><li>数据存储：通过Elasticsearch搜索分析平台进行数据持久存储，提供全文搜索和分析能力。</li><li>可视化分析：通过功能丰富的图形界面，即可对日志数据进行搜索分析，如可视化组件Kibana。</li></ul><p><img src="/My-Blogs/images/%E6%97%A5%E5%BF%97%E5%AE%9E%E6%97%B6%E5%88%86%E6%9E%90%E5%9C%BA%E6%99%AF-02.jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
            <tag> 应用场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雪碧图mixin</title>
      <link href="/My-Blogs/2021/01/08/css/%E9%9B%AA%E7%A2%A7%E5%9B%BEmixin/"/>
      <url>/My-Blogs/2021/01/08/css/%E9%9B%AA%E7%A2%A7%E5%9B%BEmixin/</url>
      
        <content type="html"><![CDATA[<p>icon小图标</p><a id="more"></a><h2 id="调用icon小图标的方式是通过mixin方式进行调用的"><a href="#调用icon小图标的方式是通过mixin方式进行调用的" class="headerlink" title="调用icon小图标的方式是通过mixin方式进行调用的"></a>调用icon小图标的方式是通过mixin方式进行调用的</h2><pre><code class="CSS">@mixin Ricon($width, $height, $url, $important: '') {  @include background(#{$baseURL}#{$url}.png, $important);  display: inline-block;  width: $width;  height: $height;  background-size: 100% auto;  background-position: center center;}@mixin background($url: '', $important: '') {  @if $url !='' {    @if ($important !='') {      background-image: url($url) !important;    }    @else {      background-image: url($url);    }  }  background-repeat: no-repeat;  background-size: 100% auto;}</code></pre><p>考虑到改造成本以及雪碧图的接入成本，解决方案是在构建过程中接入了<a href="https://github.com/mixtur/webpack-spritesmith">webpack-spritesmith</a>，优点是</p><ol><li> 构建过程中可根据指定目录自动生成及更新雪碧图与scss文件</li><li> 自动生成的scss文件模版允许自定义化</li><li> 无需手动引入生成的scss文件，可在webpack配置中配置自动引入</li></ol><p>构建配置如下：</p><pre><code class="JS">// 配置代码new SpritesmithPlugin({  src: {    // icon小图标目录    cwd: './src/like/act_30083/assets/img/icon/',    // 合成图片格式    glob: '*.png'  },  target: {    // 合成雪碧图本地文件地址    image: path.resolve(__dirname, './assets/img/sprite-ignore.png'),    css: [      [        // 生成雪碧图样式文件地址        path.resolve(__dirname, './styles/mixins/_sprite-ignore.scss'),        {          // scss文件模板          format: 'function_based_template'        }      ]    ]  },  customTemplates: {    // 自定义模板    'function_based_template': templateFunction,  },  apiOptions: {    // 雪碧图引用地址    cssImageRef: '~@assets/img/sprite-ignore.png',  },  spritesmithOptions: {    // 合成规则    algorithm: 'binary-tree',    // icon之间的距离    padding: 10,  }});</code></pre>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 雪碧图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次伪元素动画引起的webview崩溃</title>
      <link href="/My-Blogs/2021/01/08/css/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BC%AA%E5%85%83%E7%B4%A0%E5%8A%A8%E7%94%BB%E5%BC%95%E8%B5%B7%E7%9A%84webview%E5%B4%A9%E6%BA%83/"/>
      <url>/My-Blogs/2021/01/08/css/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BC%AA%E5%85%83%E7%B4%A0%E5%8A%A8%E7%94%BB%E5%BC%95%E8%B5%B7%E7%9A%84webview%E5%B4%A9%E6%BA%83/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前不久做了一个年终盛典的 h5 移动端活动项目，活动主页有三个排行榜页面，以及任务页面。在测试过程中，测试同事反馈排行榜页面在 android 4.x 的系统下会引起 webview 的崩溃，而且是必现，而任务页面是正常的，这让我纠结了很久，因为本身页面也做了很多的优化，像图片的懒加载，组件的懒加载，排行榜列表虚拟滚动（只渲染屏幕显示部分数据），所以一时也不知道问题在哪里。</p><a id="more"></a><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><p>仔细 review 了一下项目代码，也没发现什么端倪，就只能一点一点注释代码来调试了，发现有一段 css 代码注释掉以后 android 4.x 就正常了。</p><p>于是 google 了一番，发现是伪元素做动画惹的祸，是旧版 chromium 的问题，可以查看<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=364222">官方 issue</a>，crash 代码如下。</p><pre><code class="CSS">@-webkit-keyframes crashChrome {  0% {    -webkit-transform: translateX(0rem);  }}.anim:before {  content: "";  width: 3rem;  height: 3rem;  border-radius: 3rem;  position: absolute;  left: 5rem;  top: 5rem;  background-color: #06839f;  -webkit-animation: crashChrome;}</code></pre><pre><code class="HTML">&lt;div class="anim"&gt;&lt;/div&gt;</code></pre><p>代码一看其实也比较正常，普普通通的的用法，就是一个 before 的伪元素做了一个 一动也不动的 animation 的动画，怎么就会奔溃了呢？</p><p>这个 bug 具体是怎么回事还没想明白，但是问题得解决呀，自己活动页面的奔溃八九不离十就是 before+animation 引起的，用 div 代替 before 先把 bug 解决了。</p><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>这段 crash 的 css 代码确实比较平常，而且写法完全符合 web 的标准，故不应该是代码本身的问题。且在自己本地的开发浏览器中，以及稍微不那么旧的手机里都是正常的，所以断定这个问题因该属于浏览器的 bug，并且在某些旧版浏览器里才有的 bug，后来的新版浏览器已经修复了这个问题。</p><p>拿着会 crash 的手机测试发现，只有满足以下三个条件：伪元素（before，after 等）+ animation + rem，才会 crash。</p><p>所以得出了以下结论，在伪元素里使用 animation 动画，并且动画里有 rem 的变化就会引起了某些版本 webview 的 crash。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个问题与浏览器的底层渲染有关，并且官方没有给出具体哪些版本会受到影响，而在移动段 rem 是比较常规的单位，所以各位同学做项目的时候，就不要在伪元素里写动画。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自适应布局的相关介绍</title>
      <link href="/My-Blogs/2021/01/08/css/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D/"/>
      <url>/My-Blogs/2021/01/08/css/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>我们都知道自适应布局有很多种方式可以实现，下面让我们来看看有哪些方式比较简单？</p><a id="more"></a><h3 id="利用clamp函数"><a href="#利用clamp函数" class="headerlink" title="利用clamp函数"></a>利用clamp函数</h3><p><code>clamp()</code> 通过“限制”或限制最小和最大范围之间的灵活值来工作</p><p>使用方法如下：</p><ul><li>最小值：例如 16px</li><li>弹性值：例如 5vw</li><li>最大值：例如 34px</li></ul><pre><code class="css">h1 {  font-size: clamp(16px, 5vw, 34px);}</code></pre><p>在此示例中，该 h1 font-size 值将是 5% 视口宽度。但前提是该值大于 16px 和小于 34px。</p><p>例如，如果您的视口宽度为 300px，则您的 5vw 值将等于 15px。但是，您将该 font-size 值限制为的最小值 16px，这样就可以了。</p><p>另一方面，如果您的视口宽度为 1400px，则您 5vw 将大声疾呼 70px！但幸运的是，您将该最大值限制为34px，因此它不会超过该最大值 。</p><p><img src="/My-Blogs/images/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D-01.gif" alt="iamge"></p><p>我可以为此模板添加此代码…</p><pre><code class="css">img {  width: clamp(15vw, 800%, 100%);}h1 {  font-size: clamp(20px, 5vw, 35px);}p {  font-size: clamp(10px, 4vw, 20px);}</code></pre><p>实际上，任何其他接受长度，频率，角度，时间，百分比，数字或整数的属性</p><p><img src="/My-Blogs/images/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D-02.png" alt="image"></p><br><h3 id="利用grid布局新特性"><a href="#利用grid布局新特性" class="headerlink" title="利用grid布局新特性"></a>利用<a href="http://1linelayouts.glitch.me/">grid布局新特性</a></h3><br><h4 id="强居中"><a href="#强居中" class="headerlink" title="强居中"></a>强居中</h4><p><img src="/My-Blogs/images/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D-03.png"></p><br><h4 id="三段式布局"><a href="#三段式布局" class="headerlink" title="三段式布局"></a>三段式布局</h4><p><img src="/My-Blogs/images/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D-04.png"></p><br><h4 id="经典布局"><a href="#经典布局" class="headerlink" title="经典布局"></a>经典布局</h4><p><img src="/My-Blogs/images/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D-05.png"></p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冷知识之CSS篇【竖行横书组合】</title>
      <link href="/My-Blogs/2021/01/08/css/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87%E3%80%90%E7%AB%96%E8%A1%8C%E6%A8%AA%E4%B9%A6%E7%BB%84%E5%90%88%E3%80%91/"/>
      <url>/My-Blogs/2021/01/08/css/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87%E3%80%90%E7%AB%96%E8%A1%8C%E6%A8%AA%E4%B9%A6%E7%BB%84%E5%90%88%E3%80%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我们都知道竖书成行，自右向左换行是古文中的一种书写方式。那么在CSS中writing-mode就定义了文本在水平或垂直方向上排列方式。下面我们通过writing-mode这个属性定义一个“竹简”书写方式，同时如果在竖行文本中穿插阿拉伯数字时又当如何？</p></blockquote><a id="more"></a><p>我们要定义竹简的书写方式前，首先回顾下 CSS <code>writing-mode</code> 属性，它是定义文本在水平或垂直方向上如何排列。</p><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87%E3%80%90%E7%AB%96%E8%A1%8C%E6%A8%AA%E4%B9%A6%E7%BB%84%E5%90%88%E3%80%91-01.jpg"></p><p>CSS text-combine-upright 竖行横书组合</p><h3 id="writing-mode语法"><a href="#writing-mode语法" class="headerlink" title="writing-mode语法"></a>writing-mode语法</h3><pre><code class="CSS">writing-mode: horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr</code></pre><ul><li>horizontal-tb：水平方向自上而下的书写方式。</li><li>vertical-rl：垂直方向自右而左的书写方式。</li><li>vertical-lr：垂直方向内内容从上到下，水平方向从左到右。</li><li>sideways-rl：内容垂直方向从上到下排列。</li></ul><p>由此，我们若要定义出“竹简”的书写模式，就可以运用<code>vertical-rl</code>值，垂直方向由右到左。</p><p><strong>示例</strong></p><p>先吟诗一首🤭以此为例开始</p><p>同在屋檐下，惟有偶遇。</p><p>犹如白驹过隙，言之不尽。</p><p>因有时不我与，爬耳搔腮，</p><p>心之不及也。</p><p>—— Lucas</p><pre><code class="CSS">div{  writing-mode: vertical-rl;}</code></pre><pre><code class="HTML">&lt;div&gt;  &lt;p&gt;同在屋檐下，&lt;/p&gt;  &lt;p&gt;惟有偶遇。&lt;/p&gt;  &lt;p&gt;犹如白驹过隙，&lt;/p&gt;  &lt;p&gt;言之不尽，&lt;/p&gt;  &lt;p&gt;因有时不我与，&lt;/p&gt;  &lt;p&gt;爬耳搔腮，&lt;/p&gt;  &lt;p&gt;心之不及也。&lt;/p&gt;  &lt;p&gt;—— DeathGhost&lt;/p&gt;&lt;/div&gt;</code></pre><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87%E3%80%90%E7%AB%96%E8%A1%8C%E6%A8%AA%E4%B9%A6%E7%BB%84%E5%90%88%E3%80%91-02.jpg"></p><p>CSS writing-mode 文本排布</p><p>接下来，我们看看竖行排布中的“意外”。看看下面的图例。</p><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87%E3%80%90%E7%AB%96%E8%A1%8C%E6%A8%AA%E4%B9%A6%E7%BB%84%E5%90%88%E3%80%91-03.jpg"></p><p>CSS 书写模式 <code>writing-mode: vertical-rl</code> （从右到左）</p><p>可以看出，若以中文描述还好，但若加入阿拉伯数字，就显得怪异。</p><p>那么可否将数字转为横向（常规）书写？</p><p>下面我们重点看看CSS中的另一个属性。</p><h3 id="text-combine-upright-竖行横书组合"><a href="#text-combine-upright-竖行横书组合" class="headerlink" title="text-combine-upright 竖行横书组合"></a>text-combine-upright 竖行横书组合</h3><pre><code class="CSS">/* Keyword values */text-combine-upright: none;text-combine-upright: all;/* Digits values */text-combine-upright: digits;text-combine-upright: digits 4;/* Global values */text-combine-upright: inherit;text-combine-upright: initial;text-combine-upright: unset;</code></pre><ul><li><code>none</code>: 没有特殊处理。</li><li><code>all</code>: 试图将元素内的字符水平排列，使其它们在竖行中占据单个字符空间。</li><li><code>digits</code>: 尝试显示一个连续的ASCII数字序列（U + 0030–U + 0039），该序列的字符数少于或等于指定的整数，以致于它在垂直行框中占据单个字符的空间。如果省略整数，则计算结果为2。2-4范围以外的整数无效。</li></ul><p>值 <code>digits</code> 目前浏览器上没有看到效果，这里预先搁置。</p><p>我们要将上述文本中的数字让其横向排列，按属性值就是将其水平排列，让其占据单个字符空间。</p><p>那么，样式文本定义就可以这样：</p><pre><code class="CSS">div{  writing-mode: vertical-rl;  letter-spacing: 1px;}div b{  text-combine-upright: all;  margin: 5px 0;}</code></pre><pre><code class="HTML">&lt;div&gt;  &lt;h1&gt;清朝&lt;/h1&gt;  &lt;p&gt;是中国历史上最后一个封建王朝，&lt;/p&gt;  &lt;p&gt;共传十二帝，&lt;/p&gt;  &lt;p&gt;统治者为满洲爱新觉罗氏。&lt;/p&gt;  &lt;p&gt;从努尔哈赤建立后金起，&lt;/p&gt;  &lt;p&gt;总计&lt;b&gt;296&lt;/b&gt;年。&lt;/p&gt;  &lt;p&gt;从皇太极改国号为清起，国祚&lt;b&gt;276&lt;/b&gt;年。&lt;/p&gt;  &lt;p&gt;建立全国性政权算起为&lt;b&gt;268&lt;/b&gt;年。&lt;/p&gt;&lt;/div&gt;</code></pre><p>对文本中的<b>标签定义<code>text-combine-upright</code>为<code>all</code>即可。</b></p><b><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87%E3%80%90%E7%AB%96%E8%A1%8C%E6%A8%AA%E4%B9%A6%E7%BB%84%E5%90%88%E3%80%91-04.jpg"></p><p>CSS text-combine-upright 竖行横书组合</p><p>虽然如此，但是，它也是有一定的局限性。</p><p>例如，我们将“数字+年”合为一起，或更多文本合为一起，就会看到段尾效果。</p><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87%E3%80%90%E7%AB%96%E8%A1%8C%E6%A8%AA%E4%B9%A6%E7%BB%84%E5%90%88%E3%80%91-05.jpg"></p><p>CSS text-combine-upright 竖行横书组合</p><p>所以，它占据单个字符空间压缩是有一定限制。</p><p>本示例于浏览器 <code>chrome87</code> 版本，详细可阅读<a href="https://drafts.csswg.org/css-writing-modes-4/#text-combine-upright">这里</a>。</p></b>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 冷知识 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冷知识之CSS篇</title>
      <link href="/My-Blogs/2021/01/08/css/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87/"/>
      <url>/My-Blogs/2021/01/08/css/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>CSS的冷知识，你又了解多少呢？</p><a id="more"></a><h3 id="文字模糊效果"><a href="#文字模糊效果" class="headerlink" title="文字模糊效果"></a>文字模糊效果</h3><p>只需要添加以下两行代码，即可达到将文字模糊处理的目的。</p><pre><code class="css">color: transparent;text-shadow: #111 0 0 5px;</code></pre><br><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87-01.png" alt="image"></p><br><h3 id="毛玻璃效果"><a href="#毛玻璃效果" class="headerlink" title="毛玻璃效果"></a>毛玻璃效果</h3><p>其实毛玻璃的模糊效果技术上比较简单，只是用到了 css 滤镜（filter）中的 blur 属性。但是要做一个好的毛玻璃效果，需要注意很多细节。下面提供一个简单示例：</p><pre><code class="css">.blur {  display: block;  width: 300px;  height: 300px;  margin: 100px auto;  filter: blur(10px);}&lt;img src="./img/test.png"class="blur"alt=""&gt;</code></pre><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87-02.png" alt="image"></p><h3 id="CSS中也可以做简单运算"><a href="#CSS中也可以做简单运算" class="headerlink" title="CSS中也可以做简单运算"></a>CSS中也可以做简单运算</h3><p>在日常开发中，我们时常会遇到这样的需求：</p><blockquote><p>左侧或者右侧宽度固定，然后剩余部分自动充满。</p></blockquote><p>可能很多小伙伴会想到用flex布局，通过设置flex:1; 使其自动充满，当然这个做法也是对的，但是我们还有更为简便的方法，那就是利用css的calc函数，示例代码如下：</p><pre><code class="css">.container {  width: calc(100% - 50px);}</code></pre><p><code>calc() </code> 函数用于动态计算长度值。</p><ul><li>需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)；</li><li>任何长度值都可以使用calc()函数进行计算；</li><li>calc()函数支持 “+”, “-“, “*”, “/“ 运算；</li><li>calc()函数使用标准的数学运算优先级规则；</li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 冷知识 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人护城河</title>
      <link href="/My-Blogs/2020/02/07/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/%E4%B8%AA%E4%BA%BA%E6%8A%A4%E5%9F%8E%E6%B2%B3/"/>
      <url>/My-Blogs/2020/02/07/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/%E4%B8%AA%E4%BA%BA%E6%8A%A4%E5%9F%8E%E6%B2%B3/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="我最喜欢的职业建议是发展”个人护城河“。"><a href="#我最喜欢的职业建议是发展”个人护城河“。" class="headerlink" title="我最喜欢的职业建议是发展”个人护城河“。"></a>我最喜欢的职业建议是发展”<a href="https://eriktorenberg.substack.com/p/build-personal-moats">个人护城河</a>“。</h3><br><p><img src="https://www.wangbase.com/blogimg/asset/202009/bg2020092807.jpg" alt="image"></p><br><p>你的个人护城河是一组独特的且不断累积的竞争优势，别人很难学习，或者很难做到。如果你有了它，你会让自己变得无法取代。</p><br><p>你必须找到属于你的特殊东西，而且这些东西会随着时间的流逝而增加价值。</p><br><h3 id="如何找到自己的护城河？"><a href="#如何找到自己的护城河？" class="headerlink" title="如何找到自己的护城河？"></a>如何找到自己的护城河？</h3><br><p>你可以问自己：对我来说，什么事情容易做，而对别人却很难？我所拥有的技能中，哪些是其他人模仿会非常困难的？或者，你所爱的、擅长的事物，跟社会需要的事物有什么交汇点？</p><br><p>护城河会随着条件的变化而变化。比如，录音技术诞生之前，稀缺的是音乐本身，你想听音乐，就需要有一个艺术家给你现场表演。现在，音乐录音到处都是，稀缺的是策划、发行和个性的展示。</p><br><p>同样地，在社会中，以前的稀缺资源是金钱和特殊关系。而在互联网时代，稀缺的是特定知识和某些稀有技能。</p><br><p>漫画家斯科特·亚当斯（Scott Adams）曾经提过一种建立个人护城河的方法，就是找到自己最擅长的2个～3个事物的交集。比如，他既不是最好的漫画家，也不是最好的作家，也不是最好的企业家，但他可以是最好的商业类漫画短文作者，这就是他的护城河。</p><br><p>总之，你要发现对你来说容易而对他人却很难的事物，并在这些事物上变得出色，然后利用它来积累社会和金融资本。</p><br><h3 id="找出最擅长的2-3个事物的交集。"><a href="#找出最擅长的2-3个事物的交集。" class="headerlink" title="找出最擅长的2~3个事物的交集。"></a><strong>找出最擅长的2~3个事物的交集</strong>。</h3><br><p><img src="https://cdn.substack.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F3e1e36d1-f32a-4aff-bd08-10e131454905_1124x1063.png" alt="交集图"></p>]]></content>
      
      
      <categories>
          
          <category> 个人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 职业规划 </tag>
            
            <tag> 个人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo theme cutie v2.x tutorial</title>
      <link href="/My-Blogs/2018/02/12/hexo/hexo-theme-cutie-v2-tutorial/"/>
      <url>/My-Blogs/2018/02/12/hexo/hexo-theme-cutie-v2-tutorial/</url>
      
        <content type="html"><![CDATA[<p><img src="/My-Blogs/images/tree.png" alt="$cover"></p><p>Theme cutie has evolved from v1.x to v2.x with a refreshed and fine tuned design and more features. Follow the following instruction to install and use it. You may navigate this website to experience the new look and interaction of v2.x.</p><p><strong>Thank you for your stars and support</strong>.</p><a id="more"></a><h1 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h1><h2 id="Install-for-a-new-site"><a href="#Install-for-a-new-site" class="headerlink" title="Install for a new site"></a>Install for a new site</h2><dl><dt>Prerequiste</dt><dd>Make sure you install <code>node.js</code> and <code>hexo</code> through command line. Refer to official Hexo doc for detailed instruction.</dd></dl><dl><dt>Working directory</dt><dd>Make sure your terminal (command line) is currently in the folder where you want to create the site.</dd></dl><dl><dt>Installation steps</dt><dd>The first step is the standard hexo installation step. If you have done them, skip to step 2.<br>    1. Initialize your site<br>    <code>bash     hexo init your-site-folder     cd your-site-folder     npm install     </code><br>    2. [<em>Optional</em>][<em>Recommended</em>] Uninstall <code>hexo-renderer-marked</code> and install <code>hexo-renderer-markdown-it</code> and associated plugins.<br>    <code>bash     npm un hexo-renderer-marked --save     npm i hexo-renderer-markdown-it --save     npm i markdown-it-emoji --save     npm i markdown-it-mark --save     npm i markdown-it-deflist --save     npm i markdown-it-container --save     </code></dd></dl><pre><code>3. Download [latest theme cutie](https://github.com/qutang/hexo-theme-cutie/releases/latest) and unzip it to `themes/` folder in your site. Then rename it to `cutie`.</code></pre><dl><dt>Initial configuration file</dt><dd><code>_config.yml</code> in the root path of your site.</dd></dl><dl><dt>Initial configuration</dt><dd>1. Follow standard hexo initial configuration: <a href="https://hexo.io/docs/configuration.html">https://hexo.io/docs/configuration.html</a><br>    2. Add variables or modify the variables in your <code>_config.yml</code> according to following snippet.</dd></dl><pre><code>    ```yml _config.yml    highlight:      enable: true      line_number: true      auto_detect: false      tab_replace:     markdown:      render:        html: true        xhtmlOut: false        breaks: false        linkify: true        typographer: true        quotes: '“”‘’'      plugins:        - markdown-it-abbr        - markdown-it-footnote        - markdown-it-ins        - markdown-it-sub        - markdown-it-sup        - markdown-it-deflist      anchors:        level: 1        collisionSuffix: 'v'        permalink: false        permalinkClass: header-anchor        permalinkSymbol: ""        permalinkBefore: false    date_format: ll    archive_generator:      per_page: 0      yearly: true      monthly: false      daily: false    theme: cutie    ```</code></pre><dl><dt>Bring site alive</dt><dd><code>bash     hexo s --debug     </code></dd></dl><h2 id="Install-for-an-existing-site"><a href="#Install-for-an-existing-site" class="headerlink" title="Install for an existing site"></a>Install for an existing site</h2><dl><dt>Working directory</dt><dd>Make sure your terminal (command line) is currently in the root folder of the site.</dd></dl><p>Installation steps<br>:</p><ol><li><p>[<em>Optional</em>][<em>Recommended</em>] Uninstall <code>hexo-renderer-marked</code> and install <code>hexo-renderer-markdown-it</code> and associated plugins.</p><pre><code> ```bash npm un hexo-renderer-marked --save npm i hexo-renderer-markdown-it --save npm i markdown-it-emoji --save npm i markdown-it-mark --save npm i markdown-it-deflist --save npm i markdown-it-container --save ```</code></pre></li><li><p>Download <a href="https://github.com/qutang/hexo-theme-cutie/releases/latest">latest theme cutie</a><br>and unzip it to <code>themes/</code> folder in your site. Then rename it to <code>cutie</code>.</p></li></ol><dl><dt>Initial configuration file</dt><dd><code>_config.yml</code> in the root path of your site.</dd></dl><dl><dt>Initial configuration</dt><dd>1. Follow standard hexo initial configuration: <a href="https://hexo.io/docs/configuration.html">https://hexo.io/docs/configuration.html</a><br>    2. Add variables or modify the variables in your <code>_config.yml</code> according to following snippet.</dd></dl><pre><code>    ```yml _config.yml    highlight:      enable: true      line_number: true      auto_detect: false      tab_replace:     markdown:      render:        html: true        xhtmlOut: false        breaks: false        linkify: true        typographer: true        quotes: '“”‘’'      plugins:        - markdown-it-abbr        - markdown-it-footnote        - markdown-it-ins        - markdown-it-sub        - markdown-it-sup        - markdown-it-deflist      anchors:        level: 1        collisionSuffix: 'v'        permalink: false        permalinkClass: header-anchor        permalinkSymbol: ""        permalinkBefore: false    date_format: ll    archive_generator:      per_page: 0      yearly: true      monthly: false      daily: false    theme: cutie    ```</code></pre><dl><dt>Bring site alive</dt><dd><code>bash     hexo s --debug     </code></dd></dl><h1 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h1><h2 id="From-v2-x"><a href="#From-v2-x" class="headerlink" title="From v2.x"></a>From v2.x</h2><dl><dt>Installation steps</dt><dd>1. Delete <code>themes/cutie/</code> folder in your site.<br>    2. Download the desired version of theme cutie from <a href="https://github.com/qutang/hexo-theme-cutie/releases">release page</a>, unzip it to <code>themes/</code> folder and rename it to <code>cutie</code>.</dd></dl><dl><dt>Notes</dt><dd>There is a mimimal version requirement for each configuration, make sure your installed version is above it to use the corresponding configuration.</dd></dl><h2 id="From-v1-x"><a href="#From-v1-x" class="headerlink" title="From v1.x"></a>From v1.x</h2><dl><dt>Installation steps</dt><dd>1. Delete <code>themes/cutie/</code> folder in your site.<br>    2. Download the desired version of theme cutie from <a href="https://github.com/qutang/hexo-theme-cutie/releases">release page</a>, unzip it to <code>themes/</code> folder and rename it to <code>cutie</code>.</dd></dl><dl><dt>Configuration</dt><dd>From v2.x, theme cutie uses <em>Hexo data file</em> (<code>sources/_data/cutie.yml</code>) to store all configurations, instead of using the <code>_config.yml</code> file of your site in v1.x. And the YAML structure has changed compared to v1.x. </dd></dl><pre><code>The recommendation is to configure the theme cutie from scratch using the following configuration guidelines.You may copy or reuse some configurations about theme cutie in your old `_config.yml` along the way. Please post an issue if you have hard time migrating your configurations from v1.x to v2.x.</code></pre><h1 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h1><h2 id="Language"><a href="#Language" class="headerlink" title="Language"></a>Language</h2><dl><dt>Minimal version</dt><dd><em>Taurus</em>: <code>v2.0.0-alpha</code></dd></dl><dl><dt>Configuration file</dt><dd><code>_config.yml</code> of site</dd></dl><dl><dt>Configuration format</dt><dd>Set <code>language</code> variable in your site’s <code>_config.yml</code> file.</dd></dl><pre><code>```yml _config.ymllanguage:- en- zh-cn- it```The first row will be your site's default language.</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted, the default setting is <code>en</code>. Site will be displayed in English.</dd></dl><dl><dt>Notes</dt><dd>Currently, theme cutie only supports three languages: English, Italian and 简体中文.</dd></dl><dl><dt>Contributions</dt><dd>1. Italian translation is contributed by <a href="https://github.com/Fastbyte01">@fastbyte01</a><br>    2. More translation is welcomed if you are interested in contribution. You may add new language files in <code>themes/cutie/languages</code> folder according to Hexo’s guideline: <a href="https://hexo.io/docs/internationalization.html">https://hexo.io/docs/internationalization.html</a> and feel free to send me pull request.</dd></dl><h2 id="Scheme"><a href="#Scheme" class="headerlink" title="Scheme"></a>Scheme</h2><p>This concept is from <code>hexo-theme-next</code>, the most popular theme for Hexo, in which it uses different themes for different layout design. In theme cutie, it follows the similar idea and provides the opportunity to choose different layout design using scheme.</p><dl><dt>Minimal version</dt><dd><em>Taurus</em>: <code>v2.0.0-alpha</code></dd></dl><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Set <code>scheme</code> variable to scheme name to enable a theme scheme.</dd></dl><pre><code>```yml source/_data/cutie.ymlglobal:  scheme: Taurus # Avaliable values: Taurus```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted, the default setting is <code>Taurus</code>, scheme <code>Taurus</code> is enabled.</dd></dl><dl><dt>Notes</dt><dd>Currently, theme cutie only has <code>Taurus</code> theme, which is a two-column text-icon-based layout. Contribution is welcomed from developers or designers for new schemes.</dd></dl><dl><dt>For contributors</dt><dd>1. To add a new scheme, create a new file <code>your-scheme-name.css</code> in folder <code>themes/cutie/source/css/</code> and add your own scheme style in it.<br>    2. The system will automatically search for this css file and load it using the theme name <code>your-scheme-name</code> when changing the scheme configuration to <code>your-scheme-name</code>.</dd></dl><h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><dl><dt>Minimal version</dt><dd><code>v2.0.5-beta</code></dd></dl><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Set <code>use_animation</code> to <code>true</code> or <code>false</code> to enable or disable site animations.</dd></dl><pre><code>```yml source/_data/cutie.ymlglobal:  use_animation: true # Avaliable values: true, false```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted, the default setting is <code>true</code>, animation is enabled.</dd></dl><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><p>Theme cutie uses in-site search for the site. Use following steps to setup search page. Google custom search has been discarded since <code>v2.0.7</code>.</p><dl><dt>Minimal version</dt><dd><code>v2.0.7</code></dd></dl><dl><dt>Configuration steps</dt><dd>1. No need for configuration, work out of box.<br>    2. If you are upgrading from versions below <code>v2.0.7</code>, delete the old search page you created for your site.</dd></dl><h2 id="404-Page"><a href="#404-Page" class="headerlink" title="404 Page"></a>404 Page</h2><p>Theme cutie uses built-in 404 page. It supports a custom 404 art or tencent 404 charity page (腾讯404公益).</p><dl><dt>Minimal version</dt><dd><code>v2.0.7</code></dd></dl><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration steps</dt><dd>1. Delete the old <code>404.md</code> file of your site if you are upgrading from versions before <code>v2.0.7</code>.<br>    2. No need for configuration, work out of box.<br>    3. You may configure the built-in 404 page to use 腾讯公益404 or not, by default it is NOT using 腾讯公益404.</dd></dl><pre><code>```yml source/_data/cutie.yml# set true to enable 腾讯公益404page_404:  tencent_404: true```</code></pre><h2 id="Social-network-links"><a href="#Social-network-links" class="headerlink" title="Social network links"></a>Social network links</h2><dl><dt>Minimal version</dt><dd><code>v2.0.0-alpha</code></dd></dl><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Add social network names and links in the following format. Make sure the social network name matches the corresponding font awesome icon name. See <a href="https://fontawesome.com/icons?d=gallery&amp;s=brands">here</a> for the supported names and their icons.</dd></dl><pre><code>```yml source/_data/cutie.yml# As long as the name matches the font awesome icon name, you can add even more social linkssocial:  github: https://github.com/qutang  linkedin: https://www.linkedin.com/in/qutang```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted. No icons will be shown at the bottom right corner in the footer.</dd></dl><h2 id="Site-announcement"><a href="#Site-announcement" class="headerlink" title="Site announcement"></a>Site announcement</h2><dl><dt>Minimal version</dt><dd><code>v2.0.7</code></dd></dl><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration steps</dt><dd>1. Site announcement will display at the bottom left corner of home page as a purple box.<br>    2. Add following snippets to the configuration file to use, if omitted, site announcement is disabled.</dd></dl><pre><code>```yml source/_data/cutie.ymlglobal:  announcement:    text: This is a sample site announcement.```</code></pre><dl><dt>Notes</dt><dd>* The timeout duration for site announcement is 10s. The announcement popup will dismiss on click or on timeout.<br>    * You may use HTML markups in the announcement text. For example, you may add a link to the text.</dd></dl><h2 id="Site-header"><a href="#Site-header" class="headerlink" title="Site header"></a>Site header</h2><h3 id="Setup-site-logo"><a href="#Setup-site-logo" class="headerlink" title="Setup site logo"></a>Setup site logo</h3><dl><dt>Minimal version</dt><dd><code>v2.0.0-alpha</code></dd></dl><dl><dt>Configuration file</dt><dd><code>sources/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Set variable <code>logo</code> to your own icon’s link. Link can be either an external image link, or a relative link.</dd></dl><pre><code>```yml source/_data/cutie.ymllogo: /images/logo.svg```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted. the following image will be used as the logo image.</dd></dl><pre><code>![theme-icon](/images/logo.svg)</code></pre><h3 id="Setup-site-name-and-subtitle"><a href="#Setup-site-name-and-subtitle" class="headerlink" title="Setup site name and subtitle"></a>Setup site name and subtitle</h3><dl><dt>Minimal version</dt><dd><code>v2.0.0-alpha</code></dd></dl><dl><dt>Configuration file</dt><dd><code>_config.yml</code> of your site</dd></dl><dl><dt>Configuration format</dt><dd>Make sure your subtitle is not too log (better less than 30 characters).</dd></dl><pre><code>`title` is a standard Hexo configuration.`subtitle` is theme cutie's own configuration.```yml source/_data/cutie.ymltitle: Your site's titlesubtitle: Your site's subtitle```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted. You will not see any texts in the header.</dd></dl><dl><dt>Note</dt><dd>This configuration requires restarting the server.</dd></dl><h3 id="Setup-navigation-menu"><a href="#Setup-navigation-menu" class="headerlink" title="Setup navigation menu"></a>Setup navigation menu</h3><dl><dt>Minimal version</dt><dd><code>v2.0.0-alpha</code></dd></dl><dl><dt>Configuration file</dt><dd><code>sources/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Add navigation item in the following format. link and icon can be external or internal. You can literally add any link to it.</dd></dl><pre><code>```yml source/_data/cutie.ymlmenu:  Resume:     link: /resume/  "Menu item":    link: /aaa/```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted. No text links will show up in the header navigation menu or in the dropdown menu on any view.</dd></dl><dl><dt>Notes</dt><dd>1. If there are more than four menu items, only the first four will be shown in the header (on desktop view). However, you can find all menu items in the last dropdown menu.<br>    2. Do not use a very long menu item name. No more than three words, because there is some display issue when the name gets long.<br>    3. Compared with <code>v1.x</code>, menu icon is no longer supported.</dd></dl><h2 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h2><h3 id="Use-Light-Gallery"><a href="#Use-Light-Gallery" class="headerlink" title="Use Light Gallery"></a>Use Light Gallery</h3><p>Theme cutie uses <a href="">Light Gallery</a> to support image modal display for <em>posts</em>. By default, it is enabled, but if you want to use other hexo plugins with similar functionality, you may want to disable it.</p><dl><dt>Minimal version</dt><dd><code>v2.0.5-beta</code></dd></dl><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Set <code>use_lightgallery</code> to be <code>true</code> or <code>false</code> to enable or disable light gallery display for post images.</dd></dl><pre><code>```yml source/_data/cutie.ymlpost:  use_lightgallery: true```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted, by default light gallery is enabled for all posts.</dd></dl><dl><dt>Notes</dt><dd>It is currently not supported to enable or disable light gallery for an individual post.</dd></dl><h3 id="Use-post-version"><a href="#Use-post-version" class="headerlink" title="Use post version"></a>Use post version</h3><p>Theme cutie supports versioned post. Whenever the content of your post changes after you push your site, your visitors will see an unread badge on the post card in home page and archive pages.</p><p>Theme cutie uses Hashing and Cookie to track the post content change and the post content a visitor has last read. This feature does NOT use <code>leancloud</code> backend.</p><dl><dt>Minimal version</dt><dd><code>v2.0.8</code></dd></dl><h4 id="For-all-posts"><a href="#For-all-posts" class="headerlink" title="For all posts"></a>For all posts</h4><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Set <code>enable_unread_badge</code> to be <code>true</code> to enable post versioning and unread badge or <code>false</code> to disable this feature for all the posts.</dd></dl><pre><code>```yml source/_data/cutie.yml---post:  enable_unread_badge: false---```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted, by default this feature is <strong>disabled</strong> for all posts.</dd></dl><h4 id="For-an-individual-post"><a href="#For-an-individual-post" class="headerlink" title="For an individual post"></a>For an individual post</h4><dl><dt>Configuration file</dt><dd>A post’s front matter</dd></dl><dl><dt>Configuration format</dt><dd>Set <code>enable_unread_badge</code> to be <code>true</code> to enable post versioning and unread badge or <code>false</code> to disable this feature for the individual post.</dd></dl><pre><code>```yml post's front matter---enable_unread_badge: true---```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted, the setting will roll back to the unread badge setting for all the posts.</dd></dl><dl><dt>Notes</dt><dd>This setting has higher priority than the setting for all the posts.</dd></dl><h3 id="Setup-TOC-level"><a href="#Setup-TOC-level" class="headerlink" title="Setup TOC level"></a>Setup TOC level</h3><p>*[TOC]: Table of content</p><dl><dt>Minimal version</dt><dd><code>v2.0.5-beta</code></dd></dl><h4 id="For-all-posts-1"><a href="#For-all-posts-1" class="headerlink" title="For all posts"></a>For all posts</h4><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Set <code>toc_level</code> under <code>post</code> to set the maximum level of headings in TOC for <em>all posts</em>. Allowed value is from <code>1</code> to <code>6</code>.</dd></dl><pre><code>```yml source/_data/cutie.ymlpost:  toc_level: 2```</code></pre><dl><dt>Default configuration</dt><dd>If this configuration is omitted, by default maximum TOC level is set to 2 (meaning <code>##</code> in markdown).</dd></dl><h4 id="For-an-individual-post-1"><a href="#For-an-individual-post-1" class="headerlink" title="For an individual post"></a>For an individual post</h4><dl><dt>Configuration file</dt><dd>A post’s front matter</dd></dl><dl><dt>Configuration format</dt><dd>Use variable <code>toc_level</code> to set the maximum level of headings in TOC for <em>an individual posts</em>. Allowed value is from <code>1</code> to <code>6</code>.</dd></dl><pre><code>```yml---toc_level: 2---```</code></pre><dl><dt>Default configuration</dt><dd>If variable is omitted in the post front matter, setting will fall back to the <a href="#for-all-posts">all-post-toc-setting</a>.</dd></dl><h3 id="Setup-post-comment"><a href="#Setup-post-comment" class="headerlink" title="Setup post comment"></a>Setup post comment</h3><dl><dt>Minimal version</dt><dd><code>v2.0.5-beta</code></dd></dl><h4 id="For-all-posts-2"><a href="#For-all-posts-2" class="headerlink" title="For all posts"></a>For all posts</h4><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Set <code>allow_comment</code> to be <code>true</code> or <code>false</code> to enable or disable comment section to be displayed for <em>all posts</em>.</dd></dl><pre><code>```yml source/_data/cutie.ymlpost:  allow_comment: true```</code></pre><dl><dt>Default configuration</dt><dd>If this configuration is omitted, by default comment section is enabled for all posts.</dd></dl><h4 id="For-an-individual-post-2"><a href="#For-an-individual-post-2" class="headerlink" title="For an individual post"></a>For an individual post</h4><dl><dt>Configuration file</dt><dd>A post’s front matter</dd></dl><dl><dt>Configuration format</dt><dd>Use variable <code>allow_comment</code> to enable or disable comment section.</dd></dl><pre><code>```yml---allow_comment: true---```</code></pre><dl><dt>Default configuration</dt><dd>If variable is omitted in the post front matter, setting will fall back to the <a href="#for-all-posts-v2">all-post-comment-setting</a>.</dd></dl><h3 id="Setup-post-copyright"><a href="#Setup-post-copyright" class="headerlink" title="Setup post copyright"></a>Setup post copyright</h3><dl><dt>Minimal version</dt><dd><code>v2.0.5-beta</code></dd></dl><p>Theme cutie uses Creative Commons licenses for copyright configuration. We use three nested variables to cover the major licenses in Creative Commons.</p><ul><li><code>allow_share</code>: allow post to be shared (<code>true</code>) or not (<code>false</code>).<ul><li><code>allow_modification</code>: allow post to be modified while sharing when <code>true</code>.</li><li><code>allow_commercial</code>: allow post to be used for commercial purpose while sharing when <code>true</code>.</li></ul></li></ul><p>if <code>allow_share</code> is <code>false</code>, the other two variables will be ignored.</p><h4 id="For-all-posts-3"><a href="#For-all-posts-3" class="headerlink" title="For all posts"></a>For all posts</h4><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Use the three variables under <code>post</code> to configure the all-post copyright setting.</dd></dl><pre><code>```yml source/_data/cutie.ymlpost:  allow_share: true  allow_modification: false  allow_commercial: false```</code></pre><dl><dt>Default configuration</dt><dd>If any of these configurations is omitted, the default setting for each one will fall back to following settings,<br>    * <code>allow_share: true</code>, by default allowing sharing all posts.<br>        * <code>allow_modification: false</code>, by default post is not allowed to be modified while sharing.<br>        * <code>allow_commercial: false</code>, by default post is not allowed to be used for commercial purposes while sharing.</dd></dl><pre><code>The corresponding default Creative Commons license is _CC BY-NC-ND 4.0_.</code></pre><h4 id="For-an-individual-post-3"><a href="#For-an-individual-post-3" class="headerlink" title="For an individual post"></a>For an individual post</h4><dl><dt>Configuration file</dt><dd>A post’s front matter</dd></dl><dl><dt>Configuration format</dt><dd>Use the same three variables to configure copyright setting for a specific post.</dd></dl><pre><code>```yml---allow_share: trueallow_modification: falseallow_commercial: false---```</code></pre><dl><dt>Default configuration</dt><dd>If any of these variables is omitted in the post front matter, setting will fall back to the <a href="#for-all-posts-v3">all-post copyright setting</a>.</dd></dl><h3 id="Enable-post-visit-and-comment-counts"><a href="#Enable-post-visit-and-comment-counts" class="headerlink" title="Enable post visit and comment counts"></a>Enable post visit and comment counts</h3><dl><dt>Minimal version</dt><dd><code>v2.0.5-beta</code></dd></dl><dl><dt>Prerequiste</dt><dd>This functionality only works when you use <code>valine</code> as <a href="#comment-systems">comment system</a> and use <code>leancloud</code> as backend.</dd></dl><dl><dt>Configuration steps</dt><dd>1. Configure <code>valine</code> comment system as described <a href="#configuration-for-valine-comment-system">here</a>.<br>    2. You are all set and post visit counts and post comment counts will appear in all related pages.</dd></dl><dl><dt>Notes</dt><dd>* <em>If backend is not set up properly, icons that show post visit and comment counts will be hidden.</em><br>    * Post visit counts only <strong>unique</strong> visitors (meaning visitors with unique IPs).</dd></dl><h3 id="Enable-post-thumb-up"><a href="#Enable-post-thumb-up" class="headerlink" title="Enable post thumb up"></a>Enable post thumb up</h3><dl><dt>Minimal version</dt><dd><code>v2.1.0</code></dd></dl><dl><dt>Prerequiste</dt><dd>This functionality only works when you use <code>valine</code> as <a href="#comment-systems">comment system</a> and use <code>leancloud</code> as backend.</dd></dl><dl><dt>Configuration steps</dt><dd>1. Configure <code>valine</code> comment system as described <a href="#configuration-for-valine-comment-system">here</a>.<br>    2. You are all set and post thumb up and thumb up counts will appear in all related pages.</dd></dl><dl><dt>Notes</dt><dd>* <em>If backend is not set up properly, icons that show post thumbup status and counts will be hidden.</em><br>    * Post thumb up counts only <strong>unique</strong> visitors (meaning visitors with unique IPs).</dd></dl><h3 id="Use-post-announcement"><a href="#Use-post-announcement" class="headerlink" title="Use post announcement"></a>Use post announcement</h3><dl><dt>Minimal version</dt><dd><code>v2.0.7</code></dd></dl><dl><dt>Configuration file</dt><dd>post’s front matter</dd></dl><dl><dt>Configuration steps</dt><dd>Use following snippet to add your post annoucement</dd></dl><pre><code>```yml post's front matter---announcement:  text: This is a sample post announcement!---```</code></pre><dl><dt>Notes</dt><dd>* The default timeout for the announcement is 10 seconds. Note configurable for now.<br>    * You may use HTML markups in the announcement text.</dd></dl><h3 id="Set-post-excerpt"><a href="#Set-post-excerpt" class="headerlink" title="Set post excerpt"></a>Set post excerpt</h3><p>The post excerpt, displayed in the index page card on hover, may be manually set through front matter or adding the <code>&lt;!-- more --&gt;</code> tag plugin in the post.</p><dl><dt>Minimal version</dt><dd><code>v2.0.11</code></dd></dl><dl><dt>Configuration file</dt><dd>post’s front matter, or tag plugin</dd></dl><dl><dt>Configuration waterfall</dt><dd><code>abstract</code> variable in the front matter has the highest priority if set.</dd></dl><pre><code>```yml post's front matter---abstract: A sample excerpt.---```If `abstract` is not set, theme cutie will search `&lt;!-- more --&gt;` tag in the post content to identify the excerpt section and cut off the first 150 characters to be used as excerpt.If both `abstract` and `&lt;!-- more --&gt;` are omitted, theme cutie will automatically chunk the first 150 characters in the post content to be used as excerpt.</code></pre><h3 id="Set-post-icon"><a href="#Set-post-icon" class="headerlink" title="Set post icon"></a>Set post icon</h3><p>The post icon, displayed on the top left cornder of the index page card, may be manually set through front matter in the post.</p><dl><dt>Minimal version</dt><dd><code>v2.0.0</code></dd></dl><dl><dt>Configuration file</dt><dd>post’s front matter</dd></dl><dl><dt>Configuration waterfall</dt><dd>If <code>icon</code> variable in the post front matter is set, the system will use this icon for post.</dd></dl><pre><code>```yml post's front matter---icon: /your/post/icon/path---```I recommend you to use absolute path (starting with `/`) for the image path.If `icon` variable is not set, but post belongs to category `notes` or `projects`, the system will use the default category icon for the post.If both conditions are not satisified, the system will use a randomly generated texture image for the post.</code></pre><h2 id="Icon-sets"><a href="#Icon-sets" class="headerlink" title="Icon sets"></a>Icon sets</h2><h3 id="Select-an-icon-set"><a href="#Select-an-icon-set" class="headerlink" title="Select an icon set"></a>Select an icon set</h3><dl><dt>Minimal version</dt><dd><code>v2.0.5-beta</code></dd></dl><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Change icon set by changing the name of the icon set in the following snippet. There are three available icon sets in the theme by default: <code>blue-line</code>, <code>blue-shadow</code>, and <code>colorful-outlined</code>.</dd></dl><pre><code>```yml source/_data/cutie.ymlglobal:  icon_set: blue-line # Available values in theme: blue-line, blue-shadow, colorful-outlined```</code></pre><dl><dt>Default configuration</dt><dd><code>blue-line</code></dd></dl><p>Illustration</p><h3 id="Add-a-new-icon-set"><a href="#Add-a-new-icon-set" class="headerlink" title="Add a new icon set"></a>Add a new icon set</h3><dl><dt>Minimal version</dt><dd><code>v2.0.5-beta</code></dd></dl><dl><dt>Configuration path</dt><dd><code>source/images/</code></dd></dl><dl><dt>Configuration steps</dt><dd>1. Create a folder named <code>icons</code> in <code>source/images/</code> folder.<br>    2. Create an icon set folder <code>icon-set-name</code>(change it to your desired name) in <code>source/images/icons/</code> folder.<br>    3. Add your own four icons (keep the filename consistent) in <code>svg</code> format to <code>source/images/icons/icon-set-name/</code> folder.<br>        1. <code>search.svg</code><br>        2. <code>archive.svg</code><br>        3. <code>menu.svg</code><br>        4. <code>toc.svg</code><br>    4. Use your new icon set name <code>icon-set-name</code> in <a href="#select-an-existing-icon-set">Select an existing icon set</a></dd></dl><h2 id="Comment-systems"><a href="#Comment-systems" class="headerlink" title="Comment systems"></a>Comment systems</h2><h3 id="Select-comment-systems"><a href="#Select-comment-systems" class="headerlink" title="Select comment systems"></a>Select comment systems</h3><dl><dt>Minimal version</dt><dd><code>v2.0.0-alpha</code></dd></dl><dl><dt>User configuration location</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd><code>yml comment system     global:       comment_system: valine # Available values: valine, gitment, disqus     </code></dd></dl><dl><dt>Possible values</dt><dd><code>valine</code>(default), <code>gitment</code>, <code>disqus</code>, <code>livere</code></dd></dl><p>After selecting one of the comment systems, you need to further configure it.</p><h3 id="Configuration-for-valine-comment-system"><a href="#Configuration-for-valine-comment-system" class="headerlink" title="Configuration for valine comment system"></a>Configuration for valine comment system</h3><dl><dt>Minimal version</dt><dd><code>v2.0.0-alpha</code></dd></dl><dl><dt>User configuration location</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd><code>yml valine configuration     valine:       appId:       appKey:       placeholder:     </code><br>    See <a href="https://valine.js.org/">https://valine.js.org</a> to setup the backend and fill the values.</dd></dl><dl><dt>Default values</dt><dd>No default values, must fill if using the system.</dd></dl><h3 id="Configuration-for-gitment-comment-system"><a href="#Configuration-for-gitment-comment-system" class="headerlink" title="Configuration for gitment comment system"></a>Configuration for gitment comment system</h3><dl><dt>Minimal version</dt><dd><code>v2.0.0-alpha</code></dd></dl><dl><dt>User configuration location</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd><code>yml gitment configuration     gitment:       owner:       repo:       client_id:       client_secret:     </code><br>    See <a href="https://github.com/imsun/gitment">https://github.com/imsun/gitment</a> to setup the backend and fill the values.</dd></dl><dl><dt>Default values</dt><dd>No default values, must fill if using the system.</dd></dl><h3 id="Configuration-for-Disqus-comment-system"><a href="#Configuration-for-Disqus-comment-system" class="headerlink" title="Configuration for Disqus comment system"></a>Configuration for Disqus comment system</h3><dl><dt>Minimal version</dt><dd><code>v2.0.0-alpha</code></dd></dl><dl><dt>User configuration location</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd><code>yml disqus configuration     disqus:       shortname:     </code><br>    See <a href="https://help.disqus.com/customer/portal/articles/466208-what-s-a-shortname-">https://help.disqus.com/customer/portal/articles/466208-what-s-a-shortname-</a> to setup the backend and fill the value.</dd></dl><dl><dt>Default values</dt><dd>No default values, must fill if using the system.</dd></dl><h3 id="Configuration-for-Livere-comment-system"><a href="#Configuration-for-Livere-comment-system" class="headerlink" title="Configuration for Livere comment system"></a>Configuration for Livere comment system</h3><dl><dt>Minimal version</dt><dd><code>v2.0.11</code></dd></dl><dl><dt>User configuration location</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd><code>yml livere configuration     livere:       id: 'city' # use 'city' if using free version or `premium` if using paid version       uid:      </code><br>    The <code>uid</code> is the string you will see in the snippet provided by livere during installation, as shown in the following screenshot.</dd></dl><pre><code>![Livere setup screenshot](livere_setup.png)</code></pre><dl><dt>Default values</dt><dd>No default values, must fill if using the system.</dd></dl>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> cutie </tag>
            
            <tag> tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typography and tags</title>
      <link href="/My-Blogs/2017/12/20/hexo/Typography%20and%20tags/"/>
      <url>/My-Blogs/2017/12/20/hexo/Typography%20and%20tags/</url>
      
        <content type="html"><![CDATA[<p><img src="/My-Blogs/images/lake.png" alt="$cover"></p><h1 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h1><hr><p>This post uses <code>hexo-renderer-markdown-it</code> plugin as markdown processor, so please install it to achieve the effect.</p><pre><code class="bash">npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --savenpm i markdown-it-emoji --savenpm i markdown-it-mark --savenpm i markdown-it-deflist --savenpm i markdown-it-container --save</code></pre><h1 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h1><p>Add following to <code>_config.yml</code> of your site.</p><pre><code class="yml">markdown:  render:    html: true    xhtmlOut: false    breaks: false    linkify: true    typographer: true    quotes: '“”‘’'  plugins:    - markdown-it-abbr    - markdown-it-footnote    - markdown-it-ins    - markdown-it-sub    - markdown-it-sup    - markdown-it-deflist  anchors:    level: 2    collisionSuffix: 'v'    permalink: false    permalinkClass: header-anchor    permalinkSymbol: " "    permalinkBefore: false</code></pre><h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><hr><h2 id="Headings"><a href="#Headings" class="headerlink" title="Headings"></a>Headings</h2><pre><code class="markdown"># h1 Heading 8-)## h2 Heading### h3 Heading#### h4 Heading##### h5 Heading###### h6 Heading</code></pre><h1 id="h1-Heading-8"><a href="#h1-Heading-8" class="headerlink" title="h1 Heading 8-)"></a>h1 Heading 8-)</h1><h2 id="h2-Heading"><a href="#h2-Heading" class="headerlink" title="h2 Heading"></a>h2 Heading</h2><h3 id="h3-Heading"><a href="#h3-Heading" class="headerlink" title="h3 Heading"></a>h3 Heading</h3><h4 id="h4-Heading"><a href="#h4-Heading" class="headerlink" title="h4 Heading"></a>h4 Heading</h4><h5 id="h5-Heading"><a href="#h5-Heading" class="headerlink" title="h5 Heading"></a>h5 Heading</h5><h6 id="h6-Heading"><a href="#h6-Heading" class="headerlink" title="h6 Heading"></a>h6 Heading</h6><h2 id="Horizontal-Rules"><a href="#Horizontal-Rules" class="headerlink" title="Horizontal Rules"></a>Horizontal Rules</h2><pre><code class="markdown">___---***</code></pre><hr><hr><hr><h2 id="Typographic-replacements"><a href="#Typographic-replacements" class="headerlink" title="Typographic replacements"></a>Typographic replacements</h2><pre><code class="markdown">(c) (C) (r) (R) (tm) (TM) (p) (P) +-test.. test... test..... test?..... test!....!!!!!! ???? ,,  -- ---"Smartypants, double quotes" and 'single quotes'</code></pre><p>(c) (C) (r) (R) (tm) (TM) (p) (P) +-</p><p>test.. test… test….. test?….. test!….</p><p>!!!!!! ???? ,,  – —</p><p>“Smartypants, double quotes” and ‘single quotes’</p><h2 id="Emphasis"><a href="#Emphasis" class="headerlink" title="Emphasis"></a>Emphasis</h2><pre><code class="markdown">**This is bold text**__This is bold text__*This is italic text*_This is italic text_~~Strikethrough~~</code></pre><p><strong>This is bold text</strong></p><p><strong>This is bold text</strong></p><p><em>This is italic text</em></p><p><em>This is italic text</em></p><p><del>Strikethrough</del></p><h2 id="Blockquotes"><a href="#Blockquotes" class="headerlink" title="Blockquotes"></a>Blockquotes</h2><pre><code class="markdown">&gt; Blockquotes can also be nested...&gt;&gt; ...by using additional greater-than signs right next to each other...&gt; &gt; &gt; ...or with spaces between arrows.</code></pre><blockquote><p>Blockquotes can also be nested…</p><blockquote><p>…by using additional greater-than signs right next to each other…</p><blockquote><p>…or with spaces between arrows.</p></blockquote></blockquote></blockquote><h2 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h2><h3 id="Unordered"><a href="#Unordered" class="headerlink" title="Unordered"></a>Unordered</h3><pre><code class="markdown">+ Create a list by starting a line with `+`, `-`, or `*`+ Sub-lists are made by indenting 2 spaces:  - Marker character change forces new list start:    * Ac tristique libero volutpat at    + Facilisis in pretium nisl aliquet    - Nulla volutpat aliquam velit+ Very easy!</code></pre><ul><li>Create a list by starting a line with <code>+</code>, <code>-</code>, or <code>*</code></li><li>Sub-lists are made by indenting 2 spaces:<ul><li>Marker character change forces new list start:<ul><li>Ac tristique libero volutpat at</li></ul><ul><li>Facilisis in pretium nisl aliquet</li></ul><ul><li>Nulla volutpat aliquam velit</li></ul></li></ul></li><li>Very easy!</li></ul><h3 id="Ordered"><a href="#Ordered" class="headerlink" title="Ordered"></a>Ordered</h3><pre><code class="markdown">1. Lorem ipsum dolor sit amet  1. Indented list    1. Another level  2. Indent2. Consectetur adipiscing elit3. Integer molestie lorem at massa</code></pre><ol><li>Lorem ipsum dolor sit amet</li><li>Indented list<ol><li>Another level</li></ol></li><li>Indent</li><li>Consectetur adipiscing elit</li><li>Integer molestie lorem at massa</li></ol><pre><code class="markdown">1. You can use sequential numbers...1. ...or keep all the numbers as `1.`</code></pre><ol><li>You can use sequential numbers…</li><li>…or keep all the numbers as <code>1.</code></li></ol><h4 id="Start-numbering-with-offset"><a href="#Start-numbering-with-offset" class="headerlink" title="Start numbering with offset:"></a>Start numbering with offset:</h4><pre><code class="markdown">57. foo1. bar</code></pre><ol start="57"><li>foo</li><li>bar</li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="markdown">Inline `code`</code></pre><p>Inline <code>code</code></p><h3 id="Indented-code"><a href="#Indented-code" class="headerlink" title="Indented code"></a>Indented code</h3><pre><code class="markdown">// Some comments    line 1 of code    line 2 of code    line 3 of code</code></pre><pre><code>// Some commentsline 1 of codeline 2 of codeline 3 of code</code></pre><h3 id="Block-code-“fences”"><a href="#Block-code-“fences”" class="headerlink" title="Block code “fences”"></a>Block code “fences”</h3><pre><code class="markdown">```Sample text here...```</code></pre><pre><code>Sample text here...</code></pre><p>Syntax highlighting</p><pre><code class="markdown">``` js sample.jsvar foo = function (bar) {  return bar++;};console.log(foo(5));```</code></pre><pre><code class="js">var foo = function (bar) {  return bar++;};console.log(foo(5));</code></pre><h2 id="Tables"><a href="#Tables" class="headerlink" title="Tables"></a>Tables</h2><pre><code class="markdown">| Option | Description |Description | Description | Description | Description || ------ | ----------- |----------- | ----------- | ----------- | ----------- || data   | path to data files to supply the data that will be passed into templates. || engine | engine to be used for processing templates. Handlebars is the default. || ext    | extension to be used for dest files. |</code></pre><table><thead><tr><th>Option</th><th>Description</th><th>Description</th><th>Description</th><th>Description</th><th>Description</th></tr></thead><tbody><tr><td>data</td><td>path to data files to supply the data that will be passed into templates.</td><td></td><td></td><td></td><td></td></tr><tr><td>engine</td><td>engine to be used for processing templates. Handlebars is the default.</td><td></td><td></td><td></td><td></td></tr><tr><td>ext</td><td>extension to be used for dest files.</td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="Right-aligned-columns"><a href="#Right-aligned-columns" class="headerlink" title="Right aligned columns"></a>Right aligned columns</h3><pre><code class="markdown">| Option | Description || ------:| -----------:|| data   | path to data files to supply the data that will be passed into templates. || engine | engine to be used for processing templates. Handlebars is the default. || ext    | extension to be used for dest files. |</code></pre><table><thead><tr><th align="right">Option</th><th align="right">Description</th></tr></thead><tbody><tr><td align="right">data</td><td align="right">path to data files to supply the data that will be passed into templates.</td></tr><tr><td align="right">engine</td><td align="right">engine to be used for processing templates. Handlebars is the default.</td></tr><tr><td align="right">ext</td><td align="right">extension to be used for dest files.</td></tr></tbody></table><h2 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h2><pre><code class="markdown">[link text](http://dev.nodeca.com)</code></pre><p><a href="http://dev.nodeca.com/">link text</a></p><pre><code class="markdown">[link with title](http://nodeca.github.io/pica/demo/ "title text!")</code></pre><p><a href="http://nodeca.github.io/pica/demo/" title="title text!">link with title</a></p><pre><code class="markdown">Autoconverted link https://github.com/nodeca/pica (enabled linkify)</code></pre><p>Autoconverted link <a href="https://github.com/nodeca/pica">https://github.com/nodeca/pica</a> (enabled linkify)</p><h2 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h2><pre><code class="markdown">![Minion](https://octodex.github.com/images/minion.png)![Stormtroopocat](https://octodex.github.com/images/stormtroopocat.jpg "The Stormtroopocat")</code></pre><p><img src="https://octodex.github.com/images/minion.png" alt="Minion"><br><img src="https://octodex.github.com/images/stormtroopocat.jpg" alt="Stormtroopocat" title="The Stormtroopocat"></p><p>Like links, Images also have a footnote style syntax</p><pre><code class="markdown">![Alt text][id]With a reference later in the document defining the URL location:[id]: https://octodex.github.com/images/dojocat.jpg  "The Dojocat"</code></pre><p><img src="https://octodex.github.com/images/dojocat.jpg" alt="Alt text" title="The Dojocat"></p><p>With a reference later in the document defining the URL location:</p><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p>The killer feature of <code>markdown-it</code> is very effective support of<br><a href="https://www.npmjs.org/browse/keyword/markdown-it-plugin">syntax plugins</a>. The sample <a href="#configuration">configuration snippet</a></p><h3 id="Emojies"><a href="#Emojies" class="headerlink" title="Emojies"></a><a href="https://github.com/markdown-it/markdown-it-emoji">Emojies</a></h3><pre><code class="markdown">Classic markup: :wink: :crush: :cry: :tear: :laughing: :yum:Shortcuts (emoticons): :-) :-( 8-) ;)</code></pre><p>Classic markup: <span class="github-emoji"><span>😉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f609.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> :crush: <span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> :tear: <span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>Shortcuts (emoticons): :-) :-( 8-) ;)</p><h3 id="Subscript-Superscript"><a href="#Subscript-Superscript" class="headerlink" title="Subscript / Superscript"></a><a href="https://github.com/markdown-it/markdown-it-sub">Subscript</a> / <a href="https://github.com/markdown-it/markdown-it-sup">Superscript</a></h3><pre><code class="markdown">Superscript: 19^th^Subscript: H~2~O</code></pre><p>Superscript: 19^th^</p><p>Subscript: H<del>2</del>O</p><h3 id="lt-ins-gt"><a href="#lt-ins-gt" class="headerlink" title="<ins>"></a><a href="https://github.com/markdown-it/markdown-it-ins">&lt;ins&gt;</a></h3><pre><code class="markdown">++Inserted text++</code></pre><p>++Inserted text++</p><h3 id="lt-mark-gt"><a href="#lt-mark-gt" class="headerlink" title="<mark>"></a><a href="https://github.com/markdown-it/markdown-it-mark">&lt;mark&gt;</a></h3><pre><code class="markdown">==Marked text==</code></pre><p>==Marked text==</p><h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a><a href="https://github.com/markdown-it/markdown-it-footnote">Footnotes</a></h3><pre><code class="markdown">Footnote 1 link[^first].Footnote 2 link[^second].Inline footnote^[Text of inline footnote] definition.Duplicated footnote reference[^second].[^first]: Footnote **can have markup**    and multiple paragraphs.[^second]: Footnote text.</code></pre><p>Footnote 1 link[^first].</p><p>Footnote 2 link[^second].</p><p>Inline footnote^[Text of inline footnote] definition.</p><p>Duplicated footnote reference[^second].</p><p>[^first]: Footnote <strong>can have markup</strong></p><pre><code>and multiple paragraphs.</code></pre><p>[^second]: Footnote text.</p><h3 id="Definition-lists"><a href="#Definition-lists" class="headerlink" title="Definition lists"></a><a href="https://github.com/markdown-it/markdown-it-deflist">Definition lists</a></h3><pre><code class="markdown">Term 1:   Definition 1with lazy continuation.</code></pre><dl><dt>Term 1</dt><dd>Definition 1<br>with lazy continuation.</dd></dl><pre><code class="markdown">Term 2 with *inline markup*:   Definition 2        { some code, part of Definition 2 }    Third paragraph of definition 2.</code></pre><dl><dt>Term 2 with <em>inline markup</em></dt><dd>Definition 2</dd></dl><pre><code>    { some code, part of Definition 2 }Third paragraph of definition 2.</code></pre><p><em>Compact style:</em></p><pre><code class="markdown">Term 1  ~ Definition 1Term 2  ~ Definition 2a  ~ Definition 2b</code></pre><p>Term 1<br>  ~ Definition 1</p><p>Term 2<br>  ~ Definition 2a<br>  ~ Definition 2b</p><h3 id="Abbreviations"><a href="#Abbreviations" class="headerlink" title="Abbreviations"></a><a href="https://github.com/markdown-it/markdown-it-abbr">Abbreviations</a></h3><pre><code class="markdown">This is HTML abbreviation example.It converts "HTML", but keep intact partial entries like "xxxHTMLyyy" and so on.*[HTML]: Hyper Text Markup Language</code></pre><p>This is HTML abbreviation example.</p><p>It converts “HTML”, but keep intact partial entries like “xxxHTMLyyy” and so on.</p><p>*[HTML]: Hyper Text Markup Language</p><h3 id="Custom-containers"><a href="#Custom-containers" class="headerlink" title="Custom containers"></a><a href="https://github.com/markdown-it/markdown-it-container">Custom containers</a></h3><p>::: warning<br><em>here be dragons</em><br>:::</p><h2 id="Hexo-Built-in-Tags"><a href="#Hexo-Built-in-Tags" class="headerlink" title="Hexo Built-in Tags"></a>Hexo Built-in Tags</h2><h3 id="Blockquote-with-author"><a href="#Blockquote-with-author" class="headerlink" title="Blockquote with author"></a>Blockquote with author</h3><pre><code class="swig">{% blockquote David Levithan, Wide Awake %}Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.{% endblockquote %}</code></pre><blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p><footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote><h3 id="Blockquote-for-twitter"><a href="#Blockquote-for-twitter" class="headerlink" title="Blockquote for twitter"></a>Blockquote for twitter</h3><pre><code class="swig">{% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %}NEW: DevDocs now comes with syntax highlighting. http://devdocs.io{% endblockquote %}</code></pre><blockquote><p>NEW: DevDocs now comes with syntax highlighting. <a href="http://devdocs.io/">http://devdocs.io</a></p><footer><strong>@DevDocs</strong><cite><a href="https://twitter.com/devdocs/status/356095192085962752">twitter.com/devdocs/status/356095192085962752</a></cite></footer></blockquote><h3 id="Blockquote-for-weblink"><a href="#Blockquote-for-weblink" class="headerlink" title="Blockquote for weblink"></a>Blockquote for weblink</h3><pre><code class="swig">{% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %}Every interaction is both precious and an opportunity to delight.{% endblockquote %}</code></pre><blockquote><p>Every interaction is both precious and an opportunity to delight.</p><footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html">Welcome to Island Marketing</a></cite></footer></blockquote><h3 id="Pull-Quotes"><a href="#Pull-Quotes" class="headerlink" title="Pull Quotes"></a>Pull Quotes</h3><pre><code class="swig">{% pullquote %}content{% endpullquote %}</code></pre><blockquote class="pullquote"><p>content</p></blockquote><h3 id="jsFiddle"><a href="#jsFiddle" class="headerlink" title="jsFiddle"></a>jsFiddle</h3><pre><code class="swig">{% jsfiddle o2gxgz9r default light %}</code></pre><iframe scrolling="no" width="100%" height="300" src="https://jsfiddle.net/o2gxgz9r/embedded/js,resources,html,css,result/light" frameborder="0" loading="lazy" allowfullscreen=""></iframe><h3 id="Gist"><a href="#Gist" class="headerlink" title="Gist"></a>Gist</h3><pre><code class="swig">{% gist b6365e79be6052e7531e7ba6ea8caf23 'Sample gist' %}</code></pre><script src="//gist.github.com/b6365e79be6052e7531e7ba6ea8caf23.js?file=Sample gist"></script><h3 id="iFrame"><a href="#iFrame" class="headerlink" title="iFrame"></a>iFrame</h3><pre><code class="swig">{% iframe https://www.bing.com %}</code></pre><iframe src="https://www.bing.com/" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen=""></iframe><h3 id="Link-to-open-in-new-tab"><a href="#Link-to-open-in-new-tab" class="headerlink" title="Link to open in new tab"></a>Link to open in new tab</h3><pre><code class="swig">{% link Google https://www.google.com default Google %}</code></pre><a href="https://www.google.com/" title="default Google" target="">Google</a><h3 id="Youtube"><a href="#Youtube" class="headerlink" title="Youtube"></a>Youtube</h3><pre><code class="swig">{% youtube l_lblj8Cq0o %}</code></pre><div class="video-container"><iframe src="https://www.youtube.com/embed/l_lblj8Cq0o" frameborder="0" loading="lazy" allowfullscreen=""></iframe></div>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typography </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tag Plugins</title>
      <link href="/My-Blogs/2013/12/25/hexo/tag-plugins/"/>
      <url>/My-Blogs/2013/12/25/hexo/tag-plugins/</url>
      
        <content type="html"><![CDATA[<p>This post is used for testing tag plugins. See <a href="http://zespia.tw/hexo/docs/tag-plugins.html">docs</a> for more info.</p><h2 id="Block-Quote"><a href="#Block-Quote" class="headerlink" title="Block Quote"></a>Block Quote</h2><h3 id="Normal-blockquote"><a href="#Normal-blockquote" class="headerlink" title="Normal blockquote"></a>Normal blockquote</h3><blockquote><p>Praesent diam elit, interdum ut pulvinar placerat, imperdiet at magna.</p></blockquote><h3 id="Quote-from-a-book"><a href="#Quote-from-a-book" class="headerlink" title="Quote from a book"></a>Quote from a book</h3><blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p><footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote><h3 id="Quote-from-Twitter"><a href="#Quote-from-Twitter" class="headerlink" title="Quote from Twitter"></a>Quote from Twitter</h3><blockquote><p>NEW: DevDocs now comes with syntax highlighting. <a href="http://devdocs.io/">http://devdocs.io</a></p><footer><strong>@DevDocs</strong><cite><a href="https://twitter.com/devdocs/status/356095192085962752">twitter.com/devdocs/status/356095192085962752</a></cite></footer></blockquote><h3 id="Quote-from-an-article-on-the-web"><a href="#Quote-from-an-article-on-the-web" class="headerlink" title="Quote from an article on the web"></a>Quote from an article on the web</h3><blockquote><p>Every interaction is both precious and an opportunity to delight.</p><footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html">Welcome to Island Marketing</a></cite></footer></blockquote><h2 id="Code-Block"><a href="#Code-Block" class="headerlink" title="Code Block"></a>Code Block</h2><h3 id="Normal-code-block"><a href="#Normal-code-block" class="headerlink" title="Normal code block"></a>Normal code block</h3><pre><code>alert('Hello World!');</code></pre><h3 id="With-caption"><a href="#With-caption" class="headerlink" title="With caption"></a>With caption</h3><pre><code>array.map(callback[, thisArg])</code></pre><h3 id="With-caption-and-URL"><a href="#With-caption-and-URL" class="headerlink" title="With caption and URL"></a>With caption and URL</h3><pre><code>.compact([0, 1, false, 2, ‘’, 3]);=&gt; [1, 2, 3]</code></pre><h3 id="With-marked-lines"><a href="#With-marked-lines" class="headerlink" title="With marked lines"></a>With marked lines</h3><p>Line 1,7-8,10 should be marked with different color.</p><pre><code>const http = require('http');const hostname = '127.0.0.1';const port = 1337;http.createServer((req, res) =&gt; {  res.writeHead(200, { 'Content-Type': 'text/plain' });  res.end('Hello World\n');}).listen(port, hostname, () =&gt; {  console.log(`Server running at http://${hostname}:${port}/`);});</code></pre><p>Note: Theme’s style should support <code>.highlight.line.marked</code> (recommend to use the selection or current line color).</p><h3 id="Gist"><a href="#Gist" class="headerlink" title="Gist"></a>Gist</h3><script src="//gist.github.com/996818.js"></script><h3 id="jsFiddle"><a href="#jsFiddle" class="headerlink" title="jsFiddle"></a>jsFiddle</h3><iframe scrolling="no" width="100%" height="300" src="https://jsfiddle.net/ccWP7/embedded/js,resources,html,css,result/light" frameborder="0" loading="lazy" allowfullscreen=""></iframe><h2 id="Pullquote"><a href="#Pullquote" class="headerlink" title="Pullquote"></a>Pullquote</h2><h3 id="Left"><a href="#Left" class="headerlink" title="Left"></a>Left</h3><blockquote class="pullquote left"><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p></blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas tempus molestie arcu, et fringilla mauris placerat ac. Nullam luctus bibendum risus. Ut cursus sed ipsum feugiat egestas. Suspendisse elementum, velit eu consequat consequat, augue lorem dapibus libero, eget pulvinar dolor est sit amet nulla. Suspendisse a porta tortor, et posuere mi. Pellentesque ultricies, mi quis volutpat malesuada, erat felis vulputate nisl, ac congue ante tortor ut ante. Proin aliquam sem vel mauris tincidunt, eget scelerisque tortor euismod. Nulla tincidunt enim nec commodo dictum. Mauris id sapien et orci gravida luctus id ut dui. In vel vulputate odio. Duis vel turpis molestie, scelerisque enim eu, lobortis eros. Cras at ipsum gravida, sagittis ante vel, viverra tellus. Nunc mauris turpis, elementum ullamcorper nisl pretium, ultrices cursus justo. Mauris porttitor commodo eros, ac ornare orci interdum in. Cras fermentum cursus leo sed mattis. In dignissim lorem sem, sit amet elementum mauris venenatis ac.</p><h3 id="Right"><a href="#Right" class="headerlink" title="Right"></a>Right</h3><blockquote class="pullquote right"><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p></blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed ligula justo, lobortis sit amet semper vel, dignissim sit amet libero. Praesent ac tempus ligula. Maecenas at gravida odio. Etiam tristique volutpat lacus eu faucibus. Donec non tempus arcu. Phasellus adipiscing, mauris nec mollis egestas, ipsum nunc auctor velit, et rhoncus lorem ipsum at ante. Praesent et sem in velit volutpat auctor. Duis vel mauris nulla. Maecenas mattis interdum ante, quis sagittis nibh cursus et. Nulla facilisi. Morbi convallis gravida tortor, ut fermentum enim gravida et. Nunc vel dictum nisl, non ultrices libero. Proin vestibulum felis eget orci consectetur lobortis. Vestibulum augue nulla, iaculis vitae augue vehicula, dignissim ultrices libero. Sed imperdiet urna et quam ultrices tincidunt nec ac magna. Etiam vel pharetra elit.</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
