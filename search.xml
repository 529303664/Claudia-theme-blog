<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vim基础篇——快速移动</title>
      <link href="/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/vim%E5%BF%AB%E9%80%9F%E7%A7%BB%E5%8A%A8/"/>
      <url>/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/vim%E5%BF%AB%E9%80%9F%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>最初使用Vim时，初学者经常会感到不适应，因为它的移动方式和一般的编辑器差别很大。但是Vim的魅力就在于，当你学会Vim的移动方式后，你能迅速的把光标移动到你想要的位置。</p><p>本文介绍Vim中的移动方式：Vim中熟练的移动并不是指用hjkl移动，当你越熟练的掌握vim的移动方式，你会越少的使用hjkl移动方式。</p><a id="more"></a><blockquote><p>hjkl are the tip of the top of the iceberg and very rarely used, at least in my case.</p></blockquote><br><h3 id="1、行内移动"><a href="#1、行内移动" class="headerlink" title="1、行内移动"></a>1、行内移动</h3><blockquote><p>Test: This is a line with example text </p></blockquote><br><h4 id="最基础的移动方式是w-e-b-ge"><a href="#最基础的移动方式是w-e-b-ge" class="headerlink" title="最基础的移动方式是w/e/b/ge"></a>最基础的移动方式是w/e/b/ge</h4><br><p>w是向前移动到下一个单词的第一个位置，大写的W表示只使用空格作为分隔</p><br><pre><code class="BASH">" * 代表了光标的初始位置" 每个字母代表了如果按下这个键会跳转的位置Test: This is a line with example text*   w w    w  w w    w    w       w*     W    W  W W    W    W       W</code></pre><p>w前面可以加上数字，表示w命令重复几次，比如3w等同于按下三次w</p><p>e是向前跳动到下一个【单词的末尾】，这意味着如果当前光标在单词的中间，按下e会跳转到当前单词的末尾。大写的E表示只使用空格作为分隔</p><pre><code class="BASH">" * 代表了光标的初始位置" 每个字母代表了如果按下这个键会跳转的位置Test: This is a line with example text*  ee    e  e e    e    e       e    e*   E    E  E E    E    E       E    E </code></pre><p>b是向后移动到上一个【单词的开头】，这意味着如果当前光标在单词的中间，按下b会跳转到当前单词的开头。大写的B表示只使用空格作为分隔</p><pre><code class="BASH">" * 代表了光标的初始位置" 每个字母代表了如果按下这个键会跳转的位置Test: This is a line with example textb   b b    b  b b    b    b       b *B     B    B  B B    B    B       B *</code></pre><p>ge是向后移动到上一个【单词的末尾】。大写的gE表示只使用空格作为分隔</p><pre><code class="BASH">" * 代表了光标的初始位置" 每个字母代表了如果按下这个键会跳转的位置" &amp; 表示按下gETest: This is a line with example text  ee    e  e e    e    e       e   *   &amp;    &amp;  &amp; &amp;    &amp;    &amp;       &amp;   * </code></pre><blockquote><p>Notice：w/e/b/ge都是可以跨行移动的！</p></blockquote><br><h4 id="快速移动到行的开始和结束"><a href="#快速移动到行的开始和结束" class="headerlink" title="快速移动到行的开始和结束"></a>快速移动到行的开始和结束</h4><br><pre><code class="BASH">$ 移动到行的末尾0 移动到行的开头^ 移动到第一个非空白字符g_ 移动到最后一个非空白字符</code></pre><br><blockquote><p>0不能使用数字参数；但是$可以，$等同于1$，2$表示移动到下一行的末尾，同理3$…</p></blockquote><br><h4 id="行内移动到特定字符"><a href="#行内移动到特定字符" class="headerlink" title="行内移动到特定字符"></a>行内移动到特定字符</h4><br><p>【f+字符】表示移动到行内当前光标后面的第一个这个字符</p><p>【t+字符】表示移动到行内当前光标后的的第一个这个字符的前一个位置</p><p>【F+字符】为【f+字符】的反向</p><p>【T+字符】为【t+字符】的反向</p><br><blockquote><p>这种移动方式不能跨行</p></blockquote><br><pre><code class="BASH">" * 代表了光标的初始位置" 每个字母代表了如果按下这个键会跳转的位置" &amp; 表示按下fe" ! 表示按下teTest: This is a line with example text*&amp;                 &amp;      &amp;     &amp;  &amp; +               !</code></pre><br><p>注意到一个奇怪的现象，在第二行操作中，按下te会定位到line中的e，光标会移动到e的前一个字符n，如果再一次按下te，会定位到line中的e，光标会移动到e的前一个字符n，也就是说光标不会移动。</p><br><p>这样就告诉我们：连续按下两次【t+字符】和按下一次到达的位置一定是一样的。</p><blockquote><p>f/t/F/T均可以接受数字参数，3fe相当于按下三次fe</p></blockquote><p>事实上，重复操作有另一种方式：【; 】代表了重复查找字符，【, 】是【; 】的反向：</p><blockquote><p>【fe; 】等同于【fefe】等同于【2fe】【fe, 】等同于【feFe】</p></blockquote><br><h3 id="2、行间移动"><a href="#2、行间移动" class="headerlink" title="2、行间移动"></a>2、行间移动</h3><br><h4 id="滚动屏幕"><a href="#滚动屏幕" class="headerlink" title="滚动屏幕"></a>滚动屏幕</h4><pre><code class="BASH">&lt;Ctrl-b&gt; 向下移动一个屏幕&lt;Ctrl-f&gt; 向上移动一个屏幕&lt;Ctrl-u&gt; 向下移动半个屏幕&lt;Ctrl-d&gt; 向上移动半个屏幕</code></pre><h4 id="文件位置移动"><a href="#文件位置移动" class="headerlink" title="文件位置移动"></a>文件位置移动</h4><br><p>【数字+G】表示移动到文件的特定行</p><p>比如30G表示移动到第三十行</p><p>gg表示移动到文件的第一行</p><p>G表示移动到文件的最后一行</p><br><h3 id="3、其他移动方式"><a href="#3、其他移动方式" class="headerlink" title="3、其他移动方式"></a>3、其他移动方式</h3><br><p>【%】：找到当前光标 下或者之后 的第一个括号，并移动到它匹配的括号的位置</p><blockquote><p>括号包括：</p></blockquote><p>([{}])<br>/* */<br>#if, #ifdef, #else, #elif, #endif</p><br><pre><code class="BASH">" * 代表了光标的初始位置" 每个字母代表了如果按下这个键会跳转的位置int f(1, g(2, 3))*              %   %          *     *      %       % *</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sftp命令基本使用</title>
      <link href="/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/sftp%E5%91%BD%E4%BB%A4%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/sftp%E5%91%BD%E4%BB%A4%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><code>sftp</code> 是 SSH 提供的一个客户端应用程序，主要用来安全地访问 FTP。因为 FTP 是不加密协议，很不安全，<code>sftp</code>就相当于将 FTP 放入了 SSH。</p><a id="more"></a><p>下面的命令连接 FTP 主机</p><pre><code class="BASH">sftp username@hostname</code></pre><p>执行上面的命令，会要求输入 FTP 的密码。密码验证成功以后，就会出现 FTP 的提示符<code>sftp&gt;</code>，下面是一个例子。</p><pre><code class="BASH">sftp USER@penguin.example.comUSER@penguin.example.com's password:Connected to penguin.example.com.sftp&gt;</code></pre><p>FTP 的提示符下面，就可以输入各种 FTP 命令了，这部分完全跟传统的 FTP 用法完全一样。</p><ul><li><code>ls [directory]</code>: 列出一个远程目录的内容。如果没有指定目标目录，则默认列出当前目录。</li><li><code>cd directory</code>: 从当前目录改到指定目录。</li><li><code>mkdir directory</code>: 创建一个远程目录。</li><li><code>rmdir path</code>: 删除一个远程目录。</li><li><code>put localfile [remotefile]</code>: 本地文件传输到远程主机。</li><li><code>get remotefile [localfile]</code>: 远程文件传输到本地。</li><li><code>help</code>: 显示帮助信息。</li><li><code>bye</code>: 退出 sftp。</li><li><code>quit</code>: 退出 sftp。</li><li><code>exit</code>: 退出 sftp。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scp命令的基本使用</title>
      <link href="/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/scp%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/scp%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><code>scp</code> 是 secure copy 的缩写，相当于 <code>cp</code> 命令 + SSH。它的底层是 SSH 协议，默认端口是22，相当于先使用 <code>ssh</code> 命令登录远程主机，然后再执行拷贝操作</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>scp</code> 主要用于以下三种复制操作。</p><ul><li>本地复制到远程。</li><li>远程复制到本地。</li><li>两个远程系统之间的复制。</li></ul><p>使用 <code>scp</code> 传输数据时，文件和密码都是加密的，不会泄漏敏感信息。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><code>scp</code> 的语法类似 <code>cp</code> 的语法。</p><pre><code class="BASH">scp source destination</code></pre><p>上面命令中， <code>source</code> 是文件当前的位置， <code>destination</code> 是文件所要复制到的位置。它们都可以包含用户名和主机名。</p><pre><code class="BASH">scp user@host:foo.txt bar.txt</code></pre><p>上面命令将远程主机（ <code>user@host</code> ）用户主目录下的 <code>foo.txt</code> ，复制为本机当前目录的 <code>bar.txt</code> 。可以看到，主机与文件之间要使用冒号（ <code>:</code> ）分隔。</p><p><code>scp</code> 会先用 SSH 登录到远程主机，然后在加密连接之中复制文件。客户端发起连接后，会提示用户输入密码，这部分是跟 SSH 的用法一致的。</p><p>用户名和主机名都是可以省略的。用户名的默认值是本机的当前用户名，主机名默认为当前主机。注意， <code>scp</code> 会使用 SSH 客户端的配置文件 <code>.ssh/config</code> ，如果配置文件里面定义了主机的别名，这里也可以使用别名连接。</p><p><code>scp</code> 支持一次复制多个文件。</p><pre><code class="BASH">scp source1 source2 destination</code></pre><p>上面命令会将 <code>source1</code> 和 <code>source2</code> 两个文件，复制到 <code>destination</code> 。</p><p>注意，如果所要复制的文件，在目标位置已经存在同名文件， <code>scp</code> 会在没有警告的情况下覆盖同名文件。</p><h2 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h2><h3 id="本地文件复制到远程"><a href="#本地文件复制到远程" class="headerlink" title="本地文件复制到远程"></a>本地文件复制到远程</h3><p>复制本机文件到远程系统的用法如下。</p><pre><code class="BASH"># 语法$ scp SourceFile user@host:directory/TargetFile# 示例$ scp file.txt remote_username@10.10.0.2:/remote/directory</code></pre><p>下面是复制整个目录的例子。</p><pre><code class="BASH"># 将本机的 documents 目录拷贝到远程主机，# 会在远程主机创建 documents 目录$ scp -r documents username@server_ip:/path_to_remote_directory# 将本机整个目录拷贝到远程目录下$ scp -r localmachine/path_to_the_directory username@server_ip:/path_to_remote_directory/# 将本机目录下的所有内容拷贝到远程目录下$ scp -r localmachine/path_to_the_directory/* username@server_ip:/path_to_remote_directory/</code></pre><h3 id="远程文件复制到本地"><a href="#远程文件复制到本地" class="headerlink" title="远程文件复制到本地"></a>远程文件复制到本地</h3><p>从远程主机复制文件到本地的用法如下。</p><pre><code class="BASH"># 语法$ scp user@host:directory/SourceFile TargetFile# 示例$ scp remote_username@10.10.0.2:/remote/file.txt /local/directory</code></pre><p>下面是复制整个目录的例子。</p><pre><code class="BASH"># 拷贝一个远程目录到本机目录下$ scp -r username@server_ip:/path_to_remote_directory local-machine/path_to_the_directory/# 拷贝远程目录下的所有内容，到本机目录下$ scp -r username@server_ip:/path_to_remote_directory/* local-machine/path_to_the_directory/$ scp -r user@host:directory/SourceFolder TargetFolder</code></pre><h3 id="两个远程系统之间的复制"><a href="#两个远程系统之间的复制" class="headerlink" title="两个远程系统之间的复制"></a>两个远程系统之间的复制</h3><p>本机发出指令，从远程主机 A 拷贝到远程主机 B 的用法如下。</p><pre><code class="BASH"># 语法$ scp user@host1:directory/SourceFile user@host2:directory/SourceFile# 示例$ scp user1@host1.com:/files/file.txt user2@host2.com:/files</code></pre><p>系统将提示你输入两个远程帐户的密码。数据将直接从一个远程主机传输到另一个远程主机。</p><h2 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h2><h3 id="c"><a href="#c" class="headerlink" title="-c"></a>-c</h3><p><code>-c</code>参数用来指定文件拷贝数据传输的加密算法</p><pre><code class="BASH">scp -c blowfish some_file your_username@remotehost.edu:~</code></pre><p>上面代码指定加密算法为 <code>blowfish</code> 。</p><h3 id="C"><a href="#C" class="headerlink" title="-C"></a>-C</h3><p><code>-C</code> 参数表示是否在传输时压缩文件。</p><pre><code class="BASH">scp -c blowfish -C local_file your_username@remotehost.edu:~</code></pre><h3 id="F"><a href="#F" class="headerlink" title="-F"></a>-F</h3><p><code>-F</code> 参数用来指定 ssh_config 文件，供 ssh 使用。</p><pre><code class="BASH">scp -F /home/pungki/proxy_ssh_config Label.pdf root@172.20.10.8:/root</code></pre><h3 id="i"><a href="#i" class="headerlink" title="-i"></a>-i</h3><p><code>-i</code> 参数用来指定密钥。</p><pre><code class="BASH">scp -vCq -i private_key.pem ~/test.txt root@192.168.1.3:/some/path/test.txt</code></pre><h3 id="l"><a href="#l" class="headerlink" title="-l"></a>-l</h3><p><code>-l</code> 参数用来限制传输数据的带宽速率，单位是 Kbit/sec。对于多人分享的带宽，这个参数可以留出一部分带宽供其他人使用。</p><pre><code class="BASH">scp -l 80 yourusername@yourserver:/home/yourusername/* .</code></pre><p>上面代码中， <code>scp</code> 命令占用的带宽限制为每秒 80K 比特位，即每秒 10K 字节。</p><h3 id="p"><a href="#p" class="headerlink" title="-p"></a>-p</h3><p><code>-p</code> 参数用来保留修改时间（modification time）、访问时间（access time）、文件状态（mode）等原始文件的信息。</p><pre><code class="BASH">scp -p ~/test.txt root@192.168.1.3:/some/path/test.txt</code></pre><h3 id="P"><a href="#P" class="headerlink" title="-P"></a>-P</h3><p><code>-P</code> 参数用来指定远程主机的 SSH 端口。如果远程主机使用默认端口22，可以不用指定，否则需要用-P参数在命令中指定。</p><pre><code class="BASH">scp -P 2222 user@host:directory/SourceFile TargetFile</code></pre><h3 id="q"><a href="#q" class="headerlink" title="-q"></a>-q</h3><p><code>-q</code> 参数用来关闭显示拷贝的进度条。</p><pre><code class="BASH">scp -q Label.pdf mrarianto@202.x.x.x:.</code></pre><h3 id="r"><a href="#r" class="headerlink" title="-r"></a>-r</h3><p><code>-r</code> 参数表示是否以递归方式复制目录。</p><h3 id="v"><a href="#v" class="headerlink" title="-v"></a>-v</h3><p><code>-v</code> 参数用来显示详细的输出。</p><pre><code class="BASH">scp -v ~/test.txt root@192.168.1.3:/root/help2356.txt</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rsync的基本使用</title>
      <link href="/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/rsync%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/rsync%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><code>rsync</code> 可以用于本地计算机的两个目录之间的同步。下面就用本地同步举例，顺便讲解 <code>rsync</code> 几个主要参数的用法。</p><a id="more"></a><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="r-参数"><a href="#r-参数" class="headerlink" title="-r 参数"></a><code>-r</code> 参数</h3><p>本机使用 <code>rsync</code> 命令时，可以作为 <code>cp</code> 和 <code>mv</code> 命令的替代方法，将源目录拷贝到目标目录。</p><pre><code class="BASH">rsync -r source destination</code></pre><p>上面命令中， <code>-r</code> 表示递归，即包含子目录。注意， <code>-r</code> 是必须的，否则 rsync 运行不会成功。 <code>source</code> 目录表示源目录， <code>destination</code> 表示目标目录。上面命令执行以后，目标目录下就会出现 <code>destination/source</code> 这个子目录</p><p>如果有多个文件或目录需要同步，可以写成下面这样</p><pre><code class="BASH">rsync -r source1 source2 destination</code></pre><p>上面命令中， <code>source1</code> 、 <code>source2</code> 都会被同步到 <code>destination</code> 目录</p><h3 id="a-参数"><a href="#a-参数" class="headerlink" title="-a 参数"></a><code>-a</code> 参数</h3><p><code>-a</code> 参数可以替代 <code>-r</code> ，除了可以递归同步以外，还可以同步元信息（比如修改时间、权限等）。由于 rsync 默认使用文件大小和修改时间决定文件是否需要更新，所以 <code>-a</code> 比 <code>-r</code> 更有用。下面的用法才是常见的写法</p><pre><code class="BASH">rsync -a source destination</code></pre><p>目标目录 <code>destination</code> 如果不存在，rsync 会自动创建。执行上面的命令后，源目录 <code>source</code> 被完整地复制到了目标目录 <code>destination</code> 下面，即形成了 <code>destination/source</code> 的目录结构。</p><p>如果只想同步源目录 <code>source</code> 里面的内容到目标目录 <code>destination</code> ，则需要在源目录后面加上斜杠.</p><pre><code class="BASH">rsync -a source/ destination</code></pre><p>上面命令执行后， <code>source</code> 目录里面的内容，就都被复制到了 <code>destination</code> 目录里面，并不会在 <code>destination</code> 下面创建一个 <code>source</code> 子目录。</p><h3 id="n-参数"><a href="#n-参数" class="headerlink" title="-n 参数"></a><code>-n</code> 参数</h3><p>如果不确定 rsync 执行后会产生什么结果，可以先用-n或–dry-run参数模拟执行的结果</p><pre><code class="BASH">rsync -anv source/ destination</code></pre><p>上面命令中， <code>-n</code> 参数模拟命令执行的结果，并不真的执行命令。 <code>-v</code> 参数则是将结果输出到终端，这样就可以看到哪些内容会被同步</p><h3 id="–delete参数"><a href="#–delete参数" class="headerlink" title="–delete参数"></a>–delete参数</h3><p>默认情况下，rsync 只确保源目录的所有内容（明确排除的文件除外）都复制到目标目录。它不会使两个目录保持相同，并且不会删除文件。如果要使得目标目录成为源目录的镜像副本，则必须使用–delete参数，这将删除只存在于目标目录、不存在于源目录的文件。</p><pre><code class="BASH">rsync -av --delete source/ destination</code></pre><p>上面命令中， <code>--delete</code> 参数会使得 <code>destination</code> 成为 <code>source</code> 的一个镜像</p><h3 id="–exclude参数"><a href="#–exclude参数" class="headerlink" title="–exclude参数"></a>–exclude参数</h3><p>有时，我们希望同步时排除某些文件或目录，这时可以用–exclude参数指定排除模式</p><pre><code class="BASH">$ rsync -av --exclude='*.txt' source/ destination# 或者$ rsync -av --exclude '*.txt' source/ destination</code></pre><p>上面命令排除了所有 TXT 文件。</p><p>注意，rsync 会同步以“点”开头的隐藏文件，如果要排除隐藏文件，可以这样写 <code>--exclude=".*"</code> 。</p><p>如果要排除某个目录里面的所有文件，但不希望排除目录本身，可以写成下面这样。</p><pre><code class="BASH">$ rsync -av --exclude 'dir1/*' source/ destination</code></pre><p>多个排除模式，可以用多个 <code>--exclude</code> 参数</p><pre><code class="BASH">rsync -av --exclude 'file1.txt' --exclude 'dir1/*' source/ destination</code></pre><p>多个排除模式也可以利用 Bash 的大扩号的扩展功能，只用一个 <code>--exclude</code> 参数</p><pre><code class="BASH">rsync -av --exclude={'file1.txt','dir1/*'} source/ destination</code></pre><p>如果排除模式很多，可以将它们写入一个文件，每个模式一行，然后用 <code>--exclude-from</code> 参数指定这个文件。</p><pre><code class="BASH">rsync -av --exclude-from='exclude-file.txt' source/ destination</code></pre><h3 id="–include参数"><a href="#–include参数" class="headerlink" title="–include参数"></a>–include参数</h3><p><code>--include</code> 参数用来指定必须同步的文件模式，往往与 <code>--exclude</code> 结合使用</p><pre><code class="BASH">rsync -av --include="*.txt" --exclude='*' source/ destination</code></pre><p>上面命令指定同步时，排除所有文件，但是会包括 TXT 文件</p><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><h3 id="SSH-协议"><a href="#SSH-协议" class="headerlink" title="SSH 协议"></a>SSH 协议</h3><p>rsync 除了支持本地两个目录之间的同步，也支持远程同步。它可以将本地内容，同步到远程服务器</p><pre><code class="BASH">rsync -av source/ username@remote_host:destination</code></pre><p>也可以将远程内容同步到本地</p><pre><code class="BASH">rsync -av username@remote_host:source/ destination</code></pre><p>rsync 默认使用 SSH 进行远程登录和数据传输。</p><p>由于早期 rsync 不使用 SSH 协议，需要用 <code>-e</code> 参数指定协议，后来才改的。所以，下面 <code>-e ssh</code> 可以省略</p><pre><code class="BASH">rsync -av -e ssh source/ user@remote_host:/destination</code></pre><p>但是，如果 ssh 命令有附加的参数，则必须使用 <code>-e</code> 参数指定所要执行的 SSH 命令</p><pre><code class="BASH">rsync -av -e 'ssh -p 2234' source/ user@remote_host:/destination</code></pre><p>上面命令中， <code>-e</code> 参数指定 SSH 使用2234端口</p><h3 id="rsync-协议"><a href="#rsync-协议" class="headerlink" title="rsync 协议"></a>rsync 协议</h3><p>除了使用 SSH，如果另一台服务器安装并运行了 rsync 守护程序，则也可以用 <code>rsync://</code> 协议（默认端口873）进行传输。具体写法是服务器与目标目录之间使用双冒号分隔 <code>::</code></p><pre><code class="BASH">rsync -av source/ 192.168.122.32::module/destination</code></pre><p>注意，上面地址中的 <code>module</code> 并不是实际路径名，而是 rsync 守护程序指定的一个资源名，由管理员分配。</p><p>如果想知道 rsync 守护程序分配的所有 module 列表，可以执行下面命令。</p><pre><code class="BASH">rsync rsync://192.168.122.32</code></pre><p>rsync 协议除了使用双冒号，也可以直接用rsync://协议指定地址。</p><pre><code class="BASH">rsync -av source/ rsync://192.168.122.32/module/destination</code></pre><h2 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h2><p>rsync 的最大特点就是它可以完成增量备份，也就是默认只复制有变动的文件。</p><p>除了源目录与目标目录直接比较，rsync 还支持使用基准目录，即将源目录与基准目录之间变动的部分，同步到目标目录。</p><p>具体做法是，第一次同步是全量备份，所有文件在基准目录里面同步一份。以后每一次同步都是增量备份，只同步源目录与基准目录之间有变动的部分，将这部分保存在一个新的目标目录。这个新的目标目录之中，也是包含所有文件，但实际上，只有那些变动过的文件是存在于该目录，其他没有变动的文件都是指向基准目录文件的硬链接。</p><p><code>--link-dest</code> 参数用来指定同步时的基准目录</p><pre><code class="BASH">rsync -a --delete --link-dest /compare/path /source/path /target/path</code></pre><p>上面命令中， <code>--link-dest</code> 参数指定基准目录 <code>/compare/path</code> ，然后源目录 <code>/source/path</code> 跟基准目录进行比较，找出变动的文件，将它们拷贝到目标目录 <code>/target/path</code> 。那些没变动的文件则会生成硬链接。这个命令的第一次备份时是全量备份，后面就都是增量备份了</p><p>下面是一个脚本示例，备份用户的主目录。</p><pre><code class="BASH">#!/bin/bash# A script to perform incremental backups using rsyncset -o errexitset -o nounsetset -o pipefailreadonly SOURCE_DIR="${HOME}"readonly BACKUP_DIR="/mnt/data/backups"readonly DATETIME="$(date '+%Y-%m-%d_%H:%M:%S')"readonly BACKUP_PATH="${BACKUP_DIR}/${DATETIME}"readonly LATEST_LINK="${BACKUP_DIR}/latest"mkdir -p "${BACKUP_DIR}"rsync -av --delete \  "${SOURCE_DIR}/" \  --link-dest "${LATEST_LINK}" \  --exclude=".cache" \  "${BACKUP_PATH}"rm -rf "${LATEST_LINK}"ln -s "${BACKUP_PATH}" "${LATEST_LINK}"</code></pre><p>上面脚本中，每一次同步都会生成一个新目录 <code>${BACKUP_DIR}/${DATETIME}</code> ，并将软链接 <code>${BACKUP_DIR}/latest</code> 指向这个目录。下一次备份时，就将 <code>${BACKUP_DIR}/latest</code> 作为基准目录，生成新的备份目录。最后，再将软链接 <code>${BACKUP_DIR}/latest</code> 指向新的备份目录</p><h2 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h2><p><code>-a</code> 、 <code>--archive</code> 参数表示存档模式，保存所有的元数据，比如修改时间（modification time）、权限、所有者等，并且软链接也会同步过去。</p><p><code>--append</code> 参数指定文件接着上次中断的地方，继续传输。</p><p><code>--append-verify</code> 参数跟 <code>--append</code> 参数类似，但会对传输完成后的文件进行一次校验。如果校验失败，将重新发送整个文件。</p><p><code>-b</code> 、 <code>--backup</code> 参数指定在删除或更新目标目录已经存在的文件时，将该文件更名后进行备份，默认行为是删除。更名规则是添加由 <code>--suffix</code> 参数指定的文件后缀名，默认是~。</p><p><code>--backup-dir</code> 参数指定文件备份时存放的目录，比如 <code>--backup-dir=/path/to/backups</code> 。</p><p><code>--bwlimit</code> 参数指定带宽限制，默认单位是 KB/s，比如 <code>--bwlimit=100</code> 。</p><p><code>-c</code> 、 <code>--checksum</code> 参数改变rsync的校验方式。默认情况下，rsync 只检查文件的大小和最后修改日期是否发生变化，如果发生变化，就重新传输；使用这个参数以后，则通过判断文件内容的校验和，决定是否重新传输。</p><p><code>--delete</code> 参数删除只存在于目标目录、不存在于源目标的文件，即保证目标目录是源目标的镜像。</p><p><code>-e</code> 参数指定使用 SSH 协议传输数据。</p><p><code>--exclude</code> 参数指定排除不进行同步的文件，比如 <code>--exclude="*.iso"</code> 。</p><p><code>--exclude-from</code> 参数指定一个本地文件，里面是需要排除的文件模式，每个模式一行。</p><p><code>--existing</code> 、 <code>--ignore-non-existing</code> 参数表示不同步目标目录中不存在的文件和目录。</p><p><code>-h</code> 参数表示以人类可读的格式输出。</p><p><code>-h</code> 、 <code>--help</code> 参数返回帮助信息。</p><p><code>-i</code> 参数表示输出源目录与目标目录之间文件差异的详细情况。</p><p><code>--ignore-existing</code> 参数表示只要该文件在目标目录中已经存在，就跳过去，不再同步这些文件。</p><p><code>--include</code> 参数指定同步时要包括的文件，一般与 <code>--exclude</code> 结合使用。</p><p><code>--link-dest</code> 参数指定增量备份的基准目录。</p><p><code>-m</code> 参数指定不同步空目录。</p><p><code>--max-size</code> 参数设置传输的最大文件的大小限制，比如不超过200KB（ <code>--max-size='200k'</code> ）。</p><p><code>--min-size</code> 参数设置传输的最小文件的大小限制，比如不小于10KB（ <code>--min-size=10k</code> ）。</p><p><code>-n</code> 参数或 <code>--dry-run</code> 参数模拟将要执行的操作，而并不真的执行。配合 <code>-v</code> 参数使用，可以看到哪些内容会被同步过去。</p><p><code>-P</code> 参数是 <code>--progress</code> 和 <code>--partial</code> 这两个参数的结合。</p><p><code>--partial</code> 参数允许恢复中断的传输。不使用该参数时，rsync会删除传输到一半被打断的文件；使用该参数后，传输到一半的文件也会同步到目标目录，下次同步时再恢复中断的传输。一般需要与 <code>--append</code> 或 <code>--append-verify</code> 配合使用。</p><p><code>--partial-dir</code> 参数指定将传输到一半的文件保存到一个临时目录，比如 <code>--partial-dir=.rsync-partial</code> 。一般需要与 <code>--append</code> 或 <code>--append-verify</code> 配合使用。</p><p><code>--progress</code> 参数表示显示进展。</p><p><code>-r</code> 参数表示递归，即包含子目录。</p><p><code>--remove-source-files</code> 参数表示传输成功后，删除发送方的文件。</p><p><code>--size-only</code> 参数表示只同步大小有变化的文件，不考虑文件修改时间的差异。</p><p><code>--suffix</code> 参数指定文件名备份时，对文件名添加的后缀，默认是~。</p><p><code>-u</code> 、 <code>--update</code> 参数表示同步时跳过目标目录中修改时间更新的文件，即不同步这些有更新的时间戳的文件。</p><p><code>-v</code> 参数表示输出细节。 <code>-vv</code> 表示输出更详细的信息， <code>-vvv</code> 表示输出最详细的信息。</p><p><code>--version</code> 参数返回 <code>rsync</code> 的版本。</p><p><code>-z</code> 参数指定同步时压缩数据</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.digitalocean.com/community/tutorials/how-to-use-rsync-to-sync-local-and-remote-directories-on-a-vps">How To Use Rsync to Sync Local and Remote Directories on a VPS</a>, Justin Ellingwood</li><li><a href="https://www.howtoforge.com/mirroring_with_rsync">Mirror Your Web Site With rsync</a>, Falko Timme</li><li><a href="https://linuxconfig.org/examples-on-how-to-use-rsync-for-local-and-remote-data-backups-and-synchonization">Examples on how to use Rsync</a>, Egidio Docile</li><li><a href="https://linuxconfig.org/how-to-create-incremental-backups-using-rsync-on-linux">How to create incremental backups using rsync on Linux</a>, Egidio Docile</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>awk统计文本中同一数据出现的次数排序</title>
      <link href="/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/awk%E7%BB%9F%E8%AE%A1%E6%96%87%E6%9C%AC%E4%B8%AD%E5%90%8C%E4%B8%80%E6%95%B0%E6%8D%AE%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <url>/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/awk%E7%BB%9F%E8%AE%A1%E6%96%87%E6%9C%AC%E4%B8%AD%E5%90%8C%E4%B8%80%E6%95%B0%E6%8D%AE%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>突然发现awk原来可以统计同一数据在要处理的文件中所出现的次数. 原来的时候 为了分析数据还自己写程序, 哎, 无语, 当时还以为自己多强, 手工分析不过来的东西写程序处理. 现在想来实在是年少轻狂. 解决问题嘛, 不讲究方式, 只要快速 高效的完成任务就OK了.</p><a id="more"></a><p>好, 今天小试牛刀统计了一下passwd文件中shell部分重复的shell名和出现的次数, 看命令:</p><pre><code class="BASH">$awk -F: '{a[$7]++}END{for (i in a) print i" "a[i]}' /etc/passwd/bin/false 13/bin/sh 18/bin/bash 2/usr/sbin/nologin 1/bin/sync 1</code></pre><h3 id="解说一下"><a href="#解说一下" class="headerlink" title="解说一下"></a>解说一下</h3><ul><li>-F: 以: 分割字段</li><li>a[7]++定义了个名称为a的数组7]++定义了个名称为a的数组7在passwd文件中是shell名，在这里是数组索引.awk的数据- 索引可以是是字符类型这点真 是太帅了.</li><li>for (i in a) print i” “a[i]</li><li>用for循环取出数据来, 这时候i取的时下标, a[i]是里面存储的数据</li><li>是$7出现的次数, 狠!</li><li>郁闷了, 这办法太强了, 以后再遇到问题还是先baidu, 再google然后再自己动手吧!</li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>后来发现，如果awk玩得不咋熟悉的话，用命令组合也可以实现同样的功能</p><pre><code class="BASH"> awk -F: '{print $7}'|sort|uniq -c /etc/passwd</code></pre><p><strong>快速统计日志文件里点击量前十位的URL</strong></p><p>关于shell命令，网上流传着很多奇技淫巧，比如说快速统计日志文件里点击量前十位的URL：</p><pre><code class="BASH">awk ‘{print $7}’ /path/to/log | sort | uniq -c | sort -nr | head -n 10</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>awk命令的基本使用</title>
      <link href="/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/awk%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/awk%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Awk  pattern scanning and processing language，对文本和数据进行处理。</p><p>awk 是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输(stdin)、一个或多个文件，或其它命令的输出。它在命令行中使用，但更多是作为脚本来使用。awk有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。</p><a id="more"></a><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><pre><code class="BASH">awk&nbsp;[options]&nbsp;'scripts'&nbsp;var=value&nbsp;filename</code></pre><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><pre><code class="BASH">-F&nbsp;指定分隔符（可以是字符串或正则表达式）-f&nbsp;从脚本文件中读取awk命令-v&nbsp;var=value&nbsp;赋值变量，将外部变量传递给awk</code></pre><h2 id="脚本基本结构"><a href="#脚本基本结构" class="headerlink" title="脚本基本结构"></a>脚本基本结构</h2><pre><code class="BASH">awk&nbsp;'BEGIN{&nbsp;print&nbsp;"start"&nbsp;}&nbsp;pattern{&nbsp;commands&nbsp;}&nbsp;END{&nbsp;print&nbsp;"end"&nbsp;}'&nbsp;filename</code></pre><p>一个awk脚本通常由BEGIN语句+模式匹配+END语句三部分组成, 这三部分都是可选项.</p><p>工作原理:</p><ul><li>第一步执行BEGIN 语句</li><li>第二步从文件或标准输入读取一行，然后再执行pattern语句，逐行扫描文件到文件全部被读取</li><li>第三步执行END语句</li></ul><p>实例展示:</p><pre><code class="BASH">echo&nbsp;"hello&nbsp;"&nbsp;|&nbsp;awk&nbsp;'BEGIN{&nbsp;print&nbsp;"welcome"&nbsp;}&nbsp;END{&nbsp;print&nbsp;"2017-08-08"&nbsp;}'welcome2017-08-08echo&nbsp;-e&nbsp;"hello"&nbsp;|&nbsp;awk&nbsp;'BEGIN{&nbsp;print&nbsp;"welcome"&nbsp;}&nbsp;{print}&nbsp;END{&nbsp;print&nbsp;"2017-08-08"&nbsp;}'welcomehello2017-08-08#不加print参数时默认只打印当前的行echo|awk&nbsp;'{&nbsp;a="hello";&nbsp;b="nihao";&nbsp;c="mingongge";&nbsp;print&nbsp;a,b,c;&nbsp;}'hello&nbsp;nihao&nbsp;mingongge#使用print以逗号分隔时，打印则是以空格分界echo|awk&nbsp;'{&nbsp;a="mgg";&nbsp;b="mingg";&nbsp;c="mingongge";&nbsp;print&nbsp;a"&nbsp;is&nbsp;"b"&nbsp;or&nbsp;"c;&nbsp;}'mgg&nbsp;is&nbsp;mingg&nbsp;or&nbsp;mingongge#awk的print语句中双引号其实就是个拼接作用</code></pre><h2 id="Awk的变量"><a href="#Awk的变量" class="headerlink" title="Awk的变量"></a>Awk的变量</h2><h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h3><pre><code class="BASH">$0&nbsp;&nbsp;&nbsp;#当前记录$1~$n&nbsp;#当前记录的第N个字段FS&nbsp;&nbsp;&nbsp;#输入字段分隔符（-F相同作用）默认空格RS&nbsp;&nbsp;&nbsp;#输入记录分割符，默认换行符NF&nbsp;&nbsp;&nbsp;#字段个数就是列 NR&nbsp;&nbsp;&nbsp;#记录数，就是行号，默认从1开始OFS&nbsp;&nbsp;#输出字段分隔符，默认空格ORS&nbsp;&nbsp;#输出记录分割符，默认换行符 </code></pre><p>外部变量</p><pre><code class="BASH">[mingongge@&nbsp;~]#a=100[mingongge@&nbsp;~]#b=100[mingongge@&nbsp;~]#echo&nbsp;|awk&nbsp;'{print&nbsp;v1*v2&nbsp;}'&nbsp;v1=$a&nbsp;v2=$b10000</code></pre><h2 id="Awk运算与判断"><a href="#Awk运算与判断" class="headerlink" title="Awk运算与判断"></a>Awk运算与判断</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><pre><code class="BASH">+&nbsp;-&nbsp;加减*&nbsp;/&nbsp;&amp;&nbsp;乘&nbsp;除&nbsp;求余^&nbsp;*&nbsp;&nbsp;求幂++&nbsp;--&nbsp;增加或减少，作为前缀或后缀</code></pre><pre><code class="BASH">[mingongge@&nbsp;~]#awk&nbsp;'BEGIN{a="b";print&nbsp;a,a++,a--,++a;}'b&nbsp;0&nbsp;1&nbsp;1[mingongge@&nbsp;~]#awk&nbsp;'BEGIN{a="0";print&nbsp;a,a++,a--,++a;}'0&nbsp;0&nbsp;1&nbsp;1[mingongge@&nbsp;~]#awk&nbsp;'BEGIN{a="0";print&nbsp;a,a++,--a,++a;}'0&nbsp;0&nbsp;0&nbsp;1#和其它编程语言一样，所有用作算术运算符进行操作，操作数自动转为数值，所有非数值都变为0</code></pre><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><pre><code class="BASH">=&nbsp;+=&nbsp;-=&nbsp;*=&nbsp;/=&nbsp;%=&nbsp;^=&nbsp;**=</code></pre><h3 id="正则运算符"><a href="#正则运算符" class="headerlink" title="正则运算符"></a>正则运算符</h3><pre><code class="BASH">~&nbsp;!~&nbsp;&nbsp;匹配正则表达式/不匹配正则表达式</code></pre><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><pre><code class="BASH">||&nbsp;&nbsp;&amp;&amp;&nbsp;&nbsp;逻辑或&nbsp;&nbsp;逻辑与</code></pre><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><pre><code class="BASH">&lt;&nbsp;&lt;=&nbsp;&gt;&nbsp;&gt;=&nbsp;!=&nbsp;= </code></pre><h3 id="其它运算符"><a href="#其它运算符" class="headerlink" title="其它运算符"></a>其它运算符</h3><pre><code class="BASH">$&nbsp;&nbsp;&nbsp;字段引用&nbsp;空格&nbsp;字符串链接符?:&nbsp;&nbsp;&nbsp;三目运算符ln&nbsp;&nbsp;&nbsp;数组中是否存在某键值</code></pre><h2 id="Awk正则"><a href="#Awk正则" class="headerlink" title="Awk正则"></a>Awk正则</h2><pre><code class="BASH">^&nbsp;&nbsp;&nbsp;&nbsp;行首定位符$&nbsp;&nbsp;&nbsp;&nbsp;行尾定位符.&nbsp;&nbsp;&nbsp;&nbsp;匹配任意单个字符*&nbsp;&nbsp;&nbsp;&nbsp;匹配0个或多个前导字符（包括回车）+&nbsp;&nbsp;&nbsp;&nbsp;匹配1个或多个前导字符?&nbsp;&nbsp;&nbsp;&nbsp;匹配0个或1个前导字符&nbsp;[]&nbsp;&nbsp;&nbsp;匹配指定字符组内的任意一个字符/^[ab][^]&nbsp;&nbsp;匹配不在指定字符组内的任意一个字符()&nbsp;&nbsp;&nbsp;子表达式|&nbsp;&nbsp;&nbsp;&nbsp;或者&nbsp;&nbsp;&nbsp;&nbsp;转义符~,!~&nbsp;匹配或不匹配的条件语句x{m}&nbsp;x字符重复m次x{m,}&nbsp;x字符至少重复m次X{m,n}&nbsp;x字符至少重复m次但不起过n次（需指定参数-posix或--re-interval）</code></pre><h2 id="Awk实例介绍"><a href="#Awk实例介绍" class="headerlink" title="Awk实例介绍"></a>Awk实例介绍</h2><pre><code class="BASH">awk&nbsp;–F&nbsp;:&nbsp;‘{print&nbsp;$2}’&nbsp;datafile#以:分隔打印第二列awk&nbsp;–F&nbsp;:&nbsp;‘/^Dan/{print&nbsp;$2}’&nbsp;datafile#以:分隔打印以Dan开头行的第二列内容awk&nbsp;–F&nbsp;:&nbsp;‘/^[CE]/{print&nbsp;$1}’&nbsp;datafile&nbsp;#打印以C或E开头行的第一列awk&nbsp;–F&nbsp;:&nbsp;‘{if(length($1)&nbsp;==&nbsp;4)&nbsp;print&nbsp;$1}’&nbsp;datafile&nbsp;#打印以:分隔且长度为4字符的第一列内容awk&nbsp;–F&nbsp;:&nbsp;‘/[916]/{print&nbsp;$1}’&nbsp;datafile#匹配916的行以:分隔打印第一列awk&nbsp;-F&nbsp;:&nbsp;'/^Vinh/{print&nbsp;"a"$5}'&nbsp;2.txt#显示以Dan开头行并在第五列前加上aawk&nbsp;–F&nbsp;:&nbsp;‘{print&nbsp;$2”,”$1}’&nbsp;&nbsp;datafile#打印第二列第一列并以,分隔awk&nbsp;-F&nbsp;:&nbsp;'($5&nbsp;==&nbsp;68900)&nbsp;{print&nbsp;$1}'&nbsp;2.txt#以:分隔打印第五列是68900的行第一列 awk&nbsp;-F&nbsp;:&nbsp;'{if(length($1)&nbsp;==&nbsp;11)&nbsp;print&nbsp;$1}'&nbsp;2.txt#打印以:分隔且长度为4字符的第一列内容awk&nbsp;-F&nbsp;:&nbsp;'$1~/Tommy&nbsp;Savage/&nbsp;{print&nbsp;$5}'&nbsp;2.txtawk&nbsp;-F&nbsp;:&nbsp;'($1&nbsp;==&nbsp;"Tommy&nbsp;Savage")&nbsp;{print&nbsp;$5}'&nbsp;2.txt#打印以:分隔且第一列为Tommy&nbsp;Savage的第五列内容ll&nbsp;|awk&nbsp;'BEGIN&nbsp;{size=0;}&nbsp;{size=size+$5;}&nbsp;END{print&nbsp;"[end]size&nbsp;is&nbsp;",size}'#统计目录个的文件所有的字节数awk&nbsp;'BEGIN{size=0;}&nbsp;{size=size+$5;}&nbsp;END{print&nbsp;"[end]size&nbsp;is&nbsp;",size/1024/1024,"M"}'&nbsp;#以M为单位显示目录下的所有字节数awk&nbsp;'BEGIN{a=10;a+=10;print&nbsp;a}'20&nbsp;#a+10等价于&nbsp;a=a+10echo|awk&nbsp;'BEGIN{a="100testaaa"}a~/test/{print&nbsp;"ok"}'&nbsp;#正则匹配a&nbsp;是否有test字符，成立打印okawk&nbsp;'BEGIN{a="b";print&nbsp;a=="b"?"ok":"err"}'okawk&nbsp;'BEGIN{a="b";print&nbsp;a=="c"?"ok":"err"}'err#三目运算符?:awk&nbsp;'/root/{print&nbsp;$0}'&nbsp;passwd&nbsp;#匹配所有包含root的行awk&nbsp;-F:&nbsp;'$5~/root/{print&nbsp;$0}'&nbsp;passwd&nbsp;#&nbsp;以分号作为分隔符，匹配第5个字段是root的行ifconfig&nbsp;eth0|awk&nbsp;'BEGIN{FS="[[:space:]:]+"}&nbsp;NR==2{print&nbsp;$4}'#打印IP地址awk&nbsp;'{print&nbsp;toupper($0)}'&nbsp;test.txt#toupper是awk内置函数，将所小写字母转换成大写</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cron基本的使用</title>
      <link href="/My-Blogs/2021/01/08/Linux/shell/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/cron%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/My-Blogs/2021/01/08/Linux/shell/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/cron%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>先来看一张图</p><a id="more"></a><p><img src="/My-Blogs/images/cron%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-01.png"></p><pre><code class="BASH">#编辑crontab任务vim /etc/crontab# 启动crontabsudo /etc/init.d/cron start#停止crontabsudo /etc/init.d/cron stop#重启crontabsudo /etc/init.d/cron restart#重载/etc/crontab配置sudo /etc/init.d/cron reload# 强制重载/etc/crontab配置sudo /etc/init.d/cron force-reload# 查看crontab服务状态sudo /etc/init.d/cron status# 查看crontab运行记录tail -f /var/log/cron.log# 查看最近十行crontab运行记录tail -n /var/log/cron.log</code></pre><h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><h3 id="crontab不运行"><a href="#crontab不运行" class="headerlink" title="crontab不运行"></a>crontab不运行</h3><ol><li> 查看配置是否正确 比如有没’等特殊符号 时间设置是否有错</li><li> 查看crontab服务状态</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes 组件介绍</title>
      <link href="/My-Blogs/2021/01/08/k8s/Kubernetes%E7%BB%84%E4%BB%B6/"/>
      <url>/My-Blogs/2021/01/08/k8s/Kubernetes%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Kubernetes-组件"><a href="#Kubernetes-组件" class="headerlink" title="Kubernetes 组件"></a>Kubernetes 组件</h2><a id="more"></a><p><strong>Kubernetes 集群由代表控制平面的组件和一组称为节点的机器组成。</strong></p><p>当你部署完 Kubernetes, 即拥有了一个完整的集群。</p><p>一个 Kubernetes 集群包含 集群由一组被称作节点的机器组成。这些节点上运行 Kubernetes 所管理的容器化应用。集群具有至少一个工作节点。</p><p>工作节点托管作为应用负载的组件的 Pod 。控制平面管理集群中的工作节点和 Pod 。 为集群提供故障转移和高可用性，这些控制平面一般跨多主机运行，集群跨多个节点运行。</p><p>本文档概述了交付正常运行的 Kubernetes 集群所需的各种组件。</p><p>这张图表展示了包含所有相互关联组件的 Kubernetes 集群。</p><p>![Kubernetes 组件](/images/Kubernetes 组件-01.svg)</p><h3 id="控制平面组件（Control-Plane-Components）"><a href="#控制平面组件（Control-Plane-Components）" class="headerlink" title="控制平面组件（Control Plane Components）"></a>控制平面组件（Control Plane Components）<a href="#control-plane-components"></a></h3><p>控制平面的组件对集群做出全局决策(比如调度)，以及检测和响应集群事件（例如，当不满足部署的 <code>replicas</code> 字段时，启动新的 <a href="/docs/concepts/workloads/pods/pod-overview/">pod</a>）。</p><p>控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件，并且不会在此计算机上运行用户容器。 请参阅<a href="/zh/docs/setup/production-environment/tools/kubeadm/high-availability/">构建高可用性集群</a> 中对于多主机 VM 的设置示例。</p><h4 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver<a href="#kube-apiserver"></a></h4><p>API 服务器是 Kubernetes <a href="/zh/docs/reference/glossary/?all=true#term-control-plane">控制面</a>的组件， 该组件公开了 Kubernetes API。 API 服务器是 Kubernetes 控制面的前端。</p><p>Kubernetes API 服务器的主要实现是 <a href="/zh/docs/reference/command-line-tools-reference/kube-apiserver/">kube-apiserver</a>。 kube-apiserver 设计上考虑了水平伸缩，也就是说，它可通过部署多个实例进行伸缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。</p><h4 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd<a href="#etcd"></a></h4><p>etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。</p><p>您的 Kubernetes 集群的 etcd 数据库通常需要有个备份计划。</p><p>要了解 etcd 更深层次的信息，请参考 <a href="https://etcd.io/docs/">etcd 文档</a>。</p><h4 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler<a href="#kube-scheduler"></a></h4><p>主节点上的组件，该组件监视那些新创建的未指定运行节点的 Pod，并选择节点让 Pod 在上面运行。</p><p>调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。</p><h4 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager<a href="#kube-controller-manager"></a></h4><p>在主节点上运行 <a href="/zh/docs/concepts/architecture/controller/">控制器</a> 的组件。</p><p>从逻辑上讲，每个<a href="/zh/docs/concepts/architecture/controller/">控制器</a>都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。</p><p>这些控制器包括:</p><ul><li>  节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应。</li><li>  副本控制器（Replication Controller）: 负责为系统中的每个副本控制器对象维护正确数量的 Pod。</li><li>  端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)。</li><li>  服务帐户和令牌控制器（Service Account &amp; Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌.</li></ul><h4 id="cloud-controller-manager"><a href="#cloud-controller-manager" class="headerlink" title="cloud-controller-manager"></a>cloud-controller-manager<a href="#cloud-controller-manager"></a></h4><p>云控制器管理器是指嵌入特定云的控制逻辑的 <a href="/zh/docs/reference/glossary/?all=true#term-control-plane">控制平面</a>组件。 云控制器管理器允许您链接聚合到云提供商的应用编程接口中， 并分离出相互作用的组件与您的集群交互的组件。</p><p><code>cloud-controller-manager</code> 仅运行特定于云平台的控制回路。 如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的环境中不需要云控制器管理器。</p><p>与 <code>kube-controller-manager</code> 类似， <code>cloud-controller-manager</code> 将若干逻辑上独立的 控制回路组合到同一个可执行文件中，供你以同一进程的方式运行。 你可以对其执行水平扩容（运行不止一个副本）以提升性能或者增强容错能力。</p><p>下面的控制器都包含对云平台驱动的依赖：</p><ul><li>  节点控制器（Node Controller）: 用于在节点终止响应后检查云提供商以确定节点是否已被删除</li><li>  路由控制器（Route Controller）: 用于在底层云基础架构中设置路由</li><li>  服务控制器（Service Controller）: 用于创建、更新和删除云提供商负载均衡器</li></ul><h3 id="Node-组件"><a href="#Node-组件" class="headerlink" title="Node 组件"></a>Node 组件<a href="#node-components"></a></h3><p>节点组件在每个节点上运行，维护运行的 Pod 并提供 Kubernetes 运行环境。</p><h4 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet<a href="#kubelet"></a></h4><p>一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。</p><p>kubelet 接收一组通过各类机制提供给它的 PodSpecs，确保这些 PodSpecs 中描述的容器处于运行状态且健康。kubelet 不会管理不是由 Kubernetes 创建的容器。</p><h4 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy<a href="#kube-proxy"></a></h4><p><a href="/zh/docs/reference/command-line-tools-reference/kube-proxy/">kube-proxy</a> 是集群中每个节点上运行的网络代理， 实现 Kubernetes <a href="/zh/docs/concepts/services-networking/service/">服务（Service）</a> 概念的一部分。</p><p>kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p><p>如果操作系统提供了数据包过滤层并可用的话，kube-proxy 会通过它来实现网络规则。否则， kube-proxy 仅转发流量本身。</p><h4 id="容器运行时（Container-Runtime）"><a href="#容器运行时（Container-Runtime）" class="headerlink" title="容器运行时（Container Runtime）"></a>容器运行时（Container Runtime）<a href="#container-runtime"></a></h4><p>容器运行环境是负责运行容器的软件。</p><p>Kubernetes 支持多个容器运行环境: <a href="/zh/docs/reference/kubectl/docker-cli-to-kubectl/">Docker</a>、 <a href="https://containerd.io/docs/">containerd</a>、<a href="https://cri-o.io/#what-is-cri-o">CRI-O</a> 以及任何实现 <a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md">Kubernetes CRI (容器运行环境接口)</a>。</p><h3 id="插件（Addons）"><a href="#插件（Addons）" class="headerlink" title="插件（Addons）"></a>插件（Addons）<a href="#addons"></a></h3><p>插件使用 Kubernetes 资源（<a href="/zh/docs/concepts/workloads/controllers/daemonset/">DaemonSet</a>、 <a href="/zh/docs/concepts/workloads/controllers/deployment/">Deployment</a>等）实现集群功能。 因为这些插件提供集群级别的功能，插件中命名空间域的资源属于 <code>kube-system</code> 命名空间。</p><p>下面描述众多插件中的几种。有关可用插件的完整列表，请参见 <a href="/zh/docs/concepts/cluster-administration/addons/">插件（Addons）</a>。</p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS<a href="#dns"></a></h4><p>尽管其他插件都并非严格意义上的必需组件，但几乎所有 Kubernetes 集群都应该 有<a href="/zh/docs/concepts/services-networking/dns-pod-service/">集群 DNS</a>， 因为很多示例都需要 DNS 服务。</p><p>集群 DNS 是一个 DNS 服务器，和环境中的其他 DNS 服务器一起工作，它为 Kubernetes 服务提供 DNS 记录。</p><p>Kubernetes 启动的容器自动将此 DNS 服务器包含在其 DNS 搜索列表中。</p><h4 id="Web-界面（仪表盘）"><a href="#Web-界面（仪表盘）" class="headerlink" title="Web 界面（仪表盘）"></a>Web 界面（仪表盘）<a href="#web-%E7%95%8C%E9%9D%A2-%E4%BB%AA%E8%A1%A8%E7%9B%98"></a></h4><p><a href="/zh/docs/tasks/access-application-cluster/web-ui-dashboard/">Dashboard</a> 是Kubernetes 集群的通用的、基于 Web 的用户界面。 它使用户可以管理集群中运行的应用程序以及集群本身并进行故障排除。</p><h4 id="容器资源监控"><a href="#容器资源监控" class="headerlink" title="容器资源监控"></a>容器资源监控<a href="#%E5%AE%B9%E5%99%A8%E8%B5%84%E6%BA%90%E7%9B%91%E6%8E%A7"></a></h4><p><a href="/zh/docs/tasks/debug-application-cluster/resource-usage-monitoring/">容器资源监控</a> 将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中，并提供用于浏览这些数据的界面。</p><h4 id="集群层面日志"><a href="#集群层面日志" class="headerlink" title="集群层面日志"></a>集群层面日志<a href="#%E9%9B%86%E7%BE%A4%E5%B1%82%E9%9D%A2%E6%97%A5%E5%BF%97"></a></h4><p><a href="/zh/docs/concepts/cluster-administration/logging/">集群层面日志</a> 机制负责将容器的日志数据 保存到一个集中的日志存储中，该存储能够提供搜索和浏览接口。</p>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七张图了解k8s内部的架构</title>
      <link href="/My-Blogs/2021/01/08/k8s/%E4%B8%83%E5%BC%A0%E5%9B%BE%E4%BA%86%E8%A7%A3k8s%E5%86%85%E9%83%A8%E7%9A%84%E6%9E%B6%E6%9E%84/"/>
      <url>/My-Blogs/2021/01/08/k8s/%E4%B8%83%E5%BC%A0%E5%9B%BE%E4%BA%86%E8%A7%A3k8s%E5%86%85%E9%83%A8%E7%9A%84%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>七张图，带你走进k8s的世界</p><a id="more"></a><h3 id="Kubernetes架构和组成"><a href="#Kubernetes架构和组成" class="headerlink" title="Kubernetes架构和组成"></a>Kubernetes架构和组成</h3><p><code>Kubernetes</code> 具有去中心化的架构，不会线性处理任务。它基于声明性模型运行并实现”所需状态”的概念。下面这些步骤说明了 <code>Kubernetes</code> 的基本过程:</p><ul><li>管理员创建应用程序的所需状态并将其放入清单文件manifest.yml中。</li><li>使用CLI或提供的用户界面将清单文件提供给 <code>Kubernetes API Server</code>。 <code>Kubernetes</code>的默认命令行工具称为kubectl。</li><li><code>Kubernetes</code>将清单文件（描述了应用程序的期望状态）存储在称为键值存储（etcd）的数据库中。</li><li><code>Kubernetes</code>随后在集群内的所有相关应用程序上实现所需的状态。</li><li><code>Kubernetes</code>持续监控集群的元素，以确保应用程序的当前状态不会与所需状态有所不同。</li></ul><p><img src="/My-Blogs/images/%E4%B8%83%E5%BC%A0%E5%9B%BE%E4%BA%86%E8%A7%A3k8s%E5%86%85%E9%83%A8%E7%9A%84%E6%9E%B6%E6%9E%84-01.png" alt="image"></p><h3 id="主节点"><a href="#主节点" class="headerlink" title="主节点"></a>主节点</h3><p><code>Kubernetes</code> 的主节点通过API从CLI（命令行界面）或UI（用户界面）接收输入。这些是你提供给 <code>Kubernetes</code> 的命令。</p><p>你可以定义想要让 <code>Kubernetes</code> 维护的Pod，副本集和Service。例如，要使用的容器镜像，要公开的端口以及要运行的Pod副本数量。还可以为该集群中运行的应用程序提供”所需状态”的参数。</p><p><img src="/My-Blogs/images/%E4%B8%83%E5%BC%A0%E5%9B%BE%E4%BA%86%E8%A7%A3k8s%E5%86%85%E9%83%A8%E7%9A%84%E6%9E%B6%E6%9E%84-02.png" alt="image"></p><h4 id="API-Server"><a href="#API-Server" class="headerlink" title="API Server"></a>API Server</h4><p>API Server是Kubernetes控制程序的前端，也是用户唯一可以直接进行交互的Kubernetes组件，内部系统组件以及外部用户组件均通过相同的API进行通信。</p><h4 id="键值存储etcd"><a href="#键值存储etcd" class="headerlink" title="键值存储etcd"></a>键值存储etcd</h4><p>键值存储（也称为etcd）是Kubernetes用来备份所有集群数据的数据库。它存储集群的整个配置和状态。主节点查询etcd以检索节点，容器和容器的状态参数。</p><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><p>控制器的作用是从API Server获得所需状态。它检查要控制的节点的当前状态，确定是否与所需状态存在任何差异，并解决它们（如果有）。</p><h4 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h4><p>调度程序会监视来自API Server的新请求，并将其分配给运行状况良好的节点。它对节点的质量进行排名，并将Pod部署到最适合的节点。如果没有合适的节点，则将Pod置于挂起状态，直到出现合适的节点。</p><blockquote><p>注意：最好不要在主节点上运行用户应用程序。让Kubernetes主节点可以完全专注于管理集群。</p></blockquote><h3 id="工作节点"><a href="#工作节点" class="headerlink" title="工作节点"></a>工作节点</h3><p>工作节点监听API Server发送过来的新的工作分配；他们会执行分配给他们的工作，然后将结果报告给Kubernetes主节点。</p><p><img src="/My-Blogs/images/%E4%B8%83%E5%BC%A0%E5%9B%BE%E4%BA%86%E8%A7%A3k8s%E5%86%85%E9%83%A8%E7%9A%84%E6%9E%B6%E6%9E%84-03.png" alt="image"></p><h4 id="Kubelet"><a href="#Kubelet" class="headerlink" title="Kubelet"></a>Kubelet</h4><p>kubelet在群集中的每个节点上运行。它是Kubernetes内部的主要代理。通过安装kubelet，节点的CPU，RAM和存储成为所处集群的一部分。它监视从API Server发送来的任务，执行任务，并报告给主节点。它还会监视Pod，如果Pod不能完全正常运行，则会向控制程序报告。然后，基于该信息，主服务器可以决定如何分配任务和资源以达到所需状态。</p><h4 id="Container-Runtime"><a href="#Container-Runtime" class="headerlink" title="Container Runtime"></a>Container Runtime</h4><p>容器运行时从容器镜像库中拉取镜像，然后启动和停止容器。容器运行时由第三方软件或插件（例如Docker）担当。</p><h4 id="Kube-proxy"><a href="#Kube-proxy" class="headerlink" title="Kube-proxy"></a>Kube-proxy</h4><p>kube-proxy确保每个节点都获得其IP地址，实现本地iptables和规则以处理路由和流量负载均衡。</p><h4 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h4><p>在Kubernetes中，Pod是调度的最小元素。没有它，容器就不能成为集群的一部分。如果你需要扩展应用程序，则只能通过添加或删除Pod来实现。</p><p>Pod是Kubernetes中一个抽象化概念，由一个或多个容器组合在一起得共享资源。根据资源的可用性，主节点会把Pod调度到特定工作节点上，并与容器运行时协调以启动容器。</p><p><img src="/My-Blogs/images/%E4%B8%83%E5%BC%A0%E5%9B%BE%E4%BA%86%E8%A7%A3k8s%E5%86%85%E9%83%A8%E7%9A%84%E6%9E%B6%E6%9E%84-04.png" alt="image"></p><p>在Pod意外无法执行任务的情况下，Kubernetes不会尝试修复它们。相反，它会在其位置创建并启动一个新Pod。这个新Pod是原来的副本，除了DNS和IP地址都和以前的Pod一样。此功能对开发人员设计应用程序的方式产生了深远的影响。</p><p>由于Kubernetes架构的灵活性，不再需要将应用程序绑定到Pod的特定实例。取而代之的是，需要对应用程序进行设计，以便在集群内任何位置创建的全新Pod可以无缝取代旧Pod。Kubernetes会使用Service来协助此过程。</p><h3 id="Kubernetes-Service"><a href="#Kubernetes-Service" class="headerlink" title="Kubernetes Service"></a>Kubernetes Service</h3><p>Pod不是恒定的。 Kubernetes提供的最佳功能之一是无法正常运行的Pod会自动被新的Pod取代。</p><p>但是，这些新的Pod具有一组不同的IP。这可能导致处理问题，并且由于IP不再匹配，IP流失。如果无人看管，此属性将使吊舱高度不可靠。</p><p>为了将稳定的IP地址和DNS名称引入到不稳定的Pod世界中，Kubernetes引入了Service来提供可靠的网络连接。</p><p>通过控制进出Pod的流量，Service提供了稳定的网络终结点-固定的IP，DNS和端口。有了Service，可以添加或删除任何Pod，而不必担心基本网络信息会改变。</p><h4 id="Service是怎么工作的"><a href="#Service是怎么工作的" class="headerlink" title="Service是怎么工作的"></a>Service是怎么工作的</h4><p>Pod通过称为标签（Label）和选择器（Selector）的键值对与Service相关联。Service会自动发现带有与选择器匹配的标签的新Pod。</p><p>此过程无缝地将新的Pod添加到Service，同时，从群集中删除已终止的Pod。</p><p>例如，如果所需状态定义了需要一个Pod的三个副本，而运行一个副本的节点发生故障，则当前状态将减少为两个Pod。Kubernetes观察到所需的状态是三个Pod。然后，它会调度一个新副本来代替发生故障的Pod，并将其分配给集群中的另一个节点。</p><p>通过添加或删除容器来更新或缩放应用程序时，同样适用。一旦我们更新了所需状态的定义，Kubernetes就会注意到差异并添加或删除Pod以匹配清单文件manifest.yml里定义的所需状态。Kubernetes控制面板记录，实现和运行后台协调循环，该循环会不断检查环境是否符合用户定义的环境要求</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/My-Blogs/images/%E4%B8%83%E5%BC%A0%E5%9B%BE%E4%BA%86%E8%A7%A3k8s%E5%86%85%E9%83%A8%E7%9A%84%E6%9E%B6%E6%9E%84-05.svg" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊前端大文件上传</title>
      <link href="/My-Blogs/2021/01/08/JavaScript/%E8%81%8A%E8%81%8A%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/My-Blogs/2021/01/08/JavaScript/%E8%81%8A%E8%81%8A%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<p>前端文件上传似乎是个说不完的话题，让我们来总结下目前主要的一些上传方式吧</p><a id="more"></a><h2 id="文件上传的几种方式"><a href="#文件上传的几种方式" class="headerlink" title="文件上传的几种方式"></a>文件上传的几种方式</h2><h3 id="普通表单上传"><a href="#普通表单上传" class="headerlink" title="普通表单上传"></a>普通表单上传</h3><p>使用PHP来展示常规的表单上传是一个不错的选择。首先构建文件上传的表单，并指定表单的提交内容类型为enctype=”multipart/form-data”，表明表单需要上传二进制数据。</p><pre><code class="HTML">&lt;form action="/index.php" method="POST" enctype="multipart/form-data"&gt;  &lt;input type="file" name="myfile"&gt;  &lt;input type="submit"&gt;&lt;/form&gt;</code></pre><p>然后编写index.php上传文件接收代码，使用move_uploaded_file方法即可(php大法好…)</p><pre><code class="PHP">$imgName = 'IMG'.time().'.'.str_replace('image/','',$_FILES["myfile"]['type']);$fileName =  'upload/'.$imgName;// 移动上传文件至指定upload文件夹下，并根据返回值判断操作是否成功if (move_uploaded_file($_FILES['myfile']['tmp_name'], $fileName)){    echo $fileName;}else {    echo "nonn";}</code></pre><p>form表单上传大文件时，很容易遇见服务器超时的问题。通过xhr，前端也可以进行异步上传文件的操作，一般由两个思路。</p><h3 id="文件编码上传"><a href="#文件编码上传" class="headerlink" title="文件编码上传"></a>文件编码上传</h3><p>第一个思路是将文件进行编码，然后在服务端进行解码，之前写过一篇在前端实现图片压缩上传的博客，其主要实现原理就是将图片转换成base64进行传递</p><pre><code class="js">var imgURL = URL.createObjectURL(file);ctx.drawImage(imgURL, 0, 0);// 获取图片的编码，然后将图片当做是一个很长的字符串进行传递var data = canvas.toDataURL("image/jpeg", 0.5); </code></pre><p>在服务端需要做的事情也比较简单，首先解码base64，然后保存图片即可</p><pre><code class="PHP">$imgData = $_REQUEST['imgData'];$base64 = explode(',', $imgData)[1];$img = base64_decode($base64);$url = './test.jpg';if (file_put_contents($url, $img)) {    exit(json_encode(array(        url =&gt; $url    )));}</code></pre><p>base64编码的缺点在于其体积比原图片更大（因为Base64将三个字节转化成四个字节，因此编码后的文本，会比原文本大出三分之一左右），对于体积很大的文件来说，上传和解析的时间会明显增加。</p><p>更多关于base64的知识，可以参考Base64笔记。</p><p>除了进行base64编码，还可以在前端直接读取文件内容后以二进制格式上传</p><pre><code class="JS">// 读取二进制文件function readBinary(text){   var data = new ArrayBuffer(text.length);   var ui8a = new Uint8Array(data, 0);   for (var i = 0; i &lt; text.length; i++){      ui8a[i] = (text.charCodeAt(i) &amp; 0xff);   }   console.log(ui8a)}var reader = new FileReader();reader.onload = function(){      readBinary(this.result) // 读取result或直接上传}// 把从input里读取的文件内容，放到fileReader的result字段里reader.readAsBinaryString(file);</code></pre><h3 id="formData异步上传"><a href="#formData异步上传" class="headerlink" title="formData异步上传"></a>formData异步上传</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/Using_FormData_Objects">FormData</a><br>对象主要用来组装一组用 XMLHttpRequest发送请求的键/值对，可以更加灵活地发送Ajax请求。可以使用FormData来模拟表单提交。</p><pre><code class="JS">let files = e.target.files // 获取input的file对象let formData = new FormData();formData.append('file', file);axios.post(url, formData);</code></pre><p>服务端处理方式与直接form表单请求基本相同。</p><h3 id="iframe无刷新页面"><a href="#iframe无刷新页面" class="headerlink" title="iframe无刷新页面"></a>iframe无刷新页面</h3><p>在低版本的浏览器（如IE）上，xhr是不支持直接上传formdata的，因此只能用form来上传文件，而form提交本身会进行页面跳转，这是因为form表单的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/form">target</a>属性导致的，其取值有</p><ul><li>_self，默认值，在相同的窗口中打开响应页面</li><li>_blank，在新窗口打开</li><li>_parent，在父窗口打开</li><li>_top，在最顶层的窗口打开</li><li>framename，在指定名字的iframe中打开</li></ul><p>如果需要让用户体验异步上传文件的感觉，可以通过framename指定<code>iframe</code>来实现。把form的target属性设置为一个看不见的iframe，那么返回的数据就会被这个iframe接受，因此只有该iframe会被刷新，至于返回结果，也可以通过解析这个iframe内的文本来获取。</p><pre><code class="JS">function upload(){    var now = +new Date()    var id = 'frame' + now    $("body").append(`&lt;iframe  name="${id}" id="${id}" /&gt;`);    var $form = $("#myForm")    $form.attr({        "action": '/index.php',        "method": "post",        "enctype": "multipart/form-data",        "encoding": "multipart/form-data",        "target": id    }).submit()    $("#"+id).on("load", function(){        var content = $(this).contents().find("body").text()        try{            var data = JSON.parse(content)        }catch(e){            console.log(e)        }    })}</code></pre><h2 id="大文件上传"><a href="#大文件上传" class="headerlink" title="大文件上传"></a>大文件上传</h2><p>现在来看看在上面提到的几种上传方式中实现大文件上传会遇见的超时问题，</p><ul><li>表单上传和iframe无刷新页面上传，实际上都是通过form标签进行上传文件，这种方式将整个请求完全交给浏览器处理，当上传大文件时，可能会遇见请求超时的情形</li><li>通过fromData，其实际也是在xhr中封装一组请求参数，用来模拟表单请求，无法避免大文件上传超时的问题</li><li>编码上传，我们可以比较灵活地控制上传的内容</li></ul><p>大文件上传最主要的问题就在于：<strong>在同一个请求中，要上传大量的数据，导致整个过程会比较漫长，且失败后需要重头开始上传</strong>。试想，如果我们将这个请求拆分成多个请求，每个请求的时间就会缩短，且如果某个请求失败，只需要重新发送这一次请求即可，无需从头开始，这样是否可以解决大文件上传的问题呢？</p><p>综合上面的问题，看来大文件上传需要实现下面几个需求</p><ul><li>支持拆分上传请求(即切片)</li><li>支持断点续传</li><li>支持显示上传进度和暂停上传</li></ul><p>接下来让我们依次实现这些功能，看起来最主要的功能应该就是切片了</p><h3 id="文件切片"><a href="#文件切片" class="headerlink" title="文件切片"></a>文件切片</h3><p>参考： <a href="https://blog.csdn.net/baochao95/article/details/52812876">大文件切割上传</a></p><p>编码方式上传中，在前端我们只要先获取文件的二进制内容，然后对其内容进行拆分，最后将每个切片上传到服务端即可。</p><p>在JavaScript中，文件FIle对象是Blob对象的子类，Blob对象包含一个重要的方法<code>slice</code>，通过这个方法，我们就可以对二进制文件进行拆分。</p><p>下面是一个拆分文件的示例</p><pre><code class="JS">function slice(file, piece = 1024 * 1024 * 5) {  let totalSize = file.size; // 文件总大小  let start = 0; // 每次上传的开始字节  let end = start + piece; // 每次上传的结尾字节  let chunks = []  while (start &lt; totalSize) {    // 根据长度截取每次需要上传的数据    // File对象继承自Blob对象，因此包含slice方法    let blob = file.slice(start, end);     chunks.push(blob)    start = end;    end = start + piece;  }  return chunks}</code></pre><p>将文件拆分成<code>piece</code>大小的分块，然后每次请求只需要上传这一个部分的分块即可</p><pre><code class="JS">let file =  document.querySelector("[name=file]").files[0];const LENGTH = 1024 * 1024 * 0.1;let chunks = slice(file, LENGTH); // 首先拆分切片chunks.forEach(chunk=&gt;{  let fd = new FormData();  fd.append("file", chunk);  post('/mkblk.php', fd)})</code></pre><p>服务器接收到这些切片后，再将他们拼接起来就可以了，下面是PHP拼接切片的示例代码</p><pre><code class="JS">$filename = './upload/' . $_POST['filename'];//确定上传的文件名//第一次上传时没有文件，就创建文件，此后上传只需要把数据追加到此文件中if(!file_exists($filename)){    move_uploaded_file($_FILES['file']['tmp_name'],$filename);}else{    file_put_contents($filename,file_get_contents($_FILES['file']['tmp_name']),FILE_APPEND);    echo $filename;}</code></pre><p>测试时记得修改nginx的server配置，否则大文件可能会提示<code>413 Request Entity Too Large</code>的错误。</p><pre><code class="NGINX">server {    // ...    client_max_body_size 50m;}</code></pre><p>上面这种方式来存在一些问题</p><ul><li>无法识别一个切片是属于哪一个切片的，当同时发生多个请求时，追加的文件内容会出错</li><li>切片上传接口是异步的，无法保证服务器接收到的切片是按照请求顺序拼接的<br>因此接下来我们来看看应该如何在服务端还原切片。</li></ul><h3 id="还原切片"><a href="#还原切片" class="headerlink" title="还原切片"></a>还原切片</h3><p>在后端需要将多个相同文件的切片还原成一个文件，上面这种处理切片的做法存在下面几个问题</p><ul><li><p>如何识别多个切片是来自于同一个文件的，这个可以在每个切片请求上传递一个相同文件的<code>context</code>参数</p></li><li><p>如何将多个切片还原成一个文件</p><ul><li>确认所有切片都已上传，这个可以通过客户端在切片全部上传后调用mkfile接口来通知服务端进行拼接</li><li>找到同一个context下的所有切片，确认每个切片的顺序，这个可以在每个切片上标记一个位置索引值</li><li>按顺序拼接切片，还原成文件<br>上面有一个重要的参数，即<code>context</code>，我们需要获取为一个文件的唯一标识，可以通过下面两种方式获取</li></ul></li><li><p>根据文件名、文件长度等基本信息进行拼接，为了避免多个用户上传相同的文件，可以再额外拼接用户信息如uid等保证唯一性</p></li><li><p>根据文件的二进制内容计算文件的hash，这样只要文件内容不一样，则标识也会不一样，缺点在于计算量比较大.</p></li></ul><p>修改上传代码，增加相关参数</p><pre><code class="JS">// 获取context，同一个文件会返回相同的值function createContext(file) {     return file.name + file.length}let file = document.querySelector("[name=file]").files[0];const LENGTH = 1024 * 1024 * 0.1;let chunks = slice(file, LENGTH);// 获取对于同一个文件，获取其的contextlet context = createContext(file);let tasks = [];chunks.forEach((chunk, index) =&gt; {  let fd = new FormData();  fd.append("file", chunk);  // 传递context  fd.append("context", context);  // 传递切片索引值  fd.append("chunk", index + 1);  tasks.push(post("/mkblk.php", fd));});// 所有切片上传完毕后，调用mkfile接口Promise.all(tasks).then(res =&gt; {  let fd = new FormData();  fd.append("context", context);  fd.append("chunks", chunks.length);  post("/mkfile.php", fd).then(res =&gt; {    console.log(res);  });});</code></pre><p>在<code>mkblk.php</code>接口中，我们通过<code>context</code>来保存同一个文件相关的切片</p><pre><code class="PHP">// mkblk.php$context = $_POST['context'];$path = './upload/' . $context;if(!is_dir($path)){    mkdir($path);}// 把同一个文件的切片放在相同的目录下$filename = $path .'/'. $_POST['chunk'];$res = move_uploaded_file($_FILES['file']['tmp_name'],$filename);</code></pre><p>除了上面这种简单通过目录区分切片的方法之外，还可以将切片信息保存在数据库来进行索引。接下来是<code>mkfile.php</code>接口的实现，这个接口会在所有切片上传后调用</p><pre><code class="PHP">// mkfile.php$context = $_POST['context'];$chunks = (int)$_POST['chunks'];//合并后的文件名$filename = './upload/' . $context . '/file.jpg'; for($i = 1; $i &lt;= $chunks; ++$i){    $file = './upload/'.$context. '/' .$i; // 读取单个切块    $content = file_get_contents($file);    if(!file_exists($filename)){        $fd = fopen($filename, "w+");    }else{        $fd = fopen($filename, "a");    }    fwrite($fd, $content); // 将切块合并到一个文件上}echo $filename;</code></pre><p>这样就解决了上面的两个问题：</p><ul><li>识别切片来源</li><li>保证切片拼接顺序</li></ul><h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p>即使将大文件拆分成切片上传，我们仍需等待所有切片上传完毕，在等待过程中，可能发生一系列导致部分切片上传失败的情形，如网络故障、页面关闭等。由于切片未全部上传，因此无法通知服务端合成文件。这种情况下可以通过<strong>断点续传</strong>来进行处理。</p><p>断点续传指的是：可以从已经上传部分开始继续上传未完成的部分，而没有必要从头开始上传，节省上传时间。</p><p>由于整个上传过程是按切片维度进行的，且<code>mkfile</code>接口是在所有切片上传完成后由客户端主动调用的，因此断点续传的实现也十分简单：</p><ul><li>在切片上传成功后，保存已上传的切片信息</li><li>当下次传输相同文件时，遍历切片列表，只选择未上传的切片进行上传</li><li>所有切片上传完毕后，再调用<code>mkfile</code>接口通知服务端进行文件合并</li></ul><p>因此问题就落在了如何保存已上传切片的信息了，保存一般有两种策略</p><ul><li>可以通过locaStorage等方式保存在前端浏览器中，这种方式不依赖于服务端，实现起来也比较方便，缺点在于如果用户清除了本地文件，会导致上传记录丢失</li><li>服务端本身知道哪些切片已经上传，因此可以由服务端额外提供一个根据文件context查询已上传切片的接口，在上传文件前调用该文件的历史上传记录</li></ul><p>下面让我们通过在本地保存已上传切片记录，来实现断点上传的功能</p><pre><code class="JS"> // 获取已上传切片记录function getUploadSliceRecord(context){  let record = localStorage.getItem(context)  if(!record){    return []  }else {    try{      return JSON.parse(record)    }catch(e){}  }}// 保存已上传切片function saveUploadSliceRecord(context, sliceIndex){  let list = getUploadSliceRecord(context)  list.push(sliceIndex)  localStorage.setItem(context, JSON.stringify(list))}</code></pre><p>然后对上传逻辑稍作修改，主要是增加上传前检测是已经上传、上传后保存记录的逻辑</p><pre><code class="JS">let context = createContext(file);// 获取上传记录let record = getUploadSliceRecord(context);let tasks = [];chunks.forEach((chunk, index) =&gt; {  // 已上传的切片则不再重新上传  if(record.includes(index)){    return  }  let fd = new FormData();  fd.append("file", chunk);  fd.append("context", context);  fd.append("chunk", index + 1);  let task = post("/mkblk.php", fd).then(res=&gt;{    // 上传成功后保存已上传切片记录    saveUploadSliceRecord(context, index)    record.push(index)  })  tasks.push(task);});</code></pre><p>此时上传时刷新页面或者关闭浏览器，再次上传相同文件时，之前已经上传成功的切片就不会再重新上传了。</p><p>服务端实现断点续传的逻辑基本相似，只要在<code>getUploadSliceRecord</code>内部调用服务端的查询接口获取已上传切片的记录即可，因此这里不再展开。</p><p>此外断点续传还需要考虑切片过期的情况：如果调用了<code>mkfile</code>接口，则磁盘上的切片内容就可以清除掉了，如果客户端一直不调用<code>mkfile</code>的接口，放任这些切片一直保存在磁盘显然是不可靠的，一般情况下，切片上传都有一段时间的有效期，超过该有效期，就会被清除掉。基于上述原因，断点续传也必须同步切片过期的实现逻辑。</p><h3 id="上传进度和暂停"><a href="#上传进度和暂停" class="headerlink" title="上传进度和暂停"></a>上传进度和暂停</h3><p>通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/upload">xhr.upload</a>中的progress方法可以实现监控每一个切片上传进度。</p><p>上传暂停的实现也比较简单，通过xhr.abort可以取消当前未完成上传切片的上传，实现上传暂停的效果，恢复上传就跟断点续传类似，先获取已上传的切片列表，然后重新发送未上传的切片。</p><p>由于篇幅关系，上传进度和暂停的功能这里就先不实现了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>目前社区已经存在一些成熟的大文件上传解决方案，如<a href="https://github.com/qiniu">七牛SDK</a>，<a href="https://cloud.tencent.com/document/product/266/9239">腾讯云SDK</a>等，也许并不需要我们手动去实现一个简陋的大文件上传库，但是了解其原理还是十分有必要的。</p><p>本文首先整理了前端文件上传的几种方式，然后讨论了大文件上传的几种场景，以及大文件上传需要实现的几个功能</p><p>通过Blob对象的<code>slice</code>方法将文件拆分成切片<br>整理了服务端还原文件所需条件和参数，演示了PHP将切片还原成文件<br>通过保存已上传切片的记录来实现断点续传<br>还留下了一些问题，如：合并文件时避免内存溢出、切片失效策略、上传进度暂停等功能，并没有去深入或一一实现，继续学习吧~</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冷知识之JS篇</title>
      <link href="/My-Blogs/2021/01/08/JavaScript/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BJS%E7%AF%87/"/>
      <url>/My-Blogs/2021/01/08/JavaScript/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BJS%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>关于JavaScript的冷知识又有哪些呢？让我们一起看看吧</p><a id="more"></a><h3 id="浮点数快速向下取整"><a href="#浮点数快速向下取整" class="headerlink" title="浮点数快速向下取整"></a>浮点数快速向下取整</h3><p>JavaScript中是没有整型概念的，但利用好位操作符可以轻松处理，同时获得效率上的提升。</p><br><p>|0和~~是很好的一个例子，使用这两者可以将浮点转成整型且效率方面要比同类的parseInt, Math.round 要快。在处理像素及动画位移等效果的时候会很有用。</p><pre><code class="JavaScript">(12.4 / 4.13) | 0    // =&gt; 3    ~~(12.4 / 4.13)// =&gt; 3</code></pre><h3 id="生成随机字符串"><a href="#生成随机字符串" class="headerlink" title="生成随机字符串"></a>生成随机字符串</h3><p>生成随机字符串，我们第一想到的，可能是先定义一个字符串数组，然后通过随机取数组中的字符进而拼接成一个随机长度的字符串。<br>但是下面还有一个更简单的方法，代码如下：</p><pre><code class="js">function generateRandomAlphaNum(len) {    var rdmString = "";    for (; rdmString.length &lt; len; rdmString += Math.random().toString(36).substr(2));    return rdmString.substr(0, len);}</code></pre><blockquote><p>主要是利用了toString() 方法的特性</p></blockquote><p><img src="/My-Blogs/images/toString.png" alt="image"></p><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>利用copy方法复制Console控制台的变量</p><pre><code class="js">var temp1 = 1111;copy(temp1);</code></pre><h3 id="console-table"><a href="#console-table" class="headerlink" title="console.table"></a>console.table</h3><p>Chrome专属，IE绕道的console方法。可以将JavaScript关联数组以表格形式输出到浏览器console，效果很惊赞，界面很美观。</p><pre><code class="js">//采购情况var data = [{    '品名': '杜雷斯',    '数量': 4}, {    '品名': '冈本',    '数量': 3}];console.table(data);</code></pre><p><img src="/My-Blogs/images/console.table.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Intersection Observer接口实现可视区域渲染</title>
      <link href="/My-Blogs/2021/01/08/JavaScript/%E4%BD%BF%E7%94%A8Intersection%20Observer%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%BA%E5%9F%9F%E6%B8%B2%E6%9F%93/"/>
      <url>/My-Blogs/2021/01/08/JavaScript/%E4%BD%BF%E7%94%A8Intersection%20Observer%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%BA%E5%9F%9F%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API">Intersection Observer</a>大家有了解过么？</p><a id="more"></a><h2 id="使用Intersection-Observer接口实现可视区域渲染"><a href="#使用Intersection-Observer接口实现可视区域渲染" class="headerlink" title="使用Intersection Observer接口实现可视区域渲染"></a>使用Intersection Observer接口实现可视区域渲染</h2><p>由于客户端使用的webview内核在较低配置的Android手机上打开多图页面时出现内存暴涨，无法回收导致客户端崩溃的情况，我们使用Android studio进行分析发现，问题出在了webview的图层渲染引擎。<br>我们发现，随着我们下拉加载越多，图片量增多时，图层渲染<br>Graphics部分内存持续上涨，且不存在回收的情况。因此，这种情况下，使用图片懒加载已经<br>不能解决问题了。<br>经过调研，我们采用了<code>Intersection Observer</code> 实现虚拟渲染的方案，即<br>只在可视区域才进行图片的渲染。</p><h2 id="为什么使用Intersection-Observer-接口"><a href="#为什么使用Intersection-Observer-接口" class="headerlink" title="为什么使用Intersection Observer 接口"></a>为什么使用Intersection Observer 接口</h2><p><code>Intersection Observer</code> API提供了一种异步检测目标元素与祖先元素或viewport相交变化情况的方法（MDN）。<br>换句话说，之前检测元素是否可见，元素与元素是否相交是不容易的，可能的几个方法是基于监听滚动事件，再结合使用元素的宽高属性，以计算元素当前所处位置这种耗性能的方式。前述类型的方法，在监听滚动事件的过程中, 频繁调用Element.getBoundingClientRect方法，会使得浏览器重复多次计算元素的宽高属性。<br>事件监听和调用Element.getBoundingClientRect都是在主线程上运行，这样 可能会阻塞后续js代码的执行，造成性能问题。<br>如果使用<code>Intersection Observer</code>接口，我们不但省去了自己编写代码计算位<br>置的功夫，而且因该接口是异步的，还使得我们在执行该接口进行监测的时候不会阻塞js线程的执行，可以说是一举两得。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><code>Intersection Observer</code> 接口通过观测根元素和目标元素的相对位置，在开发者设定的目标元素与根元素相交触发点<br>触发回调函数，以实现开发者的业务目的。开发者可以设置一些数值来指定目标元素进入到根元素的百分之几时触发回调函数。</p><p><img src="/My-Blogs/images/%E4%BD%BF%E7%94%A8IntersectionObserver%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%BA%E5%9F%9F%E6%B8%B2%E6%9F%93-01.gif" alt="img"></p><p>在上面的gif中，根元素是白色的视窗，目标元素为绿色的小方块。可以看到，当滚动屏幕时，绿色方块逐渐出现在视口中，分别在绿色方块与视口相交比例达到25%, 50%, 75%, 100%时触发了回调函数。<br>当然，我们可以把任意一个目标元素的祖先元素当作根元素，这对于懒加载，视频播放等都有重要的意义。</p><h2 id="怎么使用-Intersection-Observer-API"><a href="#怎么使用-Intersection-Observer-API" class="headerlink" title="怎么使用 Intersection Observer API"></a>怎么使用 Intersection Observer API</h2><p>1、新建一个观察器</p><pre><code class="JS">const callback = (entries) =&gt; {};const options = () =&gt; {};const observer = new IntersectionObserver(callback, options);</code></pre><p>callback 为相交时的处理函数, 每当被观测的元素与指定的根元素或视窗相交时便会被执行。其参数为IntersectionObserverEntry对象，该对象记录了相交时的一些状态信息，如元素的宽高，相交比率<br>等信息。<br>options, 用于指定回调函数执行时被观测元素的的环境。如指定根元素root, 指定被观测元素位于哪个位置时触发相交处理函数rootMargin, 具体可见<a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API">MDN</a></p><p>2、指定相交时的处理函数</p><pre><code class="JS">const callback = (entries) =&gt; {  entries.forEach(entry =&gt; {    if (entry.isIntersecting) { // 当true时，表示被观测元素与指定元素相交了      // 执行你要的操作    }  })}</code></pre><p>3、对目标元素进行观察</p><pre><code class="JS">const ele = document.getElementById('target');observer.observe(ele);</code></pre><p>4、<code>Intersection Observer</code>可用的方法</p><pre><code class="JS">1. observe(ele): 用于开始观察某个指定的目标元素， 观察者可以多次调用此方法对不同的元素进行观测。2. unobserve(ele): 可用来取消对某个元素的观察。3. disconnect(): 使用该方法， 可以取消对所有元素的观测， 即之前通过observer方法观测的元素不再受到观测，相应的处理函数也不会得到执行。</code></pre><h2 id="实现可视区域渲染"><a href="#实现可视区域渲染" class="headerlink" title="实现可视区域渲染"></a>实现可视区域渲染</h2><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>我们把视口当作根元素，将头像容器元素作为目标元素，设定当头像容器的面积出现在视口（即与视口相交）的比例超过50%时， 就触发一次我们的回调函数，离开时也触发我们的回调函数。<br>回调函数的功能为，当相交且目标元素可见时，将头像url地址赋值给头像元素的背景（你也可以用img来实现）url，当离开时则将目标元素的背景url置空，以保证图像渲染层保存的图片仅是目前可视区域的图片，以达到控制图像渲染引擎内存占用的目的。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ol><li> 首先，新建一个观察者</li></ol><pre><code class="JS">let hasInterSection;try {  require('intersection-observer');  hasInterSection = true;} catch (e) {  hasInterSection = false;  console.log(e);}const observer = hasInterSection &amp;&amp; (new IntersectionObserver((entries, options) =&gt; {  entries.forEach(isIntersectHandler);}, {  rootMargin: '0px 0px 0px 0px',  threshold: [0.5],  trackVisibility: true,  delay: 300}));</code></pre><blockquote><p>在新建一个observer之前，先尝试引入intersection-observer插件，这是<code>Intersection Observer</code><br>的polyfill，是为了兼容一些暂时不支持该接口的浏览器。<br>引入后，在新建的观察器中，我们传入了一些配置，在这里，我们根元素就是视口元素，且没有对视口的范围进行扩充（rootMargin: ‘0px 0px 0px 0px’, ）, 如果要对视口的范围进行扩充或缩小，则可以改变rootMargin的值。<br>这里，相交比例达到0.5时，我们才让它显示头像，离开时也是达到0.5才会隐藏头像，关于threshold的理解，mdn有一<br>个很好的例子: <code>threshold</code>.<br>至于我们例子中为什么设置了0.5的比例，主要还是出于业务需要，因为在滚动屏幕过程中，当一个目标元素进入到视口时，如果没有达到50%的比例，则认为还没出现，则不对其头像进行赋值。trackVisibility设置为true，是因为我们有对元素是否可见进行一个判断的需要。回调函数中，我们对entries逐一进行处理，因为observer可以监测多个元素，所以entries是一个数组，需要逐一处理。</p></blockquote><ol start="2"><li> 回调函数的处理函数</li></ol><pre><code class="JS">function isIntersectHandler(entry) {  const target = entry.target;  const isIntersecting = entry.isIntersecting;  if (isIntersecting) {    const src = target.dataset.src;    const ele = target.getElementsByClassName('user-item-thump-icon')[0];    if (src &amp;&amp; entry.isVisible) {      const styleStr = `url(${src}), url("${defaultAvatar}")`;      ele.style.backgroundImage = styleStr;    } else {      ele.style.backgroundImage = '';    }  } else {    const ele = target.getElementsByClassName('user-item-thump-icon')[0];    ele &amp;&amp; (ele.style.backgroundImage = '');  }}</code></pre><blockquote><p>回调函数的处理函数中，我们对单个entry进行处理。首先我们判断元素是否相交（正常来说能触发这个函数的<br>都是已经相交了的），相交的时候则从目标元素的dataset中拿到头像url并判断是否可见，从而赋值到背景url, 以使得头像被渲染。当离开时，则对背景url进行置空操作，使得其不被渲染。</p></blockquote><ol start="3"><li> 开始观察元素</li></ol><pre><code class="JS">mounted() {  observer.observe(this.$refs.thump);}</code></pre><blockquote><p>开始监测后即可对元素的背景url进行自定义的操作了。</p></blockquote><ol start="4"><li> 停止观察元素</li></ol><pre><code class="JS">beforeDestroy() {  observer.unobserve(this.$refs.thump);}</code></pre><h3 id="几个注意点"><a href="#几个注意点" class="headerlink" title="几个注意点"></a>几个注意点</h3><p>虽然监测函数的执行是异步的，但是回调函数的执行是在主线程上。如果回调函数里面处理的逻辑比较复杂，则可能影响js线程的执行，此时建议采用 <code>window.requestIdleCallback</code> 。<br>对于目标元素的visible，受多个因素影响，如opacity, translation等属性都可能影响，具体可参考<a href="https://developers.google.com/web/updates/2019/02/intersectionobserver-v2">google</a>.</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的Blob</title>
      <link href="/My-Blogs/2021/01/08/JavaScript/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Blob/"/>
      <url>/My-Blogs/2021/01/08/JavaScript/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Blob/</url>
      
        <content type="html"><![CDATA[<p>如果你允许用户从你的网站上下载某些文件，那你可能会遇到 Blob 类型。为了实现上述的功能，你可以很容易从网上找到相关的示例，并根据实际需求进行适当的调整。对于部分开发者来说，在完成上述功能之后，他们并不会继续思考 Blob 是什么？</p><a id="more"></a><p>这就导致了一些开发者，还是停留在熟练使用 API 的层面，当遇到比较棘手的问题时，就束手无策。<strong>换句话说，如果当你在熟悉 API 的使用之后，还能继续多问几个为什么，继续探究下去，不仅能加深对知识的理解，还能触类旁通，拓展自己的知识面提高自己。</strong></p><p>好了，如果你想继续了解什么是 Blob，那么就跟上我的脚步，来一个 Blob Web API 探索之旅。还在犹豫什么，Let’s go！</p><p>读完本文你将了解到以下内容：</p><ul><li><p>Blob 是什么</p></li><li><p>Blob API 简介</p></li><li><p>构造函数</p></li><li><p>属性和方法</p></li><li><p>Blob 使用场景</p></li><li><p>分片上传</p></li><li><p>从互联网下载数据</p></li><li><p>Blob 用作 URL</p></li><li><p>Blob 转换为 Base64</p></li><li><p>图片压缩</p></li><li><p>生成 PDF</p></li><li><p>Blob 与 ArrayBuffer 的区别</p></li></ul><h3 id="一、Blob-是什么"><a href="#一、Blob-是什么" class="headerlink" title="一、Blob 是什么"></a><span style="display: none; "></span>一、Blob 是什么<span style="display: none; "></span></h3><p>Blob（Binary Large Object）表示二进制类型的大对象。在数据库管理系统中，将二进制数据存储为一个单一个体的集合。Blob 通常是影像、声音或多媒体文件。<strong>在 JavaScript 中 Blob 类型的对象表示不可变的类似文件对象的原始数据。</strong> 为了更直观的感受 Blob 对象，我们先来使用 Blob 构造函数，创建一个 myBlob 对象，具体如下图所示：</p><p><img src="/My-Blogs/images/blobInfo.webp"></p><p>如你所见，myBlob 对象含有两个属性：size 和 type。其中 <code>size</code> 属性用于表示数据的大小（以字节为单位）， <code>type</code> 是 MIME 类型的字符串。Blob 表示的不一定是 JavaScript 原生格式的数据。比如 <code>File</code> 接口基于 <code>Blob</code> ，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p><h3 id="二、Blob-API-简介"><a href="#二、Blob-API-简介" class="headerlink" title="二、Blob API 简介"></a><span style="display: none; "></span>二、Blob API 简介<span style="display: none; "></span></h3><p><code>Blob</code> 由一个可选的字符串 <code>type</code> （通常是 MIME 类型）和 <code>blobParts</code> 组成：</p><p><img src="/My-Blogs/images/blobInfo2.webp"></p><blockquote><p>MIME（Multipurpose Internet Mail Extensions）多用途互联网邮件扩展类型，是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。</p><p>常见的 MIME 类型有：超文本标记语言文本 .html text/html、PNG图像 .png image/png、普通文本 .txt text/plain 等。</p></blockquote><h4 id="2-1-构造函数"><a href="#2-1-构造函数" class="headerlink" title="2.1 构造函数"></a><span style="display: none; "></span>2.1 构造函数<span style="display: none; "></span></h4><p>Blob 构造函数的语法为：</p><pre><code class="js">var aBlob = new Blob(blobParts, options);</code></pre><p>相关的参数说明如下：</p><ul><li><p>blobParts：它是一个由 ArrayBuffer，ArrayBufferView，Blob，DOMString 等对象构成的数组。DOMStrings 会被编码为 UTF-8。</p></li><li><p>options：一个可选的对象，包含以下两个属性：</p></li><li><p>type —— 默认值为 <code>""</code>，它代表了将会被放入到 blob 中的数组内容的 MIME 类型。</p></li><li><p>endings —— 默认值为 <code>"transparent"</code>，用于指定包含行结束符 <code>\n</code> 的字符串如何被写入。它是以下两个值中的一个：<code>"native"</code>，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 <code>"transparent"</code>，代表会保持 blob 中保存的结束符不变。</p></li></ul><p><strong>示例一：从字符串创建 Blob</strong></p><pre><code class="js">let myBlobParts = ['&lt;html&gt;&lt;h2&gt;Hello&nbsp;Semlinker&lt;/h2&gt;&lt;/html&gt;']; //&nbsp;an&nbsp;array&nbsp;consisting&nbsp;of&nbsp;a&nbsp;single&nbsp;DOMStringlet myBlob = new Blob(myBlobParts, {    type: 'text/html',    endings: "transparent"}); //the&nbsp;blobconsole.log(myBlob.size + "&nbsp;bytes&nbsp;size"); //&nbsp;Output:&nbsp;37&nbsp;bytes&nbsp;sizeconsole.log(myBlob.type + "&nbsp;is&nbsp;the&nbsp;type"); //&nbsp;Output:&nbsp;text/html&nbsp;is&nbsp;the&nbsp;type</code></pre><p><strong>示例二：从类型化数组和字符串创建 Blob</strong></p><pre><code class="js">let hello = new Uint8Array([72, 101, 108, 108, 111]); //&nbsp;二进制格式的&nbsp;"hello"let blob = new Blob([hello, '&nbsp;', 'semlinker'], {    type: 'text/plain'});</code></pre><p>介绍完 Blob 构造函数，接下来我们来分别介绍 Blob 类的属性和方法：</p><p><img src="/My-Blogs/images/blobInfo3.webp"></p><h4 id="2-2-属性"><a href="#2-2-属性" class="headerlink" title="2.2 属性"></a><span style="display: none; "></span>2.2 属性<span style="display: none; "></span></h4><p>前面我们已经知道 Blob 对象包含两个属性：</p><ul><li><p>size（只读）：表示 <code>Blob</code> 对象中所包含数据的大小（以字节为单位）。</p></li><li><p>type（只读）：一个字符串，表明该 <code>Blob</code> 对象所包含数据的 MIME 类型。如果类型未知，则该值为空字符串。</p></li></ul><h4 id="2-3-方法"><a href="#2-3-方法" class="headerlink" title="2.3 方法"></a><span style="display: none; "></span>2.3 方法<span style="display: none; "></span></h4><ul><li><p>slice([start[, end[, contentType]]])：返回一个新的 Blob 对象，包含了源 Blob 对象中指定范围内的数据。</p></li><li><p>stream()：返回一个能读取 blob 内容的 <code>ReadableStream</code>。</p></li><li><p>text()：返回一个 Promise 对象且包含 blob 所有内容的 UTF-8 格式的 <code>USVString</code>。</p></li><li><p>arrayBuffer()：返回一个 Promise 对象且包含 blob 所有内容的二进制格式的 <code>ArrayBuffer</code>。</p></li></ul><p>这里我们需要注意的是，** <code>Blob</code> 对象是不可改变的**。我们不能直接在一个 Blob 中更改数据，但是我们可以对一个 Blob 进行分割，从其中创建新的 Blob 对象，将它们混合到一个新的 Blob 中。这种行为类似于 JavaScript 字符串：我们无法更改字符串中的字符，但可以创建新的更正后的字符串。</p><h3 id="三、Blob-使用场景"><a href="#三、Blob-使用场景" class="headerlink" title="三、Blob 使用场景"></a><span style="display: none; "></span>三、Blob 使用场景<span style="display: none; "></span></h3><h4 id="3-1-分片上传"><a href="#3-1-分片上传" class="headerlink" title="3.1 分片上传"></a><span style="display: none; "></span>3.1 分片上传<span style="display: none; "></span></h4><p>File 对象是特殊类型的 Blob，且可以用在任意的 Blob 类型的上下文中。所以针对大文件传输的场景，我们可以使用 slice 方法对大文件进行切割，然后分片进行上传，具体示例如下：</p><pre><code class="js">const file = new File(["a".repeat(1000000)], "test.txt");const chunkSize = 40000;const url = "https://httpbin.org/post";async function chunkedUpload() {    for (let start = 0; start &lt; file.size; start += chunkSize) {        const chunk = file.slice(start, start + chunkSize + 1);        const fd = new FormData();        fd.append("data", chunk);        await fetch(url, {            method: "post",            body: fd        }).then((res) =&gt; res.text());    }}</code></pre><h4 id="3-2-从互联网下载数据"><a href="#3-2-从互联网下载数据" class="headerlink" title="3.2 从互联网下载数据"></a><span style="display: none; "></span>3.2 从互联网下载数据<span style="display: none; "></span></h4><p>我们可以使用以下方法从互联网上下载数据并将数据存储到 Blob 对象中，比如：</p><pre><code class="js">const downloadBlob = (url, callback) =&gt; {    const xhr = new XMLHttpRequest()    xhr.open('GET', url)    xhr.responseType = 'blob'    xhr.onload = () =&gt; {        callback(xhr.response)    }    xhr.send(null)}</code></pre><p>当然除了使用 <code>XMLHttpRequest</code> API 之外，我们也可以使用 <code>fetch</code> API 来实现以流的方式获取二进制数据。这里我们来看一下如何使用 fetch API 获取线上图片并本地显示，具体实现如下：</p><pre><code class="js">const myImage = document.querySelector('img');const myRequest = new Request('flowers.jpg');fetch(myRequest)    .then(function(response) {        return response.blob();    })    .then(function(myBlob) {        let objectURL = URL.createObjectURL(myBlob);        myImage.src = objectURL;    });</code></pre><p>当 fetch 请求成功的时候，我们调用 response 对象的 <code>blob()</code> 方法，从 response 对象中读取一个 Blob 对象，然后使用 <code>createObjectURL()</code> 方法创建一个 objectURL，然后把它赋值给 <code>img</code> 元素的 <code>src</code> 属性从而显示这张图片。</p><h4 id="3-3-Blob-用作-URL"><a href="#3-3-Blob-用作-URL" class="headerlink" title="3.3 Blob 用作 URL"></a><span style="display: none; "></span>3.3 Blob 用作 URL<span style="display: none; "></span></h4><p>Blob 可以很容易的作为 <code>&lt;a&gt;</code> 、 <code>&lt;img&gt;</code> 或其他标签的 URL，多亏了 <code>type</code> 属性，我们也可以上传/下载 <code>Blob</code> 对象。下面我们将举一个 Blob 文件下载的示例，不过在看具体示例前我们得简单介绍一下 Blob URL。</p><p><strong>1. Blob URL/Object URL</strong></p><p>Blob URL/Object URL 是一种伪协议，允许 Blob 和 File 对象用作图像，下载二进制数据链接等的 URL 源。在浏览器中，我们使用 <code>URL.createObjectURL</code> 方法来创建 Blob URL，该方法接收一个 <code>Blob</code> 对象，并为其创建一个唯一的 URL，其形式为 <code>blob:&lt;origin&gt;/&lt;uuid&gt;</code> ，对应的示例如下：</p><pre><code class="html">blob:https://example.org/40a5fb5a-d56d-4a33-b4e2-0acf6a8e5f641</code></pre><p>浏览器内部为每个通过 <code>URL.createObjectURL</code> 生成的 URL 存储了一个 URL → Blob 映射。因此，此类 URL 较短，但可以访问 <code>Blob</code> 。生成的 URL 仅在当前文档打开的状态下才有效。它允许引用 <code>&lt;img&gt;</code> 、 <code>&lt;a&gt;</code> 中的 <code>Blob</code> ，但如果你访问的 Blob URL 不再存在，则会从浏览器中收到 404 错误。</p><p>上述的 Blob URL 看似很不错，但实际上它也有副作用。虽然存储了 URL → Blob 的映射，但 Blob 本身仍驻留在内存中，浏览器无法释放它。映射在文档卸载时自动清除，因此 Blob 对象随后被释放。</p><p>但是，如果应用程序寿命很长，那不会很快发生。因此，如果我们创建一个 Blob URL，即使不再需要该 Blob，它也会存在内存中。</p><p>针对这个问题，我们可以调用 <code>URL.revokeObjectURL(url)</code> 方法，从内部映射中删除引用，从而允许删除 Blob（如果没有其他引用），并释放内存。接下来，我们来看一下 Blob 文件下载的具体示例。</p><p><strong>2. Blob 文件下载示例</strong></p><p><strong>index.html</strong></p><pre><code class="html">&lt;!DOCTYPE&nbsp;html&gt;&lt;html&gt;&nbsp;&nbsp;&lt;head&gt;&nbsp;&nbsp;&nbsp;    &lt;meta&nbsp;charset="UTF-8"&nbsp; /&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;title&gt;Blob&nbsp;文件下载示例&lt;/title&gt;&nbsp;&nbsp;&lt;/head&gt;&nbsp;&nbsp;&lt;body&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;button&nbsp;id="downloadBtn"&gt;文件下载&lt;/button&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;script&nbsp;src="index.js"&gt;&lt;/script&gt;&nbsp;&nbsp;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>index.js</strong></p><pre><code class="js">const download = (fileName, blob) =&gt; {    const link = document.createElement("a");    link.href = URL.createObjectURL(blob);    link.download = fileName;    link.click();    link.remove();    URL.revokeObjectURL(link.href);};const downloadBtn = document.querySelector("#downloadBtn");downloadBtn.addEventListener("click", (event) =&gt; {    const fileName = "blob.txt";    const myBlob = new Blob(["一文彻底掌握&nbsp;Blob&nbsp;Web&nbsp;API"], {        type: "text/plain"    });    download(fileName, myBlob);});</code></pre><p>在示例中，我们通过调用 Blob 的构造函数来创建类型为 <strong>“text/plain”</strong> 的 Blob 对象，然后通过动态创建 <code>a</code> 标签来实现文件的下载。</p><h4 id="3-4-Blob-转换为-Base64"><a href="#3-4-Blob-转换为-Base64" class="headerlink" title="3.4 Blob 转换为 Base64"></a><span style="display: none; "></span>3.4 Blob 转换为 Base64<span style="display: none; "></span></h4><p><code>URL.createObjectURL</code> 的一个替代方法是，将 <code>Blob</code> 转换为 base64 编码的字符串。<strong>Base64</strong> 是一种基于 64 个可打印字符来表示二进制数据的表示方法，<strong>它常用于在处理文本数据的场合，表示、传输、存储一些二进制数据，包括 MIME 的电子邮件及 XML 的一些复杂数据。</strong></p><p>在 MIME 格式的电子邮件中，base64 可以用来将二进制的字节序列数据编码成 ASCII 字符序列构成的文本。使用时，在传输编码方式中指定 base64。使用的字符包括大小写拉丁字母各 26 个、数字 10 个、加号 + 和斜杠 /，共 64 个字符，等号 = 用来作为后缀用途。</p><p>下面我们来介绍如何在 HTML 中嵌入 base64 编码的图片。在编写 HTML 网页时，对于一些简单图片，通常会选择将图片内容直接内嵌在网页中，从而减少不必要的网络请求，但是图片数据是二进制数据，该怎么嵌入呢？绝大多数现代浏览器都支持一种名为 <code>Data URLs</code> 的特性，允许使用 base64 对图片或其他文件的二进制数据进行编码，将其作为文本字符串嵌入网页中。</p><p>Data URLs 由四个部分组成：前缀（ <code>data:</code> ）、指示数据类型的 MIME 类型、如果非文本则为可选的 <code>base64</code> 标记、数据本身：</p><pre><code class="html">data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</code></pre><p><code>mediatype</code> 是个 MIME 类型的字符串，例如 “ <code>image/jpeg</code> “ 表示 JPEG 图像文件。如果被省略，则默认值为 <code>text/plain;charset=US-ASCII</code> 。如果数据是文本类型，你可以直接将文本嵌入（根据文档类型，使用合适的实体字符或转义字符）。如果是二进制数据，你可以将数据进行 base64 编码之后再进行嵌入。比如嵌入一张图片：</p><pre><code class="html">&lt;img&nbsp;alt="logo"&nbsp;src="data:image /png;base64,iVBORw0KGgoAAAANSUhEUg..."&gt;</code></pre><p><strong>但需要注意的是：如果图片较大，图片的色彩层次比较丰富，则不适合使用这种方式，因为该图片经过 base64 编码后的字符串非常大，会明显增大 HTML 页面的大小，从而影响加载速度。</strong> 除此之外，利用 FileReader API，我们也可以方便的实现图片本地预览功能，具体代码如下：</p><pre><code class="html">&lt;input&nbsp;type="file"&nbsp;accept="image /*"&nbsp;onchange="loadFile(event)"&gt;&lt;img&nbsp;id="output" /&gt;&lt;script&gt;    const loadFile = function(event) {        const reader = new FileReader();        reader.onload = function() {            const output = document.querySelector('output');            output.src = reader.result;        };        reader.readAsDataURL(event.target.files[0]);    };&lt;/script&gt;</code></pre><p>在以上示例中，我们为 file 类型输入框绑定 <code>onchange</code> 事件处理函数 <code>loadFile</code> ，在该函数中，我们创建了一个 FileReader 对象并为该对象绑定 <code>onload</code> 相应的事件处理函数，然后调用 FileReader 对象的 <code>readAsDataURL()</code> 方法，把本地图片对应的 File 对象转换为 Data URL。</p><p>在完成本地图片预览之后，我们可以直接把图片对应的 Data URLs 数据提交到服务器。针对这种情形，服务端需要做一些相关处理，才能正常保存上传的图片，这里以 Express 为例，具体处理代码如下：</p><pre><code class="js">const app = require('express')();app.post('/upload', function(req, res) {    let imgData = req.body.imgData; //&nbsp;获取POST请求中的base64图片数据&nbsp;&nbsp;&nbsp;&nbsp;    let base64Data = imgData.replace(/^data:image\/\w+;base64,/, "");    let dataBuffer = Buffer.from(base64Data, 'base64');    fs.writeFile("image.png", dataBuffer, function(err) {        if (err) {            res.send(err);        } else {            res.send("图片上传成功！");        }    });});</code></pre><p>对于 FileReader 对象来说，除了支持把 Blob/File 对象转换为 Data URL 之外，它还提供了 <code>readAsArrayBuffer()</code> 和 <code>readAsText()</code> 方法，用于把 Blob/File 对象转换为其它的数据格式。这里我们来看个 <code>readAsArrayBuffer()</code> 的使用示例：</p><pre><code class="js">//&nbsp;从&nbsp;blob&nbsp;获取&nbsp;arrayBufferlet fileReader = new FileReader();fileReader.onload = function(event) {    let arrayBuffer = fileReader.result;};fileReader.readAsArrayBuffer(blob);</code></pre><h4 id="3-5-图片压缩"><a href="#3-5-图片压缩" class="headerlink" title="3.5 图片压缩"></a><span style="display: none; "></span>3.5 图片压缩<span style="display: none; "></span></h4><p>在一些场合中，我们希望在上传本地图片时，先对图片进行一定的压缩，然后再提交到服务器，从而减少传输的数据量。在前端要实现图片压缩，我们可以利用 Canvas 对象提供的 <code>toDataURL()</code> 方法，该方法接收 <code>type</code> 和 <code>encoderOptions</code> 两个可选参数。</p><p>其中 <code>type</code> 表示图片格式，默认为 <code>image/png</code> 。而 <code>encoderOptions</code> 用于表示图片的质量，在指定图片格式为 <code>image/jpeg</code> 或 <code>image/webp</code> 的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 <code>0.92</code> ，其他参数会被忽略。</p><p>下面我们来看一下具体如何实现图片压缩：</p><pre><code class="js">//&nbsp;compress.jsconst MAX_WIDTH = 800; //&nbsp;图片最大宽度function compress(base64, quality, mimeType) {    let canvas = document.createElement("canvas");    let img = document.createElement("img");    img.crossOrigin = "anonymous";    return new Promise((resolve, reject) =&gt; {        img.src = base64;        img.onload = () =&gt; {            let targetWidth, targetHeight;            if (img.width &gt; MAX_WIDTH) {                targetWidth = MAX_WIDTH;                targetHeight = (img.height * MAX_WIDTH) / img.width;            } else {                targetWidth = img.width;                targetHeight = img.height;            }            canvas.width = targetWidth;            canvas.height = targetHeight;            let ctx = canvas.getContext("2d");            ctx.clearRect(0, 0, targetWidth, targetHeight); //&nbsp;清除画布&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);            let imageData = canvas.toDataURL(mimeType, quality / 100);            resolve(imageData);        };    });}</code></pre><p>对于返回的 Data URL 格式的图片数据，为了进一步减少传输的数据量，我们可以把它转换为 Blob 对象：</p><pre><code class="js">function dataUrlToBlob(base64, mimeType) {    let bytes = window.atob(base64.split(",")[1]);    let ab = new ArrayBuffer(bytes.length);    let ia = new Uint8Array(ab);    for (let i = 0; i &lt; bytes.length; i++) {        ia[i] = bytes.charCodeAt(i);    }    return new Blob([ia], {        type: mimeType    });}</code></pre><p>在转换完成后，我们就可以压缩后的图片对应的 Blob 对象封装在 FormData 对象中，然后再通过 AJAX 提交到服务器上：</p><pre><code class="js">function uploadFile(url, blob) {    let formData = new FormData();    let request = new XMLHttpRequest();    formData.append("image", blob);    request.open("POST", url, true);    request.send(formData);}</code></pre><p>其实 Canvas 对象除了提供 <code>toDataURL()</code> 方法之外，它还提供了一个 <code>toBlob()</code> 方法，该方法的语法如下：</p><blockquote><p>canvas.toBlob(callback, mimeType, qualityArgument)</p></blockquote><p>和 <code>toDataURL()</code> 方法相比， <code>toBlob()</code> 方法是异步的，因此多了个 <code>callback</code> 参数，这个 <code>callback</code> 回调方法默认的第一个参数就是转换好的 <code>blob</code> 文件信息。</p><p>介绍完上述的内容，我们来看一下本地图片压缩完整的示例：</p><pre><code class="html">&lt;!DOCTYPE&nbsp;html&gt;&lt;html&gt;&nbsp;&nbsp;&lt;head&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;meta&nbsp;charset="UTF-8"&nbsp; /&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;meta&nbsp;name="viewport"&nbsp;content="width=device-width,&nbsp;initial-scale=1.0"&nbsp; /&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;title&gt;本地图片压缩&lt;/title&gt;&nbsp;&nbsp;&lt;/head&gt;&nbsp;&nbsp;&lt;body&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;input&nbsp;type="file"&nbsp;accept="image /*"&nbsp;onchange="loadFile(event)" &nbsp; /&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;script&nbsp;src=". /compress.js"&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;script&gt;        const loadFile = function(event) {            const reader = new FileReader();            reader.onload = async function() {                let compressedDataURL = await compress(                    reader.result,                    90,                    "image/jpeg"                );                let compressedImageBlob = dataUrlToBlob(compressedDataURL);                uploadFile("https://httpbin.org/post", compressedImageBlob);            };            reader.readAsDataURL(event.target.files[0]);        };    &lt;/script&gt;&nbsp;&nbsp;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="3-6-生成-PDF-文档"><a href="#3-6-生成-PDF-文档" class="headerlink" title="3.6 生成 PDF 文档"></a><span style="display: none; "></span>3.6 生成 PDF 文档<span style="display: none; "></span></h4><p>PDF（便携式文件格式，Portable Document Format）是由 Adobe Systems 在 1993 年用于文件交换所发展出的文件格式。在浏览器端，利用一些现成的开源库，比如 jsPDF，我们也可以方便地生成 PDF 文档。</p><pre><code class="html">&lt;!DOCTYPE&nbsp;html&gt;&lt;html&gt;&nbsp;&nbsp;&lt;head&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;meta&nbsp;charset="UTF-8"&nbsp; /&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;meta&nbsp;name="viewport"&nbsp;content="width=device-width,&nbsp;initial-scale=1.0"&nbsp; /&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;title&gt;客户端生成&nbsp;PDF&nbsp;示例&lt;/title&gt;&nbsp;&nbsp;&lt;/head&gt;&nbsp;&nbsp;&lt;body&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;h3&gt;客户端生成&nbsp;PDF&nbsp;示例&lt;/h3&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;script&nbsp;src="https: //unpkg.com/jspdf@latest/dist/jspdf.min.js"&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;script&gt;        (function generatePdf() {            const doc = new jsPDF();            doc.text("Hello&nbsp;semlinker!", 66, 88);            const blob = new Blob([doc.output()], {                type: "application/pdf"            });            blob.text().then((blobAsText) =&gt; {                console.log(blobAsText);            });        })();    &lt;/script&gt;&nbsp;&nbsp;&lt;/body&gt;&lt;/html&gt;</code></pre><p>在以上示例中，我们首先创建 PDF 文档对象，然后调用该对象上的 <code>text()</code> 方法在指定的坐标点上添加 <code>Hello semlinker!</code> 文本，然后我们利用生成的 PDF 内容来创建对应的 Blob 对象，需要注意的是我们设置 Blob 的类型为 <code>application/pdf</code> ，最后我们把 Blob 对象中保存的内容转换为文本并输出到控制台。由于内容较多，这里我们只列出少部分输出结果：</p><pre><code class="js">% PDF - 1.3 % ºß¬ à3 0 obj &lt;&lt; /Type&nbsp;/Page / Parent 1 0 R / Resources 2 0 R / MediaBox[0 0 595.28 841.89] / Contents 4 0 R &gt;&gt; endobj....</code></pre><p>其实 jsPDF 除了支持纯文本之外，它也可以生成带图片的 PDF 文档，比如：</p><pre><code class="js">let imgData = 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/...';let doc = new jsPDF();doc.setFontSize(40);doc.text(35, 25, 'Paranyan&nbsp;loves&nbsp;jsPDF');doc.addImage(imgData, 'JPEG', 15, 40, 180, 160);</code></pre><p>Blob 的应用场景还很多，这里我们就不一一列举了，感兴趣的小伙伴可以自行查阅相关资料。</p><h3 id="四、Blob-与-ArrayBuffer-的区别"><a href="#四、Blob-与-ArrayBuffer-的区别" class="headerlink" title="四、Blob 与 ArrayBuffer 的区别"></a><span style="display: none; "></span>四、Blob 与 ArrayBuffer 的区别<span style="display: none; "></span></h3><p><strong>ArrayBuffer</strong> 对象用于表示通用的，固定长度的原始二进制数据缓冲区。你不能直接操纵 ArrayBuffer 的内容，而是需要创建一个类型化数组对象或 DataView 对象，该对象以特定格式表示缓冲区，并使用该对象读取和写入缓冲区的内容。</p><p><strong>Blob</strong> 类型的对象表示不可变的类似文件对象的原始数据。Blob 表示的不一定是 JavaScript 原生格式的数据。File 接口基于 Blob，继承了Blob 功能并将其扩展为支持用户系统上的文件。</p><h4 id="4-1-Blob-vs-ArrayBuffer"><a href="#4-1-Blob-vs-ArrayBuffer" class="headerlink" title="4.1 Blob vs ArrayBuffer"></a><span style="display: none; "></span>4.1 Blob vs ArrayBuffer<span style="display: none; "></span></h4><ul><li><p>除非你需要使用 ArrayBuffer 提供的写入/编辑的能力，否则 Blob 格式可能是最好的。</p></li><li><p>Blob 对象是不可变的，而 ArrayBuffer 是可以通过 TypedArrays 或 DataView 来操作。</p></li><li><p>ArrayBuffer 是存在内存中的，可以直接操作。而 Blob 可以位于磁盘、高速缓存内存和其他不可用的位置。</p></li><li><p>虽然 Blob 可以直接作为参数传递给其他函数，比如 <code>window.URL.createObjectURL()</code>。但是，你可能仍需要 FileReader 之类的 File API 才能与 Blob 一起使用。</p></li><li><p>Blob 与 ArrayBuffer 对象之间是可以相互转化的：</p></li><li><p>使用 FileReader 的 <code>readAsArrayBuffer()</code> 方法，可以把 Blob 对象转换为 ArrayBuffer 对象；</p></li><li><p>使用 Blob 构造函数，如 <code>new Blob([new Uint8Array(data]);</code>，可以把 ArrayBuffer 对象转换为 Blob 对象。</p></li></ul><p>对于 HTTP 的场景，比如在 AJAX 场景下，<strong>Blob</strong> 和 <strong>ArrayBuffer</strong> 可以通过以下方式来使用：</p><pre><code class="js">function GET(url, callback) {    let xhr = new XMLHttpRequest();    xhr.open('GET', url, true);    xhr.responseType = 'arraybuffer'; //&nbsp;or&nbsp;xhr.responseType&nbsp;=&nbsp;"blob";&nbsp;&nbsp;    xhr.send();    xhr.onload = function(e) {            if (xhr.status != 200) {                alert("Unexpected&nbsp;status&nbsp;code&nbsp;" + xhr.status + "&nbsp;for&nbsp;" + url);                return false;            }            callback(new Uint8Array(xhr.response)); //&nbsp;or&nbsp;new&nbsp;Blob([xhr.response]);&nbsp;&nbsp;};}</code></pre><p>对于 <strong>ArrayBuffer</strong> 和 <strong>Uint8Array</strong> 感兴趣的读者，可以阅读<a href="http://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;mid=2247484317&amp;idx=1&amp;sn=c0b397b6bd5fdfced0c1bebc187a7c0d&amp;chksm=ea47a2c5dd302bd37b285f65dd7a92df8ca1bc213465091e82a28be08ec5808b905e9fb69bec&amp;scene=21#wechat_redirect"><strong>Deno bytes 模块全解析</strong></a>这篇文章。</p><p>了解完上述的内容，相信有的读者可能会觉得意犹未尽。那么，对于 Blob 来说还有哪些内容可以继续深入学习的呢？本人下一步的计划是基于 Deno 的源码，来逐步分析 DenoBlob 的具体实现。当然也会顺便分析一下 <code>URL.createObjectURL()</code> 方法和 <code>revokeObjectURL()</code> 方法的实现。  </p><h3 id="五、参考资源"><a href="#五、参考资源" class="headerlink" title="五、参考资源"></a><span style="display: none; "></span>五、参考资源<span style="display: none; "></span></h3><ul><li><p>MDN - Blob</p></li><li><p>MDN - Data URLs</p></li><li><p>javascript.info - blob</p></li><li><p>flaviocopes - blob</p></li><li><p>arraybuffer-vs-blob</p></li><li><p>javascript-interview-question-what-is-a-blob</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Blob </tag>
            
            <tag> 二进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript模块化演进及原理浅析</title>
      <link href="/My-Blogs/2021/01/08/JavaScript/javascript%E6%A8%A1%E5%9D%97%E5%8C%96%E6%BC%94%E8%BF%9B%E5%8F%8A%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
      <url>/My-Blogs/2021/01/08/JavaScript/javascript%E6%A8%A1%E5%9D%97%E5%8C%96%E6%BC%94%E8%BF%9B%E5%8F%8A%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="模块化解决了什么问题"><a href="#模块化解决了什么问题" class="headerlink" title="模块化解决了什么问题"></a>模块化解决了什么问题</h3><a id="more"></a><p>我们仔细想一下，Javascript编程其实很多时候就是管理变量以及变量赋值这件事，比如把一个value赋值给一个变量，给一个变量加上一个value，或者把两个变量相加的结果赋值给另外一个变量，怎样去管理这些变量对日后如何维护这些代码就显得至关重要。</p><p>在开发中如果我们一次仅需要考虑几个变量，那么工作就会变得很简单。幸运的是，JavsScript有个作用域链来帮助我们解决变量过多的问题，因为作用域链的存在，在一个函数的内部无法访问另外一个函数内部的变量，这样就使得我们在编程的时候只需要关注自己函数内部的那几个变量就可以了，不需要过分去担心其他函数的影响，头发也可以少掉几根。</p><p>但是，很多时候我们不得不跟其他函数共享状态，这时候我们会将这些变量存储在全局（window/global）上，项目小的时候当然问题不大，但是当项目一大，变量一多，通过script引入代码的加载顺序等等问题就开始让后期维护变得很蛋疼，因此人们开始思考如何在没有模块的语言上去实现模块这一件事情。。。</p><h3 id="原始时期"><a href="#原始时期" class="headerlink" title="原始时期"></a>原始时期</h3><h4 id="直接定义依赖"><a href="#直接定义依赖" class="headerlink" title="直接定义依赖"></a>直接定义依赖</h4><pre><code class="js">function a() {}function b() {}</code></pre><p>在原始时期，“模块化”也就是直接定义函数，共享变量，这种做法最明显的缺点就是<strong>污染</strong>了全局变量，变量的重名会导致后面覆盖前面，并且各个模块成员之间看不出有什么直接的关系。</p><h4 id="闭包模块化"><a href="#闭包模块化" class="headerlink" title="闭包模块化"></a>闭包模块化</h4><pre><code class="js">var modules = (fuction(my, $) {    function privateMethod() {        // ...    }    my.moduleProperty = 1;    my.moduleMethod = function() {        //$()....        //privateMethod()...        // ...    };    return my;}(widnow.modules || {}, jQuery))</code></pre><p>通过立即执行函数（IIFE），外部函数无法调用到里面的<strong>privateMethod</strong>，解决了全局变量污染的问题。同时这种模式还可以将一个模块拆分，在闭包内可以调用或继承其他子模块、添加新的方法，新的变量，返回新的模块。但是同时缺点也很明显：</p><ul><li>  为了在模块内部调用其他全局变量，必须<strong>显示注入全局变量</strong>，比如上面注入了jQuery</li><li>  跨文件使用模块时，需要将模块挂载到全局变量上（window）上</li><li>  没有解决如何管理这些模块的问题，各个模块之间的依赖关系需要通过script的引入顺序来保证</li></ul><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>从1999年开始，js模块化的探索都是基于语言层面上的优化，真正的改变要从2009年CommonJS的引入开始，Node采用CommonJS模块规范，每个文件就是一个模块，有自己的作用域，在一个文件里面定义的变量、函数、类都是私有了。</p><pre><code class="js">// package/lib is a dependency we requireconst lib = require('package/lib');// some behaviour for our modulefunction foo() {    lib.log('hello world!');}// export (expose) foo to other modulesexports.foo = foo;</code></pre><h4 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h4><ul><li>  module模块本身，是Module的一个实例</li><li>  exports指向module.exports，可以通过exports向module.exports对象中添加变量</li><li>  require用于加载模块（核心）</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>  所有模块都运行在模块作用域，不会污染全局作用域</li><li>  模块加载的顺序，按照代码中出现的顺序执行（也就是同步）</li><li>  模块输入的值是复制（基础类型为复制，引用类型为值引用），第一次加载结果就被缓存了，之后再加载就直接读取缓存中的结果，如果要让模块再次运行，需要清除缓存。或者直接导出函数，每次调用函数重新计算。</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>由于篇幅有限，这里不讨论require的加载选择路径优先级的判断，也不讨论模块缓存的过程，并假定加载的文件都是js文件，主要实现代码如下<a href="https://github.com/joyent/node/blob/master/lib/module.js">源代码</a></p><pre><code class="js">function Module(id, parent) {    this.id = id;    this.expotrs = {};    this.parent = parent;    if (parent &amp;&amp; parent.children) {        parent.children.push(this);    }    this.fileanme = null;    this.loaded = false;    this.children = [];}// 这里的module是全局变量module.exports = Module;// 通过一个path加载模块，并返回exports属性Module.prototype.require = function(path) {    return Module._load(path, this);}Module._load = function(path, parent) {    const filename = path;    var module = new Module(filename, parent);    // 加载模块    module.load(filename);    // 输出模块的exports属性    return module.exports;}Module.prototype.load = function(filename) {    // 通过磁盘中读取文件    var content = fs.readFileSync(filename, 'utf8');    module._compile(content, filename);    this.loaded = true;}// 模块编译Module.prototype._compile = function(content, filename) {    const self = this;    const args = [self.exports, require, self, filename, dirname];    // 在沙箱中执行代码    return compiledWrapper.apply(self.exports, args);}</code></pre><p>从代码中可以看出，模块加载实质上就是注入了exports，require，module三个全局变量，然后执行模块的源码，最后将模块的exports的变量输入</p><pre><code class="js">(function(exports, require, module, __filename, __dirname) {    // 模块源码});</code></pre><h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><ul><li>  缺少模块封装的能力，CommonJS规范中每个模块都是一个文件，这意味着每个文件只有一个模块。这在服务器上是可行的，但是在浏览器中就不是很友好，浏览器中需要做到尽可能少的发起请求。</li><li>  使用同步的方式加载依赖，在浏览器中由于JS的加载会阻塞渲染，同步加载会导致长时间的白屏，对于用户体验是致命的。</li><li>  CommonJS规范中使用了<strong>export</strong>的对象来暴露模块，可以讲需要导出的变量附加到<strong>export</strong>上，但是要导出一个函数确是能使用<strong>module.export</strong>，这种语法容易让人感到困惑。</li></ul><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>AMD，全称是Asynchronous Module Definition，即异步模块加载机制，它采用异步方式加载模块，模块的加载不影响后面语句的运行，AMD规范定义了一个<strong>define</strong>全局方法用来定义和加载模块</p><pre><code class="js">define(id ? , dependencies ? , factory);</code></pre><ul><li>  id: 模块标识，可以省略</li><li>  dependences：所依赖的模块数组，可以省略</li><li>  factory：模块的实现，或者一个对象</li></ul><p>AMD也使用了使用<strong>require</strong>全局方法来加载模块，但不同于CommonJS，它要求两个参数，dependences是需要前置的依赖，只有所有前置依赖都加载完了才会触发回调函数，dependences的加载是<strong>通过动态创建sciprt和事件监听的方式来异步加载模块</strong>，解决了CommonJS同步加载的问题。</p><pre><code class="js">require([dependence], callback);</code></pre><h4 id="RequireJS使用"><a href="#RequireJS使用" class="headerlink" title="RequireJS使用"></a>RequireJS使用</h4><p>RequireJS 是 AMD 规范的代表之作，基本使用方式如下</p><pre><code class="js">define(['./a', './b'], function(moduleA, moduleB) {    // 依赖前置    moduleA.mehodA();    console.log(moduleB.dataB);    // 导出数据    return {};});</code></pre><h4 id="RequireJS的实现"><a href="#RequireJS的实现" class="headerlink" title="RequireJS的实现"></a>RequireJS的实现</h4><p>这里同样不讨论RequireJS的模块信息配置，缓存的过程，也不考虑各种链接补全的情况，只是简单实现模块的加载调用，以及所有依赖加载完毕触发callback回调的过程</p><blockquote><p>依赖的定义</p></blockquote><pre><code class="js">// 缓存定义的模块const defMap = {}define = (name, deps, callback) =&gt; {    defMap[name] = {        name,        deps,        callback    }}</code></pre><blockquote><p>依赖模块加载与调用</p></blockquote><p>模块加载的时候会首先通过<strong>Modules</strong>构造函数创建一个模块实例，然后调用初始化<strong>init</strong>的方法传入需要加载的依赖跟回调函数</p><pre><code class="js">// 全局require方法req = require = (name, deps, callback) =&gt; {    const mod = new Module(name)    mod.init(deps, callback)}// 模块加载构造函数class Modules {    constructor(name) {        this.name = name        this.depCount = 0        this.deps = []        this.depExports = []        this.callback = null        this.defineFn = () =&gt; {}    }    init(deps, callback) {        this.deps = deps        this.callback = callback        // 判断是否有依赖，有依赖先加载依赖        if (deps.length === 0) {            this.check()        } else {            this.enable()        }    }}</code></pre><p>其中<strong>enable</strong>函数用来遍历依赖，并绑定回调函数<strong>definedFn</strong></p><pre><code class="js">class Module {    ...    // 加载依赖    enabne() {        this.deps.forEach((name, i) =&gt; {            // 记录加载的模块数            this.depCount++            // 实例化依赖模块，绑定回调            const mod = new Module(name)            mod.definedFn = exports =&gt; {                this.depCount--                // 返回的代码，将模块代码存储起来，全部加载完毕后当作变量传递给父模块调用                this.depExports[i] = exports                // 每次返回一个回调都check一下是否所有依赖都加载完了                this.check()            }            // 通过script加载模块            loadModule(name)        })    }}</code></pre><p><strong>loadModule</strong>是源码的核心，通过动态创建scirpt异步加载依赖，加载完之后再循环加载子模块的依赖，直到全部依赖都加载完毕。</p><pre><code class="js">const loadModule = (name, url) =&gt; {    const head = document.getElementsByTagName('head')[0]    const node = document.createElement('script')    node.type = 'text/javascript'    node.async = true    // 设置一个 data 属性，便于依赖加载完毕后拿到模块名     node.setAttribute('data-module', name)    node.addEventListener('load', onScriptLoad, false)    node.src = url    head.appendChild(node)    return node}// 节点绑定的onload事件函数const onScriptLoad = evt =&gt; {    const node = evt.currentTarget    node.removeEventListener('load', onScriptLoad, false)    // 获取模块名    const name = node.getAttribute('data-module')    // 实例化子模块    const mod = new Module(name)    // 从全局变量defMap中获取模块的依赖和回调    const def = defMap[name]    // 循环加载子模块的依赖    mod.init(def.deps, def.callback)}</code></pre><p><strong>check</strong>函数检查依赖是否全部加载完毕了，加载完毕之后执行回调函数。</p><pre><code class="js">class Module {    ...    // 检查依赖是否加载完毕    check() {        // 依赖数小于1，表示依赖全部加载完        if (this.depCount &lt; 1) {            // 触发回调函数，并获取该模块的内容            this.exports = this.callback.apply(null, this.depExports)            // 激活defined回调，表示当前模块加载完成            this.definedFn(exports)        }    }}</code></pre><p>可以看出，RequireJS最核心的原理就是<strong>通过动态加载script并且监听load事件的方式来实现异步加载模块</strong></p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><blockquote><p>概述</p></blockquote><p>相对于AMD的异步加载，CMD更倾向于懒加载，而且CMD的写法跟CommonJS极为相近，只需要在CommonJS外增加一个函数调用即可，如下</p><pre><code class="js">// CMDdefine(function(require, exports, module) {    const $ = require('Jquery')    $('id')})</code></pre><p>AMD规范的代表作品sea.js在模块加载方式上与RequireJS的原理一致，都是<strong>通过动态加载script并且监听load事件的方式来实现异步加载模块</strong>，跟RequireJS的主要区别在与依赖声明跟加载的时机，其中RequireJS在声明的时候先优先加载了。sea.js则使用懒加载，按需加载的方式，只有在require的地方，才会真正加载运行该模块。</p><blockquote><p>sea.js实现原理</p></blockquote><p>sea.js看起来像是很神奇，JS不是异步的吗？但怎么sea.js调用模块看起来像是同步的？原理这里采用了知乎的一段回答<a href="https://www.zhihu.com/question/20342350/answer/14828786">卢勃</a></p><ol><li> 通过回调函数的Function.toString函数，使用正则表达式（后面改成了状态机进行词法分析的方式）来捕捉内部的require字段，找到require(‘jquery’)内部依赖的模块jquery</li><li> 根据配置文件，找到jquery的js文件的实际路径</li><li> 在dom中插入script标签，载入模块指定的js，绑定加载完成的事件，使得加载完成后将js文件绑定到require模块指定的id（这里就是jquery这个字符串）上</li><li> 回调函数内部依赖的js全部加载（暂不调用）完后，调用回调函数</li><li> 当回调函数调用require(‘jquery’)，即执行绑定在’jquery’这个id上的js文件，即刻执行，并将返回值传给$</li></ol><h3 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h3><p>UMD（Universal Module Definnition）通用模块定义模式，主要用来解决CommonJS模式和AMD模式代码不能在服务端跟Web端通用的问题，并同时还支持老式的全局变量规范。</p><pre><code class="js">(function(global, factory) {    typeof exports === 'object' &amp;&amp; typeof module !== 'undefined' ? module.exports = factory() :        typeof define === 'function' &amp;&amp; define.amd ? define(factory) :        (global = global || self, global.myBundle = factory());}(this, (function() {    const main = () =&gt; {        return 'hello world';    };    return main;})))</code></pre><p>上面代码做了3个判断</p><ol><li> 判断<strong>module</strong>是否为一个对象，并且是否存在<strong>module.exports</strong>来判断是否为<strong>CommonJS</strong>规范</li><li> 判断<strong>define</strong>是否为函数，并且是否存在<strong>define.amd</strong>，来判断是否为AMD规范</li><li> 如果以上两种都没有，则为原始的代码规范</li></ol><h3 id="ES-Modules"><a href="#ES-Modules" class="headerlink" title="ES Modules"></a>ES Modules</h3><h4 id="概述跟语法"><a href="#概述跟语法" class="headerlink" title="概述跟语法"></a>概述跟语法</h4><p>相对于CommonJS和AMD两种比较流行的社区模块加载方案，前者主要用于服务器层面，后者主要用于浏览器层面，ES 2015终于在语言标准层面上，实现了模块功能，而且语法更加简洁，更加人性化。</p><p>模块导出只有一个关键字<strong>export</strong>，可以直接导出变量，函数，或者通过大括号直接输出一组变量，更有独特的<strong>default</strong>可以用来直接导出默认值。</p><pre><code class="js">// moduleA// 直接导出某个变量跟函数export const name = 'chen'export function getName() {    return 'chen'}// 可以通过大括号输出一组变量const anotherName = 'nomad'constfunction getAnotherName() {    return 'nomad'}export {    anotherName,    getAnotherName}// 也可以直接导出默认值export default anotherName</code></pre><p>模块导入可以通过<strong>import</strong>命令加载其他JS文件中<strong>export</strong>的变量，同样可以同时导入其他文件中的默认值<strong>default</strong>（如果存在）跟其他变量</p><pre><code class="js">import defaultName, {    name,    getName,    anotherName,    getAnotherName} from './moduleA'</code></pre><p>具体语法包括导入变量的改名，导入并同时导出的复合写法等就不再赘述，具体可以查看网上的教程。</p><h4 id="CommonJS跟ES-Modules的差异"><a href="#CommonJS跟ES-Modules的差异" class="headerlink" title="CommonJS跟ES Modules的差异"></a>CommonJS跟ES Modules的差异</h4><p>CommonJS模块的<strong>require</strong>是同步加载模块，而ESM 会对静态代码分析，即在代码编译时进行模块的加载，在运行时之前就已经确定了依赖关系（可解决循环引用的问题，后面原理部分有解释）</p><p>CommonJS模块输入的是值拷贝（基础类型为复制，引用类型为值引用）</p><pre><code class="js">// CommonJS// ModuleAconst obj = {    a: 1}let b = 1setTimeout(() =&gt; {    obj.a++    b++});exports.obj = obj;exports.b = b;// ModuleBconst {    obj,    b} = require('./moduleA');console.log(`a: ${obj.a}`);console.log(`b: ${b}`);setTimeout(() =&gt; {    console.log(`a: ${obj.a}`);    console.log(`b: ${b}`);}, 100);// result// a: 1// b: 1// a: 2// b: 1</code></pre><p>ESM模块是动态引用，变量不会被缓存，而是成为一个指向加载模块的引用，只有真正取值的时候才会进行计算取值</p><pre><code class="js">// ESM// moduleAconst obj = {    a: 1}let b = 1setTimeout(() =&gt; {    obj.a++    b++});export {    obj,    b}// moduleBimport {    obj,    b} from './moduleA.mjs';console.log(`a: ${obj.a}`);console.log(`b: ${b}`);setTimeout(() =&gt; {    console.log(`a: ${obj.a}`);    console.log(`b: ${b}`);}, 100);// result// a: 1// b: 1// a: 2// b: 2</code></pre><h4 id="ESM加载的过程"><a href="#ESM加载的过程" class="headerlink" title="ESM加载的过程"></a>ESM加载的过程</h4><ol><li> 构造（Construction）：找到文件下载，并解析成模块记录（module record）</li><li> 实例化（Instantiation）：把所有<strong>export</strong>的变量放入到内存中（暂时不求值），然后把相关<strong>export</strong>跟<strong>import</strong>都指向同一个内存区域</li><li> 求值（Evaluation）：运行代码，把得到值放到指向的内存区域</li></ol><blockquote><p>构造（Construction）</p></blockquote><p>从入口文件开始，并通过代码解析（module specifiers）找到入口文件所依赖的模块，一步一步找到其他模块，并将所有模块解析成模块记录（module record），并缓存到<strong>module map</strong>中，遇到不同文件获取相同依赖，都会直接在<strong>module map</strong>缓存中获取，注意这里并不是要把所有模块的依赖关系全部解析完再开始下一步，因为浏览器一次性下载这么多文件会跟CommonJS一样阻塞主线程。所以这也就是为什么<strong>ESM spec</strong>要把3个加载过程区分开执行的原因。</p><p><img src="/My-Blogs/images/module_record.png" alt="image"></p><blockquote><p>实例化（Instantiation）</p></blockquote><p>实例化的过程就是将代码导出的变量一一指向内存。JS引擎通过<strong>优先深度后序遍历</strong>遍历整个模块关系图，即从依赖关系的最后一个模块（没有引入其他模块）开始实例化，并将所有模块导出的变量绑定在内存上，然后再将<strong>所有模块导入变量绑定到与导出变量同一个内存区域</strong>。所以一旦导出值发生变化，导入值也会变化。这也是ESM导出的是<strong>值引用</strong>的原理。同样也<strong>解决了循环调用</strong>的问题，为什么CommonJS无法解决循环调用的详细解释请查看<a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/">图解ES Modules</a></p><p><img src="/My-Blogs/images/module_bindings.png" alt="image"></p><blockquote><p>求值（Evaluation）</p></blockquote><p>求值步骤相对简单，只要运行代码把计算出来的值填入之前记录的内存地址就可以了，这里就不展开说明了。</p><h4 id="附录：参考-翻译"><a href="#附录：参考-翻译" class="headerlink" title="附录：参考/翻译"></a>附录：参考/翻译</h4><ul><li>  <a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/">ES modules: A cartoon deep-dive</a></li><li>  <a href="https://blog.shenfq.com/2019/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%89%8D%E4%B8%96/">前端模块化的前世</a></li><li>  <a href="http://www.ruanyifeng.com/blog/2015/05/require.html">require源码解读</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冷知识之HTML篇</title>
      <link href="/My-Blogs/2021/01/08/HTML/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BHTML%E7%AF%87/"/>
      <url>/My-Blogs/2021/01/08/HTML/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BHTML%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>这期让我们来看看关于HTML的冷知识都有哪些吧~</p><a id="more"></a><h3 id="浏览器秒变编辑器"><a href="#浏览器秒变编辑器" class="headerlink" title="浏览器秒变编辑器"></a>浏览器秒变编辑器</h3><p>这个还是在浏览器地址栏上面做文章，将以下代码复制粘贴到浏览器地址栏，运行后浏览器就变成了一个原始简单的编辑器，和window自带的notepad差不多，长见识了吧，话不多说，我们来试试。</p><pre><code class="JavaScript">data: text / html, &lt; html contenteditable &gt;</code></pre><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BHTML%E7%AF%87-01.png" alt="image"></p><blockquote><p>归根结底多亏了HTML5中新加的contenteditable属性，当元素指定了该属性后，元素的内容成为可编辑状态。</p></blockquote><p>同理，在控制台执行以下代码，同样可以将整个页面变得可以编辑。</p><blockquote><p>document.body.contentEditable=’true’; </p></blockquote><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BHTML%E7%AF%87-02.png" alt="image"></p><h3 id="实时编写样式的输入框"><a href="#实时编写样式的输入框" class="headerlink" title="实时编写样式的输入框"></a>实时编写样式的输入框</h3><br><p>同理，也是利用了HTML5中的contenteditable属性，巧妙的在body增加一个可编辑的style标签。</p><br><pre><code class="html">&lt;body&gt;  &lt;style style="display:block; position: fixed;" contentEditable&gt;    body {      background: red;    }  &lt;/style&gt;&lt;/body&gt;</code></pre><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BHTML%E7%AF%87-03.png" alt="image"></p><br><h3 id="利用a标签解析url"><a href="#利用a标签解析url" class="headerlink" title="利用a标签解析url"></a>利用a标签解析url</h3><br><p>很多时候我们有从一个URL中提取域名，查询关键字，变量参数值等的需要, 然而处理 url 字符串是比较麻烦的，可以使用 a 标签自动解析 url。</p><br><p>主要方法就是在JS中创建一个a标签，然后将需要处理的URL赋值给我们新创建的a标签的href属性，然后就可以得到我们想要的东西了。</p><br><pre><code class="javascript">var a = document.createElement('a');a.href = 'https://juejin.cn/user/2796746682939054/posts';console.log(a.host);</code></pre><br><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BHTML%E7%AF%87-04.png" alt="image"></p><br><p>利用这一方法，稍微进行封装一下，就可以得到一个非常实用的工具函数了，下面提供一个网上常见的封装示例。</p><pre><code class="javascript">function urlParse(url, key) {  var a = document.createElement('a')  a.href = url  var result = {    href: url,    protocol: a.protocol.replace(':', ''),    port: a.port,    query: a.search,    params: (function() {      var ret = {},        centArr,        seg = a.search.replace(/^\?/, '').replace(/^\?/, '').split('&amp;')      for (i = 0, len = seg.length; i &lt; len; i++) {        if (!seg[i]) {          continue        }        centArr = seg[i].split('=')        ret[centArr[0]] = centArr[1]      }      return ret    }()),    hash: a.hash,    file: (a.pathname.match(/\/([^\/?#]+)$/i) || [, ''])[1],    path: a.pathname.replace(/^([^\/])/, '/$1'),    relative: (a.href.match(/tps?:\/\/[^\/]+(.+)/) || [, ''])[1],    segments: a.pathname.replace(/^\//, '').split('/')  }  a = null  return key ? result[key] : result}</code></pre><br><blockquote><p>H5 有新的 API URL 也可以快速的处理一个链接</p></blockquote><br><pre><code class="JavaScript">var url = new URL('https://www.baidu.com/')url.hash  ...</code></pre>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> 冷知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单介绍2020Google开发者大会web亮点</title>
      <link href="/My-Blogs/2021/01/08/Google/%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D2020Google%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9Aweb%E4%BA%AE%E7%82%B9/"/>
      <url>/My-Blogs/2021/01/08/Google/%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D2020Google%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9Aweb%E4%BA%AE%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="sameSite"><a href="#sameSite" class="headerlink" title="sameSite"></a>sameSite</h3><blockquote><p>Chrome 51 开始，浏览器的 Cookie 新增加了一个SameSite属性，用来防止 CSRF 攻击和用户追踪，分为Strict ，Lax，None</p></blockquote><ul><li><code>Strict</code>最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie</li></ul><p><strong>这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态</strong></p><ul><li><code>Lax</code>规则稍稍放宽，允许同站请求发送Cookie，但大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。</li><li><code>None</code>允许跨站请求，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效</li></ul><table><thead><tr><th>sameSite</th><th>HTTP → HTTPS</th><th>HTTPS → HTTP</th></tr></thead><tbody><tr><td>SameSite=Strict</td><td>⛔ Blocked</td><td>⛔ Blocked</td></tr><tr><td>SameSite=Lax</td><td>✓ Allowed</td><td>✓ Allowed</td></tr><tr><td>SameSite=None; Secure</td><td>✓ Allowed</td><td>⛔ Blocked</td></tr></tbody></table><p><a href="https://web.dev/schemeful-samesite/">查看更多信息</a></p><h3 id="User-Agent-Client-Hints-UA-CH"><a href="#User-Agent-Client-Hints-UA-CH" class="headerlink" title="User-Agent Client Hints(UA-CH)"></a>User-Agent Client Hints(UA-CH)</h3><blockquote><p>从Chrome 85开始，正式发布</p></blockquote><table><thead><tr><th>⬇️ ResponseAccept-CH</th><th>⬆️ Requestheader</th><th>⬆️ RequestExample value</th><th>Description</th></tr></thead><tbody><tr><td>UA</td><td>Sec-CH-UA</td><td>“Chromium”; v=”84”, “Google Chrome”; v=”84”</td><td>List of browser brands and their significant version.</td></tr><tr><td>UA-Mobile</td><td>Sec-CH-UA-Mobile</td><td>?1</td><td>Boolean indicating if the browser is on a mobile device (?1&nbsp;for true) or not (?0&nbsp;for false).</td></tr><tr><td>UA-Full-Version</td><td>Sec-CH-UA-Full-Version</td><td>“84.0.4143.2”</td><td>The complete version for the browser.</td></tr><tr><td>UA-Platform</td><td>Sec-CH-UA-Platform</td><td>“Android”</td><td>The platform for the device, usually the operating system (OS).</td></tr><tr><td>UA-Platform-Version</td><td>Sec-CH-UA-Platform-Version</td><td>“10”</td><td>The version for the platform or OS.</td></tr><tr><td>UA-Arch</td><td>Sec-CH-UA-Arch</td><td>“ARM64”</td><td>The underlying architecture for the device. While this may not be relevant to displaying the page, the site may want to offer a download which defaults to the right format.</td></tr><tr><td>UA-Model</td><td>Sec-CH-UA-Model</td><td>“Pixel 3”</td><td>The device model.</td></tr></tbody></table><h3 id="JavaScript-API"><a href="#JavaScript-API" class="headerlink" title="JavaScript API"></a>JavaScript API</h3><p>Alongside the headers, the User-Agent can also be accessed in JavaScript via navigator.userAgentData. The default Sec-CH-UA and Sec-CH-UA-Mobile header information can be accessed via the brands and mobile properties, respectively:</p><pre><code class="JavaScript">// Log the brand dataconsole.log(navigator.userAgentData.brands);// output[{    brand: 'Chromium',    version: '84',  },  {    brand: 'Google Chrome',    version: '84',  },];// Log the mobile indicatorconsole.log(navigator.userAgentData.mobile);// outputfalse;</code></pre><p><a href="https://web.dev/user-agent-client-hints/">查看更多信息</a></p><h2 id="CSS布局"><a href="#CSS布局" class="headerlink" title="CSS布局"></a>CSS布局</h2><blockquote><p>介绍了一些grid新特性</p></blockquote><h3 id="强居中"><a href="#强居中" class="headerlink" title="强居中"></a>强居中</h3><img src="https://user-images.githubusercontent.com/5030910/100298195-71db5c00-2fcb-11eb-89a2-f4e5ed8a4e8d.png" align="center"><h3 id="三段式布局"><a href="#三段式布局" class="headerlink" title="三段式布局"></a>三段式布局</h3><img src="https://user-images.githubusercontent.com/5030910/100298209-7a339700-2fcb-11eb-95df-49fff7c11a46.png" align="center"><h3 id="经典布局"><a href="#经典布局" class="headerlink" title="经典布局"></a>经典布局</h3><img src="https://user-images.githubusercontent.com/5030910/100298312-c8e13100-2fcb-11eb-8631-d0aba105fa86.png" align="center"><p><a href="http://1linelayouts.glitch.me/">查看更多实例</a></p><p><strong>思考：优化运营后台页面，自适应布局？</strong></p><h2 id="搜索（高级SEO）"><a href="#搜索（高级SEO）" class="headerlink" title="搜索（高级SEO）"></a>搜索（高级SEO）</h2><blockquote><p>利用结构化数据获取 Google 搜索的自然流量</p></blockquote><h3 id="构建富媒体搜索数据，助力Bigo海外电商，直播，imoJobs等业务"><a href="#构建富媒体搜索数据，助力Bigo海外电商，直播，imoJobs等业务" class="headerlink" title="构建富媒体搜索数据，助力Bigo海外电商，直播，imoJobs等业务"></a>构建富媒体搜索数据，助力Bigo海外电商，直播，imoJobs等业务</h3><ul><li><p><strong><a href="https://developers.google.com/search/docs/data-types/product">电商</a></strong></p><img src="https://user-images.githubusercontent.com/5030910/100297927-bfa39480-2fca-11eb-8df7-99606a72f2cf.png" align="center"></li><li><p><strong><a href="https://developers.google.com/search/docs/data-types/video">直播</a></strong></p></li></ul><p><img src="https://user-images.githubusercontent.com/5030910/100444919-3a61d200-30e7-11eb-9fdb-bcf3f609608b.png" alt="image"></p><ul><li><p><strong><a href="https://developers.google.com/search/docs/data-types/job-posting">imojobs</a></strong></p><img src="https://user-images.githubusercontent.com/5030910/100225858-cfcf5b80-2f59-11eb-81fd-ecb766bfc198.png" align="center"></li></ul><p><a href="https://search.google.com/test/rich-results">测试地址</a></p><h3 id="下面是一个购物信息汇总网站页面示例"><a href="#下面是一个购物信息汇总网站页面示例" class="headerlink" title="下面是一个购物信息汇总网站页面示例"></a>下面是一个购物信息汇总网站页面示例</h3><pre><code class="html"> &lt;html&gt; &lt;head&gt;   &lt;title&gt;Executive Anvil&lt;/title&gt; &lt;/head&gt; &lt;body&gt;   &lt;div&gt;     &lt;div itemtype="http://schema.org/Product" itemscope&gt;       &lt;meta itemprop="mpn" content="925872" /&gt;       &lt;meta itemprop="name" content="Executive Anvil" /&gt;       &lt;link itemprop="image" href="https://example.com/photos/16x9/photo.jpg" /&gt;       &lt;link itemprop="image" href="https://example.com/photos/4x3/photo.jpg" /&gt;       &lt;link itemprop="image" href="https://example.com/photos/1x1/photo.jpg" /&gt;       &lt;meta itemprop="description" content="Sleeker than ACME's Classic Anvil, the Executive Anvil is perfect for the business traveler looking for something to drop from a height." /&gt;       &lt;div itemprop="offers" itemtype="http://schema.org/AggregateOffer" itemscope&gt;         &lt;meta itemprop="lowPrice" content="119.99" /&gt;         &lt;meta itemprop="highPrice" content="199.99" /&gt;         &lt;meta itemprop="offerCount" content="6" /&gt;         &lt;meta itemprop="priceCurrency" content="USD" /&gt;       &lt;/div&gt;       &lt;div itemprop="aggregateRating" itemtype="http://schema.org/AggregateRating" itemscope&gt;         &lt;meta itemprop="reviewCount" content="89" /&gt;         &lt;meta itemprop="ratingValue" content="4.4" /&gt;       &lt;/div&gt;       &lt;div itemprop="review" itemtype="http://schema.org/Review" itemscope&gt;         &lt;div itemprop="author" itemtype="http://schema.org/Person" itemscope&gt;           &lt;meta itemprop="name" content="Fred Benson" /&gt;         &lt;/div&gt;         &lt;div itemprop="reviewRating" itemtype="http://schema.org/Rating" itemscope&gt;           &lt;meta itemprop="ratingValue" content="4" /&gt;           &lt;meta itemprop="bestRating" content="5" /&gt;         &lt;/div&gt;       &lt;/div&gt;       &lt;meta itemprop="sku" content="0446310786" /&gt;       &lt;div itemprop="brand" itemtype="http://schema.org/Brand" itemscope&gt;         &lt;meta itemprop="name" content="ACME" /&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;</code></pre><p><strong>思考：可以利用Node+CDN服务搭建富媒体HTML直出平台，优化SEO？</strong></p><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><h3 id="PageSpeed-Insights-PSI"><a href="#PageSpeed-Insights-PSI" class="headerlink" title=" PageSpeed Insights(PSI)"></a><a href="https://developers.google.com/speed/pagespeed/insights/"> PageSpeed Insights(PSI)</a></h3><blockquote><p>PSI 作为一款专注于改进网页性能的开发者工具</p></blockquote><p><strong>它主要具有以下两个优势：</strong></p><ul><li>真实的网页运行速度。这是 PSI 2.0 中的新功能，PSI 结合 Chrome 用户体验报告中的数据，向开发者展示他们的网页的实际性能，这一点对于开发者来说是很有价值的。那么，PSI 则成为了用户获得真实的网页运行速度的窗口。</li><li>优化建议。根据一些常用的网页性能优化规则(如避免过多的重定向)，PSI 会基于该网页的优化空间为用户提供一些网页优化建议。</li></ul><h3 id="Puppeteer"><a href="#Puppeteer" class="headerlink" title="Puppeteer"></a><a href="https://github.com/puppeteer/puppeteer">Puppeteer</a></h3><blockquote><p>Nodejs工具库，它提供了高级的JavaScript API 来通过DevTools控制 Chromium与其他浏览器</p></blockquote><p><strong>Puppeteer能做什么？</strong></p><ul><li>生成页面的屏幕截图和PDF。</li><li>爬取SPA（单页应用程序）并生成预渲染的内容（即“ SSR”（服务器端渲染））。</li><li>高级爬虫，可以爬取大量异步渲染内容的网页。</li><li>自动进行表单提交，UI测试，键盘输入，模拟时区，改变深色主题等。</li><li>创建最新的自动化测试环境。使用最新的JavaScript和浏览器功能，直接在最新版本的Chrome中运行测试。</li><li>捕获站点的时间线跟踪，以帮助诊断性能问题。</li><li>测试Chrome扩展程序。</li></ul><p><strong>example.js</strong></p><pre><code class="js">const puppeteer = require('puppeteer');(async () =&gt; {  const browser = await puppeteer.launch();  const page = await browser.newPage();  await page.goto('https://example.com');  await page.screenshot({    path: 'example.png'  });  await browser.close();})();</code></pre><blockquote><p>node example.js</p></blockquote><p><strong>最新进展介绍</strong></p> <img src="https://user-images.githubusercontent.com/5030910/100229116-aebd3980-2f5e-11eb-8c5b-e85159a427d7.png " width="500" align="center"><p><strong>思考：可以构建Serveless服务，搭建FaaS平台，助力前端服务和运营服务？</strong></p><h3 id="Web-Vitals"><a href="#Web-Vitals" class="headerlink" title="Web Vitals"></a>Web Vitals</h3><blockquote><p>什么是 Web Vitals ，Google 给的定义是一个良好网站的基本指标 (Essential metrics for a healthy site)，为什么还要再定义一个新的指标集，原因是过去要衡量一个好的网站，需要使用的指标太多，推出 Web Vitals 是简化这个学习的曲线，站主只要观注 Web Vitals 指标表现即可。</p></blockquote><h4 id="三大指标"><a href="#三大指标" class="headerlink" title="三大指标"></a>三大指标</h4><p><img src="https://user-images.githubusercontent.com/5030910/100299467-bf0cfd00-2fce-11eb-972f-48b4b8c60a3c.png" alt="image"></p><p>使用<a href="https://github.com/GoogleChrome/web-vitals">web-vitals</a>库，测量每个指标就像调用单个函数一样简单（有关完整用法和 API详细信息，请参阅文档 ）：</p><pre><code class="js">import {  getCLS,  getFID,  getLCP} from 'web-vitals';function sendToAnalytics(metric) {  const body = JSON.stringify(metric);  // Use `navigator.sendBeacon()` if available, falling back to `fetch()`.  (navigator.sendBeacon &amp;&amp; navigator.sendBeacon('/analytics', body)) ||  fetch('/analytics', {    body,    method: 'POST',    keepalive: true  });}getCLS(sendToAnalytics);getFID(sendToAnalytics);getLCP(sendToAnalytics);</code></pre><table><thead><tr><th>Platform</th><th>LCP</th><th>FID</th><th>CLS</th></tr></thead><tbody><tr><td><a href="https://developers.google.com/web/tools/chrome-user-experience-report">Chrome User Experience Report</a></td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td><a href="https://developers.google.com/speed/pagespeed/insights/">PageSpeed Insights</a></td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td><a href="https://support.google.com/webmasters/answer/9205520">Search Console (Core Web Vitals report)</a></td><td>✔</td><td>✔</td><td>✔</td></tr></tbody></table><p><strong>思考：利用Web Vitals结合puppeteer，搭建网页自动化测试平台，爬虫工具？</strong></p><h2 id="Chrome相关（DevTools，Lighthouse）"><a href="#Chrome相关（DevTools，Lighthouse）" class="headerlink" title="Chrome相关（DevTools，Lighthouse）"></a>Chrome相关（DevTools，Lighthouse）</h2><h3 id="支持CSS-in-JS框架的样式编辑"><a href="#支持CSS-in-JS框架的样式编辑" class="headerlink" title="支持CSS-in-JS框架的样式编辑"></a><a href="https://developers.google.com/web/updates/images/2020/06/css-in-js.mp4">支持CSS-in-JS框架的样式编辑</a></h3><p><img src="https://user-images.githubusercontent.com/5030910/100299322-60e01a00-2fce-11eb-96b6-a37621b3180a.png" alt="image"></p><h3 id="模拟时区"><a href="#模拟时区" class="headerlink" title="模拟时区"></a>模拟时区</h3><p><img src="https://user-images.githubusercontent.com/5030910/100299410-92f17c00-2fce-11eb-8447-6eb810ec5a8d.png" alt="image"></p><h3 id="媒体面板"><a href="#媒体面板" class="headerlink" title="媒体面板"></a>媒体面板</h3><p><img src="https://user-images.githubusercontent.com/5030910/100299683-35a9fa80-2fcf-11eb-9a67-cf3927b48199.png" alt="image"></p><h3 id="一键修复文字的色彩对比"><a href="#一键修复文字的色彩对比" class="headerlink" title="一键修复文字的色彩对比"></a>一键修复文字的色彩对比</h3><p><img src="https://user-images.githubusercontent.com/5030910/100299746-638f3f00-2fcf-11eb-9e12-0e2a7017c6a9.png" alt="image"></p><h3 id="利用Lighthouse-生成性能报告"><a href="#利用Lighthouse-生成性能报告" class="headerlink" title="利用Lighthouse 生成性能报告"></a>利用Lighthouse 生成性能报告</h3><p><img src="https://user-images.githubusercontent.com/5030910/100299914-d0a2d480-2fcf-11eb-8500-a0fdc33c45c0.png" alt="image"></p><p><strong><a href="https://developers.google.com/web/updates">更多内容查看这里</a></strong></p><h2 id="PWA与WebPush"><a href="#PWA与WebPush" class="headerlink" title="PWA与WebPush"></a>PWA与WebPush</h2><h3 id="利用PWA解决以下问题"><a href="#利用PWA解决以下问题" class="headerlink" title="利用PWA解决以下问题"></a>利用PWA解决以下问题</h3><p><img src="https://user-images.githubusercontent.com/5030910/100417600-3cfb0200-30bc-11eb-8c5b-16148406d95c.png" alt="image"></p><h3 id="WebPush流程图"><a href="#WebPush流程图" class="headerlink" title="WebPush流程图"></a>WebPush流程图</h3><p><strong>授权流程</strong></p><p><img src="https://user-images.githubusercontent.com/5030910/100417630-50a66880-30bc-11eb-8ecc-2199dab3dc11.png" alt="Web push授权流程"></p><p><strong>通知流程</strong></p><p><img src="https://user-images.githubusercontent.com/5030910/100417986-eb06ac00-30bc-11eb-9ecf-6b3dd9b5a69e.png" alt="image"></p><p><strong>代码实现</strong></p><p><img src="https://user-images.githubusercontent.com/5030910/100418090-17bac380-30bd-11eb-8ca5-6fe9c18deddd.png" alt="image"></p><p><strong>成果</strong></p><p><img src="https://user-images.githubusercontent.com/5030910/100418205-505a9d00-30bd-11eb-9bda-9e12c38f60f1.png" alt="image"></p><p><strong>思考：利用Node，搭建PWA构建平台，助力海外电商业务，将营销推广类活动页封装成PWA</strong></p><h2 id="TensorFlow-js"><a href="#TensorFlow-js" class="headerlink" title="TensorFlow.js"></a>TensorFlow.js</h2><h3 id="来分享一个有意思的场景"><a href="#来分享一个有意思的场景" class="headerlink" title="来分享一个有意思的场景"></a>来分享一个有意思的场景</h3><p><strong><a href="https://blog.tensorflow.org/2020/09/bringing-mona-lisa-effect-to-life-tensorflow-js.html">交互式《蒙娜丽莎》画像</a></strong></p><blockquote><p>传说中，不管你从哪个角度看《蒙娜丽莎》画像，都会感到画像中的女子在看着你。TensorFlow 的官方博客，演示怎么用 TensorFlow.js，制作一个交互式的《蒙娜丽莎》画像，摄像头捕捉观看者的角度，然后自动改变画像的眼神。</p></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/202009/bg2020092603.jpg" alt="image"></p><p><img src="https://www.wangbase.com/blogimg/asset/202009/bg2020092604.jpg" alt="image"></p><h3 id="利用TensorFlow-Privacy-检查隐私保护措施"><a href="#利用TensorFlow-Privacy-检查隐私保护措施" class="headerlink" title="利用TensorFlow Privacy 检查隐私保护措施"></a>利用TensorFlow Privacy 检查隐私保护措施</h3><p><img src="https://user-images.githubusercontent.com/5030910/100418941-851b2400-30be-11eb-98cf-af0d5dbb1a5f.png" alt="image"></p><p><img src="https://user-images.githubusercontent.com/5030910/100419020-a3811f80-30be-11eb-9237-c33f9de6b58a.png" alt="image"></p><p><img src="https://user-images.githubusercontent.com/5030910/100419041-ada31e00-30be-11eb-88cd-0c5f8b2c89bd.png" alt="image"></p><p><strong>思考：或许可以利用Node+TensorFlow，对于用户上传的图片进行二次处理？</strong></p><ul><li><p><a href="https://www.tensorflow.org/js/?hl=zh_cn">官网</a></p></li><li><p><a href="https://www.icourse163.org/learn/youdao-1460578162?tid=1461280442#/learn/content">入门课程</a></p></li><li><p><a href="https://flutter.dev/web">Flutter Web</a></p></li><li><p><a href="https://space.bilibili.com/64169458/channel/detail?cid=156180">视频集合链接</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Google </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git远程操作详解【转载】</title>
      <link href="/My-Blogs/2021/01/08/Git/Git%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91/"/>
      <url>/My-Blogs/2021/01/08/Git/Git%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>Git有很多优势，其中之一就是远程操作非常简便。本文详细介绍5个Git命令，它们的概念和用法，理解了这些内容，你就会完全掌握Git远程操作。</p><a id="more"></a><pre><code class="BASH">git clonegit remotegit fetchgit pullgit push</code></pre><p>本文针对初级用户，从最简单的讲起，但是需要读者对Git的基本用法有所了解。同时，本文覆盖了上面5个命令的几乎所有的常用用法，所以对于熟练用户也有参考价值。</p><h3 id="一、git-clone"><a href="#一、git-clone" class="headerlink" title="一、git clone"></a>一、git clone</h3><p>远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。</p><pre><code class="BASH">$ git clone &amp;lt;版本库的网址&amp;gt;</code></pre><p>比如，克隆jQuery的版本库。</p><pre><code class="BASH">$ git clone https://github.com/jquery/jquery.git</code></pre><p>该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。</p><pre><code class="BASH">$ git clone &amp;lt;版本库的网址&amp;gt; &amp;lt;本地目录名&amp;gt;</code></pre><p>git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。</p><pre><code class="BASH">$ git clone http[s]://example.com/path/to/repo.git/$ git clone ssh://example.com/path/to/repo.git/$ git clone git://example.com/path/to/repo.git/$ git clone /opt/git/project.git $ git clone file:///opt/git/project.git$ git clone ftp[s]://example.com/path/to/repo.git/$ git clone rsync://example.com/path/to/repo.git/</code></pre><p>SSH协议还有另一种写法。</p><pre><code class="BASH">$ git clone [user@]example.com:path/to/repo.git/</code></pre><p>通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考官方文档。</p><h3 id="二、git-remote"><a href="#二、git-remote" class="headerlink" title="二、git remote"></a>二、git remote</h3><p>为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。</p><p>不带选项的时候，git remote命令列出所有远程主机。</p><pre><code class="BASH">$ git remote origin</code></pre><p>使用-v选项，可以参看远程主机的网址。</p><pre><code class="BASH">$ git remote -vorigin  git@github.com:jquery/jquery.git (fetch)origin  git@github.com:jquery/jquery.git (push)</code></pre><p>上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。</p><p>克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。</p><pre><code class="BASH">$ git clone -o jQuery https://github.com/jquery/jquery.git$ git remote</code></pre><p>jQuery</p><p>上面命令表示，克隆的时候，指定远程主机叫做jQuery。</p><pre><code class="BASH">git remote show命令加上主机名，可以查看该主机的详细信息。$ git remote show &lt;主机名&gt;git remote add命令用于添加远程主机。$ git remote add &lt;主机名&gt; &lt;网址&gt;git remote rm命令用于删除远程主机。$ git remote rm &lt;主机名&gt;git remote rename命令用于远程主机的改名。$ git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</code></pre><h3 id="三、git-fetch"><a href="#三、git-fetch" class="headerlink" title="三、git fetch"></a>三、git fetch</h3><p>一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。</p><pre><code class="BASH">$ git fetch &lt;远程主机名&gt;</code></pre><p>上面命令将某个远程主机的更新，全部取回本地。</p><p><code>git fetch</code> 命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。</p><p>默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。</p><pre><code class="BASH">$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;</code></pre><p>比如，取回origin主机的master分支。</p><pre><code class="BASH">$ git fetch origin master</code></pre><p>所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。</p><p>git branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。</p><pre><code class="BASH">$ git branch -rorigin/master$ git branch -a* master  remotes/origin/master</code></pre><p>上面命令表示，本地主机的当前分支是master，远程分支是origin/master。</p><p>取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。</p><pre><code class="BASH">$ git checkout -b newBrach origin/master</code></pre><p>上面命令表示，在origin/master的基础上，创建一个新分支。</p><p>此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。</p><pre><code class="BASH">$ git pull origin next:master</code></pre><p>上面命令表示在当前分支上，合并origin/master。</p><h3 id="四、git-pull"><a href="#四、git-pull" class="headerlink" title="四、git pull"></a>四、git pull</h3><p>git pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。</p><pre><code class="BASH">$ git pull &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;</code></pre><p>比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。</p><pre><code class="BASH">$ git pull origin next:master</code></pre><p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p><pre><code class="BASH">$ git pull origin next</code></pre><p>上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。</p><pre><code class="BASH">$ git fetch origin$ git merge origin/next</code></pre><p>在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。</p><p>Git也允许手动建立追踪关系。</p><pre><code class="BASH">git branch --set-upstream master origin/next</code></pre><p>上面命令指定master分支追踪origin/next分支。</p><p>如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。</p><pre><code class="BASH">$ git pull origin</code></pre><p>上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”（remote-tracking branch）进行合并。</p><p>如果当前分支只有一个追踪分支，连远程主机名都可以省略。</p><pre><code class="BASH">$ git pull</code></pre><p>上面命令表示，当前分支自动与唯一一个追踪分支进行合并。</p><p>如果合并需要采用rebase模式，可以使用–rebase选项。</p><pre><code class="BASH">$ git pull --rebase &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;</code></pre><p>如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。</p><p>但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。</p><pre><code class="BASH">$ git pull -p等同于下面的命令$ git fetch --prune origin $ git fetch -p</code></pre><h3 id="五、git-push"><a href="#五、git-push" class="headerlink" title="五、git push"></a>五、git push</h3><p>git push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。</p><pre><code class="BASH">$ git push &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名&amp;gt;:&amp;lt;远程分支名&amp;gt;</code></pre><p>注意，分支推送顺序的写法是&lt; 来源地&gt; :&lt; 目的地&gt; ，所以git pull是&lt; 远程分支&gt; :&lt; 本地分支&gt; ，而git push是&lt; 本地分支&gt; :&lt; 远程分支&gt; 。</p><p>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</p><pre><code class="BASH">$ git push origin master</code></pre><p>上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。</p><p>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p><pre><code class="BASH">$ git push origin :master等同于$ git push origin --delete master</code></pre><p>上面命令表示删除origin主机的master分支。</p><p>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</p><pre><code class="BASH">$ git push origin</code></pre><p>上面命令表示，将当前分支推送到origin主机的对应分支。</p><p>如果当前分支只有一个追踪分支，那么主机名都可以省略。</p><pre><code class="BASH">$ git push</code></pre><p>如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。</p><pre><code class="BASH">$ git push -u origin master</code></pre><p>上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。</p><p>不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。</p><pre><code class="BASH">$ git config --global push.default matching或者$ git config --global push.default simple</code></pre><p>还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用–all选项。</p><pre><code class="BASH">$ git push --all origin</code></pre><p>上面命令表示，将所有本地分支都推送到origin主机。</p><p>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用–force选项。</p><pre><code class="BASH">$ git push --force origin</code></pre><p>上面命令使用–force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用–force选项。</p><p>最后，git push不会推送标签（tag），除非使用–tags选项。</p><pre><code class="BASH">$ git push origin --tags</code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git回滚操作</title>
      <link href="/My-Blogs/2021/01/08/Git/git%E5%9B%9E%E6%BB%9A%E6%93%8D%E4%BD%9C/"/>
      <url>/My-Blogs/2021/01/08/Git/git%E5%9B%9E%E6%BB%9A%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>我们都知道万一提交错了代码，想要删除又想准确无误怎么办呢？下面介绍两种方式，看是否有适合你的呢</p><a id="more"></a><h2 id="git删除指定commit"><a href="#git删除指定commit" class="headerlink" title="git删除指定commit"></a>git删除指定commit</h2><ol><li> 使用git log 命令，查看已提交的记录。例如红色圈出的commit是本次要删除的commit。</li></ol><p><img src="/My-Blogs/images/git%E5%9B%9E%E6%BB%9A%E6%93%8D%E4%BD%9C-01.png"></p><br><ol start="2"><li><p> 先找到此次提交之前的一次提交的commit 1d6b81b138f89735265900b94fcd1ec39375e7b4</p></li><li><p> 执行git rebase -i 1d6b81b138f89735265900b94fcd1ec39375e7b4，弹出如下页面（不包含当前commit）：</p></li></ol><p><img src="/My-Blogs/images/git%E5%9B%9E%E6%BB%9A%E6%93%8D%E4%BD%9C-02.png"></p><br><p>按字母I键进入编辑模式，将需要删除的commit的pick改为drop，然后按esc退出编辑，：wq保存</p><p><img src="/My-Blogs/images/git%E5%9B%9E%E6%BB%9A%E6%93%8D%E4%BD%9C-03.png"></p><br><ol start="4"><li> 再次执行git log命令，查看已提交记录，之前红色圈出的commit记录已被删除。</li></ol><p><img src="/My-Blogs/images/git%E5%9B%9E%E6%BB%9A%E6%93%8D%E4%BD%9C-04.png"></p><p><strong>PS：以上方法不适用特定merge提交删除</strong></p><h2 id="优雅撤销中间某次merge提交"><a href="#优雅撤销中间某次merge提交" class="headerlink" title="优雅撤销中间某次merge提交"></a>优雅撤销中间某次merge提交</h2><pre><code class="BASH">git revert commit_id//如果commit_id是merge节点的话,-m是指定具体哪个提交点git revert commit_id -m 1//接着就是解决冲突git add -Agit commit -m ".."git revert commit_id -m 2//接着就是解决冲突git add -Agit commit -m ".."git push</code></pre><p>其中<code>git revert commit_id -m 数字</code>是针对，<code>merge</code>提交点的操作。<br>如果是普通的提交点，直接用rebase即可，不需要这么麻烦。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eslint使用规则</title>
      <link href="/My-Blogs/2021/01/08/eslint/%E5%85%B3%E4%BA%8Eeslint%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99%EF%BC%8C%E5%92%8C%E5%90%84%E7%A7%8D%E6%8A%A5%E9%94%99%E5%BA%94%E5%AF%B9%E4%B9%A6%E5%86%99%E8%A7%84%E5%88%99/"/>
      <url>/My-Blogs/2021/01/08/eslint/%E5%85%B3%E4%BA%8Eeslint%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99%EF%BC%8C%E5%92%8C%E5%90%84%E7%A7%8D%E6%8A%A5%E9%94%99%E5%BA%94%E5%AF%B9%E4%B9%A6%E5%86%99%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>整理了一些eslint常用规则，欢迎大家评阅</p><a id="more"></a><p><strong>为了方便查看和使用所以进行了整理，以下。</strong></p><blockquote><p>0=”off” 1=”warn” 2=”error”</p></blockquote><pre><code class="js">"no-alert": 0,//禁止使用alert confirm prompt"no-array-constructor": 2,//禁止使用数组构造器"no-bitwise": 0,//禁止使用按位运算符"no-caller": 1,//禁止使用arguments.caller或arguments.callee"no-catch-shadow": 2,//禁止catch子句参数与外部作用域变量同名"no-class-assign": 2,//禁止给类赋值"no-cond-assign": 2,//禁止在条件表达式中使用赋值语句"no-console": 2,//禁止使用console"no-const-assign": 2,//禁止修改const声明的变量"no-constant-condition": 2,//禁止在条件中使用常量表达式 if(true) if(1)"no-continue": 0,//禁止使用continue"no-control-regex": 2,//禁止在正则表达式中使用控制字符"no-debugger": 2,//禁止使用debugger"no-delete-var": 2,//不能对var声明的变量使用delete操作符"no-div-regex": 1,//不能使用看起来像除法的正则表达式/=foo/"no-dupe-keys": 2,//在创建对象字面量时不允许键重复 {a:1,a:1}"no-dupe-args": 2,//函数参数不能重复"no-duplicate-case": 2,//switch中的case标签不能重复"no-else-return": 2,//如果if语句里面有return,后面不能跟else语句"no-empty": 2,//块语句中的内容不能为空"no-empty-character-class": 2,//正则表达式中的[]内容不能为空"no-empty-label": 2,//禁止使用空label"no-eq-null": 2,//禁止对null使用==或!=运算符"no-eval": 1,//禁止使用eval"no-ex-assign": 2,//禁止给catch语句中的异常参数赋值"no-extend-native": 2,//禁止扩展native对象"no-extra-bind": 2,//禁止不必要的函数绑定"no-extra-boolean-cast": 2,//禁止不必要的bool转换"no-extra-parens": 2,//禁止非必要的括号"no-extra-semi": 2,//禁止多余的冒号"no-fallthrough": 1,//禁止switch穿透"no-floating-decimal": 2,//禁止省略浮点数中的0 .5 3."no-func-assign": 2,//禁止重复的函数声明"no-implicit-coercion": 1,//禁止隐式转换"no-implied-eval": 2,//禁止使用隐式eval"no-inline-comments": 0,//禁止行内备注"no-inner-declarations": [2, "functions"],//禁止在块语句中使用声明（变量或函数）"no-invalid-regexp": 2,//禁止无效的正则表达式"no-invalid-this": 2,//禁止无效的this，只能用在构造器，类，对象字面量"no-irregular-whitespace": 2,//不能有不规则的空格"no-iterator": 2,//禁止使用__iterator__ 属性"no-label-var": 2,//label名不能与var声明的变量名相同"no-labels": 2,//禁止标签声明"no-lone-blocks": 2,//禁止不必要的嵌套块"no-lonely-if": 2,//禁止else语句内只有if语句"no-loop-func": 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）"no-mixed-requires": [0, false],//声明时不能混用声明类型"no-mixed-spaces-and-tabs": [2, false],//禁止混用tab和空格"linebreak-style": [0, "windows"],//换行风格"no-multi-spaces": 1,//不能用多余的空格"no-multi-str": 2,//字符串不能用\换行"no-multiple-empty-lines": [1, {"max": 2}],//空行最多不能超过2行"no-native-reassign": 2,//不能重写native对象"no-negated-in-lhs": 2,//in 操作符的左边不能有!"no-nested-ternary": 0,//禁止使用嵌套的三目运算"no-new": 1,//禁止在使用new构造一个实例后不赋值"no-new-func": 1,//禁止使用new Function"no-new-object": 2,//禁止使用new Object()"no-new-require": 2,//禁止使用new require"no-new-wrappers": 2,//禁止使用new创建包装实例，new String new Boolean new Number"no-obj-calls": 2,//不能调用内置的全局对象，比如Math() JSON()"no-octal": 2,//禁止使用八进制数字"no-octal-escape": 2,//禁止使用八进制转义序列"no-param-reassign": 2,//禁止给参数重新赋值"no-path-concat": 0,//node中不能使用__dirname或__filename做路径拼接"no-plusplus": 0,//禁止使用++，--"no-process-env": 0,//禁止使用process.env"no-process-exit": 0,//禁止使用process.exit()"no-proto": 2,//禁止使用__proto__属性"no-redeclare": 2,//禁止重复声明变量"no-regex-spaces": 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/"no-restricted-modules": 0,//如果禁用了指定模块，使用就会报错"no-return-assign": 1,//return 语句中不能有赋值表达式"no-script-url": 0,//禁止使用javascript:void(0)"no-self-compare": 2,//不能比较自身"no-sequences": 0,//禁止使用逗号运算符"no-shadow": 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名"no-shadow-restricted-names": 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用"no-spaced-func": 2,//函数调用时 函数名与()之间不能有空格"no-sparse-arrays": 2,//禁止稀疏数组， [1,,2]"no-sync": 0,//nodejs 禁止同步方法"no-ternary": 0,//禁止使用三目运算符"no-trailing-spaces": 1,//一行结束后面不要有空格"no-this-before-super": 0,//在调用super()之前不能使用this或super"no-throw-literal": 2,//禁止抛出字面量错误 throw "error";"no-undef": 1,//不能有未定义的变量"no-undef-init": 2,//变量初始化时不能直接给它赋值为undefined"no-undefined": 2,//不能使用undefined"no-unexpected-multiline": 2,//避免多行表达式"no-underscore-dangle": 1,//标识符不能以_开头或结尾"no-unneeded-ternary": 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;"no-unreachable": 2,//不能有无法执行的代码"no-unused-expressions": 2,//禁止无用的表达式"no-unused-vars": [2, {"vars": "all", "args": "after-used"}],//不能有声明后未被使用的变量或参数"no-use-before-define": 2,//未定义前不能使用"no-useless-call": 2,//禁止不必要的call和apply"no-void": 2,//禁用void操作符"no-var": 0,//禁用var，用let和const代替"no-warning-comments": [1, { "terms": ["todo", "fixme", "xxx"], "location": "start" }],//不能有警告备注"no-with": 2,//禁用with"array-bracket-spacing": [2, "never"],//是否允许非空数组里面有多余的空格"arrow-parens": 0,//箭头函数用小括号括起来"arrow-spacing": 0,//=&gt;的前/后括号"accessor-pairs": 0,//在对象中使用getter/setter"block-scoped-var": 0,//块语句中使用var"brace-style": [1, "1tbs"],//大括号风格"callback-return": 1,//避免多次调用回调什么的"camelcase": 2,//强制驼峰法命名"comma-dangle": [2, "never"],//对象字面量项尾不能有逗号"comma-spacing": 0,//逗号前后的空格"comma-style": [2, "last"],//逗号风格，换行时在行首还是行尾"complexity": [0, 11],//循环复杂度"computed-property-spacing": [0, "never"],//是否允许计算后的键名什么的"consistent-return": 0,//return 后面是否允许省略"consistent-this": [2, "that"],//this别名"constructor-super": 0,//非派生类不能调用super，派生类必须调用super"curly": [2, "all"],//必须使用 if(){} 中的{}"default-case": 2,//switch语句最后必须有default"dot-location": 0,//对象访问符的位置，换行的时候在行首还是行尾"dot-notation": [0, { "allowKeywords": true }],//避免不必要的方括号"eol-last": 0,//文件以单一的换行符结束"eqeqeq": 2,//必须使用全等"func-names": 0,//函数表达式必须有名字"func-style": [0, "declaration"],//函数风格，规定只能使用函数声明/函数表达式"generator-star-spacing": 0,//生成器函数*的前后空格"guard-for-in": 0,//for in循环要用if语句过滤"handle-callback-err": 0,//nodejs 处理错误"id-length": 0,//变量名长度"indent": [2, 4],//缩进风格"init-declarations": 0,//声明时必须赋初值"key-spacing": [0, { "beforeColon": false, "afterColon": true }],//对象字面量中冒号的前后空格"lines-around-comment": 0,//行前/行后备注"max-depth": [0, 4],//嵌套块深度"max-len": [0, 80, 4],//字符串最大长度"max-nested-callbacks": [0, 2],//回调嵌套深度"max-params": [0, 3],//函数最多只能有3个参数"max-statements": [0, 10],//函数内最多有几个声明"new-cap": 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用"new-parens": 2,//new时必须加小括号"newline-after-var": 2,//变量声明后是否需要空一行"object-curly-spacing": [0, "never"],//大括号内是否允许不必要的空格"object-shorthand": 0,//强制对象字面量缩写语法"one-var": 1,//连续声明"operator-assignment": [0, "always"],//赋值运算符 += -=什么的"operator-linebreak": [2, "after"],//换行时运算符在行尾还是行首"padded-blocks": 0,//块语句内行首行尾是否要空行"prefer-const": 0,//首选const"prefer-spread": 0,//首选展开运算"prefer-reflect": 0,//首选Reflect的方法"quotes": [1, "single"],//引号类型 `` "" ''"quote-props":[2, "always"],//对象字面量中的属性名是否强制双引号"radix": 2,//parseInt必须指定第二个参数"id-match": 0,//命名检测"require-yield": 0,//生成器函数必须有yield"semi": [2, "always"],//语句强制分号结尾"semi-spacing": [0, {"before": false, "after": true}],//分号前后空格"sort-vars": 0,//变量声明时排序"space-after-keywords": [0, "always"],//关键字后面是否要空一格"space-before-blocks": [0, "always"],//不以新行开始的块{前面要不要有空格"space-before-function-paren": [0, "always"],//函数定义时括号前面要不要有空格"space-in-parens": [0, "never"],//小括号里面要不要有空格"space-infix-ops": 0,//中缀操作符周围要不要有空格"space-return-throw-case": 2,//return throw case后面要不要加空格"space-unary-ops": [0, { "words": true, "nonwords": false }],//一元运算符的前/后要不要加空格"spaced-comment": 0,//注释风格不要有空格什么的"strict": 2,//使用严格模式"use-isnan": 2,//禁止比较时使用NaN，只能用isNaN()"valid-jsdoc": 0,//jsdoc规则"valid-typeof": 2,//必须使用合法的typeof的值"vars-on-top": 2,//var必须放在作用域顶部"wrap-iife": [2, "inside"],//立即执行函数表达式的小括号风格"wrap-regex": 0,//正则表达式字面量用小括号包起来"yoda": [2, "never"]//禁止尤达条件</code></pre>]]></content>
      
      
      <categories>
          
          <category> eslint </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eslint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时序分析场景</title>
      <link href="/My-Blogs/2021/01/08/Elasticsearch/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90%E5%9C%BA%E6%99%AF/"/>
      <url>/My-Blogs/2021/01/08/Elasticsearch/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>时序数据是按时间顺序记录设备、系统状态变化的数据。典型的时序数据有传统的服务器监控指标数据、应用系统性能监控数据、智能硬件、工业物联网传感器数据等。</p><p>早在2017年我们也基于ES进行了时序分析场景的探索。时序分析场景具有高并发写入、低查询时延、多维分析的特点。</p><p>由于ES具有集群扩展、批量写入、读写带路由、数据分片等能力，目前已实现线上单集群最大规模达到600+ 节点、1000w/s的写入吞吐、单条曲线或单个时间线的查询延时可控制在10ms。</p><p>ES提供灵活、多维度的统计分析能力，实现查看监控按照地域、业务模块等灵活的进行统计分析。另外，ES支持列存储、高压缩比、副本数按需调整等能力，可实现较低存储成本。最后时序数据也可通过Kibana组件轻松实现可视化。</p><p><img src="/My-Blogs/images/%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90%E5%9C%BA%E6%99%AF-01.jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
            <tag> 应用场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志实时分析场景</title>
      <link href="/My-Blogs/2021/01/08/Elasticsearch/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E6%97%A5%E5%BF%97%E5%AE%9E%E6%97%B6%E5%88%86%E6%9E%90%E5%9C%BA%E6%99%AF/"/>
      <url>/My-Blogs/2021/01/08/Elasticsearch/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E6%97%A5%E5%BF%97%E5%AE%9E%E6%97%B6%E5%88%86%E6%9E%90%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>日志是互联网行业基础广泛的数据形式。典型日志有用来定位业务问题的运营日志，如慢日志、异常日志；用来分析用户行为的业务日志，如用户的点击、访问日志；以及安全行为分析的审计日志等。</p><p>Elastic生态提供了完整的日志解决方案。通过简单部署，即可搭建一个完整的日志实时分析服务。ES生态完美的解决了日志实时分析场景需求，这也是近几年ES快速发展的一个重要原因。</p><p>日志从产生到可访问一般在10s级，相比于传统大数据解决方案的几十分钟、小时级时效性非常高。</p><p>ES底层支持倒排索引、列存储等数据结构，使得在日志场景可以利用ES非常灵活的搜索分析能力。通过ES交互式分析能力，即使在万亿级日志的情况下，日志搜索响应时间也是秒级。</p><p>日志处理的基本流程包含：日志采集-&gt; 数据清洗-&gt; 存储-&gt; 可视化分析。ElasticStack通过完整的日志解决方案，帮助用户完成对日志处理全链路管理。</p><p><img src="/My-Blogs/images/%E6%97%A5%E5%BF%97%E5%AE%9E%E6%97%B6%E5%88%86%E6%9E%90%E5%9C%BA%E6%99%AF-01.jpeg"></p><p>其中：</p><ul><li>日志采集：通过轻量级日志采集组件FileBeat实时读取业务日志文件，发送数据至下游组件如Logstash。</li><li> 文本解析：利用正则解析等机制，将日志文本数据转换成结构化数据。可使用独立的Logstash服务或Elasticsearch内置的轻量级数据处理模块IngestPipe-line，完成数据清洗和转换。</li><li>数据存储：通过Elasticsearch搜索分析平台进行数据持久存储，提供全文搜索和分析能力。</li><li>可视化分析：通过功能丰富的图形界面，即可对日志数据进行搜索分析，如可视化组件Kibana。</li></ul><p><img src="/My-Blogs/images/%E6%97%A5%E5%BF%97%E5%AE%9E%E6%97%B6%E5%88%86%E6%9E%90%E5%9C%BA%E6%99%AF-02.jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
            <tag> 应用场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雪碧图mixin</title>
      <link href="/My-Blogs/2021/01/08/css/%E9%9B%AA%E7%A2%A7%E5%9B%BEmixin/"/>
      <url>/My-Blogs/2021/01/08/css/%E9%9B%AA%E7%A2%A7%E5%9B%BEmixin/</url>
      
        <content type="html"><![CDATA[<p>icon小图标</p><a id="more"></a><h2 id="调用icon小图标的方式是通过mixin方式进行调用的"><a href="#调用icon小图标的方式是通过mixin方式进行调用的" class="headerlink" title="调用icon小图标的方式是通过mixin方式进行调用的"></a>调用icon小图标的方式是通过mixin方式进行调用的</h2><pre><code class="CSS">@mixin Ricon($width, $height, $url, $important: '') {  @include background(#{$baseURL}#{$url}.png, $important);  display: inline-block;  width: $width;  height: $height;  background-size: 100% auto;  background-position: center center;}@mixin background($url: '', $important: '') {  @if $url !='' {    @if ($important !='') {      background-image: url($url) !important;    }    @else {      background-image: url($url);    }  }  background-repeat: no-repeat;  background-size: 100% auto;}</code></pre><p>考虑到改造成本以及雪碧图的接入成本，解决方案是在构建过程中接入了<a href="https://github.com/mixtur/webpack-spritesmith">webpack-spritesmith</a>，优点是</p><ol><li> 构建过程中可根据指定目录自动生成及更新雪碧图与scss文件</li><li> 自动生成的scss文件模版允许自定义化</li><li> 无需手动引入生成的scss文件，可在webpack配置中配置自动引入</li></ol><p>构建配置如下：</p><pre><code class="JS">// 配置代码new SpritesmithPlugin({  src: {    // icon小图标目录    cwd: './src/like/act_30083/assets/img/icon/',    // 合成图片格式    glob: '*.png'  },  target: {    // 合成雪碧图本地文件地址    image: path.resolve(__dirname, './assets/img/sprite-ignore.png'),    css: [      [        // 生成雪碧图样式文件地址        path.resolve(__dirname, './styles/mixins/_sprite-ignore.scss'),        {          // scss文件模板          format: 'function_based_template'        }      ]    ]  },  customTemplates: {    // 自定义模板    'function_based_template': templateFunction,  },  apiOptions: {    // 雪碧图引用地址    cssImageRef: '~@assets/img/sprite-ignore.png',  },  spritesmithOptions: {    // 合成规则    algorithm: 'binary-tree',    // icon之间的距离    padding: 10,  }});</code></pre>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 雪碧图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次伪元素动画引起的webview崩溃</title>
      <link href="/My-Blogs/2021/01/08/css/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BC%AA%E5%85%83%E7%B4%A0%E5%8A%A8%E7%94%BB%E5%BC%95%E8%B5%B7%E7%9A%84webview%E5%B4%A9%E6%BA%83/"/>
      <url>/My-Blogs/2021/01/08/css/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BC%AA%E5%85%83%E7%B4%A0%E5%8A%A8%E7%94%BB%E5%BC%95%E8%B5%B7%E7%9A%84webview%E5%B4%A9%E6%BA%83/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前不久做了一个年终盛典的 h5 移动端活动项目，活动主页有三个排行榜页面，以及任务页面。在测试过程中，测试同事反馈排行榜页面在 android 4.x 的系统下会引起 webview 的崩溃，而且是必现，而任务页面是正常的，这让我纠结了很久，因为本身页面也做了很多的优化，像图片的懒加载，组件的懒加载，排行榜列表虚拟滚动（只渲染屏幕显示部分数据），所以一时也不知道问题在哪里。</p><a id="more"></a><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><p>仔细 review 了一下项目代码，也没发现什么端倪，就只能一点一点注释代码来调试了，发现有一段 css 代码注释掉以后 android 4.x 就正常了。</p><p>于是 google 了一番，发现是伪元素做动画惹的祸，是旧版 chromium 的问题，可以查看<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=364222">官方 issue</a>，crash 代码如下。</p><pre><code class="CSS">@-webkit-keyframes crashChrome {  0% {    -webkit-transform: translateX(0rem);  }}.anim:before {  content: "";  width: 3rem;  height: 3rem;  border-radius: 3rem;  position: absolute;  left: 5rem;  top: 5rem;  background-color: #06839f;  -webkit-animation: crashChrome;}</code></pre><pre><code class="HTML">&lt;div class="anim"&gt;&lt;/div&gt;</code></pre><p>代码一看其实也比较正常，普普通通的的用法，就是一个 before 的伪元素做了一个 一动也不动的 animation 的动画，怎么就会奔溃了呢？</p><p>这个 bug 具体是怎么回事还没想明白，但是问题得解决呀，自己活动页面的奔溃八九不离十就是 before+animation 引起的，用 div 代替 before 先把 bug 解决了。</p><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>这段 crash 的 css 代码确实比较平常，而且写法完全符合 web 的标准，故不应该是代码本身的问题。且在自己本地的开发浏览器中，以及稍微不那么旧的手机里都是正常的，所以断定这个问题因该属于浏览器的 bug，并且在某些旧版浏览器里才有的 bug，后来的新版浏览器已经修复了这个问题。</p><p>拿着会 crash 的手机测试发现，只有满足以下三个条件：伪元素（before，after 等）+ animation + rem，才会 crash。</p><p>所以得出了以下结论，在伪元素里使用 animation 动画，并且动画里有 rem 的变化就会引起了某些版本 webview 的 crash。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个问题与浏览器的底层渲染有关，并且官方没有给出具体哪些版本会受到影响，而在移动段 rem 是比较常规的单位，所以各位同学做项目的时候，就不要在伪元素里写动画。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自适应布局的相关介绍</title>
      <link href="/My-Blogs/2021/01/08/css/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D/"/>
      <url>/My-Blogs/2021/01/08/css/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>我们都知道自适应布局有很多种方式可以实现，下面让我们来看看有哪些方式比较简单？</p><a id="more"></a><h3 id="利用clamp函数"><a href="#利用clamp函数" class="headerlink" title="利用clamp函数"></a>利用clamp函数</h3><p><code>clamp()</code> 通过“限制”或限制最小和最大范围之间的灵活值来工作</p><p>使用方法如下：</p><ul><li>最小值：例如 16px</li><li>弹性值：例如 5vw</li><li>最大值：例如 34px</li></ul><pre><code class="css">h1 {  font-size: clamp(16px, 5vw, 34px);}</code></pre><p>在此示例中，该 h1 font-size 值将是 5% 视口宽度。但前提是该值大于 16px 和小于 34px。</p><p>例如，如果您的视口宽度为 300px，则您的 5vw 值将等于 15px。但是，您将该 font-size 值限制为的最小值 16px，这样就可以了。</p><p>另一方面，如果您的视口宽度为 1400px，则您 5vw 将大声疾呼 70px！但幸运的是，您将该最大值限制为34px，因此它不会超过该最大值 。</p><p><img src="/My-Blogs/images/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D-01.gif" alt="iamge"></p><p>我可以为此模板添加此代码…</p><pre><code class="css">img {  width: clamp(15vw, 800%, 100%);}h1 {  font-size: clamp(20px, 5vw, 35px);}p {  font-size: clamp(10px, 4vw, 20px);}</code></pre><p>实际上，任何其他接受长度，频率，角度，时间，百分比，数字或整数的属性</p><p><img src="/My-Blogs/images/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D-02.png" alt="image"></p><br><h3 id="利用grid布局新特性"><a href="#利用grid布局新特性" class="headerlink" title="利用grid布局新特性"></a>利用<a href="http://1linelayouts.glitch.me/">grid布局新特性</a></h3><br><h4 id="强居中"><a href="#强居中" class="headerlink" title="强居中"></a>强居中</h4><p><img src="/My-Blogs/images/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D-03.png"></p><br><h4 id="三段式布局"><a href="#三段式布局" class="headerlink" title="三段式布局"></a>三段式布局</h4><p><img src="/My-Blogs/images/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D-04.png"></p><br><h4 id="经典布局"><a href="#经典布局" class="headerlink" title="经典布局"></a>经典布局</h4><p><img src="/My-Blogs/images/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D-05.png"></p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冷知识之CSS篇【竖行横书组合】</title>
      <link href="/My-Blogs/2021/01/08/css/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87%E3%80%90%E7%AB%96%E8%A1%8C%E6%A8%AA%E4%B9%A6%E7%BB%84%E5%90%88%E3%80%91/"/>
      <url>/My-Blogs/2021/01/08/css/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87%E3%80%90%E7%AB%96%E8%A1%8C%E6%A8%AA%E4%B9%A6%E7%BB%84%E5%90%88%E3%80%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我们都知道竖书成行，自右向左换行是古文中的一种书写方式。那么在CSS中writing-mode就定义了文本在水平或垂直方向上排列方式。下面我们通过writing-mode这个属性定义一个“竹简”书写方式，同时如果在竖行文本中穿插阿拉伯数字时又当如何？</p></blockquote><a id="more"></a><p>我们要定义竹简的书写方式前，首先回顾下 CSS <code>writing-mode</code> 属性，它是定义文本在水平或垂直方向上如何排列。</p><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87%E3%80%90%E7%AB%96%E8%A1%8C%E6%A8%AA%E4%B9%A6%E7%BB%84%E5%90%88%E3%80%91-01.jpg"></p><p>CSS text-combine-upright 竖行横书组合</p><h3 id="writing-mode语法"><a href="#writing-mode语法" class="headerlink" title="writing-mode语法"></a>writing-mode语法</h3><pre><code class="CSS">writing-mode: horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr</code></pre><ul><li>horizontal-tb：水平方向自上而下的书写方式。</li><li>vertical-rl：垂直方向自右而左的书写方式。</li><li>vertical-lr：垂直方向内内容从上到下，水平方向从左到右。</li><li>sideways-rl：内容垂直方向从上到下排列。</li></ul><p>由此，我们若要定义出“竹简”的书写模式，就可以运用<code>vertical-rl</code>值，垂直方向由右到左。</p><p><strong>示例</strong></p><p>先吟诗一首🤭以此为例开始</p><p>同在屋檐下，惟有偶遇。</p><p>犹如白驹过隙，言之不尽。</p><p>因有时不我与，爬耳搔腮，</p><p>心之不及也。</p><p>—— Lucas</p><pre><code class="CSS">div{  writing-mode: vertical-rl;}</code></pre><pre><code class="HTML">&lt;div&gt;  &lt;p&gt;同在屋檐下，&lt;/p&gt;  &lt;p&gt;惟有偶遇。&lt;/p&gt;  &lt;p&gt;犹如白驹过隙，&lt;/p&gt;  &lt;p&gt;言之不尽，&lt;/p&gt;  &lt;p&gt;因有时不我与，&lt;/p&gt;  &lt;p&gt;爬耳搔腮，&lt;/p&gt;  &lt;p&gt;心之不及也。&lt;/p&gt;  &lt;p&gt;—— DeathGhost&lt;/p&gt;&lt;/div&gt;</code></pre><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87%E3%80%90%E7%AB%96%E8%A1%8C%E6%A8%AA%E4%B9%A6%E7%BB%84%E5%90%88%E3%80%91-02.jpg"></p><p>CSS writing-mode 文本排布</p><p>接下来，我们看看竖行排布中的“意外”。看看下面的图例。</p><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87%E3%80%90%E7%AB%96%E8%A1%8C%E6%A8%AA%E4%B9%A6%E7%BB%84%E5%90%88%E3%80%91-03.jpg"></p><p>CSS 书写模式 <code>writing-mode: vertical-rl</code> （从右到左）</p><p>可以看出，若以中文描述还好，但若加入阿拉伯数字，就显得怪异。</p><p>那么可否将数字转为横向（常规）书写？</p><p>下面我们重点看看CSS中的另一个属性。</p><h3 id="text-combine-upright-竖行横书组合"><a href="#text-combine-upright-竖行横书组合" class="headerlink" title="text-combine-upright 竖行横书组合"></a>text-combine-upright 竖行横书组合</h3><pre><code class="CSS">/* Keyword values */text-combine-upright: none;text-combine-upright: all;/* Digits values */text-combine-upright: digits;text-combine-upright: digits 4;/* Global values */text-combine-upright: inherit;text-combine-upright: initial;text-combine-upright: unset;</code></pre><ul><li><code>none</code>: 没有特殊处理。</li><li><code>all</code>: 试图将元素内的字符水平排列，使其它们在竖行中占据单个字符空间。</li><li><code>digits</code>: 尝试显示一个连续的ASCII数字序列（U + 0030–U + 0039），该序列的字符数少于或等于指定的整数，以致于它在垂直行框中占据单个字符的空间。如果省略整数，则计算结果为2。2-4范围以外的整数无效。</li></ul><p>值 <code>digits</code> 目前浏览器上没有看到效果，这里预先搁置。</p><p>我们要将上述文本中的数字让其横向排列，按属性值就是将其水平排列，让其占据单个字符空间。</p><p>那么，样式文本定义就可以这样：</p><pre><code class="CSS">div{  writing-mode: vertical-rl;  letter-spacing: 1px;}div b{  text-combine-upright: all;  margin: 5px 0;}</code></pre><pre><code class="HTML">&lt;div&gt;  &lt;h1&gt;清朝&lt;/h1&gt;  &lt;p&gt;是中国历史上最后一个封建王朝，&lt;/p&gt;  &lt;p&gt;共传十二帝，&lt;/p&gt;  &lt;p&gt;统治者为满洲爱新觉罗氏。&lt;/p&gt;  &lt;p&gt;从努尔哈赤建立后金起，&lt;/p&gt;  &lt;p&gt;总计&lt;b&gt;296&lt;/b&gt;年。&lt;/p&gt;  &lt;p&gt;从皇太极改国号为清起，国祚&lt;b&gt;276&lt;/b&gt;年。&lt;/p&gt;  &lt;p&gt;建立全国性政权算起为&lt;b&gt;268&lt;/b&gt;年。&lt;/p&gt;&lt;/div&gt;</code></pre><p>对文本中的<b>标签定义<code>text-combine-upright</code>为<code>all</code>即可。</b></p><b><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87%E3%80%90%E7%AB%96%E8%A1%8C%E6%A8%AA%E4%B9%A6%E7%BB%84%E5%90%88%E3%80%91-04.jpg"></p><p>CSS text-combine-upright 竖行横书组合</p><p>虽然如此，但是，它也是有一定的局限性。</p><p>例如，我们将“数字+年”合为一起，或更多文本合为一起，就会看到段尾效果。</p><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87%E3%80%90%E7%AB%96%E8%A1%8C%E6%A8%AA%E4%B9%A6%E7%BB%84%E5%90%88%E3%80%91-05.jpg"></p><p>CSS text-combine-upright 竖行横书组合</p><p>所以，它占据单个字符空间压缩是有一定限制。</p><p>本示例于浏览器 <code>chrome87</code> 版本，详细可阅读<a href="https://drafts.csswg.org/css-writing-modes-4/#text-combine-upright">这里</a>。</p></b>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 冷知识 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冷知识之CSS篇</title>
      <link href="/My-Blogs/2021/01/08/css/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87/"/>
      <url>/My-Blogs/2021/01/08/css/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>CSS的冷知识，你又了解多少呢？</p><a id="more"></a><h3 id="文字模糊效果"><a href="#文字模糊效果" class="headerlink" title="文字模糊效果"></a>文字模糊效果</h3><p>只需要添加以下两行代码，即可达到将文字模糊处理的目的。</p><pre><code class="css">color: transparent;text-shadow: #111 0 0 5px;</code></pre><br><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87-01.png" alt="image"></p><br><h3 id="毛玻璃效果"><a href="#毛玻璃效果" class="headerlink" title="毛玻璃效果"></a>毛玻璃效果</h3><p>其实毛玻璃的模糊效果技术上比较简单，只是用到了 css 滤镜（filter）中的 blur 属性。但是要做一个好的毛玻璃效果，需要注意很多细节。下面提供一个简单示例：</p><pre><code class="css">.blur {  display: block;  width: 300px;  height: 300px;  margin: 100px auto;  filter: blur(10px);}&lt;img src="./img/test.png"class="blur"alt=""&gt;</code></pre><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87-02.png" alt="image"></p><h3 id="CSS中也可以做简单运算"><a href="#CSS中也可以做简单运算" class="headerlink" title="CSS中也可以做简单运算"></a>CSS中也可以做简单运算</h3><p>在日常开发中，我们时常会遇到这样的需求：</p><blockquote><p>左侧或者右侧宽度固定，然后剩余部分自动充满。</p></blockquote><p>可能很多小伙伴会想到用flex布局，通过设置flex:1; 使其自动充满，当然这个做法也是对的，但是我们还有更为简便的方法，那就是利用css的calc函数，示例代码如下：</p><pre><code class="css">.container {  width: calc(100% - 50px);}</code></pre><p><code>calc() </code> 函数用于动态计算长度值。</p><ul><li>需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)；</li><li>任何长度值都可以使用calc()函数进行计算；</li><li>calc()函数支持 “+”, “-“, “*”, “/“ 运算；</li><li>calc()函数使用标准的数学运算优先级规则；</li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 冷知识 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo theme cutie v2.x tutorial</title>
      <link href="/My-Blogs/2018/02/12/hexo/hexo-theme-cutie-v2-tutorial/"/>
      <url>/My-Blogs/2018/02/12/hexo/hexo-theme-cutie-v2-tutorial/</url>
      
        <content type="html"><![CDATA[<p><img src="/My-Blogs/images/tree.png" alt="$cover"></p><p>Theme cutie has evolved from v1.x to v2.x with a refreshed and fine tuned design and more features. Follow the following instruction to install and use it. You may navigate this website to experience the new look and interaction of v2.x.</p><p><strong>Thank you for your stars and support</strong>.</p><a id="more"></a><h1 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h1><h2 id="Install-for-a-new-site"><a href="#Install-for-a-new-site" class="headerlink" title="Install for a new site"></a>Install for a new site</h2><dl><dt>Prerequiste</dt><dd>Make sure you install <code>node.js</code> and <code>hexo</code> through command line. Refer to official Hexo doc for detailed instruction.</dd></dl><dl><dt>Working directory</dt><dd>Make sure your terminal (command line) is currently in the folder where you want to create the site.</dd></dl><dl><dt>Installation steps</dt><dd>The first step is the standard hexo installation step. If you have done them, skip to step 2.<br>    1. Initialize your site<br>    <code>bash     hexo init your-site-folder     cd your-site-folder     npm install     </code><br>    2. [<em>Optional</em>][<em>Recommended</em>] Uninstall <code>hexo-renderer-marked</code> and install <code>hexo-renderer-markdown-it</code> and associated plugins.<br>    <code>bash     npm un hexo-renderer-marked --save     npm i hexo-renderer-markdown-it --save     npm i markdown-it-emoji --save     npm i markdown-it-mark --save     npm i markdown-it-deflist --save     npm i markdown-it-container --save     </code></dd></dl><pre><code>3. Download [latest theme cutie](https://github.com/qutang/hexo-theme-cutie/releases/latest) and unzip it to `themes/` folder in your site. Then rename it to `cutie`.</code></pre><dl><dt>Initial configuration file</dt><dd><code>_config.yml</code> in the root path of your site.</dd></dl><dl><dt>Initial configuration</dt><dd>1. Follow standard hexo initial configuration: <a href="https://hexo.io/docs/configuration.html">https://hexo.io/docs/configuration.html</a><br>    2. Add variables or modify the variables in your <code>_config.yml</code> according to following snippet.</dd></dl><pre><code>    ```yml _config.yml    highlight:      enable: true      line_number: true      auto_detect: false      tab_replace:     markdown:      render:        html: true        xhtmlOut: false        breaks: false        linkify: true        typographer: true        quotes: '“”‘’'      plugins:        - markdown-it-abbr        - markdown-it-footnote        - markdown-it-ins        - markdown-it-sub        - markdown-it-sup        - markdown-it-deflist      anchors:        level: 1        collisionSuffix: 'v'        permalink: false        permalinkClass: header-anchor        permalinkSymbol: ""        permalinkBefore: false    date_format: ll    archive_generator:      per_page: 0      yearly: true      monthly: false      daily: false    theme: cutie    ```</code></pre><dl><dt>Bring site alive</dt><dd><code>bash     hexo s --debug     </code></dd></dl><h2 id="Install-for-an-existing-site"><a href="#Install-for-an-existing-site" class="headerlink" title="Install for an existing site"></a>Install for an existing site</h2><dl><dt>Working directory</dt><dd>Make sure your terminal (command line) is currently in the root folder of the site.</dd></dl><p>Installation steps<br>:</p><ol><li><p>[<em>Optional</em>][<em>Recommended</em>] Uninstall <code>hexo-renderer-marked</code> and install <code>hexo-renderer-markdown-it</code> and associated plugins.</p><pre><code> ```bash npm un hexo-renderer-marked --save npm i hexo-renderer-markdown-it --save npm i markdown-it-emoji --save npm i markdown-it-mark --save npm i markdown-it-deflist --save npm i markdown-it-container --save ```</code></pre></li><li><p>Download <a href="https://github.com/qutang/hexo-theme-cutie/releases/latest">latest theme cutie</a><br>and unzip it to <code>themes/</code> folder in your site. Then rename it to <code>cutie</code>.</p></li></ol><dl><dt>Initial configuration file</dt><dd><code>_config.yml</code> in the root path of your site.</dd></dl><dl><dt>Initial configuration</dt><dd>1. Follow standard hexo initial configuration: <a href="https://hexo.io/docs/configuration.html">https://hexo.io/docs/configuration.html</a><br>    2. Add variables or modify the variables in your <code>_config.yml</code> according to following snippet.</dd></dl><pre><code>    ```yml _config.yml    highlight:      enable: true      line_number: true      auto_detect: false      tab_replace:     markdown:      render:        html: true        xhtmlOut: false        breaks: false        linkify: true        typographer: true        quotes: '“”‘’'      plugins:        - markdown-it-abbr        - markdown-it-footnote        - markdown-it-ins        - markdown-it-sub        - markdown-it-sup        - markdown-it-deflist      anchors:        level: 1        collisionSuffix: 'v'        permalink: false        permalinkClass: header-anchor        permalinkSymbol: ""        permalinkBefore: false    date_format: ll    archive_generator:      per_page: 0      yearly: true      monthly: false      daily: false    theme: cutie    ```</code></pre><dl><dt>Bring site alive</dt><dd><code>bash     hexo s --debug     </code></dd></dl><h1 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h1><h2 id="From-v2-x"><a href="#From-v2-x" class="headerlink" title="From v2.x"></a>From v2.x</h2><dl><dt>Installation steps</dt><dd>1. Delete <code>themes/cutie/</code> folder in your site.<br>    2. Download the desired version of theme cutie from <a href="https://github.com/qutang/hexo-theme-cutie/releases">release page</a>, unzip it to <code>themes/</code> folder and rename it to <code>cutie</code>.</dd></dl><dl><dt>Notes</dt><dd>There is a mimimal version requirement for each configuration, make sure your installed version is above it to use the corresponding configuration.</dd></dl><h2 id="From-v1-x"><a href="#From-v1-x" class="headerlink" title="From v1.x"></a>From v1.x</h2><dl><dt>Installation steps</dt><dd>1. Delete <code>themes/cutie/</code> folder in your site.<br>    2. Download the desired version of theme cutie from <a href="https://github.com/qutang/hexo-theme-cutie/releases">release page</a>, unzip it to <code>themes/</code> folder and rename it to <code>cutie</code>.</dd></dl><dl><dt>Configuration</dt><dd>From v2.x, theme cutie uses <em>Hexo data file</em> (<code>sources/_data/cutie.yml</code>) to store all configurations, instead of using the <code>_config.yml</code> file of your site in v1.x. And the YAML structure has changed compared to v1.x. </dd></dl><pre><code>The recommendation is to configure the theme cutie from scratch using the following configuration guidelines.You may copy or reuse some configurations about theme cutie in your old `_config.yml` along the way. Please post an issue if you have hard time migrating your configurations from v1.x to v2.x.</code></pre><h1 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h1><h2 id="Language"><a href="#Language" class="headerlink" title="Language"></a>Language</h2><dl><dt>Minimal version</dt><dd><em>Taurus</em>: <code>v2.0.0-alpha</code></dd></dl><dl><dt>Configuration file</dt><dd><code>_config.yml</code> of site</dd></dl><dl><dt>Configuration format</dt><dd>Set <code>language</code> variable in your site’s <code>_config.yml</code> file.</dd></dl><pre><code>```yml _config.ymllanguage:- en- zh-cn- it```The first row will be your site's default language.</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted, the default setting is <code>en</code>. Site will be displayed in English.</dd></dl><dl><dt>Notes</dt><dd>Currently, theme cutie only supports three languages: English, Italian and 简体中文.</dd></dl><dl><dt>Contributions</dt><dd>1. Italian translation is contributed by <a href="https://github.com/Fastbyte01">@fastbyte01</a><br>    2. More translation is welcomed if you are interested in contribution. You may add new language files in <code>themes/cutie/languages</code> folder according to Hexo’s guideline: <a href="https://hexo.io/docs/internationalization.html">https://hexo.io/docs/internationalization.html</a> and feel free to send me pull request.</dd></dl><h2 id="Scheme"><a href="#Scheme" class="headerlink" title="Scheme"></a>Scheme</h2><p>This concept is from <code>hexo-theme-next</code>, the most popular theme for Hexo, in which it uses different themes for different layout design. In theme cutie, it follows the similar idea and provides the opportunity to choose different layout design using scheme.</p><dl><dt>Minimal version</dt><dd><em>Taurus</em>: <code>v2.0.0-alpha</code></dd></dl><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Set <code>scheme</code> variable to scheme name to enable a theme scheme.</dd></dl><pre><code>```yml source/_data/cutie.ymlglobal:  scheme: Taurus # Avaliable values: Taurus```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted, the default setting is <code>Taurus</code>, scheme <code>Taurus</code> is enabled.</dd></dl><dl><dt>Notes</dt><dd>Currently, theme cutie only has <code>Taurus</code> theme, which is a two-column text-icon-based layout. Contribution is welcomed from developers or designers for new schemes.</dd></dl><dl><dt>For contributors</dt><dd>1. To add a new scheme, create a new file <code>your-scheme-name.css</code> in folder <code>themes/cutie/source/css/</code> and add your own scheme style in it.<br>    2. The system will automatically search for this css file and load it using the theme name <code>your-scheme-name</code> when changing the scheme configuration to <code>your-scheme-name</code>.</dd></dl><h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><dl><dt>Minimal version</dt><dd><code>v2.0.5-beta</code></dd></dl><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Set <code>use_animation</code> to <code>true</code> or <code>false</code> to enable or disable site animations.</dd></dl><pre><code>```yml source/_data/cutie.ymlglobal:  use_animation: true # Avaliable values: true, false```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted, the default setting is <code>true</code>, animation is enabled.</dd></dl><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><p>Theme cutie uses in-site search for the site. Use following steps to setup search page. Google custom search has been discarded since <code>v2.0.7</code>.</p><dl><dt>Minimal version</dt><dd><code>v2.0.7</code></dd></dl><dl><dt>Configuration steps</dt><dd>1. No need for configuration, work out of box.<br>    2. If you are upgrading from versions below <code>v2.0.7</code>, delete the old search page you created for your site.</dd></dl><h2 id="404-Page"><a href="#404-Page" class="headerlink" title="404 Page"></a>404 Page</h2><p>Theme cutie uses built-in 404 page. It supports a custom 404 art or tencent 404 charity page (腾讯404公益).</p><dl><dt>Minimal version</dt><dd><code>v2.0.7</code></dd></dl><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration steps</dt><dd>1. Delete the old <code>404.md</code> file of your site if you are upgrading from versions before <code>v2.0.7</code>.<br>    2. No need for configuration, work out of box.<br>    3. You may configure the built-in 404 page to use 腾讯公益404 or not, by default it is NOT using 腾讯公益404.</dd></dl><pre><code>```yml source/_data/cutie.yml# set true to enable 腾讯公益404page_404:  tencent_404: true```</code></pre><h2 id="Social-network-links"><a href="#Social-network-links" class="headerlink" title="Social network links"></a>Social network links</h2><dl><dt>Minimal version</dt><dd><code>v2.0.0-alpha</code></dd></dl><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Add social network names and links in the following format. Make sure the social network name matches the corresponding font awesome icon name. See <a href="https://fontawesome.com/icons?d=gallery&amp;s=brands">here</a> for the supported names and their icons.</dd></dl><pre><code>```yml source/_data/cutie.yml# As long as the name matches the font awesome icon name, you can add even more social linkssocial:  github: https://github.com/qutang  linkedin: https://www.linkedin.com/in/qutang```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted. No icons will be shown at the bottom right corner in the footer.</dd></dl><h2 id="Site-announcement"><a href="#Site-announcement" class="headerlink" title="Site announcement"></a>Site announcement</h2><dl><dt>Minimal version</dt><dd><code>v2.0.7</code></dd></dl><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration steps</dt><dd>1. Site announcement will display at the bottom left corner of home page as a purple box.<br>    2. Add following snippets to the configuration file to use, if omitted, site announcement is disabled.</dd></dl><pre><code>```yml source/_data/cutie.ymlglobal:  announcement:    text: This is a sample site announcement.```</code></pre><dl><dt>Notes</dt><dd>* The timeout duration for site announcement is 10s. The announcement popup will dismiss on click or on timeout.<br>    * You may use HTML markups in the announcement text. For example, you may add a link to the text.</dd></dl><h2 id="Site-header"><a href="#Site-header" class="headerlink" title="Site header"></a>Site header</h2><h3 id="Setup-site-logo"><a href="#Setup-site-logo" class="headerlink" title="Setup site logo"></a>Setup site logo</h3><dl><dt>Minimal version</dt><dd><code>v2.0.0-alpha</code></dd></dl><dl><dt>Configuration file</dt><dd><code>sources/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Set variable <code>logo</code> to your own icon’s link. Link can be either an external image link, or a relative link.</dd></dl><pre><code>```yml source/_data/cutie.ymllogo: /images/logo.svg```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted. the following image will be used as the logo image.</dd></dl><pre><code>![theme-icon](/images/logo.svg)</code></pre><h3 id="Setup-site-name-and-subtitle"><a href="#Setup-site-name-and-subtitle" class="headerlink" title="Setup site name and subtitle"></a>Setup site name and subtitle</h3><dl><dt>Minimal version</dt><dd><code>v2.0.0-alpha</code></dd></dl><dl><dt>Configuration file</dt><dd><code>_config.yml</code> of your site</dd></dl><dl><dt>Configuration format</dt><dd>Make sure your subtitle is not too log (better less than 30 characters).</dd></dl><pre><code>`title` is a standard Hexo configuration.`subtitle` is theme cutie's own configuration.```yml source/_data/cutie.ymltitle: Your site's titlesubtitle: Your site's subtitle```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted. You will not see any texts in the header.</dd></dl><dl><dt>Note</dt><dd>This configuration requires restarting the server.</dd></dl><h3 id="Setup-navigation-menu"><a href="#Setup-navigation-menu" class="headerlink" title="Setup navigation menu"></a>Setup navigation menu</h3><dl><dt>Minimal version</dt><dd><code>v2.0.0-alpha</code></dd></dl><dl><dt>Configuration file</dt><dd><code>sources/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Add navigation item in the following format. link and icon can be external or internal. You can literally add any link to it.</dd></dl><pre><code>```yml source/_data/cutie.ymlmenu:  Resume:     link: /resume/  "Menu item":    link: /aaa/```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted. No text links will show up in the header navigation menu or in the dropdown menu on any view.</dd></dl><dl><dt>Notes</dt><dd>1. If there are more than four menu items, only the first four will be shown in the header (on desktop view). However, you can find all menu items in the last dropdown menu.<br>    2. Do not use a very long menu item name. No more than three words, because there is some display issue when the name gets long.<br>    3. Compared with <code>v1.x</code>, menu icon is no longer supported.</dd></dl><h2 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h2><h3 id="Use-Light-Gallery"><a href="#Use-Light-Gallery" class="headerlink" title="Use Light Gallery"></a>Use Light Gallery</h3><p>Theme cutie uses <a href="">Light Gallery</a> to support image modal display for <em>posts</em>. By default, it is enabled, but if you want to use other hexo plugins with similar functionality, you may want to disable it.</p><dl><dt>Minimal version</dt><dd><code>v2.0.5-beta</code></dd></dl><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Set <code>use_lightgallery</code> to be <code>true</code> or <code>false</code> to enable or disable light gallery display for post images.</dd></dl><pre><code>```yml source/_data/cutie.ymlpost:  use_lightgallery: true```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted, by default light gallery is enabled for all posts.</dd></dl><dl><dt>Notes</dt><dd>It is currently not supported to enable or disable light gallery for an individual post.</dd></dl><h3 id="Use-post-version"><a href="#Use-post-version" class="headerlink" title="Use post version"></a>Use post version</h3><p>Theme cutie supports versioned post. Whenever the content of your post changes after you push your site, your visitors will see an unread badge on the post card in home page and archive pages.</p><p>Theme cutie uses Hashing and Cookie to track the post content change and the post content a visitor has last read. This feature does NOT use <code>leancloud</code> backend.</p><dl><dt>Minimal version</dt><dd><code>v2.0.8</code></dd></dl><h4 id="For-all-posts"><a href="#For-all-posts" class="headerlink" title="For all posts"></a>For all posts</h4><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Set <code>enable_unread_badge</code> to be <code>true</code> to enable post versioning and unread badge or <code>false</code> to disable this feature for all the posts.</dd></dl><pre><code>```yml source/_data/cutie.yml---post:  enable_unread_badge: false---```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted, by default this feature is <strong>disabled</strong> for all posts.</dd></dl><h4 id="For-an-individual-post"><a href="#For-an-individual-post" class="headerlink" title="For an individual post"></a>For an individual post</h4><dl><dt>Configuration file</dt><dd>A post’s front matter</dd></dl><dl><dt>Configuration format</dt><dd>Set <code>enable_unread_badge</code> to be <code>true</code> to enable post versioning and unread badge or <code>false</code> to disable this feature for the individual post.</dd></dl><pre><code>```yml post's front matter---enable_unread_badge: true---```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted, the setting will roll back to the unread badge setting for all the posts.</dd></dl><dl><dt>Notes</dt><dd>This setting has higher priority than the setting for all the posts.</dd></dl><h3 id="Setup-TOC-level"><a href="#Setup-TOC-level" class="headerlink" title="Setup TOC level"></a>Setup TOC level</h3><p>*[TOC]: Table of content</p><dl><dt>Minimal version</dt><dd><code>v2.0.5-beta</code></dd></dl><h4 id="For-all-posts-1"><a href="#For-all-posts-1" class="headerlink" title="For all posts"></a>For all posts</h4><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Set <code>toc_level</code> under <code>post</code> to set the maximum level of headings in TOC for <em>all posts</em>. Allowed value is from <code>1</code> to <code>6</code>.</dd></dl><pre><code>```yml source/_data/cutie.ymlpost:  toc_level: 2```</code></pre><dl><dt>Default configuration</dt><dd>If this configuration is omitted, by default maximum TOC level is set to 2 (meaning <code>##</code> in markdown).</dd></dl><h4 id="For-an-individual-post-1"><a href="#For-an-individual-post-1" class="headerlink" title="For an individual post"></a>For an individual post</h4><dl><dt>Configuration file</dt><dd>A post’s front matter</dd></dl><dl><dt>Configuration format</dt><dd>Use variable <code>toc_level</code> to set the maximum level of headings in TOC for <em>an individual posts</em>. Allowed value is from <code>1</code> to <code>6</code>.</dd></dl><pre><code>```yml---toc_level: 2---```</code></pre><dl><dt>Default configuration</dt><dd>If variable is omitted in the post front matter, setting will fall back to the <a href="#for-all-posts">all-post-toc-setting</a>.</dd></dl><h3 id="Setup-post-comment"><a href="#Setup-post-comment" class="headerlink" title="Setup post comment"></a>Setup post comment</h3><dl><dt>Minimal version</dt><dd><code>v2.0.5-beta</code></dd></dl><h4 id="For-all-posts-2"><a href="#For-all-posts-2" class="headerlink" title="For all posts"></a>For all posts</h4><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Set <code>allow_comment</code> to be <code>true</code> or <code>false</code> to enable or disable comment section to be displayed for <em>all posts</em>.</dd></dl><pre><code>```yml source/_data/cutie.ymlpost:  allow_comment: true```</code></pre><dl><dt>Default configuration</dt><dd>If this configuration is omitted, by default comment section is enabled for all posts.</dd></dl><h4 id="For-an-individual-post-2"><a href="#For-an-individual-post-2" class="headerlink" title="For an individual post"></a>For an individual post</h4><dl><dt>Configuration file</dt><dd>A post’s front matter</dd></dl><dl><dt>Configuration format</dt><dd>Use variable <code>allow_comment</code> to enable or disable comment section.</dd></dl><pre><code>```yml---allow_comment: true---```</code></pre><dl><dt>Default configuration</dt><dd>If variable is omitted in the post front matter, setting will fall back to the <a href="#for-all-posts-v2">all-post-comment-setting</a>.</dd></dl><h3 id="Setup-post-copyright"><a href="#Setup-post-copyright" class="headerlink" title="Setup post copyright"></a>Setup post copyright</h3><dl><dt>Minimal version</dt><dd><code>v2.0.5-beta</code></dd></dl><p>Theme cutie uses Creative Commons licenses for copyright configuration. We use three nested variables to cover the major licenses in Creative Commons.</p><ul><li><code>allow_share</code>: allow post to be shared (<code>true</code>) or not (<code>false</code>).<ul><li><code>allow_modification</code>: allow post to be modified while sharing when <code>true</code>.</li><li><code>allow_commercial</code>: allow post to be used for commercial purpose while sharing when <code>true</code>.</li></ul></li></ul><p>if <code>allow_share</code> is <code>false</code>, the other two variables will be ignored.</p><h4 id="For-all-posts-3"><a href="#For-all-posts-3" class="headerlink" title="For all posts"></a>For all posts</h4><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Use the three variables under <code>post</code> to configure the all-post copyright setting.</dd></dl><pre><code>```yml source/_data/cutie.ymlpost:  allow_share: true  allow_modification: false  allow_commercial: false```</code></pre><dl><dt>Default configuration</dt><dd>If any of these configurations is omitted, the default setting for each one will fall back to following settings,<br>    * <code>allow_share: true</code>, by default allowing sharing all posts.<br>        * <code>allow_modification: false</code>, by default post is not allowed to be modified while sharing.<br>        * <code>allow_commercial: false</code>, by default post is not allowed to be used for commercial purposes while sharing.</dd></dl><pre><code>The corresponding default Creative Commons license is _CC BY-NC-ND 4.0_.</code></pre><h4 id="For-an-individual-post-3"><a href="#For-an-individual-post-3" class="headerlink" title="For an individual post"></a>For an individual post</h4><dl><dt>Configuration file</dt><dd>A post’s front matter</dd></dl><dl><dt>Configuration format</dt><dd>Use the same three variables to configure copyright setting for a specific post.</dd></dl><pre><code>```yml---allow_share: trueallow_modification: falseallow_commercial: false---```</code></pre><dl><dt>Default configuration</dt><dd>If any of these variables is omitted in the post front matter, setting will fall back to the <a href="#for-all-posts-v3">all-post copyright setting</a>.</dd></dl><h3 id="Enable-post-visit-and-comment-counts"><a href="#Enable-post-visit-and-comment-counts" class="headerlink" title="Enable post visit and comment counts"></a>Enable post visit and comment counts</h3><dl><dt>Minimal version</dt><dd><code>v2.0.5-beta</code></dd></dl><dl><dt>Prerequiste</dt><dd>This functionality only works when you use <code>valine</code> as <a href="#comment-systems">comment system</a> and use <code>leancloud</code> as backend.</dd></dl><dl><dt>Configuration steps</dt><dd>1. Configure <code>valine</code> comment system as described <a href="#configuration-for-valine-comment-system">here</a>.<br>    2. You are all set and post visit counts and post comment counts will appear in all related pages.</dd></dl><dl><dt>Notes</dt><dd>* <em>If backend is not set up properly, icons that show post visit and comment counts will be hidden.</em><br>    * Post visit counts only <strong>unique</strong> visitors (meaning visitors with unique IPs).</dd></dl><h3 id="Enable-post-thumb-up"><a href="#Enable-post-thumb-up" class="headerlink" title="Enable post thumb up"></a>Enable post thumb up</h3><dl><dt>Minimal version</dt><dd><code>v2.1.0</code></dd></dl><dl><dt>Prerequiste</dt><dd>This functionality only works when you use <code>valine</code> as <a href="#comment-systems">comment system</a> and use <code>leancloud</code> as backend.</dd></dl><dl><dt>Configuration steps</dt><dd>1. Configure <code>valine</code> comment system as described <a href="#configuration-for-valine-comment-system">here</a>.<br>    2. You are all set and post thumb up and thumb up counts will appear in all related pages.</dd></dl><dl><dt>Notes</dt><dd>* <em>If backend is not set up properly, icons that show post thumbup status and counts will be hidden.</em><br>    * Post thumb up counts only <strong>unique</strong> visitors (meaning visitors with unique IPs).</dd></dl><h3 id="Use-post-announcement"><a href="#Use-post-announcement" class="headerlink" title="Use post announcement"></a>Use post announcement</h3><dl><dt>Minimal version</dt><dd><code>v2.0.7</code></dd></dl><dl><dt>Configuration file</dt><dd>post’s front matter</dd></dl><dl><dt>Configuration steps</dt><dd>Use following snippet to add your post annoucement</dd></dl><pre><code>```yml post's front matter---announcement:  text: This is a sample post announcement!---```</code></pre><dl><dt>Notes</dt><dd>* The default timeout for the announcement is 10 seconds. Note configurable for now.<br>    * You may use HTML markups in the announcement text.</dd></dl><h3 id="Set-post-excerpt"><a href="#Set-post-excerpt" class="headerlink" title="Set post excerpt"></a>Set post excerpt</h3><p>The post excerpt, displayed in the index page card on hover, may be manually set through front matter or adding the <code>&lt;!-- more --&gt;</code> tag plugin in the post.</p><dl><dt>Minimal version</dt><dd><code>v2.0.11</code></dd></dl><dl><dt>Configuration file</dt><dd>post’s front matter, or tag plugin</dd></dl><dl><dt>Configuration waterfall</dt><dd><code>abstract</code> variable in the front matter has the highest priority if set.</dd></dl><pre><code>```yml post's front matter---abstract: A sample excerpt.---```If `abstract` is not set, theme cutie will search `&lt;!-- more --&gt;` tag in the post content to identify the excerpt section and cut off the first 150 characters to be used as excerpt.If both `abstract` and `&lt;!-- more --&gt;` are omitted, theme cutie will automatically chunk the first 150 characters in the post content to be used as excerpt.</code></pre><h3 id="Set-post-icon"><a href="#Set-post-icon" class="headerlink" title="Set post icon"></a>Set post icon</h3><p>The post icon, displayed on the top left cornder of the index page card, may be manually set through front matter in the post.</p><dl><dt>Minimal version</dt><dd><code>v2.0.0</code></dd></dl><dl><dt>Configuration file</dt><dd>post’s front matter</dd></dl><dl><dt>Configuration waterfall</dt><dd>If <code>icon</code> variable in the post front matter is set, the system will use this icon for post.</dd></dl><pre><code>```yml post's front matter---icon: /your/post/icon/path---```I recommend you to use absolute path (starting with `/`) for the image path.If `icon` variable is not set, but post belongs to category `notes` or `projects`, the system will use the default category icon for the post.If both conditions are not satisified, the system will use a randomly generated texture image for the post.</code></pre><h2 id="Icon-sets"><a href="#Icon-sets" class="headerlink" title="Icon sets"></a>Icon sets</h2><h3 id="Select-an-icon-set"><a href="#Select-an-icon-set" class="headerlink" title="Select an icon set"></a>Select an icon set</h3><dl><dt>Minimal version</dt><dd><code>v2.0.5-beta</code></dd></dl><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Change icon set by changing the name of the icon set in the following snippet. There are three available icon sets in the theme by default: <code>blue-line</code>, <code>blue-shadow</code>, and <code>colorful-outlined</code>.</dd></dl><pre><code>```yml source/_data/cutie.ymlglobal:  icon_set: blue-line # Available values in theme: blue-line, blue-shadow, colorful-outlined```</code></pre><dl><dt>Default configuration</dt><dd><code>blue-line</code></dd></dl><p>Illustration</p><h3 id="Add-a-new-icon-set"><a href="#Add-a-new-icon-set" class="headerlink" title="Add a new icon set"></a>Add a new icon set</h3><dl><dt>Minimal version</dt><dd><code>v2.0.5-beta</code></dd></dl><dl><dt>Configuration path</dt><dd><code>source/images/</code></dd></dl><dl><dt>Configuration steps</dt><dd>1. Create a folder named <code>icons</code> in <code>source/images/</code> folder.<br>    2. Create an icon set folder <code>icon-set-name</code>(change it to your desired name) in <code>source/images/icons/</code> folder.<br>    3. Add your own four icons (keep the filename consistent) in <code>svg</code> format to <code>source/images/icons/icon-set-name/</code> folder.<br>        1. <code>search.svg</code><br>        2. <code>archive.svg</code><br>        3. <code>menu.svg</code><br>        4. <code>toc.svg</code><br>    4. Use your new icon set name <code>icon-set-name</code> in <a href="#select-an-existing-icon-set">Select an existing icon set</a></dd></dl><h2 id="Comment-systems"><a href="#Comment-systems" class="headerlink" title="Comment systems"></a>Comment systems</h2><h3 id="Select-comment-systems"><a href="#Select-comment-systems" class="headerlink" title="Select comment systems"></a>Select comment systems</h3><dl><dt>Minimal version</dt><dd><code>v2.0.0-alpha</code></dd></dl><dl><dt>User configuration location</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd><code>yml comment system     global:       comment_system: valine # Available values: valine, gitment, disqus     </code></dd></dl><dl><dt>Possible values</dt><dd><code>valine</code>(default), <code>gitment</code>, <code>disqus</code>, <code>livere</code></dd></dl><p>After selecting one of the comment systems, you need to further configure it.</p><h3 id="Configuration-for-valine-comment-system"><a href="#Configuration-for-valine-comment-system" class="headerlink" title="Configuration for valine comment system"></a>Configuration for valine comment system</h3><dl><dt>Minimal version</dt><dd><code>v2.0.0-alpha</code></dd></dl><dl><dt>User configuration location</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd><code>yml valine configuration     valine:       appId:       appKey:       placeholder:     </code><br>    See <a href="https://valine.js.org/">https://valine.js.org</a> to setup the backend and fill the values.</dd></dl><dl><dt>Default values</dt><dd>No default values, must fill if using the system.</dd></dl><h3 id="Configuration-for-gitment-comment-system"><a href="#Configuration-for-gitment-comment-system" class="headerlink" title="Configuration for gitment comment system"></a>Configuration for gitment comment system</h3><dl><dt>Minimal version</dt><dd><code>v2.0.0-alpha</code></dd></dl><dl><dt>User configuration location</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd><code>yml gitment configuration     gitment:       owner:       repo:       client_id:       client_secret:     </code><br>    See <a href="https://github.com/imsun/gitment">https://github.com/imsun/gitment</a> to setup the backend and fill the values.</dd></dl><dl><dt>Default values</dt><dd>No default values, must fill if using the system.</dd></dl><h3 id="Configuration-for-Disqus-comment-system"><a href="#Configuration-for-Disqus-comment-system" class="headerlink" title="Configuration for Disqus comment system"></a>Configuration for Disqus comment system</h3><dl><dt>Minimal version</dt><dd><code>v2.0.0-alpha</code></dd></dl><dl><dt>User configuration location</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd><code>yml disqus configuration     disqus:       shortname:     </code><br>    See <a href="https://help.disqus.com/customer/portal/articles/466208-what-s-a-shortname-">https://help.disqus.com/customer/portal/articles/466208-what-s-a-shortname-</a> to setup the backend and fill the value.</dd></dl><dl><dt>Default values</dt><dd>No default values, must fill if using the system.</dd></dl><h3 id="Configuration-for-Livere-comment-system"><a href="#Configuration-for-Livere-comment-system" class="headerlink" title="Configuration for Livere comment system"></a>Configuration for Livere comment system</h3><dl><dt>Minimal version</dt><dd><code>v2.0.11</code></dd></dl><dl><dt>User configuration location</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd><code>yml livere configuration     livere:       id: 'city' # use 'city' if using free version or `premium` if using paid version       uid:      </code><br>    The <code>uid</code> is the string you will see in the snippet provided by livere during installation, as shown in the following screenshot.</dd></dl><pre><code>![Livere setup screenshot](livere_setup.png)</code></pre><dl><dt>Default values</dt><dd>No default values, must fill if using the system.</dd></dl>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> cutie </tag>
            
            <tag> tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typography and tags</title>
      <link href="/My-Blogs/2017/12/20/hexo/Typography%20and%20tags/"/>
      <url>/My-Blogs/2017/12/20/hexo/Typography%20and%20tags/</url>
      
        <content type="html"><![CDATA[<p><img src="/My-Blogs/images/lake.png" alt="$cover"></p><h1 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h1><hr><p>This post uses <code>hexo-renderer-markdown-it</code> plugin as markdown processor, so please install it to achieve the effect.</p><pre><code class="bash">npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --savenpm i markdown-it-emoji --savenpm i markdown-it-mark --savenpm i markdown-it-deflist --savenpm i markdown-it-container --save</code></pre><h1 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h1><p>Add following to <code>_config.yml</code> of your site.</p><pre><code class="yml">markdown:  render:    html: true    xhtmlOut: false    breaks: false    linkify: true    typographer: true    quotes: '“”‘’'  plugins:    - markdown-it-abbr    - markdown-it-footnote    - markdown-it-ins    - markdown-it-sub    - markdown-it-sup    - markdown-it-deflist  anchors:    level: 2    collisionSuffix: 'v'    permalink: false    permalinkClass: header-anchor    permalinkSymbol: " "    permalinkBefore: false</code></pre><h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><hr><h2 id="Headings"><a href="#Headings" class="headerlink" title="Headings"></a>Headings</h2><pre><code class="markdown"># h1 Heading 8-)## h2 Heading### h3 Heading#### h4 Heading##### h5 Heading###### h6 Heading</code></pre><h1 id="h1-Heading-8"><a href="#h1-Heading-8" class="headerlink" title="h1 Heading 8-)"></a>h1 Heading 8-)</h1><h2 id="h2-Heading"><a href="#h2-Heading" class="headerlink" title="h2 Heading"></a>h2 Heading</h2><h3 id="h3-Heading"><a href="#h3-Heading" class="headerlink" title="h3 Heading"></a>h3 Heading</h3><h4 id="h4-Heading"><a href="#h4-Heading" class="headerlink" title="h4 Heading"></a>h4 Heading</h4><h5 id="h5-Heading"><a href="#h5-Heading" class="headerlink" title="h5 Heading"></a>h5 Heading</h5><h6 id="h6-Heading"><a href="#h6-Heading" class="headerlink" title="h6 Heading"></a>h6 Heading</h6><h2 id="Horizontal-Rules"><a href="#Horizontal-Rules" class="headerlink" title="Horizontal Rules"></a>Horizontal Rules</h2><pre><code class="markdown">___---***</code></pre><hr><hr><hr><h2 id="Typographic-replacements"><a href="#Typographic-replacements" class="headerlink" title="Typographic replacements"></a>Typographic replacements</h2><pre><code class="markdown">(c) (C) (r) (R) (tm) (TM) (p) (P) +-test.. test... test..... test?..... test!....!!!!!! ???? ,,  -- ---"Smartypants, double quotes" and 'single quotes'</code></pre><p>(c) (C) (r) (R) (tm) (TM) (p) (P) +-</p><p>test.. test… test….. test?….. test!….</p><p>!!!!!! ???? ,,  – —</p><p>“Smartypants, double quotes” and ‘single quotes’</p><h2 id="Emphasis"><a href="#Emphasis" class="headerlink" title="Emphasis"></a>Emphasis</h2><pre><code class="markdown">**This is bold text**__This is bold text__*This is italic text*_This is italic text_~~Strikethrough~~</code></pre><p><strong>This is bold text</strong></p><p><strong>This is bold text</strong></p><p><em>This is italic text</em></p><p><em>This is italic text</em></p><p><del>Strikethrough</del></p><h2 id="Blockquotes"><a href="#Blockquotes" class="headerlink" title="Blockquotes"></a>Blockquotes</h2><pre><code class="markdown">&gt; Blockquotes can also be nested...&gt;&gt; ...by using additional greater-than signs right next to each other...&gt; &gt; &gt; ...or with spaces between arrows.</code></pre><blockquote><p>Blockquotes can also be nested…</p><blockquote><p>…by using additional greater-than signs right next to each other…</p><blockquote><p>…or with spaces between arrows.</p></blockquote></blockquote></blockquote><h2 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h2><h3 id="Unordered"><a href="#Unordered" class="headerlink" title="Unordered"></a>Unordered</h3><pre><code class="markdown">+ Create a list by starting a line with `+`, `-`, or `*`+ Sub-lists are made by indenting 2 spaces:  - Marker character change forces new list start:    * Ac tristique libero volutpat at    + Facilisis in pretium nisl aliquet    - Nulla volutpat aliquam velit+ Very easy!</code></pre><ul><li>Create a list by starting a line with <code>+</code>, <code>-</code>, or <code>*</code></li><li>Sub-lists are made by indenting 2 spaces:<ul><li>Marker character change forces new list start:<ul><li>Ac tristique libero volutpat at</li></ul><ul><li>Facilisis in pretium nisl aliquet</li></ul><ul><li>Nulla volutpat aliquam velit</li></ul></li></ul></li><li>Very easy!</li></ul><h3 id="Ordered"><a href="#Ordered" class="headerlink" title="Ordered"></a>Ordered</h3><pre><code class="markdown">1. Lorem ipsum dolor sit amet  1. Indented list    1. Another level  2. Indent2. Consectetur adipiscing elit3. Integer molestie lorem at massa</code></pre><ol><li>Lorem ipsum dolor sit amet</li><li>Indented list<ol><li>Another level</li></ol></li><li>Indent</li><li>Consectetur adipiscing elit</li><li>Integer molestie lorem at massa</li></ol><pre><code class="markdown">1. You can use sequential numbers...1. ...or keep all the numbers as `1.`</code></pre><ol><li>You can use sequential numbers…</li><li>…or keep all the numbers as <code>1.</code></li></ol><h4 id="Start-numbering-with-offset"><a href="#Start-numbering-with-offset" class="headerlink" title="Start numbering with offset:"></a>Start numbering with offset:</h4><pre><code class="markdown">57. foo1. bar</code></pre><ol start="57"><li>foo</li><li>bar</li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="markdown">Inline `code`</code></pre><p>Inline <code>code</code></p><h3 id="Indented-code"><a href="#Indented-code" class="headerlink" title="Indented code"></a>Indented code</h3><pre><code class="markdown">// Some comments    line 1 of code    line 2 of code    line 3 of code</code></pre><pre><code>// Some commentsline 1 of codeline 2 of codeline 3 of code</code></pre><h3 id="Block-code-“fences”"><a href="#Block-code-“fences”" class="headerlink" title="Block code “fences”"></a>Block code “fences”</h3><pre><code class="markdown">```Sample text here...```</code></pre><pre><code>Sample text here...</code></pre><p>Syntax highlighting</p><pre><code class="markdown">``` js sample.jsvar foo = function (bar) {  return bar++;};console.log(foo(5));```</code></pre><pre><code class="js">var foo = function (bar) {  return bar++;};console.log(foo(5));</code></pre><h2 id="Tables"><a href="#Tables" class="headerlink" title="Tables"></a>Tables</h2><pre><code class="markdown">| Option | Description |Description | Description | Description | Description || ------ | ----------- |----------- | ----------- | ----------- | ----------- || data   | path to data files to supply the data that will be passed into templates. || engine | engine to be used for processing templates. Handlebars is the default. || ext    | extension to be used for dest files. |</code></pre><table><thead><tr><th>Option</th><th>Description</th><th>Description</th><th>Description</th><th>Description</th><th>Description</th></tr></thead><tbody><tr><td>data</td><td>path to data files to supply the data that will be passed into templates.</td><td></td><td></td><td></td><td></td></tr><tr><td>engine</td><td>engine to be used for processing templates. Handlebars is the default.</td><td></td><td></td><td></td><td></td></tr><tr><td>ext</td><td>extension to be used for dest files.</td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="Right-aligned-columns"><a href="#Right-aligned-columns" class="headerlink" title="Right aligned columns"></a>Right aligned columns</h3><pre><code class="markdown">| Option | Description || ------:| -----------:|| data   | path to data files to supply the data that will be passed into templates. || engine | engine to be used for processing templates. Handlebars is the default. || ext    | extension to be used for dest files. |</code></pre><table><thead><tr><th align="right">Option</th><th align="right">Description</th></tr></thead><tbody><tr><td align="right">data</td><td align="right">path to data files to supply the data that will be passed into templates.</td></tr><tr><td align="right">engine</td><td align="right">engine to be used for processing templates. Handlebars is the default.</td></tr><tr><td align="right">ext</td><td align="right">extension to be used for dest files.</td></tr></tbody></table><h2 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h2><pre><code class="markdown">[link text](http://dev.nodeca.com)</code></pre><p><a href="http://dev.nodeca.com/">link text</a></p><pre><code class="markdown">[link with title](http://nodeca.github.io/pica/demo/ "title text!")</code></pre><p><a href="http://nodeca.github.io/pica/demo/" title="title text!">link with title</a></p><pre><code class="markdown">Autoconverted link https://github.com/nodeca/pica (enabled linkify)</code></pre><p>Autoconverted link <a href="https://github.com/nodeca/pica">https://github.com/nodeca/pica</a> (enabled linkify)</p><h2 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h2><pre><code class="markdown">![Minion](https://octodex.github.com/images/minion.png)![Stormtroopocat](https://octodex.github.com/images/stormtroopocat.jpg "The Stormtroopocat")</code></pre><p><img src="https://octodex.github.com/images/minion.png" alt="Minion"><br><img src="https://octodex.github.com/images/stormtroopocat.jpg" alt="Stormtroopocat" title="The Stormtroopocat"></p><p>Like links, Images also have a footnote style syntax</p><pre><code class="markdown">![Alt text][id]With a reference later in the document defining the URL location:[id]: https://octodex.github.com/images/dojocat.jpg  "The Dojocat"</code></pre><p><img src="https://octodex.github.com/images/dojocat.jpg" alt="Alt text" title="The Dojocat"></p><p>With a reference later in the document defining the URL location:</p><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p>The killer feature of <code>markdown-it</code> is very effective support of<br><a href="https://www.npmjs.org/browse/keyword/markdown-it-plugin">syntax plugins</a>. The sample <a href="#configuration">configuration snippet</a></p><h3 id="Emojies"><a href="#Emojies" class="headerlink" title="Emojies"></a><a href="https://github.com/markdown-it/markdown-it-emoji">Emojies</a></h3><pre><code class="markdown">Classic markup: :wink: :crush: :cry: :tear: :laughing: :yum:Shortcuts (emoticons): :-) :-( 8-) ;)</code></pre><p>Classic markup: <span class="github-emoji"><span>😉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f609.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> :crush: <span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> :tear: <span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>Shortcuts (emoticons): :-) :-( 8-) ;)</p><h3 id="Subscript-Superscript"><a href="#Subscript-Superscript" class="headerlink" title="Subscript / Superscript"></a><a href="https://github.com/markdown-it/markdown-it-sub">Subscript</a> / <a href="https://github.com/markdown-it/markdown-it-sup">Superscript</a></h3><pre><code class="markdown">Superscript: 19^th^Subscript: H~2~O</code></pre><p>Superscript: 19^th^</p><p>Subscript: H<del>2</del>O</p><h3 id="lt-ins-gt"><a href="#lt-ins-gt" class="headerlink" title="<ins>"></a><a href="https://github.com/markdown-it/markdown-it-ins">&lt;ins&gt;</a></h3><pre><code class="markdown">++Inserted text++</code></pre><p>++Inserted text++</p><h3 id="lt-mark-gt"><a href="#lt-mark-gt" class="headerlink" title="<mark>"></a><a href="https://github.com/markdown-it/markdown-it-mark">&lt;mark&gt;</a></h3><pre><code class="markdown">==Marked text==</code></pre><p>==Marked text==</p><h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a><a href="https://github.com/markdown-it/markdown-it-footnote">Footnotes</a></h3><pre><code class="markdown">Footnote 1 link[^first].Footnote 2 link[^second].Inline footnote^[Text of inline footnote] definition.Duplicated footnote reference[^second].[^first]: Footnote **can have markup**    and multiple paragraphs.[^second]: Footnote text.</code></pre><p>Footnote 1 link[^first].</p><p>Footnote 2 link[^second].</p><p>Inline footnote^[Text of inline footnote] definition.</p><p>Duplicated footnote reference[^second].</p><p>[^first]: Footnote <strong>can have markup</strong></p><pre><code>and multiple paragraphs.</code></pre><p>[^second]: Footnote text.</p><h3 id="Definition-lists"><a href="#Definition-lists" class="headerlink" title="Definition lists"></a><a href="https://github.com/markdown-it/markdown-it-deflist">Definition lists</a></h3><pre><code class="markdown">Term 1:   Definition 1with lazy continuation.</code></pre><dl><dt>Term 1</dt><dd>Definition 1<br>with lazy continuation.</dd></dl><pre><code class="markdown">Term 2 with *inline markup*:   Definition 2        { some code, part of Definition 2 }    Third paragraph of definition 2.</code></pre><dl><dt>Term 2 with <em>inline markup</em></dt><dd>Definition 2</dd></dl><pre><code>    { some code, part of Definition 2 }Third paragraph of definition 2.</code></pre><p><em>Compact style:</em></p><pre><code class="markdown">Term 1  ~ Definition 1Term 2  ~ Definition 2a  ~ Definition 2b</code></pre><p>Term 1<br>  ~ Definition 1</p><p>Term 2<br>  ~ Definition 2a<br>  ~ Definition 2b</p><h3 id="Abbreviations"><a href="#Abbreviations" class="headerlink" title="Abbreviations"></a><a href="https://github.com/markdown-it/markdown-it-abbr">Abbreviations</a></h3><pre><code class="markdown">This is HTML abbreviation example.It converts "HTML", but keep intact partial entries like "xxxHTMLyyy" and so on.*[HTML]: Hyper Text Markup Language</code></pre><p>This is HTML abbreviation example.</p><p>It converts “HTML”, but keep intact partial entries like “xxxHTMLyyy” and so on.</p><p>*[HTML]: Hyper Text Markup Language</p><h3 id="Custom-containers"><a href="#Custom-containers" class="headerlink" title="Custom containers"></a><a href="https://github.com/markdown-it/markdown-it-container">Custom containers</a></h3><p>::: warning<br><em>here be dragons</em><br>:::</p><h2 id="Hexo-Built-in-Tags"><a href="#Hexo-Built-in-Tags" class="headerlink" title="Hexo Built-in Tags"></a>Hexo Built-in Tags</h2><h3 id="Blockquote-with-author"><a href="#Blockquote-with-author" class="headerlink" title="Blockquote with author"></a>Blockquote with author</h3><pre><code class="swig">{% blockquote David Levithan, Wide Awake %}Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.{% endblockquote %}</code></pre><blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p><footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote><h3 id="Blockquote-for-twitter"><a href="#Blockquote-for-twitter" class="headerlink" title="Blockquote for twitter"></a>Blockquote for twitter</h3><pre><code class="swig">{% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %}NEW: DevDocs now comes with syntax highlighting. http://devdocs.io{% endblockquote %}</code></pre><blockquote><p>NEW: DevDocs now comes with syntax highlighting. <a href="http://devdocs.io/">http://devdocs.io</a></p><footer><strong>@DevDocs</strong><cite><a href="https://twitter.com/devdocs/status/356095192085962752">twitter.com/devdocs/status/356095192085962752</a></cite></footer></blockquote><h3 id="Blockquote-for-weblink"><a href="#Blockquote-for-weblink" class="headerlink" title="Blockquote for weblink"></a>Blockquote for weblink</h3><pre><code class="swig">{% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %}Every interaction is both precious and an opportunity to delight.{% endblockquote %}</code></pre><blockquote><p>Every interaction is both precious and an opportunity to delight.</p><footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html">Welcome to Island Marketing</a></cite></footer></blockquote><h3 id="Pull-Quotes"><a href="#Pull-Quotes" class="headerlink" title="Pull Quotes"></a>Pull Quotes</h3><pre><code class="swig">{% pullquote %}content{% endpullquote %}</code></pre><blockquote class="pullquote"><p>content</p></blockquote><h3 id="jsFiddle"><a href="#jsFiddle" class="headerlink" title="jsFiddle"></a>jsFiddle</h3><pre><code class="swig">{% jsfiddle o2gxgz9r default light %}</code></pre><iframe scrolling="no" width="100%" height="300" src="https://jsfiddle.net/o2gxgz9r/embedded/js,resources,html,css,result/light" frameborder="0" loading="lazy" allowfullscreen=""></iframe><h3 id="Gist"><a href="#Gist" class="headerlink" title="Gist"></a>Gist</h3><pre><code class="swig">{% gist b6365e79be6052e7531e7ba6ea8caf23 'Sample gist' %}</code></pre><script src="//gist.github.com/b6365e79be6052e7531e7ba6ea8caf23.js?file=Sample gist"></script><h3 id="iFrame"><a href="#iFrame" class="headerlink" title="iFrame"></a>iFrame</h3><pre><code class="swig">{% iframe https://www.bing.com %}</code></pre><iframe src="https://www.bing.com/" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen=""></iframe><h3 id="Link-to-open-in-new-tab"><a href="#Link-to-open-in-new-tab" class="headerlink" title="Link to open in new tab"></a>Link to open in new tab</h3><pre><code class="swig">{% link Google https://www.google.com default Google %}</code></pre><a href="https://www.google.com/" title="default Google" target="">Google</a><h3 id="Youtube"><a href="#Youtube" class="headerlink" title="Youtube"></a>Youtube</h3><pre><code class="swig">{% youtube l_lblj8Cq0o %}</code></pre><div class="video-container"><iframe src="https://www.youtube.com/embed/l_lblj8Cq0o" frameborder="0" loading="lazy" allowfullscreen=""></iframe></div>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typography </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tag Plugins</title>
      <link href="/My-Blogs/2013/12/25/hexo/tag-plugins/"/>
      <url>/My-Blogs/2013/12/25/hexo/tag-plugins/</url>
      
        <content type="html"><![CDATA[<p>This post is used for testing tag plugins. See <a href="http://zespia.tw/hexo/docs/tag-plugins.html">docs</a> for more info.</p><h2 id="Block-Quote"><a href="#Block-Quote" class="headerlink" title="Block Quote"></a>Block Quote</h2><h3 id="Normal-blockquote"><a href="#Normal-blockquote" class="headerlink" title="Normal blockquote"></a>Normal blockquote</h3><blockquote><p>Praesent diam elit, interdum ut pulvinar placerat, imperdiet at magna.</p></blockquote><h3 id="Quote-from-a-book"><a href="#Quote-from-a-book" class="headerlink" title="Quote from a book"></a>Quote from a book</h3><blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p><footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote><h3 id="Quote-from-Twitter"><a href="#Quote-from-Twitter" class="headerlink" title="Quote from Twitter"></a>Quote from Twitter</h3><blockquote><p>NEW: DevDocs now comes with syntax highlighting. <a href="http://devdocs.io/">http://devdocs.io</a></p><footer><strong>@DevDocs</strong><cite><a href="https://twitter.com/devdocs/status/356095192085962752">twitter.com/devdocs/status/356095192085962752</a></cite></footer></blockquote><h3 id="Quote-from-an-article-on-the-web"><a href="#Quote-from-an-article-on-the-web" class="headerlink" title="Quote from an article on the web"></a>Quote from an article on the web</h3><blockquote><p>Every interaction is both precious and an opportunity to delight.</p><footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html">Welcome to Island Marketing</a></cite></footer></blockquote><h2 id="Code-Block"><a href="#Code-Block" class="headerlink" title="Code Block"></a>Code Block</h2><h3 id="Normal-code-block"><a href="#Normal-code-block" class="headerlink" title="Normal code block"></a>Normal code block</h3><pre><code>alert('Hello World!');</code></pre><h3 id="With-caption"><a href="#With-caption" class="headerlink" title="With caption"></a>With caption</h3><pre><code>array.map(callback[, thisArg])</code></pre><h3 id="With-caption-and-URL"><a href="#With-caption-and-URL" class="headerlink" title="With caption and URL"></a>With caption and URL</h3><pre><code>.compact([0, 1, false, 2, ‘’, 3]);=&gt; [1, 2, 3]</code></pre><h3 id="With-marked-lines"><a href="#With-marked-lines" class="headerlink" title="With marked lines"></a>With marked lines</h3><p>Line 1,7-8,10 should be marked with different color.</p><pre><code>const http = require('http');const hostname = '127.0.0.1';const port = 1337;http.createServer((req, res) =&gt; {  res.writeHead(200, { 'Content-Type': 'text/plain' });  res.end('Hello World\n');}).listen(port, hostname, () =&gt; {  console.log(`Server running at http://${hostname}:${port}/`);});</code></pre><p>Note: Theme’s style should support <code>.highlight.line.marked</code> (recommend to use the selection or current line color).</p><h3 id="Gist"><a href="#Gist" class="headerlink" title="Gist"></a>Gist</h3><script src="//gist.github.com/996818.js"></script><h3 id="jsFiddle"><a href="#jsFiddle" class="headerlink" title="jsFiddle"></a>jsFiddle</h3><iframe scrolling="no" width="100%" height="300" src="https://jsfiddle.net/ccWP7/embedded/js,resources,html,css,result/light" frameborder="0" loading="lazy" allowfullscreen=""></iframe><h2 id="Pullquote"><a href="#Pullquote" class="headerlink" title="Pullquote"></a>Pullquote</h2><h3 id="Left"><a href="#Left" class="headerlink" title="Left"></a>Left</h3><blockquote class="pullquote left"><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p></blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas tempus molestie arcu, et fringilla mauris placerat ac. Nullam luctus bibendum risus. Ut cursus sed ipsum feugiat egestas. Suspendisse elementum, velit eu consequat consequat, augue lorem dapibus libero, eget pulvinar dolor est sit amet nulla. Suspendisse a porta tortor, et posuere mi. Pellentesque ultricies, mi quis volutpat malesuada, erat felis vulputate nisl, ac congue ante tortor ut ante. Proin aliquam sem vel mauris tincidunt, eget scelerisque tortor euismod. Nulla tincidunt enim nec commodo dictum. Mauris id sapien et orci gravida luctus id ut dui. In vel vulputate odio. Duis vel turpis molestie, scelerisque enim eu, lobortis eros. Cras at ipsum gravida, sagittis ante vel, viverra tellus. Nunc mauris turpis, elementum ullamcorper nisl pretium, ultrices cursus justo. Mauris porttitor commodo eros, ac ornare orci interdum in. Cras fermentum cursus leo sed mattis. In dignissim lorem sem, sit amet elementum mauris venenatis ac.</p><h3 id="Right"><a href="#Right" class="headerlink" title="Right"></a>Right</h3><blockquote class="pullquote right"><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p></blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed ligula justo, lobortis sit amet semper vel, dignissim sit amet libero. Praesent ac tempus ligula. Maecenas at gravida odio. Etiam tristique volutpat lacus eu faucibus. Donec non tempus arcu. Phasellus adipiscing, mauris nec mollis egestas, ipsum nunc auctor velit, et rhoncus lorem ipsum at ante. Praesent et sem in velit volutpat auctor. Duis vel mauris nulla. Maecenas mattis interdum ante, quis sagittis nibh cursus et. Nulla facilisi. Morbi convallis gravida tortor, ut fermentum enim gravida et. Nunc vel dictum nisl, non ultrices libero. Proin vestibulum felis eget orci consectetur lobortis. Vestibulum augue nulla, iaculis vitae augue vehicula, dignissim ultrices libero. Sed imperdiet urna et quam ultrices tincidunt nec ac magna. Etiam vel pharetra elit.</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
