<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>deno的初体验</title>
      <link href="/My-Blogs/2021/01/19/Deno/deno%E7%9A%84%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/My-Blogs/2021/01/19/Deno/deno%E7%9A%84%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>这是一篇deno运行的初体验文章</p><a id="more"></a><h2 id="Deno"><a href="#Deno" class="headerlink" title="Deno"></a><a href="https://deno.land/">Deno</a></h2><p>A <code>secure</code> runtime for JavaScript and TypeScript。由Ryan Dahl（Node.js 的创始人之一）在2017年创建，Rust 语言开发。 <code>deno</code> 音译帝诺，恐龙(dinosaur)的简称，deno 这个名字就是来自 Node 的字母重新组合（Node = no + de），表示”拆除 Node.js”（de = destroy, no = Node.js）。</p><h2 id="创建原由"><a href="#创建原由" class="headerlink" title="创建原由"></a>创建原由</h2><ul><li>Node.js Callback hell。</li><li>原生支持CommonJs，对ES模块不兼容。</li><li>npm(你怕吗)模块管理工具，npm_modules 极其庞杂，还有Dependency Hell，版本重复问题等问题，极难管理。详情可查看<a href="https://juejin.cn/post/6914508615969669127">node_modules 困境</a></li><li>功能不完整，要学习很多外部工具，诸如webpack，babel，typescript、eslint、prettier……</li></ul><blockquote><p>*“由于上面这些原因，Ryan Dahl 决定放弃 Node.js，从头写一个替代品，彻底解决这些问题。deno 这个名字就是来自 Node 的字母重新组合（Node = no + de），表示”拆除 Node.js”（de = destroy, no = Node.js）。</p></blockquote><p>跟 Node.js 一样，Deno 也是一个服务器运行时，但是支持多种语言，可以直接运行 JavaScript、TypeScript 和 WebAssembly 程序。<br>它内置了 V8 引擎，用来解释 JavaScript。同时，也内置了 tsc 引擎，解释 TypeScript。它使用 Rust 语言开发，由于 Rust 原生支持 WebAssembly，所以它也能直接运行 WebAssembly。它的异步操作不使用 libuv 这个库，而是使用 Rust 语言的 Tokio 库，来实现事件循环（event loop）。”*— 出自阮一峰大神《<a href="https://www.ruanyifeng.com/blog/2020/01/deno-intro.html">Deno 运行时入门教程：Node.js 的替代品</a>》</p><p><strong>闲言少叙，书归正传，让我们一起来看看Deno的特性吧</strong></p><h2 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h2><ul><li>服务器运行时，支持多种语言，可直接运行 <code>JavaScript</code>、<code>TypeScript</code> 和 <code>WebAssembly</code> 程序。</li><li>具有安全控制，默认情况下脚本不具有读写权限。如果脚本未授权，就读写文件系统或网络，会报错。</li><li>只有一个可执行文件，所有操作都通过这个文件完成。它支持跨平台（Mac、Linux、Windows）。</li><li>异步操作 一律返回 Promise。</li><li>Deno 支持 Web API，尽量跟浏览器保持一致。<code>window</code>、<code>fetch</code>、<code>webCrypto</code>、<code>worker</code>, 也支持 <code>onload</code>、<code>onunload</code>、<code>addEventListener</code> 等事件操作函数。</li><li>所有模块通过 URL 加载，比如<code>import { bar } from "https://foo.com/bar.ts"</code>（绝对 URL）或<code>import { bar } from './foo/bar.ts'</code>（相对 URL）。本地缓存，有个Cache总目录</li><li>原生支持TypeScript。</li><li>内置各种功能，无需外部工具。</li><li>打包、格式清理、测试、安装、文档生成、linting、脚本编译成可执行文件等一条龙服务。</li></ul><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li>高效且安全</li><li>单文件，兼容浏览器标准，体积小。</li><li>替代脚本</li></ul><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><ul><li>缺少集大成框架，满足不了企业级应用开发。</li><li>具有安全控制，显示打开权限方可使用。</li><li>社区还不完善。</li></ul><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>Shell (Mac, Linux):</p><pre><code class="BASH">curl -fsSL https://deno.land/x/install/install.sh | sh</code></pre><p>PowerShell (Windows):</p><pre><code class="BASH">iwr https://deno.land/x/install/install.ps1 -useb | iex</code></pre><h3 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h3><p>Try running a simple program:</p><pre><code class="BASH">deno run https://deno.land/std/examples/welcome.ts</code></pre><p>Or a more complex one:</p><pre><code class="JS">import {  serve} from "https://deno.land/std@0.83.0/http/server.ts";const s = serve({  port: 8000});console.log("http://localhost:8000/");for await (const req of s) {  req.respond({    body: "Hello World\n"  });}</code></pre><h3 id="缓存目录"><a href="#缓存目录" class="headerlink" title="缓存目录"></a>缓存目录</h3><p>Mac</p><pre><code class="BASH"> $HOME/Library/Caches/Deno#  远程库下载地址deno run https://deno.land/std@0.83.0/examples/welcome.ts# DIRECTORIESgen/: 缓存编译为JavaScript的文件deps/: 缓存导入的远程url的文件  |__ http/: http方式导入的文件  |__ https/: https方式导入的文件# FILESdeno_history.txt: Deno REPL历史记录缓存</code></pre><p><strong>gen/</strong><br>被用来存放 JavaScript 文件，这些文件是从 TypeScript 源码编译来的。这样的编译是必要的，因为 V8 不识别 JS 子集之外的 TypeScript 语法。<br>$DENO_DIR/gen/ 被用来存放 JavaScript 文件，这些文件是从 TypeScript 源码编译来的。这样的编译是必要的，因为 V8 不识别 JS 子集之外的 TypeScript 语法。</p><p>gen/目录下的每一个 JS 文件的文件名是他的 TypeScript 源码的 hash 值。同时 JS 文件也对应一个 .map 为后缀的 source map 文件。</p><p>缓存存在的原因是为了避免在用户没有修改代码的情况下，每次运行时不断的重新编译文件。比如我们有一个 hello-world.ts 文件，他只是包含了代码 console.log(“Hello world”)。在第一次运行时，我们会看到编译信息：</p><p>$ deno hello-world.ts<br>Compiling /Users/kevinqian/my-folder/hello-world.ts<br>Hello world<br>但是在没有修改文件内容的情况下，当你重新运行代码：</p><p>$ deno hello-world.ts<br>Hello world<br>不会再有编译信息的提示。这是因为在这一次运行中，Deno 直接使用了 gen/ 中缓存的版本，而不用再次编译。</p><p>缓存加载和保存的代码，可以从文件 src/deno_dir.rs 中的 DenoDir::load_cache 和 DenoDir::code_cache 中找到。</p><p>如果想要强制 Deno 重新编译你的代码而不是使用缓存的版本，你需要使用 –recompile 标志。</p><p>deps/<br>$DENO_DIR/deps 被用来保存远端 url import 获得的文件。根据 url 的模式，他包含了子目录（现在只有http和https），并且保存文件的位置由 URL path 决定。比如，对于下面的的 import（请注意，Deno 要求用户显式地指定扩展名）。</p><p>import { serve } from “<a href="https://deno.land/x/std/net/http.ts&quot;">https://deno.land/x/std/net/http.ts"</a>;<br>下载的http.ts文件将会被存储在：</p><p>$DENO_DIR/deps/https/deno.land/x/std/net/http.ts<br>需要注意，除非用户用 –reload 标志运行代码，否则我们的http.ts文件在接下来的运行中不会被重新下载。</p><p>当前（警告：将来可能改变），Deno 会关注从远端下载的文件的内容的 MIME 类型。在文件缺少扩展名或扩展名与内容类型不匹配的情况下，Deno 将创建一个以 .mime 结尾的额外文件，来存储 HTTP 响应头提供的 mime 类型。如果我们下载的文件名是 a.ts，然而响应头里面是 Content-Type: text/javascript，一个包含text/javascript内容的a.ts.mime文件将会在他旁边被创建。由于.mime文件的存在，a.ts 后面将会被当做一个 JavaScript 文件被 import。</p>]]></content>
      
      
      <categories>
          
          <category> deno </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deno </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/My-Blogs/2021/01/19/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/%E4%B8%AA%E4%BA%BA%E6%8A%A4%E5%9F%8E%E6%B2%B3/"/>
      <url>/My-Blogs/2021/01/19/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/%E4%B8%AA%E4%BA%BA%E6%8A%A4%E5%9F%8E%E6%B2%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="我最喜欢的职业建议是发展”个人护城河“。"><a href="#我最喜欢的职业建议是发展”个人护城河“。" class="headerlink" title="我最喜欢的职业建议是发展”个人护城河“。"></a>我最喜欢的职业建议是发展”<a href="https://eriktorenberg.substack.com/p/build-personal-moats">个人护城河</a>“。</h3><br><p><img src="https://www.wangbase.com/blogimg/asset/202009/bg2020092807.jpg" alt="image"></p><br><p>你的个人护城河是一组独特的且不断累积的竞争优势，别人很难学习，或者很难做到。如果你有了它，你会让自己变得无法取代。</p><br><p>你必须找到属于你的特殊东西，而且这些东西会随着时间的流逝而增加价值。</p><br><h3 id="如何找到自己的护城河？"><a href="#如何找到自己的护城河？" class="headerlink" title="如何找到自己的护城河？"></a>如何找到自己的护城河？</h3><br><p>你可以问自己：对我来说，什么事情容易做，而对别人却很难？我所拥有的技能中，哪些是其他人模仿会非常困难的？或者，你所爱的、擅长的事物，跟社会需要的事物有什么交汇点？</p><br><p>护城河会随着条件的变化而变化。比如，录音技术诞生之前，稀缺的是音乐本身，你想听音乐，就需要有一个艺术家给你现场表演。现在，音乐录音到处都是，稀缺的是策划、发行和个性的展示。</p><br><p>同样地，在社会中，以前的稀缺资源是金钱和特殊关系。而在互联网时代，稀缺的是特定知识和某些稀有技能。</p><br><p>漫画家斯科特·亚当斯（Scott Adams）曾经提过一种建立个人护城河的方法，就是找到自己最擅长的2个～3个事物的交集。比如，他既不是最好的漫画家，也不是最好的作家，也不是最好的企业家，但他可以是最好的商业类漫画短文作者，这就是他的护城河。</p><br><p>总之，你要发现对你来说容易而对他人却很难的事物，并在这些事物上变得出色，然后利用它来积累社会和金融资本。</p><br><h3 id="找出最擅长的2-3个事物的交集。"><a href="#找出最擅长的2-3个事物的交集。" class="headerlink" title="找出最擅长的2~3个事物的交集。"></a><strong>找出最擅长的2~3个事物的交集</strong>。</h3><br><p><img src="https://cdn.substack.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F3e1e36d1-f32a-4aff-bd08-10e131454905_1124x1063.png" alt="交集图"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tree命令的基本使用</title>
      <link href="/My-Blogs/2021/01/18/Linux/shell/%E6%96%87%E4%BB%B6/tree%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/My-Blogs/2021/01/18/Linux/shell/%E6%96%87%E4%BB%B6/tree%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>每天学一个 Linux 命令之tree的基本使用</p><a id="more"></a><h2 id="命令简介"><a href="#命令简介" class="headerlink" title="命令简介"></a>命令简介</h2><p>tree 命令的作用是以树形结构显示目录下的内容。</p><p>常用的Linux发行版系统中默认没有这个命令，你需要通过安装才可以使用：</p><pre><code class="BASH">#Centosyum install tree -y#Ubuntusudo apt-get install tree</code></pre><p>安装完成之后就可以正常使用这个tree命令了。</p><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><pre><code class="BASH">tree [选项] [目录]</code></pre><h2 id="选项说明"><a href="#选项说明" class="headerlink" title="选项说明"></a>选项说明</h2><pre><code class="BASH">-a   #显示所有文件-d   #只显示目录（名称）-l   #显示链接文件的原始文件-f   #显示所列出的文件或目录的完整目录路径-i   #不以阶梯的形式显示文件或目录名称-q   #将控制字符以?字符代替，显示文件和目录名称-N   #直接显示文件或目录的名称-p   #显示每个文件的权限信息-u   #显示文件所有者或者uid-g   #显示文件所属组或者gid-s   #显示每个文件的大小信息-h   #以可读的方式显示文件的大小信息-D   #显示最后修改日期-v   #按字母数字正序显示文件-r   #按字母数字倒序显示文件-t   #按最后时间排序显示文件-C   #在文件和目录列表上加上色彩，便于区分文件类型-P pattern    #只显示匹配正则表式的文件或目录名称-I pattern    #与上结果相反</code></pre><h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><pre><code class="BASH">#树形显示当前目录及其子目录下的文件及目录名称[root@centos7&nbsp;testdir]#&nbsp;tree.├──&nbsp;dir│&nbsp;&nbsp;&nbsp;├──&nbsp;test2.txt~│&nbsp;&nbsp;&nbsp;├──&nbsp;test3.txt│&nbsp;&nbsp;&nbsp;└──&nbsp;test3.txt.bak├──&nbsp;test2.txt└──&nbsp;test2.txt~1&nbsp;directory,&nbsp;5&nbsp;files#只显示目录名称[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-d.└──&nbsp;dir1&nbsp;directory#显示目录及文件的权限信息[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-p.├──&nbsp;[drwxr-xr-x]&nbsp;&nbsp;dir│&nbsp;&nbsp;&nbsp;├──&nbsp;[-rw-r--r--]&nbsp;&nbsp;test2.txt~│&nbsp;&nbsp;&nbsp;├──&nbsp;[-rw-r--r--]&nbsp;&nbsp;test3.txt│&nbsp;&nbsp;&nbsp;└──&nbsp;[-rw-r--r--]&nbsp;&nbsp;test3.txt.bak├──&nbsp;[-rw-r--r--]&nbsp;&nbsp;test2.txt└──&nbsp;[-rw-r--r--]&nbsp;&nbsp;test2.txt~1&nbsp;directory,&nbsp;5&nbsp;files#显示几层信息2代表2层（向下）[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-L&nbsp;2.├──&nbsp;dir│&nbsp;&nbsp;&nbsp;├──&nbsp;test2.txt~│&nbsp;&nbsp;&nbsp;├──&nbsp;test3.txt│&nbsp;&nbsp;&nbsp;└──&nbsp;test3.txt.bak├──&nbsp;test2.txt└──&nbsp;test2.txt~1&nbsp;directory,&nbsp;5&nbsp;files[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-L&nbsp;1.├──&nbsp;dir├──&nbsp;test2.txt└──&nbsp;test2.txt~1&nbsp;directory,&nbsp;2&nbsp;files</code></pre><p>-C 显示各种文件类型，以颜色区分</p><p><img src="/My-Blogs/images/tree%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-01.png" alt="img"></p><pre><code class="BASH">#显示文件和目录的所有者[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-u.├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;cp&nbsp;-&gt;&nbsp;/usr/bin/cp├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;dir│??&nbsp;├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test2.txt~│??&nbsp;├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test3.txt│??&nbsp;└──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test3.txt.bak├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test2.txt└──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test2.txt~1&nbsp;directory,&nbsp;6&nbsp;files#显示文件和目录的所属组[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-g.├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;cp&nbsp;-&gt;&nbsp;/usr/bin/cp├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;dir│??&nbsp;├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test2.txt~│??&nbsp;├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test3.txt│??&nbsp;└──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test3.txt.bak├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test2.txt└──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test2.txt~1&nbsp;directory,&nbsp;6&nbsp;files#不按树形形式显示文件和目录[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-i.cp&nbsp;-&gt;&nbsp;/usr/bin/cpdirtest2.txt~test3.txttest3.txt.baktest2.txttest2.txt~1&nbsp;directory,&nbsp;6&nbsp;files[root@centos7&nbsp;testdir]#&nbsp;tree.├──&nbsp;cp&nbsp;-&gt;&nbsp;/usr/bin/cp├──&nbsp;dir│&nbsp;&nbsp;&nbsp;├──&nbsp;test2.txt~│&nbsp;&nbsp;&nbsp;├──&nbsp;test3.txt│&nbsp;&nbsp;&nbsp;└──&nbsp;test3.txt.bak├──&nbsp;test2.txt└──&nbsp;test2.txt~1&nbsp;directory,&nbsp;6&nbsp;files#显示文件和目录的完整路径[root@centos7&nbsp;testdir]#&nbsp;pwd/root/testdir[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-f.├──&nbsp;./cp&nbsp;-&gt;&nbsp;/usr/bin/cp├──&nbsp;./dir│&nbsp;&nbsp;&nbsp;├──&nbsp;./dir/test2.txt~│&nbsp;&nbsp;&nbsp;├──&nbsp;./dir/test3.txt│&nbsp;&nbsp;&nbsp;└──&nbsp;./dir/test3.txt.bak├──&nbsp;./test2.txt└──&nbsp;./test2.txt~1&nbsp;directory,&nbsp;6&nbsp;files[root@centos7&nbsp;~]#&nbsp;tree&nbsp;-f&nbsp;./testdir/./testdir├──&nbsp;./testdir/cp&nbsp;-&gt;&nbsp;/usr/bin/cp├──&nbsp;./testdir/dir│&nbsp;&nbsp;&nbsp;├──&nbsp;./testdir/dir/test2.txt~│&nbsp;&nbsp;&nbsp;├──&nbsp;./testdir/dir/test3.txt│&nbsp;&nbsp;&nbsp;└──&nbsp;./testdir/dir/test3.txt.bak├──&nbsp;./testdir/test2.txt└──&nbsp;./testdir/test2.txt~1&nbsp;directory,&nbsp;6&nbsp;files</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Explain使用分析</title>
      <link href="/My-Blogs/2021/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/Explain%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"/>
      <url>/My-Blogs/2021/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/Explain%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.<br>EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:</p><a id="more"></a><pre><code class="SQL">EXPLAIN SELECT * from user_info WHERE  id &lt; 300;</code></pre><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:</p><pre><code class="SQL">CREATE TABLE `user_info` (  `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,  `name` VARCHAR(50) NOT NULL DEFAULT '',  `age`  INT(11)              DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `name_index` (`name`))  ENGINE = InnoDB  DEFAULT CHARSET = utf8</code></pre><pre><code class="SQL">CREATE TABLE `order_info` (  `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,  `user_id`      BIGINT(20)           DEFAULT NULL,  `product_name` VARCHAR(50) NOT NULL DEFAULT '',  `productor`    VARCHAR(30)          DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`))  ENGINE = InnoDB  DEFAULT CHARSET = utf8</code></pre><h2 id="EXPLAIN-输出格式"><a href="#EXPLAIN-输出格式" class="headerlink" title="EXPLAIN 输出格式"></a>EXPLAIN 输出格式</h2><p>EXPLAIN 命令的输出内容大致如下:</p><pre><code class="SQL">mysql&gt; explain select * from user_info where id = 2\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)</code></pre><p>各列的含义如下:</p><ul><li><p><code>id</code>: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</p></li><li><p><code>select_type</code>: SELECT 查询的类型.</p></li><li><p><code>table</code>: 查询的是哪个表</p></li><li><p><code>partitions</code>: 匹配的分区</p></li><li><p><code>type</code>: join 类型</p></li><li><p><code>possible_keys</code>: 此次查询中可能选用的索引</p></li><li><p><code>key</code>: 此次查询中确切使用到的索引.</p></li><li><p><code>ref</code>: 哪个字段或常数与 key 一起被使用</p></li><li><p><code>rows</code>: 显示此查询一共扫描了多少行. 这个是一个估计值.</p></li><li><p><code>filtered</code>: 表示此查询条件所过滤的数据的百分比</p></li><li><p><code>extra</code>: 额外的信息</p></li></ul><p>接下来我们来重点看一下比较重要的几个字段.</p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p><code>select_type</code> 表示了查询的类型, 它的常用取值有:</p><ul><li><p>SIMPLE, 表示此查询不包含 UNION 查询或子查询</p></li><li><p>PRIMARY, 表示此查询是最外层的查询</p></li><li><p>UNION, 表示此查询是 UNION 的第二或随后的查询</p></li><li><p>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询</p></li><li><p>UNION RESULT, UNION 的结果</p></li><li><p>SUBQUERY, 子查询中的第一个 SELECT</p></li><li><p>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</p></li></ul><p>最常见的查询类别应该是 <code>SIMPLE</code> 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 <code>SIMPLE</code> 类型, 例如:</p><pre><code class="SQL">mysql&gt; explain select * from user_info where id = 2\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)</code></pre><p>如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:</p><pre><code class="SQL">mysql&gt; EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3))    -&gt; UNION    -&gt; (SELECT * FROM user_info WHERE id IN (3, 4, 5));+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+| id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+|  1 | PRIMARY      | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     ||  2 | UNION        | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     || NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+3 rows in set, 1 warning (0.00 sec)</code></pre><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>表示查询涉及的表或衍生表</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p><code>type</code> 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 <code>type</code> 字段, 我们判断此次查询是 <code>全表扫描</code> 还是 <code>索引扫描</code> 等.</p><p><strong>type 常用类型</strong><br>type 常用的取值有:</p><p><code>system</code> : 表中只有一条数据. 这个类型是特殊的 <code>const</code> 类型.</p><p><code>const</code> : 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. <code>const</code> 查询速度非常快, 因为它仅仅读取一次即可.<br>例如下面的这个查询, 它使用了主键索引, 因此 <code>type</code> 就是 <code>const</code> 类型的.</p><pre><code class="SQL">mysql&gt; explain select * from user_info where id = 2\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)</code></pre><ul><li><code>eq_ref</code>: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:</li></ul><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: indexpossible_keys: user_product_detail_index          key: user_product_detail_index      key_len: 314          ref: NULL         rows: 9     filtered: 100.00        Extra: Using where; Using index*************************** 2. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: eq_refpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: test.order_info.user_id         rows: 1     filtered: 100.00        Extra: NULL2 rows in set, 1 warning (0.00 sec)</code></pre><ul><li><code>ref</code>: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 <code>最左前缀</code> 规则索引的查询.</li></ul><p>例如下面这个例子中, 就使用到了 <code>ref</code> 类型的查询:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: const         rows: 1     filtered: 100.00        Extra: NULL*************************** 2. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: refpossible_keys: user_product_detail_index          key: user_product_detail_index      key_len: 9          ref: const         rows: 1     filtered: 100.00        Extra: Using index2 rows in set, 1 warning (0.01 sec)</code></pre><ul><li><code>range</code>: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.</li></ul><p>当 <code>type</code> 是 <code>range</code> 时, 那么 EXPLAIN 输出的 <code>ref</code> 字段为 NULL, 并且 <code>key_len</code> 字段是此次查询中使用到的索引的最长的那个.</p><p>例如下面的例子就是一个范围查询:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT *    -&gt;         FROM user_info    -&gt;         WHERE id BETWEEN 2 AND 8 \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: rangepossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: NULL         rows: 7     filtered: 100.00        Extra: Using where1 row in set, 1 warning (0.00 sec)</code></pre><ul><li><code>index</code>: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.</li></ul><p><code>index</code> 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 <code>Using index</code> .</p><p>例如:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT name FROM  user_info \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: indexpossible_keys: NULL          key: name_index      key_len: 152          ref: NULL         rows: 10     filtered: 100.00        Extra: Using index1 row in set, 1 warning (0.00 sec)</code></pre><p>上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 <code>index</code> , 并且 Extra 的值是 <code>Using index</code> .</p><ul><li><code>ALL</code>: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.</li></ul><p>下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT age FROM  user_info WHERE age = 20 \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 10     filtered: 10.00        Extra: Using where1 row in set, 1 warning (0.00 sec)</code></pre><p><strong>type 类型的性能比较</strong></p><p>通常来说, 不同的 type 类型的性能关系如下:</p><p> <code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code></p><p><code>ALL</code> 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.</p><p>而 <code>index</code> 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.</p><p>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</p><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p><code>possible_keys</code> 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 <code>possible_keys</code> 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 <code>key</code> 字段决定.</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>此字段是 MySQL 在当前查询时所真正使用到的索引.</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.<br>key_len 的计算规则如下:</p><ul><li><p>字符串</p><ul><li><p>char(n): n 字节长度</p></li><li><p>varchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.</p></li></ul></li><li><p>数值类型:</p><ul><li><p>TINYINT: 1字节</p></li><li><p>SMALLINT: 2字节</p></li><li><p>MEDIUMINT: 3字节</p></li><li><p>INT: 4字节</p></li><li><p>BIGINT: 8字节</p></li><li><p>时间类型</p></li><li><p>DATE: 3字节</p></li><li><p>TIMESTAMP: 4字节</p></li><li><p>DATETIME: 8字节</p></li><li><p>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.</p></li></ul></li></ul><p>我们来举两个简单的栗子:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id &lt; 3 AND product_name = 'p1' AND productor = 'WHH' \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: rangepossible_keys: user_product_detail_index          key: user_product_detail_index      key_len: 9          ref: NULL         rows: 5     filtered: 11.11        Extra: Using where; Using index1 row in set, 1 warning (0.00 sec)</code></pre><p>上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 <code>order_info</code> 有一个联合索引:</p><pre><code class="SQL">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</code></pre><p>不过此查询语句 <code>WHERE user_id &lt; 3 AND product_name = 'p1' AND productor = 'WHH'</code> 中, 因为先进行 user_id 的范围查询, 而根据 <code>最左前缀匹配</code> 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 <code>user_id</code> , 因此在 <code>EXPLAIN</code> 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 <code>BIGINT(20) NOT NULL DEFAULT '0'</code> , 则 key_length 应该是8.</p><p>上面因为 <code>最左前缀匹配</code> 原则, 我们的查询仅仅使用到了联合索引的 <code>user_id</code> 字段, 因此效率不算高.</p><p>接下来我们来看下一个例子:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = 'p1' \G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: refpossible_keys: user_product_detail_index          key: user_product_detail_index      key_len: 161          ref: const,const         rows: 2     filtered: 100.00        Extra: Using index1 row in set, 1 warning (0.00 sec)</code></pre><p>这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 <code>WHERE user_id = 1 AND product_name = 'p1'</code> 中, 仅仅使用到了联合索引中的前两个字段, 因此 <code>keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</code></p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p><code>rows</code> 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br>这个值非常直观显示 SQL 的效率好坏, 原则上 <code>rows</code> 越少越好.</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p><code>EXplain</code> 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p><ul><li><code>Using filesort</code></li></ul><p>当 Extra 中有 <code>Using filesort</code> 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 <code>Using filesort</code> , 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</p><p>例如下面的例子:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY product_name \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: indexpossible_keys: NULL          key: user_product_detail_index      key_len: 253          ref: NULL         rows: 9     filtered: 100.00        Extra: Using index; Using filesort1 row in set, 1 warning (0.00 sec)</code></pre><p>我们的索引是</p><pre><code class="SQL">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</code></pre><p>但是上面的查询中根据 <code>product_name</code> 来排序, 因此不能使用索引进行优化, 进而会产生 <code>Using filesort</code> .<br>如果我们将排序依据改为 <code>ORDER BY user_id, product_name</code> , 那么就不会出现 <code>Using filesort</code> 了. 例如:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: indexpossible_keys: NULL          key: user_product_detail_index      key_len: 253          ref: NULL         rows: 9     filtered: 100.00        Extra: Using index1 row in set, 1 warning (0.00 sec)</code></pre><ul><li><p><code>Using index</code> “覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</p></li><li><p><code>Using temporary</code> 查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>db操作常见问题</title>
      <link href="/My-Blogs/2021/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/My-Blogs/2021/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>总结了一些db操作的常见问题，让我们一起来看看吧</p><a id="more"></a><h2 id="联合索引问题"><a href="#联合索引问题" class="headerlink" title="联合索引问题"></a>联合索引问题</h2><ol><li> 在imo后台群唤醒活动中，用户数据表多达几千万，大数据这边，并未针对业务场景建立有效覆盖索引，导致后台SQL慢查询告警上千次，针对业务场景，提出以下优化，新增key1，key2索引覆盖，后台where条件严格按照stats_day，activelevel，categeory_id，cc顺序查询。</li><li> 按照MySQL联合索引最左匹配原则，比如A-B-C联合索引，则针对A，A-B，A-B-C查询有效，而A-C，B-C，B，C则无效，where条件最好根据索引顺序进行</li><li> 如果搜索条件过于复杂混乱，建议先与产品沟通清楚，确定好如何建立索引，严格把控搜索条件（从界面上）</li><li> 以下为用户数据表（千万级别）</li></ol><pre><code class="SQL">CREATE TABLE `xx_push_activelevel_categeory_day` (  `stats_day` date NOT NULL DEFAULT '2019-01-01',  `cc` varchar(10) NOT NULL DEFAULT '',  `activelevel` varchar(30) NOT NULL DEFAULT 'unknown',  `categeory_id` varchar(50) NOT NULL DEFAULT 'unknown',  `groupid` char(30) NOT NULL DEFAULT 'unknown',  `role` varchar(15) NOT NULL DEFAULT 'unknown',  `uid` varchar(25) NOT NULL DEFAULT '',  PRIMARY KEY (`role`,`activelevel`,`categeory_id`,`cc`,`uid`,`groupid`,`stats_day`),  KEY `role` (`role`,`activelevel`,`categeory_id`),  KEY `key1` (`stats_day`,`activelevel`,`categeory_id`,`cc`,`role`),  KEY `key2` (`stats_day`,`activelevel`,`categeory_id`,`cc`),  KEY `actl` (`activelevel`),  KEY `agid` (`categeory_id`),  KEY `cc` (`cc`)) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4/*!50100 PARTITION BY RANGE (TO_DAYS(stats_day))(PARTITION pd20200609 VALUES LESS THAN (737951) ENGINE = MyISAM, PARTITION pd20200610 VALUES LESS THAN (737952) ENGINE = MyISAM, PARTITION pd20200611 VALUES LESS THAN (737953) ENGINE = MyISAM) */;</code></pre><h2 id="主键偏移问题"><a href="#主键偏移问题" class="headerlink" title="主键偏移问题"></a>主键偏移问题</h2><ol><li> 在单表大数据量的情况下，使用索引并不是唯一选择，当SQL分页查询，offset达到一定量(大概20w以上？)以后，就会出现慢查询现象，是由于MySQL根据索引查出一定量数据之后，会根据offset抛弃之前的数据</li><li> 这意味着前20w数据的查询都是无用的，费力不讨好</li><li> 可以采用主键id(INT, BIGINT类型)偏移，INT类型查询天生就有优势，又是主键索引，可以做到一部到位</li><li> where条件最后，加上id排序，记录上一次的查询数据最后一条id，下一次查询作为偏移量，从而跳过前面无用的数据，再开始进行索引查询</li><li> 以下是某个项目的例子（仅供参考）</li></ol><pre><code class="SQL">SELECT id, stats_day, cc, activelevel, categeory_id, groupid, role, uid FROM xx_push_activelevel_categeory_day AS biggroupPushCategeoryWHERE biggroupPushCategeory.id &gt; 200000 AND biggroupPushCategeory.stats_day = '2020-07-01 00:00:00' AND biggroupPushCategeory.activelevel = 'gtype_unactive_2' AND biggroupPushCategeory.categeory_id = 'categeory_mems_less_300' AND biggroupPushCategeory.cc = 'PK'ORDER BY biggroupPushCategeory.id ASC LIMIT 500;</code></pre><h2 id="结果集过滤问题"><a href="#结果集过滤问题" class="headerlink" title="结果集过滤问题"></a>结果集过滤问题</h2><ol><li> 接上一个问题，当我们结合主键偏移+索引【KEY <code>sacc</code> (<code>stats_day</code>,<code>activelevel</code>,<code>categeory_id</code>,<code>cc</code>)】搜索的时候，SQL这边优先根据索引过滤结果集，根据上面那条sql，我们可能会过滤出一个大结果集，而且结果集并不保证id有序</li><li> 这时候我们需要重新修改索引键，加上主键id，例如KEY <code>sacci</code> (<code>stats_day</code>,<code>activelevel</code>,<code>categeory_id</code>,<code>cc</code>,<code>id</code>)，当我们进行索引查询取500行时，可以根据id&gt;20000，直接命中500行并返回，不需要重新排序，也不会返回之前sacc索引的所有结果集</li><li> 以下是优化前和优化后的对比图，性能提高了几十倍</li></ol><h3 id="优化前"><a href="#优化前" class="headerlink" title="优化前"></a>优化前</h3><p><img src="/My-Blogs/images/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-01.png" alt="优化前"></p><h3 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h3><p><img src="/My-Blogs/images/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-02.png" alt="优化后"></p><h2 id="where条件顺序问题"><a href="#where条件顺序问题" class="headerlink" title="where条件顺序问题"></a>where条件顺序问题</h2><ol><li> 接上一个问题，我们已经创建索引KEY <code>sacci</code> (<code>stats_day</code>,<code>activelevel</code>,<code>categeory_id</code>,<code>cc</code>,<code>id</code>)，如果我们把id放在最前，或者最后，会对查询的效率有影响吗？答案是没有。</li><li> SQL执行是会被进行一系列预处理，让查询优化器选择最优的查询计划，所以where条件的先后关系不是优化器选择规则的一条，当然前提是你的where条件数量与索引一致，如果where条件少于索引数量，会根据最左原则优先查询。</li><li> 总的来说，唯一会影响的就是where条件和索引的比对，以及跟order by等，跟先后顺序无关。</li><li> 引申开来说，如果对ABC三个字段建立联合索引，一般来说，在创建索引时，根据区分度原则，尽量让A能够排除更多记录而不是B或C，在查询时，根据索引前缀匹配原则，尽可能让A条件精确，B其次，C看着办。</li><li> 以下是id前后对比图</li></ol><p><img src="/My-Blogs/images/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-03.png" alt="alt"></p><p><img src="/My-Blogs/images/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-04.png" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PRPL模式加快Web应用加载</title>
      <link href="/My-Blogs/2021/01/08/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/"/>
      <url>/My-Blogs/2021/01/08/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>PRPL 是一种用于结构化和交付 Web 应用程序和渐进式 Web 应用（PWA）的模式，重点在于改进应用的交付和启动性能。这个模式包含一组步骤，以实现快速、可靠、高效的加载：</p><a id="more"></a><ul><li><p><code>Push</code>, 推送初始路由所需的所有资源，并且只推送这些资源，以确保它们尽早可用。</p></li><li><p><code>Render</code>, 在加载其他资源之前，渲染初始路由并使其具备交互能力。</p></li><li><p><code>Pre-cache</code>, 预缓存用户可能访问的其他路由的资源，从而在恶劣的网络条件下尽可能提高对后续请求的响应能力和弹性。</p></li><li><p><code>Lazy-load</code>, 当用户请求时，按需延迟加载路由；关键路由的资源应立即从缓存中加载，而相对不常用的资源可以根据请求从网络获取。</p></li></ul><blockquote><p>注意：PRPL模式是由Polymer团队于2016年首次引入的，但已被证明适用于其他许多技术栈。</p></blockquote><p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-01.png" alt="img"></p><center>PRPL 模式加载顺序</center><p>服务器和服务 Worker 一起为非活动路由预缓存资源。当用户切换路由时，应用会延迟加载尚未缓存的所有必需资源，并创建所需的视图。</p><p>Twitter.com 自 2017 年以来就在生产中使用 PRPL 模式了。下面我们可以看到，他们对关键脚本使用了粒度代码拆分，并使用 <code>&lt;linkrel=preload&gt;</code> 推送脚本以尽快让脚本可用：</p><p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-02.png" alt="img"></p><br><center style="margin-top: 20px">PRPL 模式：预加载关键脚本</center><br><p>其他路由会按需延迟加载。Twitter 在整个用户体验部分中会按需提供 40 多个块。Twitter 还使用服务 Workers 对其他路由进行（离线）资产预缓存，以提高对后续导航操作的响应能力：</p><br><p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-03.png" alt="img"></p><br><center style="margin-top: 20px">PRPL 模式：离线缓存资源</center><br><p>他们的应用程序外壳程序（骨架 UI）也是离线缓存的，就算用户通过缓慢或不稳定的网络连接加载站点，也会立即加载它们：</p><p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-04.png" alt="img"></p><center>PRPL 模式：应用程序外壳</center><h2 id="为什么选择-PRPL？"><a href="#为什么选择-PRPL？" class="headerlink" title="为什么选择 PRPL？"></a>为什么选择 PRPL？</h2><p>应用使用 PRPL 构建是为了达到可靠、快速和引人入胜的目的。除了这些基本目标，PRPL 还旨在：</p><ul><li><p><strong>改善应用的交互就绪水平</strong>。为了做到这一点，在第一个视图渲染并具备交互能力之前，不会向浏览器发送多余的资源。</p></li><li><p><strong>提高应用的缓存效率，尤其是长期缓存效率</strong>。为了做到这一点，资源会以很细的粒度向浏览器发送。当资源被解绑或松散地打包时，对代码的每次更改给缓存的负面影响也会减少。</p></li><li><p><strong>降低开发和部署的复杂性</strong>。为了做到这一点，这种模式使用应用的隐式依赖图将每个入口点精确映射到所需的资源集，从而减少或消除了手动管理打包和交付的需求。</p></li></ul><h2 id="PRPL-应包含哪些技术？"><a href="#PRPL-应包含哪些技术？" class="headerlink" title="PRPL 应包含哪些技术？"></a>PRPL 应包含哪些技术？</h2><p>PRPL 是一种能以各种方式实现的概念模式，但是通过以下现代 Web 特性的某种组合，可以最轻松有效地实现 PRPL：</p><ul><li><p>像JavaScript Modules这样的现代模块系统，使工具可以轻松构造完整的依赖图；</p></li><li><p>服务Workers，为后续的应用视图预缓存（“安装”）资源（进而支持离线优先架构）</p></li><li><p>预加载，用于尽快交付所需资源。你还可以使用预加载链接头，这些头可以被协作服务器拦截并升级为HTTP/2 Server Push（详情可见<a href="https://www.smashingmagazine.com/2017/04/guide-http2-server-push/">原文</a>）。一定要记住，尽管Push功能强大，但它也面临着许多已知的挑战；不过PRPL使用服务Worker可以避免过度推送的问题（仅针对初始负载使用push）。</p></li></ul><h2 id="如何实现-PRPL-模式？"><a href="#如何实现-PRPL-模式？" class="headerlink" title="如何实现 PRPL 模式？"></a>如何实现 PRPL 模式？</h2><p>PRPL 的很大一部分理念是对 JS 打包思维的颠覆，并在提供资源时拆分成尽可能接近编写资源时的粒度（至少拆分成独立的功能模块）。那么如何实现细粒度呢？</p><h3 id="基于路由或基于组件的代码拆分和延迟加载"><a href="#基于路由或基于组件的代码拆分和延迟加载" class="headerlink" title="基于路由或基于组件的代码拆分和延迟加载"></a>基于路由或基于组件的代码拆分和延迟加载</h3><p>你正在将事物编写为组件。也许你正在使用 ES 模块。对于 Webpack，我们使用动态导入和代码拆分，将你的代码库拆分为按需加载的块。</p><br><p>Next.js 和 Nuxt.js 之类的元框架会默认实现基于路由的代码拆分。如果你使用的是 create-react-app 之类的工具链样板，则需要借助 React Router 之类的路由器进行动态导入，才能将基于路由或基于组件的代码拆分添加到你的应用程序中。</p><br><p>对于 PRPL 的 push/preload 部分，Webpack 还支持将 preload 作为魔术注释来预加载关键脚本。</p><br><h3 id="预缓存"><a href="#预缓存" class="headerlink" title="预缓存"></a>预缓存</h3><p>可以使用服务 worker 预缓存剩余的路由。另一种常见的做法是，利用 Workbox 之类的服务 worker 库来简化为应用程序预缓存路由和块的过程。</p><br><h2 id="PRPL-使用何种应用程序结构？"><a href="#PRPL-使用何种应用程序结构？" class="headerlink" title="PRPL 使用何种应用程序结构？"></a>PRPL 使用何种应用程序结构？</h2><p>PRPL 鼓励采用以下结构的单页应用（SPA）架构：</p><br><ul><li><p>从每个有效路由提供的应用程序的主入口点。</p></li><li><p>这个文件应该很小，因为它将通过不同的URL提供，因此会被多次缓存。入口点中的所有资源URL都必须是绝对的，因为它可以从非顶级URL提供。</p></li><li><p>外壳（app-shell），其中包括顶级应用逻辑、router等。</p></li><li><p>延迟加载的应用片段。</p></li><li><p>可以代表特定视图代码的片段，或其他可以延迟加载的代码（例如，主应用的一些部分在第一次绘制时并不需要，比如说菜单，直到用户与应用交互时才显示）。外壳负责根据需要动态导入这些片段。</p></li></ul><p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-05.png" alt="img"></p><center style="margin: 20px 0 20px 0; ">应用外壳骨架模式</center><p>应用应根据需要调用动态导入以延迟加载片段。例如，当用户更改为新路由时，它将导入与该路由关联的片段。这可能会向服务器发起新请求，或者只是从缓存中加载资源。</p><br><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>除了针对 PWA 的基本目标和标准之外，PRPL 还尽量针对以下方面做了优化：</p><br><ul><li><p>尽量减少交互的准备工作——特别是在首次使用时（无论入口点如何）。</p></li><li><p>尽量提升缓存效率，尤其是更新不断发布后的长期缓存效率。</p></li><li><p>简化开发和部署。</p></li></ul><p>自 2016 年诞生以来，PRPL 模式已获得了大规模使用，值得你在优化应用加载时考虑。</p><p>原文链接：<a href="https://addyosmani.com/blog/the-prpl-pattern/">https://addyosmani.com/blog/the-prpl-pattern/</a></p>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈登录</title>
      <link href="/My-Blogs/2021/01/08/%E5%AE%89%E5%85%A8/%E8%B0%88%E8%B0%88%E7%99%BB%E5%BD%95/"/>
      <url>/My-Blogs/2021/01/08/%E5%AE%89%E5%85%A8/%E8%B0%88%E8%B0%88%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="一、Cookie与Session"><a href="#一、Cookie与Session" class="headerlink" title="一、Cookie与Session"></a>一、Cookie与Session</h3><p>HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行保存。因为无法管理用户状态，对于要登录的页面，每次跳转新页面时都需要再次登录。</p><a id="more"></a><p>于是引入了Cookie来管理用户状态：</p><p>① 首先客户端发起不带Cookie信息的登录请求</p><p>② 服务端接收到请求，验证用户数据正确后，添加响应头Set-Cookie</p><p>③ 客户端收到响应报文后，检查到响应头Set-Cookie，在本地保存Cookie</p><p>④ 之后每次向该域发起请求时，自动添加请求头Cookie，发送给服务端</p><p>⑤ 服务端获取请求头Cookie，根据Cookie的值，就可以判断出用户是否登录</p><p>但是Cookie极容易被篡改和伪造，于是产生了Session，Session将用户信息保存在服务端，那么Session是如何管理用户状态的呢？</p><p>① 首先客户端发起不带Cookie信息的登录请求</p><p>② 服务端接收到请求，检查到没有携带口令，验证用户密码正确后生成Session，将用户信息保存在Session，设置响应头Set-Cookie，通常是将Session ID作为口令值</p><p>③ 客户端检查到Set-Cookie响应头，在本地保存Cookie信息</p><p>④ 之后每次发起请求时，自动在请求头Cookie中携带口令，发送给服务端</p><p>⑤ 服务端获取Cookie携带的口令值，找到对应的Session，就可以判断用户状态</p><h3 id="二、如何让Session口令值更安全"><a href="#二、如何让Session口令值更安全" class="headerlink" title="二、如何让Session口令值更安全"></a>二、如何让Session口令值更安全</h3><p>虽然口令值由服务端生成，用户不容易伪造，But nothing is impossible；而且口令值存在客户端，就有可能被盗用。一旦口令值被伪造或盗用，攻击者就可以伪装成用户访问服务端的数据。</p><p>那么如何让Session口令值更安全呢？</p><p>① 将客户端的某些独有信息+口令值作为原值，对其进行签名</p><p>② 将口令值拼接签名返回给客户端，将Cookie设置为HttpOnly（禁止用户通过脚本来获取和更改Cookie）</p><p>③ 服务端再次收到请求，取客户端信息与口令值签名，与客户端携带的签名对比，不相等，说明请求不合法</p><p>这样的话：</p><p>① 即使攻击者知道了口令值，由于不知道密钥，无法伪造签名</p><p>② 即使攻击者通过某种方式得到了真实的口令值和签名，但是由于攻击者的客户端信息不一样，发送到服务端后，会得到不一样的签名，签名校验不能通过</p><h3 id="三、多系统的复杂性"><a href="#三、多系统的复杂性" class="headerlink" title="三、多系统的复杂性"></a>三、多系统的复杂性</h3><p>web系统由早期的单系统发展成多系统组成的应用群，面对如此众多的系统，用户难道要一个个登录、再一个个注销吗？</p><p>系统复杂性应该由系统内部承担，而不是用户。无论web系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问web系统的整个应用群与访问单个系统一样，只要登录/注销一次就够了。</p><p><img src="/My-Blogs/images/%E8%B0%88%E8%B0%88%E7%99%BB%E5%BD%95-01.png"></p><p>因为Cookie不允许跨域，早期多系统登录采用将Cookie种在顶级域名下的方式，来实现Cookie共享。这种方式的局限在于：</p><p>① 应用群各系统的域名得统一</p><p>② 应用群各系统的web服务端使用的技术要相同，比如Session口令值以及它的签名</p><p>方式要相同，要不Session口令值不同，无法维持会话</p><p>因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录。</p><h3 id="四、单点登录"><a href="#四、单点登录" class="headerlink" title="四、单点登录"></a>四、单点登录</h3><p>单点登录全称Single Sign On（简称SSO），是指在多系统应用群中登录一个系统，便可在其它所有系统中得到授权而无需再次登录。包括单点登录与单点注销两部分：</p><h4 id="1、单点登录"><a href="#1、单点登录" class="headerlink" title="1、单点登录"></a>1、单点登录</h4><p>　    相比于单系统登录，SSO需要一个独立的认证中心，只有认证中心能接受用户的用    户名密码等安全信息，其它系统不提供登录入口，只接受认证中心的间接授权。</p><p>通常SSO认证中心验证用户数据没问题后，会创建授权Token，分发给各个子系统。子系统拿到Token，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。这个过程，也就是单点登录的原理。</p><p><img src="/My-Blogs/images/%E8%B0%88%E8%B0%88%E7%99%BB%E5%BD%95-02.png"></p><p>例如：</p><p>    用户访问系统1，系统1发现用户未登录，跳转至SSO认证中心，并将自己的地址作为参数</p><p>    SSO认证中心发现用户未登录，将用户引导至登录页面</p><p>    用户输入用户名密码提交登录申请</p><p>    SSO认证中心校验用户信息，创建用户与SSO认证中心之间的会话，称为全局会话，同时创建授权Token</p><p>    SSO认证中心带着Token跳转回最初的请求地址（系统1）</p><p>    系统1拿到Token，去SSO认证中心校验Token是否有效</p><p>    SSO认证中心校验Token，返回有效，注册系统1</p><p>    系统1使用该Token创建与用户的会话，称为局部会话，返回受保护资源</p><p>    用户访问系统2的受保护资源</p><p>    系统2发现用户未登录，跳转至SSO认证中心，并将自己的地址作为参数</p><p>    SSO认证中心发现用户已登录，跳转回系统2的地址，并附上令牌</p><p>    系统2拿到令牌，去SSO认证中心校验令牌是否有效</p><p>    SSO认证中心校验令牌，返回有效，注册系统2</p><p>    系统2使用该令牌创建与用户的局部会话，返回受保护资源</p><p>用户登录成功之后，会与SSO认证中心及各个子系统建立会话，用户与SSO认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过SSO认证中心，全局会话与局部会话有如下约束关系：</p><p>① 局部会话存在，全局会话一定存在</p><p>② 全局会话存在，局部会话不一定存在</p><p>③ 全局会话销毁，局部会话必须销毁</p><p>2、单点注销</p><p>单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁。</p><p><img src="/My-Blogs/images/%E8%B0%88%E8%B0%88%E7%99%BB%E5%BD%95-03.png"></p><p>    用户向系统1发起注销请求</p><p>    系统1根据用户与系统1建立的会话拿到Token，向SSO认证中心发起注销请求</p><p>    SSO认证中心校验Token有效，销毁全局会话，同时取出所有用此Token注册的系统地址</p><p>    SSO认证中心向所有注册系统发起注销请求</p><p>    各注册系统接收SSO认证中心的注销请求，销毁局部会话</p><p>    SSO认证中心引导用户至登录页面</p><h3 id="五、登录安全防范"><a href="#五、登录安全防范" class="headerlink" title="五、登录安全防范"></a>五、登录安全防范</h3><p>1、CSRF攻击</p><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的登录凭证，绕过后台的用户验证，达到冒充用户对被攻击网站执行某项操作的目的。</p><p>一个典型的CSRF攻击有着如下的流程：</p><p>① 受害者登录网站a，并保留了登录凭证Cookie</p><p>② 攻击者引诱受害者访问网站b，它向网站a的服务器发送了一个跨站请求，该请求会默认携带网站a的Cookie</p><p>③ 网站a的服务器接收到请求后，对请求进行验证，确认是受害者的凭证，误以为是受害者自己发送的请求，以受害者的名义执行某个操作</p><p>④ 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让网站a执行了攻击者自己定义的操作</p><p>CSRF通常发生在第三方域名，由于浏览器同源策略的限制，攻击者不能获取到受害者的Cookie信息，只是冒用。针对这2点，我们可以制定相应的防护策略：</p><p>1）同源检测</p><p>服务器通过解析Origin 或Referer这两个请求头，确定请求的来源域，如果请求来自外域，直接阻止。</p><p>缺点：在部分情况下，攻击者可以隐藏甚至修改自己请求的Referer；会误伤一些正常请求，比如通过搜索结果跳转的页面请求。</p><p>2）Samesite Cookie</p><p>为了从源头上解决CSRF攻击，Google起草了一份草案来改进HTTP协议，即为响应头Set-Cookie新增Samesite属性：</p><p>Strict：任何情况下都不可能作为第三方Cookie，其它网站发起的任意请求都不会携带上该Cookie，包括搜索页面。</p><p>Lax：用户在不同网站之间通过链接跳转不受影响；但假如这个请求是从其它网站发起的请求，或者页面跳转是通过表单POST提交触发的，则Cookie也不会携带发送。</p><p>缺点：目前还并不成熟，其应用场景有待观望。</p><p>3）双重Cookie</p><p>①     在用户访问网站页面时，向请求域名注入两个Cookie，一个是原本要注入的Cookie，一个比如随机字符串</p><p>② 前端向后端发起请求时，取出随机字符串，添加到URL参数或请求头中</p><p>③ 后端验证携带的随机数与Cookie中的随机数是否一致，不一致则拒绝请求</p><p>缺点：难以做到子域名隔离，认证Cookie必须被种在顶级域名下，每个子域才可以访问；如果某个子域存在XSS漏洞，攻击者将这个认证Cookie修改为自己配置的Cookie；攻击者直接使用自己配置的Cookie发起CSRF攻击。</p><p>4）CSRF Token</p><p>CSRF攻击者无法直接窃取到用户的Cookie，仅仅是冒用；而CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户的请求。</p><p>① 服务器生成登录Cookie时，同时生成Token和Token签名的2个Cookie</p><p>② 前端向后端发起请求时，将Token添加到URL参数或请求头中</p><p>③ 后端收到请求，首先验证参数与Token相不相同，不相同则中止请求；然后校验签名，不相同则中止请求。因为攻击者不知道密钥，使用Token签名可以防止Cookie被篡改和伪造。</p><p>缺点：每个请求都需要携带Token，且需要服务端对每个请求进行校验。所以一般只对包含敏感数据的请求做此处理。</p><p>2、短信防刷</p><p>短信轰炸是指攻击者利用从各个网站上找到的发送动态短信的URL和前端输入的被攻击者的手机号码，发送HTTP请求，每次请求给用户发送一个动态短信。</p><p>危害：增加公司的运营成本，因为短信是需要计费的；被攻击者大量被动接收非自身请求的短信，造成无法正常使用移动运营商业务；给公司形象造成极大影响，因为一般短信会带公司签名。</p><p>常见防范手段：</p><p>    短信发送间隔设置</p><p>    发送量限制</p><p>    图文验证码</p><p>    触发流程限制</p><h3 id="六、全球部署问题"><a href="#六、全球部署问题" class="headerlink" title="六、全球部署问题"></a>六、全球部署问题</h3><p>Session存在内存里随着用户的增多会导致内存溢出，且不能跨进程、跨机器共享，且重启进程后会导致Session丢失，所以Session通常会存在第三方缓存，比如Redis里。</p><p>Redis全球部署带来的问题在于，已登录的用户再次请求时，如果请求定位到不同集群的Redis，会导致登录状态失效。</p><p>解决方案：</p><p>    不同集群Redis数据同步</p><p>    保证相同集群的Web服务请求同一集群的Redis</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> 登录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh的基本用法</title>
      <link href="/My-Blogs/2021/01/08/%E5%8D%8F%E8%AE%AE/ssh/ssh%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/My-Blogs/2021/01/08/%E5%8D%8F%E8%AE%AE/ssh/ssh%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><code>SSH</code>，我们经常操作远程服务器的时候，都会用到这个命令，但是他除了登录服务器还有很多作用，下面我们一起来了解下吧</p><a id="more"></a><h2 id="ssh登录服务器命令"><a href="#ssh登录服务器命令" class="headerlink" title="ssh登录服务器命令"></a>ssh登录服务器命令</h2><pre><code class="BASH">ssh hostname</code></pre><p>上面命令中， <code>hostname</code> 是主机名，它可以是域名，也可能是 IP 地址或局域网内部的主机名。不指定用户名的情况下，将使用客户端的当前用户名，作为远程服务器的登录用户名。</p><p>如果要指定用户名，可以采用下面的语法。</p><pre><code class="BASH">ssh user@hostname</code></pre><p>上面的命令中，用户名和主机名写在一起了，之间使用 <code>@</code> 分隔。</p><p>指定用户名，可以使用 <code>ssh</code> 和 <code>-l</code> 参数</p><pre><code class="BASH">ssh -l username host</code></pre><p>ssh 默认连接服务器的 <code>22</code> 端口， <code>-p</code> 参数可以指定其他端口</p><pre><code class="BASH">ssh -p 8821 hostname</code></pre><h2 id="ssh执行远程命令"><a href="#ssh执行远程命令" class="headerlink" title="ssh执行远程命令"></a>ssh执行远程命令</h2><p>将命令直接写在 <code>ssh</code> 命令的后面</p><pre><code class="BASH">ssh username@hostname command</code></pre><p>上面的命令会使得 SSH 在登录成功后，立刻在远程主机上执行命令 <code>command</code> 。</p><p>例子</p><pre><code class="BASH">ssh foo@server.example.com cat /etc/hosts</code></pre><p>上面的命令会在登录成功后，立即远程执行命令 <code>cat /etc/hosts</code> 。</p><h2 id="ssh命令行配置项"><a href="#ssh命令行配置项" class="headerlink" title="ssh命令行配置项"></a>ssh命令行配置项</h2><h3 id="c-参数指定加密算法。"><a href="#c-参数指定加密算法。" class="headerlink" title="-c 参数指定加密算法。"></a><code>-c</code> 参数指定加密算法。</h3><pre><code class="BASH">$ ssh -c blowfish,3des server.example.com# 或者$ ssh -c blowfish -c 3des server.example.com</code></pre><p>上面命令指定使用加密算法 <code>blowfish</code> 或 <code>3des</code></p><h3 id="C-参数表示压缩数据传输"><a href="#C-参数表示压缩数据传输" class="headerlink" title="-C 参数表示压缩数据传输"></a><code>-C</code> 参数表示压缩数据传输</h3><pre><code class="BASH">ssh -C server.example.com</code></pre><h3 id="d-参数设置打印的-debug-信息级别，数值越高，输出的内容越详细。"><a href="#d-参数设置打印的-debug-信息级别，数值越高，输出的内容越详细。" class="headerlink" title="-d 参数设置打印的 debug 信息级别，数值越高，输出的内容越详细。"></a><code>-d</code> 参数设置打印的 debug 信息级别，数值越高，输出的内容越详细。</h3><pre><code class="BASH">ssh –d 1 foo.com</code></pre><h3 id="D-参数指定本机的-Socks-监听端口"><a href="#D-参数指定本机的-Socks-监听端口" class="headerlink" title="-D 参数指定本机的 Socks 监听端口"></a><code>-D</code> 参数指定本机的 Socks 监听端口</h3><blockquote><p>该端口收到的请求，都将转发到远程的 SSH 主机，又称动态端口转发</p></blockquote><pre><code class="BASH"> ssh -D 1080 server</code></pre><p>上面命令将本机 1080 端口收到的请求，都转发到服务器 <code>server</code></p><h3 id="f-参数表示-SSH-连接在后台运行"><a href="#f-参数表示-SSH-连接在后台运行" class="headerlink" title="-f 参数表示 SSH 连接在后台运行"></a><code>-f</code> 参数表示 SSH 连接在后台运行</h3><h3 id="F-参数指定配置文件"><a href="#F-参数指定配置文件" class="headerlink" title="-F 参数指定配置文件"></a><code>-F</code> 参数指定配置文件</h3><pre><code class="BASH">ssh -F /usr/local/ssh/other_config</code></pre><p>上面命令指定使用配置文件 <code>other_config</code></p><h3 id="i-参数用于指定私钥"><a href="#i-参数用于指定私钥" class="headerlink" title="-i 参数用于指定私钥"></a><code>-i</code> 参数用于指定私钥</h3><blockquote><p>意为“identity_file”，默认值为~/.ssh/id_dsa。注意，对应的公钥必须存放到服务器</p></blockquote><pre><code class="BASH">ssh -i my-key server.example.com</code></pre><h3 id="l-参数指定远程登录的账户名"><a href="#l-参数指定远程登录的账户名" class="headerlink" title="-l 参数指定远程登录的账户名"></a><code>-l</code> 参数指定远程登录的账户名</h3><pre><code class="BASH">$ ssh -l sally server.example.com# 等同于$ ssh sally@server.example.com</code></pre><h3 id="L-参数设置本地端口转发"><a href="#L-参数设置本地端口转发" class="headerlink" title="-L 参数设置本地端口转发"></a><code>-L</code> 参数设置本地端口转发</h3><pre><code class="BASH">ssh  -L 9999:targetServer:80 user@remoteserver</code></pre><p>上面命令中，所有发向本地 <code>9999</code> 端口的请求，都会经过 <code>remoteserver</code> 发往 <code>targetServer</code> 的 <code>80</code> 端口，这就相当于直接连上了 <code>targetServer</code> 的 <code>80</code> 端口</p><h3 id="m-参数指定校验数据完整性的算法"><a href="#m-参数指定校验数据完整性的算法" class="headerlink" title="-m 参数指定校验数据完整性的算法"></a><code>-m</code> 参数指定校验数据完整性的算法</h3><pre><code class="BASH">ssh -m hmac-sha1,hmac-md5 server.example.com</code></pre><p>上面命令指定数据校验算法为 <code>hmac-sha1</code> 或 <code>hmac-md5</code></p><h3 id="o-参数用来指定一个配置命令"><a href="#o-参数用来指定一个配置命令" class="headerlink" title="-o 参数用来指定一个配置命令"></a><code>-o</code> 参数用来指定一个配置命令</h3><pre><code class="BASH">ssh -o "Keyword Value"</code></pre><p>举例来说，配置文件里面有如下内容。</p><pre><code class="BASH">User sallyPort 220</code></pre><p>通过 <code>-o</code> 参数，可以把上面两个配置命令从命令行传入。</p><pre><code class="BASH">ssh -o "User sally" -o "Port 220" server.example.com</code></pre><p>使用等号时，配置命令可以不用写在引号里面，但是等号前后不能有空格</p><pre><code class="BASH">ssh -o User=sally -o Port=220 server.example.com</code></pre><h3 id="p-参数指定-SSH-客户端连接的服务器端口"><a href="#p-参数指定-SSH-客户端连接的服务器端口" class="headerlink" title="-p 参数指定 SSH 客户端连接的服务器端口"></a><code>-p</code> 参数指定 SSH 客户端连接的服务器端口</h3><pre><code class="BASH">ssh -p 2035 server.example.com</code></pre><p>上面命令连接服务器的2035端口</p><h3 id="q-参数表示安静模式（quiet），不向用户输出任何警告信息"><a href="#q-参数表示安静模式（quiet），不向用户输出任何警告信息" class="headerlink" title="-q 参数表示安静模式（quiet），不向用户输出任何警告信息"></a><code>-q</code> 参数表示安静模式（quiet），不向用户输出任何警告信息</h3><pre><code class="BASH">ssh –q foo.comroot’s password:</code></pre><p>上面命令使用 <code>-q</code> 参数，只输出要求用户输入密码的提示</p><h3 id="R-参数指定远程端口转发"><a href="#R-参数指定远程端口转发" class="headerlink" title="-R 参数指定远程端口转发"></a><code>-R</code> 参数指定远程端口转发</h3><pre><code class="BASH">ssh -R 9999:targetServer:902 local</code></pre><p>上面命令需在跳板服务器执行，指定本地计算机 <code>local</code> 监听自己的 9999 端口，所有发向这个端口的请求，都会转向 targetServer 的 902 端口</p><h3 id="t-参数在-ssh-直接运行远端命令时，提供一个互动式-Shell"><a href="#t-参数在-ssh-直接运行远端命令时，提供一个互动式-Shell" class="headerlink" title="-t 参数在 ssh 直接运行远端命令时，提供一个互动式 Shell"></a><code>-t</code> 参数在 ssh 直接运行远端命令时，提供一个互动式 Shell</h3><pre><code class="BASH">ssh -t server.example.com emacs</code></pre><h3 id="v-参数显示详细信息"><a href="#v-参数显示详细信息" class="headerlink" title="-v 参数显示详细信息"></a><code>-v</code> 参数显示详细信息</h3><pre><code class="BASH">ssh -v server.example.com</code></pre><p><code>-v</code> 可以重复多次，表示信息的详细程度，比如 <code>-vv</code> 和 <code>-vvv</code></p><pre><code class="BASH">$ ssh -vvv server.example.com# 或者$ ssh -v -v -v server.example.com</code></pre><p>上面命令会输出最详细的连接信息</p><h3 id="V-参数输出-ssh-客户端的版本"><a href="#V-参数输出-ssh-客户端的版本" class="headerlink" title="-V 参数输出 ssh 客户端的版本"></a><code>-V</code> 参数输出 ssh 客户端的版本</h3><pre><code class="BASH">$ ssh –Vssh: SSH Secure Shell 3.2.3 (non-commercial version) on i686-pc-linux-gnu</code></pre><p>上面命令输出本机 ssh 客户端版本是 <code>SSH Secure Shell 3.2.3</code></p><h3 id="X-参数表示打开-X-窗口转发"><a href="#X-参数表示打开-X-窗口转发" class="headerlink" title="-X 参数表示打开 X 窗口转发"></a><code>-X</code> 参数表示打开 X 窗口转发</h3><pre><code class="BASH">ssh -X server.example.com</code></pre><h3 id="1-2参数指定使用-SSH1-SSH2-协议。"><a href="#1-2参数指定使用-SSH1-SSH2-协议。" class="headerlink" title="-1, -2参数指定使用 SSH1, SSH2 协议。"></a>-1, -2参数指定使用 SSH1, SSH2 协议。</h3><pre><code class="BASH">ssh -2 server.example.com</code></pre><h3 id="4-指定使用-IPv4-协议，这是默认值"><a href="#4-指定使用-IPv4-协议，这是默认值" class="headerlink" title="-4 指定使用 IPv4 协议，这是默认值"></a><code>-4</code> 指定使用 IPv4 协议，这是默认值</h3><pre><code class="BASH">ssh -4 server.example.com</code></pre><h3 id="6-指定使用-IPv6-协议"><a href="#6-指定使用-IPv6-协议" class="headerlink" title="-6 指定使用 IPv6 协议"></a><code>-6</code> 指定使用 IPv6 协议</h3><pre><code class="BASH">ssh -6 server.example.com</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务缓存原理与最佳实践</title>
      <link href="/My-Blogs/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E7%BC%93%E5%AD%98/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/My-Blogs/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E7%BC%93%E5%AD%98/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>文章主要介绍了分布式架构里的微服务缓存原理与最佳实践，下面让我们来一起看看吧</p><a id="more"></a><h2 id="为什么需要缓存？"><a href="#为什么需要缓存？" class="headerlink" title="为什么需要缓存？"></a>为什么需要缓存？</h2><ol><li><p> 程序存储在 <code>disk</code> 中</p></li><li><p> 程序是运行在 <code>RAM</code> 之中，也就是我们所说的 <code>main memory</code></p></li><li><p> 程序的计算逻辑在 <code>CPU</code> 中执行</p></li></ol><p>来看一个最简单的例子： <code>a = a + 1</code></p><ol><li><p> <code>load x:</code></p></li><li><p> <code>x0 = x0 + 1</code></p></li><li><p> <code>load x0 -&gt; RAM</code></p></li></ol><p><img src="/My-Blogs/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-01.png" alt="img"></p><p>上面提到了3种存储介质。我们都知道，三类的读写速度和成本成反比，所以我们在克服速度问题上需要引入一个 中间层。这个中间层，需要高速存取的速度，但是成本可接受。于是乎, <code>Cache</code> 被引入</p><p><img src="/My-Blogs/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-02.png" alt="img"></p><p>而在计算机系统中，有两种默认缓存：</p><p>CPU 里面的末级缓存，即 <code>LLC</code> 。缓存内存中的数据</p><p>内存中的高速页缓存，即 <code>page cache</code> 。缓存磁盘中的数据</p><h2 id="缓存读写策略"><a href="#缓存读写策略" class="headerlink" title="缓存读写策略"></a>缓存读写策略</h2><p>引入 <code>Cache</code> 之后，我们继续来看看操作缓存会发生什么。因为存在存取速度的差异「而且差异很大」，从而在操作数据时，延迟或程序失败等都会导致缓存和实际存储层数据不一致。</p><p>我们就以标准的 <code>Cache+DB</code> 来看看经典读写策略和应用场景。</p><h3 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache Aside"></a>Cache Aside</h3><p>先来考虑一种最简单的业务场景，比如用户表: <code>userId</code> : 用户id, <code>phone</code> : 用户电话token, <code>avtoar</code> : 用户头像url，缓存中我们用 <code>phone</code> 作为key存储用户头像。当用户修改头像url该如何做？</p><p>更新DB数据，再更新 <code>Cache</code> 数据</p><p>更新 DB 数据，再删除 <code>Cache</code> 数据</p><p>首先 变更数据库 和 变更缓存 是两个独立的操作，而我们并没有对操作做任何的并发控制。那么当两个线程并发更新它们的时候，就会因为写入顺序的不同造成数据不一致。</p><p>所以更好的方案是 <code>2</code> :</p><p>更新数据时不更新缓存，而是直接删除缓存</p><p>后续的请求发现缓存缺失，回去查询 <code>DB</code> ，并将结果 <code>load cache</code></p><p><img src="/My-Blogs/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-03.png" alt="img"></p><p>这个策略就是我们使用缓存最常见的策略: <code>Cache Aside</code> 。这个策略数据以数据库中的数据为准，缓存中的数据是按需加载的，分为读策略和写策略。</p><p>但是可见的问题也就出现了：频繁的读写操作会导致 <code>Cache</code> 反复地替换，缓存命中率降低。当然如果在业务中对命中率有监控报警时，可以考虑以下方案：</p><ol><li><p> 更新数据时同时更新缓存，但是在更新缓存前加一个 分布式锁。这样同一时间只有一个线程操作缓存，解决了并发问题。同时在后续读请求中时读到最新的缓存，解决了不一致的问题。</p></li><li><p> 更新数据时同时更新缓存，但是给缓存一个较短的 <code>TTL</code>。</p></li></ol><p>当然除了这个策略，在计算机体系还有其他几种经典的缓存策略，它们也有各自适用的使用场景。</p><h3 id="Write-Through"><a href="#Write-Through" class="headerlink" title="Write Through"></a>Write Through</h3><p>先查询写入数据key是否击中缓存，如果在 -&gt; 更新缓存，同时缓存组件同步数据至DB；不存在，则触发 ·。</p><p>而一般 · 有两种方式：</p><p><code>Write Allocate</code> ：写时直接分配 <code>Cache line</code></p><p><code>No-write allocate</code> ：写时不写入缓存，直接写入DB，return</p><p>在 <code>Write Through</code> 中，一般采取 <code>No-write allocate</code> 。因为其实无论哪种，最终数据都会持久化到DB中，省去一步缓存的写入，提升写性能。而缓存由 <code>Read Through</code> 写入缓存。</p><p><img src="/My-Blogs/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-04.png" alt="img"></p><p>这个策略的核心原则：<strong>用户只与缓存打交道，由缓存组件和DB通信，写入或者读取数据</strong>。在一些本地进程缓存组件可以考虑这种策略。</p><h3 id="Write-Back"><a href="#Write-Back" class="headerlink" title="Write Back"></a>Write Back</h3><p>相信你也看出上述方案的缺陷：写数据时缓存和数据库同步，但是我们知道这两块存储介质的速度差几个数量级，对写入性能是有很大影响。那我们是否异步更新数据库？</p><p><code>Write back</code> 就是在写数据时只更新该 Cache Line 对应的数据，并把该行标记为 Dirty。在读数据时或是在缓存满时换出「缓存替换策略」时，将 Dirty 写入存储。</p><p>需要注意的是：在 <code>Write Miss</code> 情况下，采取的是 <code>Write Allocate</code> ，即写入存储同时写入缓存，这样我们在之后的写请求只需要更新缓存。</p><p><img src="/My-Blogs/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-05.png" alt="img"></p><blockquote><p><code>async purge</code> 此类概念其实存在计算机体系中。 <code>Mysql</code> 中刷脏页，本质都是尽可能防止随机写，统一写磁盘时机。</p></blockquote><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><code>Redis</code> 是一个独立的系统软件，和我们写的业务程序是两个软件。当我们部署了Redis 实例后，它只会被动地等待客户端发送请求，然后再进行处理。所以，如果应用程序想要使用 Redis 缓存，我们就要在程序中增加相应的缓存操作代码。所以我们也把 <code>Redis</code> 称为 <strong>旁路缓存</strong>，也就是说：读取缓存、读取数据库和更新缓存的操作都需要在应用程序中来完成。</p><p>而作为缓存的 <code>Redis</code> ，同样需要面临常见的问题：</p><ul><li><p>缓存的容量终究有限</p></li><li><p>上游并发请求冲击</p></li><li><p>缓存与后端存储数据一致性</p></li></ul><h3 id="替换策略"><a href="#替换策略" class="headerlink" title="替换策略"></a>替换策略</h3><p>一般来说，缓存对于选定的被淘汰数据，会根据其是干净数据还是脏数据，选择直接删除还是写回数据库。但是，在 Redis 中，被淘汰数据无论干净与否都会被删除，所以，这是我们在使用 Redis 缓存时要特别注意的：当数据修改成为脏数据时，需要在数据库中也把数据修改过来。</p><p>所以不管替换策略是什么，脏数据有可能在换入换出中丢失。那我们在产生脏数据就应该删除缓存，而不是更新缓存，一切数据应该以数据库为准。这也很好理解，缓存写入应该交给读请求来完成；写请求尽可能保证数据一致性。</p><p>至于替换策略有哪些，网上已经有很多文章归纳之间的优劣，这里就不再赘述。</p><h2 id="缓存和存储更新顺序"><a href="#缓存和存储更新顺序" class="headerlink" title="缓存和存储更新顺序"></a>缓存和存储更新顺序</h2><p>这是开发中常见纠结问题：<strong>到底是先删除缓存还是先更新存储</strong>？</p><blockquote><p>情况一：先删除缓存，再更新存储；</p><ul><li>A 删除缓存，更新存储时网络延迟</li><li>B 读请求，发现缓存缺失，读存储 -&gt; 此时读到旧数据</li></ul></blockquote><p>这样会产生两个问题：</p><ul><li>B 读取旧值</li><li>B 同时读请求会把旧值写入缓存，导致后续读请求读到旧值</li></ul><p>既然是缓存可能是旧值，那就不管删除。有一个并不优雅的解决方案：<strong>在写请求更新完存储值以后</strong>， <code>sleep()</code> <strong>一小段时间，再进行一次缓存删除操作</strong>。</p><p><code>sleep</code> 是为了确保读请求结束，写请求可以删除读请求造成的缓存脏数据，当然也要考虑到 redis 主从同步的耗时。不过还是要根据实际业务而定。</p><p>这个方案会在第一次删除缓存值后，延迟一段时间再次进行删除，被称为： <code>延迟双删</code> 。</p><blockquote><p>情况二：先更新数据库值，再删除缓存值：</p><ul><li>A 删除存储值，但是删除缓存网络延迟</li><li>B 读请求时，缓存击中，就直接返回旧值</li></ul></blockquote><p>这种情况对业务的影响较小，而绝大多数缓存组件都是采取此种更新顺序，满足最终一致性要求。</p><blockquote><p>情况三：新用户注册，直接写入数据库，同时缓存中肯定没有。如果程序此时读从库，由于主从延迟，导致读取不到用户数据。</p></blockquote><p>这种情况就需要针对 Insert 这种操作：插入新数据入数据库同时写缓存。使得后续读请求可以直接读缓存，同时因为是刚插入的新数据，在一段时间修改的可能性不大。</p><p><strong>以上方案在复杂的情况或多或少都有潜在问题，需要贴合业务做具体的修改。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 分布式架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式架构 </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构三高总结</title>
      <link href="/My-Blogs/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E6%A6%82%E5%BF%B5/%E6%9E%B6%E6%9E%84%E4%B8%89%E9%AB%98%E6%80%BB%E7%BB%93/"/>
      <url>/My-Blogs/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E6%A6%82%E5%BF%B5/%E6%9E%B6%E6%9E%84%E4%B8%89%E9%AB%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>针对高性能、高可用、高扩展3个方面，罗列出需要注意的点。</p><a id="more"></a><h3 id="一、高性能的实践方案"><a href="#一、高性能的实践方案" class="headerlink" title="一、高性能的实践方案"></a>一、高性能的实践方案</h3><p>1、集群部署，通过负载均衡减轻单机压力。</p><p>2、多级缓存，包括静态数据使用CDN、本地缓存、分布式缓存等，以及对缓存场景中的热点key、缓存穿透、缓存并发、数据一致性等问题的处理。</p><p>3、分库分表和索引优化，以及借助搜索引擎解决复杂查询问题。</p><p>4、考虑数据库的使用，比如<code>HBase</code>、<code>TiDB</code>等，但是团队必须熟悉这些组件，且有较强的运维能力。</p><p>5、异步化，将次要流程通过多线程、<code>MQ</code>、甚至延时任务进行异步处理。</p><p>6、限流，需要先考虑业务是否允许限流（比如秒杀场景是允许的），包括前端限流、<code>Nginx</code>接入层的限流、服务端的限流。</p><p>7、对流量进行削峰填谷，通过<code>MQ</code>承接流量。</p><p>8、并发处理，通过多线程将串行逻辑并行化。</p><p>9、预计算，比如抢红包场景，可以提前计算好红包金额缓存起来，发红包时直接使用即可。</p><p>10、缓存预热，通过异步任务提前预热数据到本地缓存或者分布式缓存中。</p><p>11、减少IO次数，比如数据库和缓存的批量读写、<code>RPC</code>的批量接口支持、或者通过冗余数据的方式干掉<code>RPC</code>调用。</p><p>12、减少IO时的数据包大小，包括采用轻量级的通信协议、合适的数据结构、去掉接口中的多余字段、减少缓存key的大小、压缩缓存value等。</p><p>13、程序逻辑优化，比如将大概率阻断执行流程的判断逻辑前置、For循环的计算逻辑优化，或者采用更高效的算法。</p><p>14、各种池化技术的使用和池大小的设置，包括<code>HTTP</code>请求池、线程池（考虑<code>CPU密集型</code>还是<code>IO密集型</code>设置核心参数）、数据库和<code>Redis</code>连接池等。</p><p>15、<code>JVM</code>优化，包括新生代和老年代的大小、GC算法的选择等，尽可能减少GC频率和耗时。</p><p>16、锁选择，读多写少的场景用乐观锁，或者考虑通过分段锁的方式减少锁冲突。</p><p>上述方案无外乎从计算和 IO 两个维度考虑所有可能的优化点，需要有配套的监控系统实时了解当前的性能表现，并支撑你进行性能瓶颈分析，然后再遵循二八原则，抓主要矛盾进行优化。</p><h3 id="二、高可用的实践方案"><a href="#二、高可用的实践方案" class="headerlink" title="二、高可用的实践方案"></a>二、高可用的实践方案</h3><p>1、对等节点的故障转移，Nginx和服务治理框架均支持一个节点失败后访问另一个节点。</p><p>2、非对等节点的故障转移，通过心跳检测并实施主备切换（比如<code>redis</code>的哨兵模式或者集群模式、MySQL的主从切换等）。</p><p>3、接口层面的超时设置、重试策略和幂等设计。</p><p>4、降级处理：保证核心服务，牺牲非核心服务，必要时进行熔断；或者核心链路出问题时，有备选链路。</p><p>5、限流处理：对超过系统处理能力的请求直接拒绝或者返回错误码。</p><p>6、MQ场景的消息可靠性保证，包括<code>producer</code>端的重试机制、<code>broker</code>侧的持久化、<code>consumer</code>端的ack机制等。</p><p>7、灰度发布，能支持按机器维度进行小流量部署，观察系统日志和业务指标，等运行平稳后再推全量。</p><p>8、监控报警：全方位的监控体系，包括最基础的CPU、内存、磁盘、网络的监控，以及Web服务器、JVM、数据库、各类中间件的监控和业务指标的监控。</p><p>9、灾备演练：类似当前的“混沌工程”，对系统进行一些破坏性手段，观察局部故障是否会引起可用性问题。</p><p>高可用的方案主要从冗余、取舍、系统运维3个方向考虑，同时需要有配套的值班机制和故障处理流程，当出现线上问题时，可及时跟进处理。</p><h3 id="三、高扩展的实践方案"><a href="#三、高扩展的实践方案" class="headerlink" title="三、高扩展的实践方案"></a>三、高扩展的实践方案</h3><p>1、合理的分层架构：比如上面谈到的互联网最常见的分层架构，另外还能进一步按照数据访问层、业务逻辑层对微服务做更细粒度的分层（但是需要评估性能，会存在网络多一跳的情况）。</p><p>2、存储层的拆分：按照业务维度做垂直拆分、按照数据特征维度进一步做水平拆分（分库分表）。</p><p>3、业务层的拆分：最常见的是按照业务维度拆（比如电商场景的商品服务、订单服务等），也可以按照核心接口和非核心接口拆，还可以按照请求源拆（比如To C和To B，APP和H5）。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>幂等性与分布式锁</title>
      <link href="/My-Blogs/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E6%A6%82%E5%BF%B5/%E5%B9%82%E7%AD%89%E6%80%A7%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/My-Blogs/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E6%A6%82%E5%BF%B5/%E5%B9%82%E7%AD%89%E6%80%A7%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是幂等性"><a href="#1-什么是幂等性" class="headerlink" title="1. 什么是幂等性"></a>1. 什么是幂等性</h3><p><code>幂等性</code> 就是指：一个幂等操作任其执行多次所产生的影响均与一次执行的影响相同。用数学的概念表达是这样的: <code>f(f(x)) = f(x)</code> . 就像 <code>nx1 = n</code> 一样， x1 就是一个幂等操作。无论是乘以多少次结果都一样。</p><a id="more"></a><h3 id="2-常见的幂等性问题"><a href="#2-常见的幂等性问题" class="headerlink" title="2. 常见的幂等性问题"></a>2. 常见的幂等性问题</h3><blockquote><p>幂等性问题经常会是由网络问题引起的，还有重复操作引起的。</p></blockquote><p><strong>场景一：比如点赞功能，一个用户只能对同一片文章点赞一次，重复点赞提示已经点过赞了。</strong></p><p>示例代码：</p><pre><code class="JAVA">public void like(Article article,User user) {    //检查是否点过赞    if (checkIsLike(article,user)) {        //点过赞了        throw new ApiException(CodeEnums.SYSTEM_ERR);    } else {        //保存点赞        saveLike(article,user);    }}</code></pre><p>看上去好像没有什么问题，保存点赞之前已经检查过是否点赞了，理论上同一个人不会对同一篇文章重复点赞。但实际不是这样的。因为网络请求不是排队进来的，而是一窝蜂涌进来的。</p><p>某些时候，用户网络不好，可能很短的时间内点击了多次，由于网络传输问题，这些请求可能会同时来到我们的服务器。</p><ul><li><strong>第一个请求 checkIsLike（） 返回 false ， 正在执行 saveLike() 操作，还没来的及提交事务</strong> </li><li><strong>第二个请求过来了 ，checkIsLike（） 返回 也是 false , 并去 执行了 saveLike() 操作</strong></li></ul><p>这样子，就造成了一个用户同时对一篇文章进行了多次点赞操作。</p><p>这就是典型的幂等性问题， 操作了一次和操作了两次结果不一样，因为你多点了一次赞，按照幂等性原则 不管你点击了多少次结果都一样，只点了一次赞。</p><p>很多场景都是这样造成的，比如用户重复下单，重复评论，重复提交表单等。</p><p>那怎么解决呢？假设网络的请求是排队进来的就不会出现这个问题了。</p><p>于是我们可以改成这样：</p><pre><code class="JAVA">public synchronized void like(Article article,User user) {    //检查是否点过赞    if (checkIsLike(article,user)) {        //点过赞了        throw new ApiException(CodeEnums.SYSTEM_ERR);    } else {        //保存点赞        saveLike(article,user);    }}</code></pre><p><code>synchronized</code> 同步锁 这样我们的请求就会乖乖的排队进来了。</p><p>PS: 这样做是效率比较低的做法，不建议这么做，只是举例子，<code>synchronized</code> 也不适合分布式集群场景。</p><p><strong>场景二 ： 第三方回调</strong></p><p>我们系统经常需要和第三方系统打交道，比如微信充值，支付宝充值什么的，微信和支付宝常常会以回调你的接口通知你支付结果。为了保证你能收到回调，往往可能会回调多次。</p><p>有时候我们也为了保证数据的准确性会有个定时器去查询支付结果未知的流水，并执行响应的处理。<br>如果定时器的轮询和回调刚好是在同时进行，这可能又出BUG了, 又进行了两次重复操作。</p><p>那么问题来了：假设我是一个充值操作， 回调回来的时候 ，会做业务处理，成功了给用户账户加钱。这是后就要保证幂等性了， 假设微信同一笔交易给你回调了两次，如果你给用户充值了两次，这显然不合理(我是老板肯定扣你工资)，所以要保证 不管微信回调你多少次 ，同一笔交易你只能给用户充一次钱。这就幂等性</p><h3 id="解决幂等性问题方案"><a href="#解决幂等性问题方案" class="headerlink" title="解决幂等性问题方案"></a>解决幂等性问题方案</h3><ul><li>synchronized 适合单机应用，不追求性能 ，不追求并发。</li><li>分布式锁 但是往往我们的应用是分布式的集群，并且很讲究性能，并发，所以我们需要用到 分布式锁 来解决这个问题。</li></ul><p>Redis 分布式锁：</p><pre><code class="JAVA">/*** setNx**  @param key*  @param value*  @return*/public Boolean setNx(String key,Object value) {    return redisTemplate.opsForValue().setIfAbsent(key,value);}/***  @param key 锁*  @param waitTime 等待时间  毫秒*  @param expireTime 超时时间  毫秒*  @return*/public Boolean lock(String key,long waitTime,long expireTime) {    String vlaue =  UUIDUtil.mongoObjectId();    Boolean flag = setNx(key,vlaue);    //尝试获取锁  成功返回    if (flag) {        redisTemplate.expire(key,expireTime,TimeUnit.MILLISECONDS);        return flag;    } else {        //失败        //现在时间        long newTime =  System.currentTimeMillis();        //等待过期时间        long loseTime = newTime + waitTime;        //不断尝试获取锁成功返回        while (System.currentTimeMillis()  &lt; loseTime) {            Boolean testFlag = setNx(key,vlaue);            if (testFlag) {                redisTemplate.expire(key,expireTime,TimeUnit.MILLISECONDS);                return testFlag;            }            //休眠100毫秒            try {                Thread.sleep(100);            }            catch (InterruptedException e) {                e.printStackTrace();            }        }    }    return false;}/***  @param key*  @return*/public Boolean lock(String key) {    return lock(key,1000L,60  *  1000L);}/***  @param key*/public void unLock(String key) {    remove(key);}</code></pre><p>利用Redis 分布式锁 我们的代码可以改成这样：</p><pre><code class="JAVA">public void like(Article article,User user) {    String key =  "key:like"  + article.getId()  +  ":"  + user.getUserId();    //  等待锁的时间  0  ，  过期时间  一分钟防止死锁    Boolean flag = redisService.lock(key,0,60  *  1000L);    if(!flag) {        //获取锁失败  说明前面的请求已经获取了锁        throw new ApiException(CodeEnums.SYSTEM_ERR);    }    //检查是否点过赞    if (checkIsLike(article,user)) {        //点过赞了        throw new ApiException(CodeEnums.SYSTEM_ERR);    } else {        //保存点赞        saveLike(article,user);    }    //删除锁    redisService.unLock(key);}</code></pre><p>key 的设计也很讲究：</p><p>数据不冲突的两个业务场景，key不能冲突，不同人的key也不一样，不同的文章Key也不一样。</p><p>根据场景业务设定。</p><p><strong>一个原则： 尽可能的缩小key的范围。</strong> 这样才能增强我们的并发。</p><p>首先我们先获取锁，获取锁成功 执行完操作，保存数据 ，删除锁。获取不到锁返回失败。设置过期时间是为了防止‘死锁’，比如机器获取到了 锁，没有设置过期时间，但是他死机了，没有删除释放锁。</p><ul><li>版本号控制CAS 算法： CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。这个比较繁杂，有兴趣的大家可以去看看。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何学习分布式系统(转载)</title>
      <link href="/My-Blogs/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E6%96%87%E7%AB%A0/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F(%E8%BD%AC%E8%BD%BD)/"/>
      <url>/My-Blogs/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E6%96%87%E7%AB%A0/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F(%E8%BD%AC%E8%BD%BD)/</url>
      
        <content type="html"><![CDATA[<p>学习一个知识之前，我觉得比较好的方式是先理解它的来龙去脉：即这个知识产生的过程，它解决了什么问题，它是怎么样解决的并且它带来了哪些问题，这样我们才能比较好的抓到它的脉络和关键点，不会一开始就迷失在细节中。</p><p>所以，我们要解决的第一个问题是：<strong>分布式系统解决了什么问题？</strong></p><a id="more"></a><p><strong>第一个</strong>是单机性能瓶颈导致的成本问题，由于摩尔定律失效，廉价 PC 机性能的瓶颈无法继续突破，小型机和大型机能提高更高的单机性能，但是成本太大高，一般的公司很难承受；</p><p><strong>第二个</strong>是用户量和数据量爆炸性的增大导致的成本问题，进入互联网时代，用户量爆炸性的增大，用户产生的数据量也在爆炸性的增大，但是单个用户或者单条数据的价值其实比软件时代（比如银行用户）的价值是只低不高，所以必须寻找更经济的方案；</p><p><strong>第三个</strong>是业务高可用的要求，对于互联网的产品来说，都要求 7 * 24 小时提供服务，无法容忍停止服务等故障，而要提供高可用的服务，唯一的方式就是增加冗余来完成，这样就算单机系统可以支撑的服务，因为高可用的要求，也会变成一个分布式系统。</p><p>基于上面的三个原因可以看出，在互联网时代，单机系统是无法解决成本和高可用问题的，但是这两个问题对几乎对所有的公司来说都是非常关键的问题，所以，从单机系统到分布式系统是无法避免的技术大潮流。</p><p>那么，分布式系统是怎么来解决单机系统面临的成本和高可用问题呢？其实想法很简单，就是将一些廉价的 PC 机通过网络连接起来，共同完成工作，并且在系统中提供冗余来解决高可用的问题。我们来看分布式系统的定义：<strong>分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统</strong>。在定义中，我们可用看出，分布式系统它通过多工作节点来解决单机系统面临的成本和可用性问题，但是它引入了对分布式系统内部工作节点的协调问题。</p><p>掌握一个知识需要理解它的前因后果，对于分布式系统来说，前因是「分布式系统解决了什么问题」，后果是「它是怎么做内部工作节点的协调」，所以我们要解决的第二个问题是：分布式系统是怎么做内部工作节点协调的？</p><p>先从简单的情况入手，对于分布式计算（无状态）的情况，系统内部的协调需要做哪些工作：</p><h3 id="1、怎么样找到服务？"><a href="#1、怎么样找到服务？" class="headerlink" title="1、怎么样找到服务？"></a>1、怎么样找到服务？</h3><p>在分布式系统内部，会有不同的服务（角色），服务 A 怎么找到服务 B 是需要解决的问题，一般来说服务注册与发现机制是常用的思路，所以可以了解一下服务注册发现机制实现原理，并且可以思考服务注册发现是选择做成 AP 还是 CP 系统更合理；</p><h3 id="2、怎么样找到实例？"><a href="#2、怎么样找到实例？" class="headerlink" title="2、怎么样找到实例？"></a>2、怎么样找到实例？</h3><p>找到服务后，当前的请求应该选择发往服务的哪一个实例呢？一般来说，如果同一个服务的实例都是完全对等的（无状态），那么按负载均衡策略来处理就足够（轮询、权重、hash、一致性hash，fair等各种策略的适用场景）；如果同一个服务的实例不是对等的（有状态），那么需要通过路由服务（元数据服务等）先确定当前要访问的请求数据做哪一个实例上，然后再进行访问。</p><h3 id="3、怎么样避免雪崩？"><a href="#3、怎么样避免雪崩？" class="headerlink" title="3、怎么样避免雪崩？"></a>3、怎么样避免雪崩？</h3><p>系统雪崩是指故障的由于正反馈循序导致不断扩大规则的故障。一次雪崩通常是由于整个系统中一个很小的部分出现故障于引发，进而导致系统其它部分也出现故障。比如系统中某一个服务的一个实例出现故障，导致负载均衡将该实例摘除而引起其它实例负载升高，最终导致该服务的所有实例像多米诺骨牌一样一个一个全部出现故障。</p><p>避免雪崩总体的策略比较简单，只要是两个思路，一个是快速失败和降级机制（熔断、降级、限流等），通过快速减少系统负载来避免雪崩的发生；另一个为弹性扩容机制，通过快速增加系统的服务能力来避免雪崩的发生。这个根据不同的场景可以做不同的选择，或者两个策略都使用。</p><p>一般来说，快速失败会导致部分的请求失败，如果分布式系统内部对一致性要求很高的话，快速失败会带来系统数据不一致的问题，弹性扩容会是一个比较好的选择，但是弹性扩容的实现成本和响应时间比快速失败要大得多。</p><h3 id="4、怎么样监控告警？"><a href="#4、怎么样监控告警？" class="headerlink" title="4、怎么样监控告警？"></a>4、怎么样监控告警？</h3><p>对于一个分布式系统，如果我们不能很清楚地了解内部的状态，那么高可用是没有办法完全保障的，所以对分布式系统的监控（比如接口的时延和可用性等信息），分布式追踪 Trace，模拟故障的混沌工程，以及相关的告警等机制是一定要完善的；</p><p>接下来我们再来看分布式存储（有状态）的内部的协调是怎么做的，同时，前面介绍的分布式计算的协调方式在分布式存储中同样适用，就不再重复了：</p><h3 id="5、CAP-及其相关理论与衡权："><a href="#5、CAP-及其相关理论与衡权：" class="headerlink" title="5、CAP 及其相关理论与衡权："></a>5、CAP 及其相关理论与衡权：</h3><p>ACID、BASE 和 CAP 理论，了解这三个主题，推荐这一篇文章以及文章后面相关的参考文献：<a href="https://link.zhihu.com/?target=https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed/">英文版本</a>，<a href="https://link.zhihu.com/?target=https://www.infoq.cn/article/cap-twelve-years-later-how-the-rules-have-changed/">中文版本</a></p><h3 id="6、怎么样做数据分片："><a href="#6、怎么样做数据分片：" class="headerlink" title="6、怎么样做数据分片："></a>6、怎么样做数据分片：</h3><p>单机的存储能力是不可能存储所有的数据的，所以需要解决怎么将数据按一定的规则分别存储到不同的机器上，目前使用比较多的方案为: <code>Hash</code> 和 <code>Region</code> 分片策略，可以了解一下它们的优缺点和各自的应用场景；</p><h3 id="7、怎么样做数据复制："><a href="#7、怎么样做数据复制：" class="headerlink" title="7、怎么样做数据复制："></a>7、怎么样做数据复制：</h3><p>为了满足系统的高可用要求，需要对数据做冗余处理，目前的方案主要为：中心化方案（主从复制、一致性协议比如 <code>Raft</code> 和 <code>Paxos</code> 等）和 去中心化的方案（<code>Quorum</code> 和 <code>Vector Clock</code>）了解一下它们的优缺点和各自的应用场景，以及对系统外部表现出来的数据一致性级别（线性一致性、顺序一致性、最终一致性等）；</p><h3 id="8、怎么样做分布式事务："><a href="#8、怎么样做分布式事务：" class="headerlink" title="8、怎么样做分布式事务："></a>8、怎么样做分布式事务：</h3><p>对于分布式系统来说，要实现事务，首先需要一个对并发事务进行排序的能力，这样在事务冲突的时候，确认哪个事务提供成功，哪个事务提交失败。</p><p>对于单机系统来说这个完全不说问题，简单的通过时间戳加序号的方式就可以实现，但是对于分布式系统来说，系统中机器的时间不能完全同步，并且单台机器序号也没用全局意义，按上面的方式说不行的。</p><p>不过整个系统选一台机器按单机的模式生产事务ID是可以的，同城多中心和短距离的异地多中心都没有问题，不过想做成全球分布式系统的话，那么每一次事务都要去一个节点去获取事务ID的成本太高（比如中国杭州到美国东部的RTT为200+ms），Google 的 Spanner 是通过 GPS 和 原子钟实现 <code>TrueTime</code> API 来解决这个问题从而实现全球分布式数据库的。</p><p>有了事务ID后，通过 <code>2PC</code> 或者 <code>3PC</code> 协议来实现分布式事务的原子性，其他部分和单机事务差别不大，就不再细说来。</p><p>到这里，对分布式系统脉络上有了基本的概念，接下来开始进入细节学习阶段，这也是非常幸苦的阶段，对于分布式系统的理解深入与否，对细节的深入度是很重要的评价指标，毕竟魔鬼在细节。这里可以往两个方面进行系统的学习：</p><ol><li><p> 从实践出发，研究目前比较常用的分布式系统的设计，HDFS 或者 GFS（分布式文件系统）、Kafka 和 Pulsar（分布式消息队列），Redis Cluster 和 Codis（分布式缓存），MySQL 的分库分表（传统关系型数据库的分布式方案），MongoDB 的 Replica Set 和 Sharing机制集（NoSQL数据库），TiDB（NewSQL），以及一些微服务框架 等；</p></li><li><p> 从理论出发，研究分布式相关的论文，这里推荐一本书「 Designing Data-Intensive Applications」（中文版本：数据密集型应用系统设计），先整体看书，对比较感兴趣的章节，再读一读该章节中涉及到的相关参考文献。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式架构 </tag>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何构建一个完善的活动平台</title>
      <link href="/My-Blogs/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E6%96%87%E7%AB%A0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/"/>
      <url>/My-Blogs/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E6%96%87%E7%AB%A0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><blockquote><p>即是将页面的某一部分独立出来，将这一部分的用黑盒的形式全部封装到一个组件内，暴露出一些属性供外部组件传入值</p></blockquote><a id="more"></a><h3 id="白话解释"><a href="#白话解释" class="headerlink" title="白话解释"></a>白话解释</h3><blockquote><p>执行一段‘组件脚本’后，可以写“非法”HTML标签（指代组件实例），并在标签内绑定数据，该标签（组件）会根据自身逻辑，渲染出相关视图。</p></blockquote><h3 id="如下图"><a href="#如下图" class="headerlink" title="如下图"></a>如下图</h3><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-01.png"></p><br><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h3 id="一段不堪回首的经历😭"><a href="#一段不堪回首的经历😭" class="headerlink" title="一段不堪回首的经历😭"></a>一段不堪回首的经历😭</h3><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-02.png" alt="不堪回首"></p><br><h3 id="需求上线流程图"><a href="#需求上线流程图" class="headerlink" title="需求上线流程图"></a>需求上线流程图</h3><p><strong>特征：</strong></p><ol><li> 参与人员多。</li><li> 上线周期长。</li></ol><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-03.png" alt="img"></p><br><h3 id="可视化平台设想"><a href="#可视化平台设想" class="headerlink" title="可视化平台设想"></a>可视化平台设想</h3><p><strong>特征：</strong></p><ol><li> 设计、开发协作，提供通用、规范UI组件。</li><li> 用户创建活动，选择需要的组件，编辑组件数据。</li><li> 保存，预览，发布，访问。</li></ol><br><p><strong>如下图👇</strong><br><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-04.png" alt="img"></p><br><h3 id="上线流程图设想"><a href="#上线流程图设想" class="headerlink" title="上线流程图设想"></a>上线流程图设想</h3><p><strong>特征：</strong></p><ol><li> 人员少：仅运营1人。</li><li> 上线快：小时级周期。</li></ol><br><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-05.png" alt="img"></p><br><h3 id="平台启动前思考🤔"><a href="#平台启动前思考🤔" class="headerlink" title="平台启动前思考🤔"></a>平台启动前思考🤔</h3><p><code>组件开发</code>：<br>平台的组件数量应该无限制，组件之间独立，组件与平台解耦，做到动态加载、编辑组件。</p><p><code>配置平台</code>：<br>对外的核心交互，配置平台负责可视化创建页面，选择组件，编辑数据。</p><p><code>页面渲染</code>：<br>平台的最终产物，保存活动配置后，渲染页应该仅加载本活动涉及的组件。</p><p><code>总结</code>：<br>组件开发模块：负责产出页面的基本单元——组件。<br>配置平台模块：负责可视化创建，编辑活动页。<br>页面渲染模块：负责呈现活动视图。</p><br><h1 id="平台实现"><a href="#平台实现" class="headerlink" title="平台实现"></a>平台实现</h1><h3 id="组件开发架构图"><a href="#组件开发架构图" class="headerlink" title="组件开发架构图"></a>组件开发架构图</h3><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-06.png" alt="img"></p><br><h3 id="组件开发环境"><a href="#组件开发环境" class="headerlink" title="组件开发环境"></a>组件开发环境</h3><p><strong>组件开发：</strong></p><ol><li> 提供集中式开发、管理组件的项目环境。</li><li> 支持命令式创建、调试、编译、校验、发布组件。</li></ol><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-07.png" alt="img"></p><br><h3 id="再来说下组件形态"><a href="#再来说下组件形态" class="headerlink" title="再来说下组件形态"></a>再来说下组件形态</h3><ol><li> 一段可执行JS脚本——组件本身。</li><li> 一份XLSX文件——多地区语言配置。</li><li> 一份JSON文件——可编辑属性申明。</li></ol><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-08.png" alt="img"></p><br><h3 id="组件发布"><a href="#组件发布" class="headerlink" title="组件发布"></a>组件发布</h3><blockquote><p>命令式发布，相关字段被完善，注册入库。</p></blockquote><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-09.png" alt="img"></p><br><h1 id="平台实现-1"><a href="#平台实现-1" class="headerlink" title="平台实现"></a>平台实现</h1><h3 id="页面配置一览"><a href="#页面配置一览" class="headerlink" title="页面配置一览"></a>页面配置一览</h3><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-10.png" alt="img"></p><br><h3 id="页面配置-编辑"><a href="#页面配置-编辑" class="headerlink" title="页面配置-编辑"></a>页面配置-编辑</h3><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-11.png" alt="img"></p><br><h3 id="页面配置-发布"><a href="#页面配置-发布" class="headerlink" title="页面配置-发布"></a>页面配置-发布</h3><p><strong>发布流程</strong></p><ol><li> 将组件、配置打包。</li><li> 打包文件推至CDN。</li></ol><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-12.png" alt="img"></p><br><h3 id="页面渲染-解析"><a href="#页面渲染-解析" class="headerlink" title="页面渲染-解析"></a>页面渲染-解析</h3><ol><li> 加载CDN配置文件。</li><li> 遍历Render组件并传入该组件配置</li></ol><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-13.png" alt="img"></p><br><h3 id="页面渲染-监控"><a href="#页面渲染-监控" class="headerlink" title="页面渲染-监控"></a>页面渲染-监控</h3><ol><li> 异常监控+告警。</li><li> 页面性能监控+告警。</li><li> 用户行为监控。</li></ol><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-14.png" alt="img"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>组件开发</code>：关键数据有JS, JSON, XLSX。</li><li><code>页面配置</code>：选择组件，编辑组件，保存配置。</li><li><code>页面渲染</code>：逐个渲染组件并传入配置，页面监控。</li></ul><br><h1 id="实现细节总结"><a href="#实现细节总结" class="headerlink" title="实现细节总结"></a>实现细节总结</h1><ul><li><code>组件编辑面板</code>: 根据组件JSON配置，展开编辑面板。</li><li><code>组件通信</code>: 将发射、接收的事件、方法名申明，添加事件监听并调用暴露方法。</li><li><code>组件嵌套</code>: 配置中父子关系链。</li><li><code>多语言</code>: 汇总各组件多语言文件，集中处理成包，再以Hash ID分发。</li><li><code>主题色</code>: 规范视觉UI的色值占位，一套主题即一套词典。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式架构 </tag>
            
            <tag> 活动平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>easywebpack项目添加svg处理</title>
      <link href="/My-Blogs/2021/01/08/webpack/easywebpack/easywebpack%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0svg%E5%A4%84%E7%90%86/"/>
      <url>/My-Blogs/2021/01/08/webpack/easywebpack/easywebpack%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0svg%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>比如查看webpack最终的loader： <code>easywebpack print test -n module.rules</code></p><a id="more"></a><p>easywebpack配置svg-sprite-loader的配置：</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><blockquote><p>去除默认svg处理，并添加svg-sprite-loader配置</p></blockquote><pre><code class="JS">loaders: {  urlimage: {    test: /\.(png|jpe?g|gif)(\?.*)?$/, // 默认的url-loader在将svg也处理了，需要去掉  },  svg: {    test: /\.svg$/,    loader: 'svg-sprite-loader',    options: {      symbolId: 'icon-[name]',    },    include: resolve('app/web/asset/svg'),  },}</code></pre><p>网上关于<a href="https://juejin.cn/post/6854573215646875655">svg-sprite-loader</a>的介绍</p>]]></content>
      
      
      <categories>
          
          <category> easywebpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> svg </tag>
            
            <tag> webpack </tag>
            
            <tag> 基础构建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Vue3新特性</title>
      <link href="/My-Blogs/2021/01/08/vue/vue3/%E6%B5%85%E8%B0%88Vue3%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/My-Blogs/2021/01/08/vue/vue3/%E6%B5%85%E8%B0%88Vue3%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>Vue3的<a href="https://github.com/vuejs/vue-next">release版本</a>终于发布了，新的Vue3在语法以及底层都进行了全新的重构，带来了更快的运行速度，更小的构建包，更友好的编程规范。</p><a id="more"></a><h2 id="更快"><a href="#更快" class="headerlink" title="更快"></a>更快</h2><p>传统的虚拟dom算法：</p><p>组件patch的时候，需要重新创建整个vdom树，然后遍历整棵树进行diff，update…</p><p>更快的虚拟dom算法，源自编译模板时给予更多的运行时提示：</p><ol><li> 编译模板时对动态内容进行patch标记，告诉patch算法只关注被标记的动态部分</li></ol><p><img src="/My-Blogs/images/%E6%B5%85%E8%B0%88Vue3%E6%96%B0%E7%89%B9%E6%80%A7-01.png"></p><ol><li> 对静态内容进行静态提升（变量提升），只在页面初始化时创建并渲染一次，其余时候不再渲染</li></ol><p><img src="/My-Blogs/images/%E6%B5%85%E8%B0%88Vue3%E6%96%B0%E7%89%B9%E6%80%A7-02.png"></p><ol><li> 对事件监听函数进行缓存，防止内联监听函数带来的副作用</li></ol><p>开启缓存前：</p><p><img src="/My-Blogs/images/%E6%B5%85%E8%B0%88Vue3%E6%96%B0%E7%89%B9%E6%80%A7-03.png"></p><p>开启缓存后：</p><p><img src="/My-Blogs/images/%E6%B5%85%E8%B0%88Vue3%E6%96%B0%E7%89%B9%E6%80%A7-04.png"></p><p>……</p><p>从在线模板编译器中编辑并查看新变化 =&gt;<a href="https://vue-next-template-explorer.netlify.app/">模板编译器</a></p><h2 id="更小"><a href="#更小" class="headerlink" title="更小"></a>更小</h2><h3 id="全局API的使用"><a href="#全局API的使用" class="headerlink" title="全局API的使用"></a>全局API的使用</h3><p>全局 API 现在只能作为 ES 模块构建的命名导出进行访问。</p><h4 id="Vue2的使用方式"><a href="#Vue2的使用方式" class="headerlink" title="Vue2的使用方式"></a>Vue2的使用方式</h4><p>Vue.nextTick（this.$nextTick）、Vue.set、Vue.delete …</p><h4 id="Vue3的使用方式"><a href="#Vue3的使用方式" class="headerlink" title="Vue3的使用方式"></a>Vue3的使用方式</h4><p>import { nextTick, set, delete, … } from ‘vue’; </p><p>nextTick(() =&gt; {// dosomething});<br>……</p><h3 id="内部组件与helper的使用"><a href="#内部组件与helper的使用" class="headerlink" title="内部组件与helper的使用"></a>内部组件与helper的使用</h3><p>当在模板中使用到transtion组件、keepAlive组件、 …</p><p>经complier编译后，生成</p><p>import { transtion, keepAlive, … } from ‘vue’</p><p>当在模板中使用到v-show、v-model…</p><p>complier编译后，生成</p><p>import { vShow, vModel … } from ‘vue’</p><p>意味着只有在应用程序实际使用了某个API或者组件的时候才会导入它。没有使用到的功能代码将不会出现在最终的构建包中。框架体积进一步缩小。</p><h2 id="更友好？"><a href="#更友好？" class="headerlink" title="更友好？"></a>更友好？</h2><h4 id="VUE2组件现存的缺陷"><a href="#VUE2组件现存的缺陷" class="headerlink" title="VUE2组件现存的缺陷"></a>VUE2组件现存的缺陷</h4><ol><li><p> 组件越来越大，可读性和可维护性越来越差。根本原因在于Vue使用的option API：必须按配置(options)来组织代码，你需要把一个功能的实现分布在各个配置里：data，computed，watcher，methods，但是在某些情况下按功能来组织代码更合理。如果要在一个很大的组件中修改一个功能，就要跳到各个属性找，如果组件里面还用了mixins，还得跳文件看</p></li><li><p>mixins无法特别好的在多个组件中复用同一段代码  </p><p> mixins有什么问题？<br> 可读性太差，得跳到mixins所在的文件中才能知道它到底有什么<br> 不同的mixins容易冲突<br> 复用其他同伴的mixins的时候，有些代码不合自己的预期，但是不能随意更改</p></li><li><p> 对typeScript的支持有限</p></li></ol><h4 id="使用componsition-API"><a href="#使用componsition-API" class="headerlink" title="使用componsition API"></a>使用componsition API</h4><p>什么时候使用componsition API？</p><p><img src="/My-Blogs/images/%E6%B5%85%E8%B0%88Vue3%E6%96%B0%E7%89%B9%E6%80%A7-05.png"></p><ol><li> 如果你有一个很大的组件，想要按功能来聚合代码。</li><li> 如果你想要复用组件的一部分代码。</li><li> 如果你想要更好地支持typeScript</li></ol><pre><code class="JS">import useFeature1 from '../use/useFeature1';import useFeature2 from '../use/useFeature2';export default {  setup() {    const {      data1,      data2,      method1,      computed1,      ...    } = useFeature1();    const {      data3,      data4,      method2,      computed2,      ...    } = useFeature2();    // do something    return {      data1,      data2,      method1,      ...    };  }}</code></pre><p>上面这段代码是compsition API的一种示例，它做到了：按功能组织代码，想要修改某个业务逻辑时，不需要满大街找散布各地的数据和方法了，响应式属性与组件解耦，自由控制需要成为响应式的以及需要暴露给模板的属性。</p><p>setup内的代码只依赖于传入的参数和全局引入的Vue API，而不是特殊修改过的 <code>this</code> 。所以只需要导出你想要复用的功能函数。甚至可以导出整个 <code>setup</code> 函数去实现“类似”继承的效果。</p><h4 id="两种创建响应式属性的API"><a href="#两种创建响应式属性的API" class="headerlink" title="两种创建响应式属性的API"></a>两种创建响应式属性的API</h4><h5 id="ref-为传入的值封装一个响应式对象，通过value属性访问与设置对象的值"><a href="#ref-为传入的值封装一个响应式对象，通过value属性访问与设置对象的值" class="headerlink" title="ref: 为传入的值封装一个响应式对象，通过value属性访问与设置对象的值"></a>ref: 为传入的值封装一个响应式对象，通过value属性访问与设置对象的值</h5><pre><code class="JS">setup() {  const capacity = ref(3);  const attending = ref(['tim', 'Bob', 'Joe']);  watch(capacity, () =&gt; {    console.log('capacity changed!');  });  watch(attending, () =&gt; {    console.log('attending changed!');  });  onMounted(() =&gt; {    capacity.value += 1; // capacity changed!    attending.value[0] = 'Jack'; // ?    // 通过ref封装的响应式对象无法进行深层监听  });  return {    capacity  };}</code></pre><h5 id="reactive-让传入的对象成为响应式对象"><a href="#reactive-让传入的对象成为响应式对象" class="headerlink" title="reactive: 让传入的对象成为响应式对象"></a>reactive: 让传入的对象成为响应式对象</h5><pre><code class="JS">setup() {  const event = reactive({    capacity: 3,    attending: ['tim', 'Bob', 'Joe'],  });  watch(event, () =&gt; {    console.log('something changed!');  });  onMounted(() =&gt; {    event.attending[0] = 'Jack'; // something changed!  });  return {    event  };}</code></pre><p>Vue3的响应式监听的实现方式与Vue2有很大不同，并挣脱了Vue2中无法监听动态增加对象属性与数组元素直接赋值的束缚。</p><p>点这里查看<a href="https://github.com/LaiTaoGDUT/learnVue3/blob/master/public/reactive.html">简略版本的新响应式监听实现</a></p><h4 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h4><h5 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h5><pre><code class="JS">setup() {  const capacity = ref(3);  const attending = ref(['tim', 'Bob', 'Joe']);  const stop = watchEffect(() =&gt; {    console.log(capacity.value + attending.value.length);  })  onMounted(() =&gt; {    capacity.value += 1; // 7  });  return {    capacity,    attending,    stop  };}stop(); // 停止监听</code></pre><p><a href="https://vue3js.cn/docs/zh/api/">更多API请参考官方文档</a></p><h4 id="compisition-API的下一步"><a href="#compisition-API的下一步" class="headerlink" title="compisition API的下一步"></a>compisition API的下一步</h4><h5 id="现存的缺点"><a href="#现存的缺点" class="headerlink" title="现存的缺点"></a>现存的缺点</h5><ol><li> ref和reactive太像了，初上手时很难决定到底用哪个。</li><li> 没有了options的限制，一不小心就可能会写出比使用option API更加臃肿难读的代码</li><li> 使用Composition API时，需要区分哪些值或者对象是响应式的，哪些不是。</li><li> 阅读或者修改ref会有点麻烦，因为必须通过<code>.value</code>才能实现。</li><li> 一旦组件需要使用的数据多起来，import和return语句就会很冗长。</li></ol><h5 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h5><p><a href="https://github.com/vuejs/rfcs/pull/222">New script setup and ref sugar</a></p><p>前阵子，Vue3.0提出了两个新提案，分别为script-setup提案与ref-suger提案</p><p>对于以下源代码：</p><pre><code class="HTML">&lt;script&gt;  import {    ref  } from 'vue'  export default {    setup() {      const count = ref(1)      const inc = () =&gt; {        count.value++      }      return {        count,        inc      }    }  }&lt;/script&gt;</code></pre><p><strong>使用script-setup 提案，将 options.setup 提取到代码顶层，所有顶层声明默认导出为模板使用</strong></p><pre><code class="HTML">&lt;script setup&gt;  import {    ref  } from 'vue'  const count = ref(0)  const inc = () =&gt; {    count.value++  }&lt;/script&gt;</code></pre><p><strong>使用ref-sugar 提案，将 ref.value 的写法，做进一步简化，放弃<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/label">标记语句</a>的普通语法，将其作为ref声明的语法糖。</strong></p><pre><code class="HTML">&lt;script setup&gt;  ref: count = 1  const inc = () =&gt; {    count++  }  // 通过添加$前缀来访问响应式对象  console.log($count.value)&lt;/script&gt;</code></pre><p>这是Vue3带来的小改进还是大挑战 ？</p><h2 id="其他变化"><a href="#其他变化" class="headerlink" title="其他变化"></a>其他变化</h2><h4 id="不再支持keyCode修饰"><a href="#不再支持keyCode修饰" class="headerlink" title="不再支持keyCode修饰"></a>不再支持keyCode修饰</h4><pre><code class="HTML">&lt;input v-on:keyup.13="handleEnter"&gt;&lt;/input&gt;</code></pre><p>替换为</p><pre><code class="HTML">&lt;input v-on:keyup:enter="handleEnter"&gt;&lt;/input&gt;</code></pre><h4 id="过渡类名变更"><a href="#过渡类名变更" class="headerlink" title="过渡类名变更"></a>过渡类名变更</h4><p>.v-enter =&gt; .v-enter-from</p><p>.v-leave =&gt; .v-leave-from</p><h4 id="v-model变更"><a href="#v-model变更" class="headerlink" title="v-model变更"></a>v-model变更</h4><p>可使用多个v-model, 不再需要.sync修饰符来进行双向绑定了</p><pre><code class="HTML">&lt;ChildComponent v-model:title="pageTitle" /&gt;</code></pre><p>相当于</p><pre><code class="HTML">&lt;ChildComponent :title="pageTitle" @update:title="pageTitle = $event" /&gt;</code></pre><h4 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h4><p>Vue认为$ on，$ off 和 $once 实例方法不应该由它来提供，因此Vue3将它们移除了</p><p>过滤器filters被移除了，需要使用计算属性或方法来代替</p><p>新增Suspence组件 =&gt; 组件loading完成前显示后备内容</p><p>新增teleport组件（portal） =&gt; 允许传送组件内容到根节点以外的任何地方<br>…</p>]]></content>
      
      
      <categories>
          
          <category> vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis缓存的三大问题及其解决方案</title>
      <link href="/My-Blogs/2021/01/08/Redis/%E3%80%90Redis%E3%80%91%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/My-Blogs/2021/01/08/Redis/%E3%80%90Redis%E3%80%91%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>Redis经常用于系统中的缓存，这样可以解决目前IO设备无法满足互联网应用海量的读写请求的问题。</p><a id="more"></a><h2 id="一、缓存穿透"><a href="#一、缓存穿透" class="headerlink" title="一、缓存穿透"></a>一、缓存穿透</h2><p>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起id为-1的数据或者特别大的不存在的数据。有可能是黑客利用漏洞攻击从而去压垮应用的数据库。</p><h3 id="1-常见解决方案"><a href="#1-常见解决方案" class="headerlink" title="1. 常见解决方案"></a>1. 常见解决方案</h3><p>对于缓存穿透问题，常见的解决方案有以下三种：</p><ul><li>验证拦截：接口层进行校验，如鉴定用户权限，对ID之类的字段做基础的校验，如id&lt;=0的字段直接拦截；</li><li>缓存空数据：当数据库查询到的数据为空时，也将这条数据进行缓存，但缓存的有效性设置得要较短，以免影响正常数据的缓存；</li></ul><pre><code class="JAVA">public Student getStudentsByID(Long id) {    // 从Redis中获取学生信息    Student student = redisTemplate.opsForValue()        .get(String.valueOf(id));    if (student != null) {        return student;    }    // 从数据库查询学生信息，并存入Redis    student = studentDao.selectByStudentId(id);    if (student != null) {        redisTemplate.opsForValue()            .set(String.valueOf(id), student, 60, TimeUnit.MINUTES);    } else {        // 即使不存在，也将其存入缓存中        redisTemplate.opsForValue()            .set(String.valueOf(id), null, 60, TimeUnit.SECONDS);    }    return student;}</code></pre><ul><li>使用布隆过滤器：布隆过滤器是一种比较独特数据结构，有一定的误差。当它指定一个数据存在时，它不一定存在，但是当它指定一个数据不存在时，那么它一定是不存在的。</li></ul><h3 id="2-布隆过滤器"><a href="#2-布隆过滤器" class="headerlink" title="2. 布隆过滤器"></a>2. 布隆过滤器</h3><p>布隆过滤器是一种比较特殊的数据结构，有点类似与HashMap，在业务中我们可能会通过使用HashMap来判断一个值是否存在，它可以在<code>O(1)</code>时间复杂度内返回结果，效率极高，但是受限于存储容量，如果可能需要去判断的值超过亿级别，那么HashMap所占的内存就很可观了。<br>而<code>BloomFilter</code>解决这个问题的方案很简单。首先用多个bit位去代替HashMap中的数组，这样的话储存空间就下来了，之后就是对 Key 进行多次哈希，将 Key 哈希后的值所对应的 bit 位置为1。<br>当判断一个元素是否存在时，就去判断这个值哈希出来的比特位是否都为1，如果都为1，那么可能存在，也可能不存在（如下图F）。但是如果有一个bit位不为1，那么这个Key就肯定不存在。</p><p><img src="/My-Blogs/images/%E3%80%90Redis%E3%80%91%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-01.png" alt="img"></p><br><p>注意：<code>BloomFilter</code>并不支持删除操作，只支持添加操作。这一点很容易理解，因为你如果要删除数据，就得将对应的bit位置为0，但是你这个Key对应的bit位可能其他的Key也对应着。</p><h3 id="3-缓存空数据与布隆过滤器的比较"><a href="#3-缓存空数据与布隆过滤器的比较" class="headerlink" title="3. 缓存空数据与布隆过滤器的比较"></a>3. 缓存空数据与布隆过滤器的比较</h3><p>上面对这两种方案都进行了简单的介绍，缓存空数据与布隆过滤器都能有效解决缓存穿透问题，但使用场景有着些许不同；</p><ul><li>当一些恶意攻击查询查询的key各不相同，而且数量巨多，此时缓存空数据不是一个好的解决方案。因为它需要存储所有的Key，内存空间占用高。并且在这种情况下，很多key可能只用一次，所以存储下来没有意义。所以对于这种情况而言，使用布隆过滤器是个不错的选择；</li><li>而对与空数据的Key数量有限、Key重复请求效率较高的场景而言，可以选择缓存空数据的方案。</li></ul><h2 id="二、缓存击穿"><a href="#二、缓存击穿" class="headerlink" title="二、缓存击穿"></a>二、缓存击穿</h2><p>缓存击穿是指当前热点数据存储到期时，多个线程同时并发访问热点数据。因为缓存刚过期，所有并发请求都会到数据库中查询数据。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>将热点数据设置为永不过期；</li><li>加互斥锁：互斥锁可以控制查询数据库的线程访问，但这种方案会导致系统的吞吐量下降，需要根据实际情况使用。</li></ul><pre><code class="JAVA">public String get(key) {    String value = redis.get(key);    if (value == null) { // 代表缓存值过期        // 设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db        if (redis.setnx(key_mutex, 1, 3 * 60) == 1) {  // 代表设置成功            value = db.get(key);            redis.set(key, value, expire_secs);            redis.del(key_mutex);        } else {  // 这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可            sleep(50);            get(key);  // 重试        }    } else {        return value;          }}</code></pre><h2 id="三、缓存雪崩"><a href="#三、缓存雪崩" class="headerlink" title="三、缓存雪崩"></a>三、缓存雪崩</h2><p>缓存雪崩发生有几种情况，比如大量缓存集中在或者缓存同时在大范围中失效，出现了大量请求去访问数据库，从而导致CPU和内存过载，甚至停机。</p><p>一个简单的雪崩过程：</p><ol><li> Redis 集群产生了大面积故障；</li><li> 缓存失败，此时仍有大量请求去访问 Redis 缓存服务器；</li><li> 在大量 Redis 请求失败后，这些请求将会去访问数据库；</li><li> 由于应用的设计依赖于数据库和 Redis 服务，很快就会造成服务器集群的雪崩，最终导致整个系统的瘫痪。</li></ol><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>【事前】高可用缓存：高可用缓存是防止出现整个缓存故障。即使个别节点，机器甚至机房都关闭，系统仍然可以提供服务，Redis 哨兵(Sentinel) 和 Redis 集群(Cluster) 都可以做到高可用；</li><li>【事中】缓存降级（临时支持）：当访问次数急剧增加导致服务出现问题时，我们如何确保服务仍然可用。在国内使用比较多的是 Hystrix，它通过熔断、降级、限流三个手段来降低雪崩发生后的损失。只要确保数据库不死，系统总可以响应请求，每年的春节 12306 我们不都是这么过来的吗？只要还可以响应起码还有抢到票的机会；</li><li>【事后】Redis备份和快速预热：Redis数据备份和恢复、快速缓存预热。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWA在likee业务线的实践</title>
      <link href="/My-Blogs/2021/01/08/PWA/PWA%E5%9C%A8likee%E4%B8%9A%E5%8A%A1%E7%BA%BF%E7%9A%84%E5%AE%9E%E8%B7%B5/"/>
      <url>/My-Blogs/2021/01/08/PWA/PWA%E5%9C%A8likee%E4%B8%9A%E5%8A%A1%E7%BA%BF%E7%9A%84%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是PWA？"><a href="#1-什么是PWA？" class="headerlink" title="1. 什么是PWA？"></a>1. 什么是PWA？</h2><p>PWA（Progressive web apps，渐进式 Web 应用）运用现代的 Web API 以及传统的渐进式增强策略来创建跨平台 Web 应用程序。</p><a id="more"></a><p>如何理解渐进式？</p><ul><li>  渐进式构建。构成 PWA 的标准都来自 Web 技术，它们都是浏览器提供的、向下兼容的、没有额外运行时代价的技术。因此可以把任何现有的框架开发的 Web 页面改造成 PWA，不需要完全重构现有代码，可以逐步地迁移和改善。</li><li>  渐进式增强。浏览器厂商会逐步提供对 PWA 相关api的支持，现代浏览器的用户会逐步受益，但不会为使用旧版浏览器的用户破坏任何内容。</li></ul><h2 id="2-PWA能做什么？"><a href="#2-PWA能做什么？" class="headerlink" title="2. PWA能做什么？"></a>2. PWA能做什么？</h2><ul><li><p>  安装添加桌面图标</p></li><li><p>  提供前端网络代理</p></li><li><p>  利用cache api对response进行缓存</p></li><li><p>发送push通知  </p><p>  接收服务端推送</p></li></ul><h2 id="3-PWA的工作原理"><a href="#3-PWA的工作原理" class="headerlink" title="3. PWA的工作原理"></a>3. PWA的工作原理</h2><p>PWA实现上述功能，依赖于service worker提供的能力。</p><p>service worker是web worker的一种，是运行在独立线程中的js代码。一个service worker的完整生命周期如下图所示。</p><p><img src="/My-Blogs/images/PWA%E5%9C%A8likee%E4%B8%9A%E5%8A%A1%E7%BA%BF%E7%9A%84%E5%AE%9E%E8%B7%B5-01.png"></p><p>通常遵循以下基本步骤来使用 service worker：</p><ul><li><p>  service worker URL 通过 serviceWorkerContainer.register() 来获取和注册。</p></li><li><p>  如果注册成功，service worker 就在 ServiceWorkerGlobalScope 环境中运行； 这是一个特殊类型的 worker 上下文运行环境，与主运行线程（执行脚本）相独立，同时也没有访问 DOM 的能力。</p></li><li><p>service worker 现在可以处理事件了。  </p><p>  受 service worker 控制的页面打开后会尝试去安装 service worker。最先发送给 service worker 的事件是安装事件。</p></li><li><p>  当 oninstall 事件的处理程序执行完毕后，可以认为 service worker 安装完成了。</p></li><li><p>  下一步是激活。当 service worker 安装完成后，会接收到一个激活事件(activate event)。onactivate 主要用途是清理先前版本的service worker 脚本中使用的资源。</p></li><li><p>  service worker 现在可以控制页面了，但仅是在 register() 成功后的打开的页面。</p></li></ul><p>示例代码如下：</p><pre><code class="JS">navigator.serviceWorker.register(opts.url).then(function(registration) {  console.log("Service worker successfully registered.");})</code></pre><h2 id="4-处理业务需要封装的基本方法"><a href="#4-处理业务需要封装的基本方法" class="headerlink" title="4. 处理业务需要封装的基本方法"></a>4. 处理业务需要封装的基本方法</h2><p>为了处理业务，我们对service worker相关的基本方法进行了封装</p><p>主线程js封装如下：</p><pre><code class="JS">/** * service worker sdk *  * @param {string} opts.url [required] sw文件地址 * @param {function} opts.onReady [optional] sw注册成功 * @param {function} opts.onBeforeInstallPrompt [optional] 未安装pwa事件触发 * @param {function} opts.onClickInstallPrompt [optional] 点击安装确认弹窗 * @param {function} opts.onInstalled [optional] pwa安装成功时触发 * @param {function} opts.onNotificationPermission [optional] 点击通知授权确认弹窗 *  */export function SWSdk(opts) {  /**   * 初始化sw   */  /**   * sw注册成功   */  /**   * 未安装pwa事件触发   */  /**   * pwa安装成功时触发   */  /**   * 弹出安装确认弹窗   */  /**   * 监听sw事件   */  /**   * 触发sw事件   */  /**   * 弹出通知授权确认弹窗   */  /**   * 发送一条通知   */  /**   * 缓存资源   */  /**   * 删除缓存资源   */}</code></pre><p>sw线程js封装如下：</p><pre><code class="JS">/** * SW *  * @param {string} opts. CACHE_NAME [optional] 缓存命名空间，建议每个应用独立命名 * @param {number} opts.tickTime [optional] 每个tick的时间间隔，单位ms，默认1000 * @param {function} opts.onTick [optional] 每个时间间隔调用一次 * @param {function} opts.onProxy [optional] 代理网络请求 * @param {function} opts.onInstall [optional] 安装事件的回调 * @param {function} opts.onActivate [optional] 激活事件的回调 * @param {function} opts.onPush [optional] 收到服务端事件的回调 * @param {function} opts.notificationOnClick [optional] 点击push通知的回调 */var SW = function(opts) {  /**   * 初始化sw   */  /**   * 监听窗口事件   */  /**   * 触发窗口事件   */  /**   * 设置cache   */  /**   * 获取cache   */  /**   * 发送一条通知   */};</code></pre><p>对service worker api的封装，使我们可以更加集中精力处理业务。</p><p>封装的基本方法有：</p><blockquote><p>a. 线程间通讯。主线程和service worker线程之间需要频繁的通信，因此需要封装比较友好的通信方法</p></blockquote><p>主线程：</p><pre><code class="JS">/** * 监听sw事件 *  * @param {string} eventName [required] 事件名称 * @param {function} handler [required] 处理函数 */this.on = function(eventName, handler) {  this.eventListener.push({    eventName: eventName,    handler: handler  })};/** * 触发sw事件 *  * @param {string} eventName [required] 事件名称 * @param {any} payload [optional] 传递的数据 */this.emit = function(eventName, payload) {  const data = {    eventName: eventName,    payload: payload  };  try {    if (navigator.serviceWorker.controller) {      navigator.serviceWorker.controller.postMessage(data);    } else {      navigator.serviceWorker.addEventListener("controllerchange", () =&gt; {        navigator.serviceWorker.controller.postMessage(data);      });    }  } catch (err) {    console.error(err);  }}</code></pre><p>service worker线程：</p><pre><code class="JS">/** * 监听窗口事件 *  * @param {string} eventName [required] 事件名称 * @param {function} handler [required] 处理函数 */this.on = function(eventName, handler) {  this.eventListener.push({    eventName: eventName,    handler: handler  })};/** * 触发窗口事件 *  * @param {string} eventName [required] 事件名称 * @param {any} payload [optional] 传递的数据 */this.emit = function(eventName, payload) {  clients.matchAll({    type: 'window',    includeUncontrolled: true  }).then(function(matchClient) {    matchClient.forEach(function(client) {      client.postMessage({        eventName: eventName,        payload: payload      });    })  });};</code></pre><blockquote><p>b. 本地存储。在service worker 线程中，我们无法使用cookie，localStorage和sessionStorage，我们只能使用cache api或者indexDB作为存储key-value数据的载体。</p></blockquote><pre><code class="JS">/** * 设置cache *  * @param {string} key cache的key * @param {any} value cache的值 */this.setCache = function(key, value) {  try {    return caches.open(this.CACHE_NAME).then(function(cache) {      return cache.put(key, new Response(value));    })  } catch (err) {    const that = this;    return new Promise(function(resolve) {      if (!that.cacheStorage[that.CACHE_NAME]) {        that.cacheStorage[that.CACHE_NAME] = {};      }      that.cacheStorage[that.CACHE_NAME][key] = value;      resolve();    })  }};/** * 获取cache *  * @param {string} key cache的key */this.getCache = function(key) {  try {    return caches.open(this.CACHE_NAME).then(function(cache) {      return cache.match(key);    }).then(function(response) {      return response ? response.text() : '';    })  } catch (err) {    const that = this;    return new Promise(function(resolve) {      resolve(new String(that.cacheStorage[that.CACHE_NAME][key]));    })  }};</code></pre><p>cache api无法直接保存key-value键值对数据，只能保存url-response对数据，我们这里使用了一些小技巧，使它可以存储key-value型数据</p><blockquote><p>c. 通知</p></blockquote><p>主线程申请授权</p><pre><code class="JS">/** * 弹出通知授权确认弹窗 */this.requestNotificationPermission = function() {  Notification.requestPermission().then((result) =&gt; {    that.onNotificationPermission.bind(that)(result);  });};</code></pre><p>service worker线程发送通知</p><pre><code class="JS">/** * 发送一条通知 *  * @param {object} params [required] * @param {string} params.title [required] 标题 * @param {string} params.desc [optional] 描述 * @param {string} params.icon [optional] 图标 * @param {any} params.data [optional] 传递参数 * @param {string} params.url [optional] 点击跳转地址 */this.showNotification = function(params) {  try {    self.registration.showNotification(params.title, {      body: params.desc,      icon: params.icon,      image: params.image,      data: Object.assign({        url: params.url      }, params.data)    })  } catch (err) {    console.log(err);  }};</code></pre><h2 id="5-业务需求及对策"><a href="#5-业务需求及对策" class="headerlink" title="5. 业务需求及对策"></a>5. 业务需求及对策</h2><p>此小节内容太多，不详细展开，有兴趣可以私聊</p><blockquote><p>a. 安装桌面快捷方式</p></blockquote><ul><li>  未安装事件</li><li>  弹出询问安装弹窗api</li></ul><blockquote><p>b. 本地推送通知</p></blockquote><ul><li>  询问授权通知api</li><li>  发送通知</li></ul><blockquote><p>c. sw内埋点</p></blockquote><ul><li>  Fetch api</li><li>  请求数据构造</li></ul><blockquote><p>d. 拉活桌面pwa</p></blockquote><ul><li>  需要安装google play服务</li><li>  需要由不同域的页面发起重定向跳转</li><li>  与pwa同域的链接均可拉活pwa，且pwa展示跳转链接，而非start_url中配置的链接</li><li>  中转页策略</li></ul><blockquote><p>e. 视频预加载</p></blockquote><ul><li>  使用cache api</li></ul><blockquote><p>f. 识别用户访问的是web页面还是桌面pwa</p></blockquote><ul><li>  桌面入口拉活</li><li>  链接拉活</li></ul><h2 id="6-遇到的问题"><a href="#6-遇到的问题" class="headerlink" title="6. 遇到的问题"></a>6. 遇到的问题</h2><blockquote><p>a. 兼容问题</p></blockquote><p>pwa的兼容性是比较差的，几乎每个api都有兼容问题，需要对不同的设备做适配。这些兼容问题很多是查看线上统计数据后才发现的</p><blockquote><p>b. 数据统计</p></blockquote><p>为了统计pwa转化效果，我们需要识别用户访问的是web页面还是桌面的pwa，然而，我们只能统计到桌面图标打开的用户和链接拉活的pwa用户，对于push拉活，第三方app拉活的场景，我们是无法识别的。</p>]]></content>
      
      
      <categories>
          
          <category> PWA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Libuv线程池如何提高nodejs性能</title>
      <link href="/My-Blogs/2021/01/08/NodeJs/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Libuv%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98NodeJs%E6%80%A7%E8%83%BD/"/>
      <url>/My-Blogs/2021/01/08/NodeJs/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Libuv%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98NodeJs%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>如何提高NodeJS性能？下面我们来介绍一种方式，一起看看吧</p><a id="more"></a><h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><a href="https://hackernoon.com/how-libuv-thread-pool-can-boost-your-node-js-performance-bel3tyf">原文链接</a></h3><h3 id="Libuv线程池"><a href="#Libuv线程池" class="headerlink" title="Libuv线程池"></a>Libuv线程池</h3><p>Libuv启动一个包含4个线程的线程池，用于将同步操作卸载到该线程池。为此，Libuv确保同步任务不会不必要地阻止我们的应用程序。</p><p>在这里，我们将利用设置来更好地适应我们的计算机或将应用程序部署到的虚拟机的规格。这是因为我们被允许将4个线程的默认值更改为最多1024个线程。我们通过设置UV_THREADPOOL_SIZE Node变量来实现。</p><p>物理与逻辑CPU内核</p><p>为了更好地了解将UV_THREADPOOL_SIZE设置为什么，我们首先需要了解我们的计算机正在运行多少个逻辑核心。如果以我的MacBook Pro为例，它运行的是6个物理CPU内核（英特尔）。</p><p>但是，这些内核具有超线程，这意味着每个内核可以同时运行2个操作。因此，我们将具有超线程的1个物理核心视为2个逻辑核心。就我而言，我的MacBook Pro运行12个逻辑核心。</p><h3 id="如何提高Node-JS性能"><a href="#如何提高Node-JS性能" class="headerlink" title="如何提高Node JS性能"></a>如何提高Node JS性能</h3><p>建议将 <code>UV_THREADPOOL_SIZE</code> 设置为计算机正在运行的逻辑核心数。就我而言，我将线程池大小设置为12。</p><p>将大小设置为除硬件正在运行的逻辑内核之外的任何值都没有意义，实际上可能会导致性能降低。</p><h3 id="如何检查逻辑核心"><a href="#如何检查逻辑核心" class="headerlink" title="如何检查逻辑核心"></a>如何检查逻辑核心</h3><p>部署时，最后要做的是手动设置UV_THREADPOOL_SIZE，因为您的应用程序可能在具有不同机器规格的多个环境中运行。因此，我们需要一种在相关环境中启动应用程序后动态设置线程池大小的方法。</p><p>好消息是，这很简单，但必须谨慎对待。为此，请将以下代码添加到Node应用程序的根JS文件的顶部：</p><pre><code class="JavaScript">const OS = require('os')process.env.UV_THREADPOOL_SIZE = OS.cpus().length</code></pre><p>该OS模块是原产于节点JS。它具有一个函数cpus（），该函数返回计算机正在运行的逻辑内核的总数。很好的是，如果您的CPU内核没有超线程，则此函数将只返回物理cpu内核的数量，这是完美的。</p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx配置小结</title>
      <link href="/My-Blogs/2021/01/08/nginx/Nginx%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93/"/>
      <url>/My-Blogs/2021/01/08/nginx/Nginx%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>nginx配置有哪些变量？匹配规则又有哪些？让我们一起看看吧</p><a id="more"></a><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><pre><code class="NGINX">$args ： 这个变量等于请求行中的参数，同$query_string$content_length ： 请求头中的Content-length字段$content_type ： 请求头中的Content-Type字段$document_root ： 当前请求在root指令中指定的值$host ： 请求主机头字段，否则为服务器名称$http_user_agent ： 客户端agent信息$http_cookie ： 客户端cookie信息$limit_rate ： 这个变量可以限制连接速率$request_method ： 客户端请求的动作，通常为GET或POST$remote_addr ： 客户端的IP地址$remote_port ： 客户端的端口$remote_user ： 已经经过Auth Basic Module验证的用户名$request_filename ： 当前请求的文件路径，由root或alias指令与URI请求生成$scheme ： HTTP方法（如http，https）$server_protocol ： 请求使用的协议，通常是HTTP/1.0或HTTP/1.1$server_addr ： 服务器地址，在完成一次系统调用后可以确定这个值$server_name ： 服务器名称$server_port ： 请求到达服务器的端口号$request_uri ： 包含请求参数的原始URI，不包含主机名，如/foo/bar.php?arg=baz$uri ： 不带请求参数的当前URI，$uri不包含主机名，如/foo/bar.html$document_uri ： 与$uri相同</code></pre><p>假设请求为<a href="http://www.qq.com:8080/a/b/c.php%EF%BC%8C%E5%88%99">http://www.qq.com:8080/a/b/c.php，则</a></p><pre><code class="NGINX">$host：www.qq.com$server_port：8080$request_uri：http://www.qq.com:8080/a/b/c.php$document_uri：/a/b/c.php$document_root：/var/www/html$request_filename：/var/www/html/a/b/c.php</code></pre><h2 id="主机名（server-name）匹配"><a href="#主机名（server-name）匹配" class="headerlink" title="主机名（server_name）匹配"></a>主机名（server_name）匹配</h2><p>从上到下的优先级为从高到低</p><ol><li> 明确的<code>server_name</code>名称，如<code>www.qq.com</code></li><li> 前缀通配符，如<code>*.qq.com</code>或<code>. qq.com</code></li><li> 后缀通配符，如<code>www.qq.*</code></li><li> 正则表达式，如<code>~[a-z]+\.qq\.com</code></li></ol><h2 id="Location查找规则"><a href="#Location查找规则" class="headerlink" title="Location查找规则"></a>Location查找规则</h2><p>从上到下的优先级为从高到低</p><ol><li> 等号类型，精确匹配，如location = / {}</li><li> ^<del>类型，前缀匹配，不支持正则，如location ^</del> /user {}</li><li> <del>和</del>*类型，正则匹配，<del>区分大小写，</del>*不区分大小写，如location ~ ^/user {}</li><li> 常规字符串匹配类型，如location / {}或location /user {}</li></ol><h2 id="Try-files规则"><a href="#Try-files规则" class="headerlink" title="Try_files规则"></a>Try_files规则</h2><p>try_files $uri $uri/ /index.php<br>假设请求为<code>http://www.qq.com/test</code>，则<code>$uri</code>为<code>test</code></p><p>查找<code>/$root/test</code>文件<br>查找<code>/$root/test/</code>目录<br>发起<code>/index.php</code>的内部“子请求”</p><h2 id="Rewrite规则"><a href="#Rewrite规则" class="headerlink" title="Rewrite规则"></a>Rewrite规则</h2><p>rewrite ^/images/(.*).(png|jpg|gif)$ /images?name=$1.$4 last;</p><p>上面的<code>rewrite</code>规则会将文件名改写到参数中</p><ul><li>last : 相当于<code>Apache</code>的[L]标记，表示完成<code>rewrite</code></li><li>break : 停止执行当前虚拟主机的后续<code>rewrite</code>指令集</li><li>redirect : 返回302临时重定向，地址栏会显示跳转后的地址</li><li>permanent : 返回301永久重定向，地址栏会显示跳转后的地址</li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>例子如下</p><pre><code class="NGINX">upstream backend1 {    server backend1.qq.com weight=5;    server 127.0.0.1:8080 max_fails=3 fail_timeout=30s;    server unix:/tmp/backend3 backup;}upstream backend2 {    ip_hash;    server backend1.qq.com;    server backend2.qq.com;    server backend3.qq.com down;    server backend4.qq.com;}server {    location / {        proxy_pass http://backend1;    }    location /api {        proxy_pass http://backend2;    }}</code></pre><h2 id="查看一个实例"><a href="#查看一个实例" class="headerlink" title="查看一个实例"></a>查看一个实例</h2><p>下面是一个 <code>laravel</code>框架<code>Nginx</code>配置的例子，听过这堂课终于了解了下面的原理。</p><pre><code class="NGINX">server {    listen 80 default_server;    listen [::]:80 default_server ipv6only=on;    # 设定网站根目录    root /var/www/laravel/public;    # 网站默认首页    index index.php index.html index.htm;    # 服务器名称，server_domain_or_IP 请替换为自己设置的名称或者 IP 地址    server_name server_domain_or_IP;    # 修改为 Laravel 转发规则，否则PHP无法获取$_GET信息，提示404错误    location / {        try_files $uri $uri/ /index.php?$query_string;    }    # PHP 支持    location ~ \.php$ {        try_files $uri /index.php =404;        fastcgi_split_path_info ^(.+\.php)(/.+)$;        fastcgi_pass unix:/var/run/php5-fpm.sock;        fastcgi_index index.php;        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;        include fastcgi_params;    }}</code></pre><p>我们主要关注两个<code>location</code>，假设地址是<code>http://www.qq.com/user/info</code>，会匹配到如下<code>location</code></p><pre><code class="NGINX">location / {    try_files $uri $uri/ /index.php?$query_string;}</code></pre><p>由于<code>$uri</code>和<code>$uri/</code>是不存在的，所以会走<code>/index.php?$query_string</code>，这时候会发起一个内部“子请求”，“子请求”会重新匹配<code>location</code>，然后匹配到如下<code>location</code></p><pre><code class="NGINX">location ~ \.php$ {    try_files $uri /index.php =404;    fastcgi_split_path_info ^(.+\.php)(/.+)$;    fastcgi_pass unix:/var/run/php5-fpm.sock;    fastcgi_index index.php;    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;    include fastcgi_params;}</code></pre><p>这样请求就会发送到<code>fastcgi</code>去做处理。</p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> devops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx代理proxy pass配置去除前缀问题</title>
      <link href="/My-Blogs/2021/01/08/nginx/Nginx%E4%BB%A3%E7%90%86proxy%20pass%E9%85%8D%E7%BD%AE%E5%8E%BB%E9%99%A4%E5%89%8D%E7%BC%80%E9%97%AE%E9%A2%98/"/>
      <url>/My-Blogs/2021/01/08/nginx/Nginx%E4%BB%A3%E7%90%86proxy%20pass%E9%85%8D%E7%BD%AE%E5%8E%BB%E9%99%A4%E5%89%8D%E7%BC%80%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>设置反向代理的时候，有时候程序会拿不到URL后面的path部分，这是为什么呢？让我们一起来看看吧</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用Nginx做代理的时候，可以简单的直接把请求原封不动的转发给下一个服务。</p><p>比如，访问abc.com/appv2/a/b.html, 要求转发到localhost:8088/appv2/a/b.html</p><p>简单配置如下：</p><pre><code class="nginx">upstream one {  server localhost:8088 weight=5;}server {    listen              80;    server_name         abc.com;    access_log  "pipe:rollback /data/log/nginx/access.log interval=1d baknum=7 maxsize=1G"  main;    location / {        proxy_set_header Host $host;        proxy_set_header  X-Real-IP        $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;        proxy_set_header X-NginX-Proxy true;        proxy_pass http://one;    }}</code></pre><p>即，设置 <code>proxy_pass</code> 即可。请求只会替换域名。</p><p>但很多时候，我们需要根据url的前缀转发到不同的服务。</p><p>比如</p><p>abc.com/user/profile.html 转发到 用户服务localhost:8089/profile.html</p><p>abc.com/order/details.html 转发到 订单服务 localhost:8090/details.html</p><p>即，url的前缀对下游的服务是不需要的，除非下游服务添加context-path, 但很多时候我们并不喜欢加这个。如果Nginx转发的时候，把这个前缀去掉就好了。</p><h3 id="一个种方案是proxy-pass后面加根路径"><a href="#一个种方案是proxy-pass后面加根路径" class="headerlink" title="一个种方案是proxy_pass后面加根路径 / ."></a>一个种方案是proxy_pass后面加根路径 <code>/</code> .</h3><pre><code class="nginx">server {    listen              80;    server_name         abc.com;    access_log  "pipe:rollback /data/log/nginx/access.log interval=1d baknum=7 maxsize=1G"  main;    location ^~/user/ {        proxy_set_header Host $host;        proxy_set_header  X-Real-IP        $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;        proxy_set_header X-NginX-Proxy true;        proxy_pass http://user/;    }    location ^~/order/ {        proxy_set_header Host $host;        proxy_set_header  X-Real-IP        $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;        proxy_set_header X-NginX-Proxy true;        proxy_pass http://order/;    }}</code></pre><p><code>^~/user/</code> 表示匹配前缀是 <code>user</code> 的请求，proxy_pass的结尾有/， 则会把 <code>/user/*</code> 后面的路径直接拼接到后面，即移除user.</p><h3 id="另一种方案是使用-rewrite"><a href="#另一种方案是使用-rewrite" class="headerlink" title="另一种方案是使用 rewrite"></a>另一种方案是使用 <code>rewrite</code></h3><pre><code class="nginx">upstream user {  server localhost:8089 weight=5;}upstream order {  server localhost:8090 weight=5;}server {    listen              80;    server_name         abc.com;    access_log  "pipe:rollback /data/log/nginx/access.log interval=1d baknum=7 maxsize=1G"  main;    location ^~/user/ {        proxy_set_header Host $host;        proxy_set_header  X-Real-IP        $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;        proxy_set_header X-NginX-Proxy true;        rewrite ^/user/(.*)$ /$1 break;        proxy_pass http://user;    }    location ^~/order/ {        proxy_set_header Host $host;        proxy_set_header  X-Real-IP        $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;        proxy_set_header X-NginX-Proxy true;        rewrite ^/order/(.*)$ /$1 break;        proxy_pass http://order;    }}</code></pre><p>注意到proxy_pass结尾没有 <code>/</code> , <code>rewrite</code> 重写了url。</p><p>关于rewrite</p><pre><code class="nginx">syntax: rewrite regex replacement [flag]Default: —Context: server, location, if</code></pre>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> devops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx location匹配规则</title>
      <link href="/My-Blogs/2021/01/08/nginx/Nginx%20location%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/"/>
      <url>/My-Blogs/2021/01/08/nginx/Nginx%20location%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>location的匹配规则有哪些呢？让我们来一起看看吧</p><a id="more"></a><h3 id="url匹配规则"><a href="#url匹配规则" class="headerlink" title="url匹配规则"></a>url匹配规则</h3><pre><code class="nginx">location [=|~|~*|^~|@] /uri/ {  ...} </code></pre><ul><li><code>=</code> : 表示精确匹配后面的url</li><li><code>~</code> : 表示正则匹配，但是区分大小写</li><li><code>~*</code> : 正则匹配，不区分大小写</li><li><code>^~</code> : 表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录</li><li><code>@</code> : “@” 定义一个命名的 location，使用在内部定向时，例如 error_page</li></ul><p>上述匹配规则的优先匹配顺序：</p><ol><li> = 前缀的指令严格匹配这个查询。如果找到，停止搜索；</li><li> 所有剩下的常规字符串，最长的匹配。如果这个匹配使用 ^~ 前缀，搜索停止；</li><li> 正则表达式，在配置文件中定义的顺序；</li><li> 如果第 3 条规则产生匹配的话，结果被使用。否则，使用第 2 条规则的结果。</li></ol><h3 id="目标地址处理规则"><a href="#目标地址处理规则" class="headerlink" title="目标地址处理规则"></a>目标地址处理规则</h3><p>匹配到uri后，接下来要代理到目标服务地址。</p><pre><code class="NGINX">upstream api_server {  server 10.0.101.62:8081;  server 10.0.101.61:8082;}location / {        rewrite ^(.*)$ http://10.0.101.62:8000/my-module$1 break;}location ^~ /my-module/ {    root   /data/my-module/dist;    rewrite ^/my-module/(.*)$  /$1 break;    index  index.html index.htm;}location /my-module/api {    proxy_pass  http://api_server;    proxy_set_header Host $host;    proxy_set_header  X-Real-IP        $remote_addr;    proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;    proxy_set_header  your-custome-header    "myHeader";    proxy_set_header X-NginX-Proxy true;}</code></pre><p>上述配置，默认访问 <code>/</code> 会重定向到 <code>/my-module</code> , 然后直接返回 <code>/data/my-module/dist</code> 下的html等静态文件。</p><p>访问 <code>/my-module/api</code> 则会代理到我们api服务器地址，是一个默认的round-robin负载均衡配置。</p><p>下面是访问localhost的日志, 访问首页一共进行了2次重定向。</p><pre><code class="PHP">Request URL: http://10.0.101.62:8000/Request Method: GETStatus Code: 302 Moved TemporarilyLocation: http://10.0.101.62:8000/flash/Request URL: http://10.0.101.62:8000/flash/Request Method: GETStatus Code: 302 Moved TemporarilyLocation: http://10.0.101.62:8000/flash/index.htmlRequest URL: http://10.0.101.62:8000/flash/index.htmlRequest Method: GETStatus Code: 304 Not Modified</code></pre><h3 id="alias与root的区别"><a href="#alias与root的区别" class="headerlink" title="alias与root的区别"></a>alias与root的区别</h3><blockquote><p>root 实际访问文件路径会拼接URL中的路径</p><p>alias 实际访问文件路径不会拼接URL中的路径</p></blockquote><p>示例如下：</p><pre><code class="NGINX">location ^~ /sta/ {     alias /usr/local/nginx/html/static/;  }</code></pre><p>请求：<code>http://test.com/sta/sta1.html</code><br>实际访问：<code>/usr/local/nginx/html/static/sta1.html</code> 文件</p><pre><code class="NGINX">location ^~ /tea/ {     root /usr/local/nginx/html/;  }</code></pre><p>请求： <code>http://test.com/tea/tea1.html</code></p><p>实际访问： <code>/usr/local/nginx/html/tea/tea1.html</code> 文件</p><p>显然，第二次重定向是不需要的，本意是访问/flash/的时候，直接访问对应目录下的html静态文件。 但因为root拼接flash导致找不到对应文件，要重写url，去掉flash这个模块前缀，使用了 <code>rewrite</code> , 而 <code>rewrite</code> 会返回302重定向。</p><p>接下来，我们修改 <code>root</code> 为 <code>alias</code></p><pre><code class="NGINX">location ^~ /flash/ {    alias   /data/flash/dist/;    #rewrite ^/flash/(.*)$  /$1 break;    index  index.html index.htm;}</code></pre><p>直接重定向1次后返回html</p><pre><code class="PHP">Request URL: http://10.0.101.62:8000/Request Method: GETStatus Code: 302 Moved TemporarilyRequest URL: http://10.0.101.62:8000/flash/Request Method: GETStatus Code: 200 OK (from disk cache)</code></pre><h3 id="last-和-break关键字的区别"><a href="#last-和-break关键字的区别" class="headerlink" title="last 和 break关键字的区别"></a>last 和 break关键字的区别</h3><p>只用到了break，即匹配到此处后不会继续跳。</p><h3 id="permanent-和-redirect关键字的区别"><a href="#permanent-和-redirect关键字的区别" class="headerlink" title="permanent 和 redirect关键字的区别"></a>permanent 和 redirect关键字的区别</h3><ul><li>rewrite … permanent 永久性重定向，请求日志中的状态码为301</li><li>rewrite … redirect 临时重定向，请求日志中的状态码为302</li></ul><p>我们常用的 <code>80</code> 端口转 <code>443</code> ，即http转https的一种配置方案为</p><pre><code class="NGINX">server {    listen 80;    server_name demo.com;    rewrite ^(.*)$ https://${server_name}$1 permanent; }</code></pre><p>会返回301永久重定向到对应的https：</p><pre><code class="PHP">Request URL: http://demo.com/flash/index.htmlRequest Method: GETStatus Code: 301 Moved PermanentlyLocation: https://demo/flash/index.html</code></pre><h3 id="一些使用场景"><a href="#一些使用场景" class="headerlink" title="一些使用场景"></a>一些使用场景</h3><p>上述demo差不多就是我平时用的前后端分离的代理配置方案。下面是一些遇到过的场景。</p><p>配置一个静态文件下载服务，我们下面软件会经常看到index /的页面。</p><pre><code class="NGINX">server {        listen       8888;        #端口        server_name  _;   #服务名        charset utf-8,gbk;        root    /data/download;  #显示的根索引目录        autoindex on;             #开启索引功能        autoindex_exact_size off; # 关闭计算文件确切大小（单位bytes），只显示大概大小（单位kb、mb、gb）        autoindex_localtime on;   # 显示本机时间而非 GMT 时间}</code></pre><p>配置http重定向到https</p><pre><code class="NGINX">server {    listen 80;    server_name demo.com;    rewrite ^(.*)$ https://${server_name}$1 permanent; }server {    listen       443;    server_name  demo.com;    charset utf-8;    location / {       alias   /data/web;       index  index.html index.htm;    }}</code></pre><p>配置静态前端页面</p><pre><code class="NGINX">location / {    alias   /data/web;    index  index.html index.htm;}</code></pre><p>配置反向代理, 比如我们访问<a href="http://demo.com/api/aaa/bbb%EF%BC%8C%E6%88%91%E4%BB%AC%E6%83%B3%E8%A6%81%E4%BB%A3%E7%90%86%E5%88%B0http://api.com/api/aaa/bbb">http://demo.com/api/aaa/bbb，我们想要代理到http://api.com/api/aaa/bbb</a>, 只切换了域名，uri相同。</p><pre><code class="NGINX">upstream api_server {  server 10.0.101.62:8081;  server 10.0.101.61:8082;}location /api {    proxy_pass  http://api_server;    proxy_set_header Host $host;    proxy_set_header  X-Real-IP        $remote_addr;    proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;    proxy_set_header  your-custome-header    "myHeader";    proxy_set_header X-NginX-Proxy true;}</code></pre><p>配置反向代理时，移除前缀。比如我们的服务<a href="http://demo.com/users/aaa/bbb">http://demo.com/users/aaa/bbb</a>, 我们想要代理到<a href="http://users.com/aaa/bbb%EF%BC%8C%E5%8D%B3%E5%88%87%E6%8D%A2%E5%9F%9F%E5%90%8D%E7%9A%84%E5%90%8C%E6%97%B6%EF%BC%8C%E5%8E%BB%E6%8E%89users%E5%89%8D%E7%BC%80%E3%80%82%E5%8C%BA%E5%88%AB%E6%98%AFproxy_pass">http://users.com/aaa/bbb，即切换域名的同时，去掉users前缀。区别是proxy_pass</a> 结尾的 <code>/</code> .</p><pre><code class="NGINX">location ^~/users/ {    proxy_set_header Host $host;    proxy_set_header  X-Real-IP        $remote_addr;    proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;    proxy_set_header X-NginX-Proxy true;    proxy_pass http://users.com/;}</code></pre><p>反向代理时，想要自定义修改uri。使用rewrite正则修改。</p><pre><code class="NGINX"># 修改uri，去掉了flash的前缀，$1表示正则匹配到的字符串内容。location ^~ /flash/ {    root   /data/flash/dist/;    rewrite ^/flash/(.*)$  /$1 break;    index  index.html index.htm;}# 修改uri, 重新代理到新的地址location ^~/order/ {    proxy_set_header Host $host;    proxy_set_header  X-Real-IP        $remote_addr;    proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;    proxy_set_header X-NginX-Proxy true;    rewrite ^/order/(.*)$ /$1 break;    proxy_pass http://order;}</code></pre><p>代理跨域, 比如bing每日一图，不支持我们ajax获取图片地址，我们可以自己写一个支持的接口。</p><p><a href="http://101.200.218.760/proxy/bing/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1">http://101.200.218.760/proxy/bing/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1</a></p><p>代理对象为：</p><p><a href="https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1">https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1</a></p><pre><code class="NGINX">location ^~/proxy/bing/ {    add_header 'Access-Control-Allow-Origin' 'http://localhost:8088';    add_header 'Cache-Control' 'public, max-age=604800';    add_header 'Access-Control-Allow-Credentials' 'true';    add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';    rewrite ^/proxy/bing/(.*)$ /$1 break;    proxy_pass https://cn.bing.com/; }</code></pre><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><ul><li><a href="https://www.cnblogs.com/duhuo/p/8323812.html">https://www.cnblogs.com/duhuo/p/8323812.html</a></li><li><a href="https://www.cnblogs.com/woshimrf/p/nginx-proxy-rewrite-url.html">https://www.cnblogs.com/woshimrf/p/nginx-proxy-rewrite-url.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> devops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx的负载均衡实例，均衡策略，session保持方案</title>
      <link href="/My-Blogs/2021/01/08/nginx/Nginx%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E4%BE%8B%EF%BC%8C%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%EF%BC%8Csession%E4%BF%9D%E6%8C%81%E6%96%B9%E6%A1%88/"/>
      <url>/My-Blogs/2021/01/08/nginx/Nginx%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E4%BE%8B%EF%BC%8C%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%EF%BC%8Csession%E4%BF%9D%E6%8C%81%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>负载均衡定义：代理服务器将接收的请求均衡的分发到各服务器中<br>负载均衡作用：主要解决网络拥塞问题，提高服务器响应速度，服务就近提供，达到更好的访问质量，减少后台服务器并发压力。</p><a id="more"></a><h2 id="负载均衡的配置实例"><a href="#负载均衡的配置实例" class="headerlink" title="负载均衡的配置实例"></a>负载均衡的配置实例</h2><p>可访问的服务有两个：</p><ul><li><a href="http://172.16.25.44:8080/rsbi">http://172.16.25.44:8080/rsbi</a></li><li><a href="http://192.168.1.138:8080/rsbi">http://192.168.1.138:8080/rsbi</a></li></ul><p>nginx.conf完整配置如下：</p><pre><code class="NGINX">#user &nbsp;nobody;worker_processes &nbsp;1;events {&nbsp; &nbsp; worker_connections &nbsp;1024;}http {&nbsp; &nbsp; &nbsp; &nbsp; include &nbsp; &nbsp; &nbsp; mime.types;&nbsp; &nbsp; &nbsp; &nbsp; default_type &nbsp;application/octet-stream;&nbsp; &nbsp; &nbsp; &nbsp; sendfile &nbsp; &nbsp; &nbsp; &nbsp;on;&nbsp; &nbsp; &nbsp; &nbsp; keepalive_timeout &nbsp;65;&nbsp; &nbsp; &nbsp; &nbsp; #此处定义常量xd-projec&nbsp; &nbsp; &nbsp; &nbsp; upstream xd-project{&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #注意 此处的server只能是ip:port 不能有任何多余的http或者项目名称&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; server 172.16.25.44:8080;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; server &nbsp;192.168.1.138:8080;&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; server{&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; listen 8081;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; server_name &nbsp;localhost;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; location / {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #此处使用上面定义常量xd-projec&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proxy_pass http://xd-project;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; location ~ .* {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proxy_pass http://xd-project;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proxy_set_header Host $http_host;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proxy_set_header X-Real-IP $remote_addr;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error_page &nbsp; 500 502 503 504 &nbsp;/50x.html;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; location = /50x.html {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root &nbsp; html;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; include servers/*;}</code></pre><p>说明：上面的均衡方式是轮询，即nginx的默认负载均衡方式</p><h2 id="nginx的负载均衡策略及其适用场景"><a href="#nginx的负载均衡策略及其适用场景" class="headerlink" title="nginx的负载均衡策略及其适用场景"></a>nginx的负载均衡策略及其适用场景</h2><h3 id="1-轮询（默认）"><a href="#1-轮询（默认）" class="headerlink" title="1.  轮询（默认）"></a>1.  轮询（默认）</h3><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。主要用于大量请求场景中环节服务端的压力。<br>配置实例：</p><pre><code class="NGINX">upstream xd-project{        #注意 此处的server只能是ip:port 不能有任何多余的http或者项目名称        server 172.16.25.44:8080;        server  192.168.1.138:8080;} </code></pre><h3 id="2-weight"><a href="#2-weight" class="headerlink" title="2.  weight"></a>2.  weight</h3><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。<br>配置实例</p><pre><code class="NGINX">upstream xd-project{  #注意 此处的server只能是ip:port 不能有任何多余的http或者项目名称  server 172.16.25.44:8080 weight=1;  server  192.168.1.138:8080 weight=2;}</code></pre><p>说明：假设有三次访问，因为weight的值，会有一次落在172.16.25.44:8080，两次落在192.168.1.138:8080<br>应用场景：后端服务器性能不均的情况</p><h3 id="3-ip-hash"><a href="#3-ip-hash" class="headerlink" title="3.  ip_hash"></a>3.  ip_hash</h3><p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。<br>配置实例：</p><pre><code class="NGINX">upstream xd-project{        ip_hash;        server 172.16.25.44:8080;        server  192.168.1.138:8080;}</code></pre><p>应用场景：当你服务端的一个特定url路径会被同一个用户连续访问时，如果负载均衡策略还是轮询的话，那该用户的多次访问会被打到各台服务器上，这显然并不高效（会建立多次http链接等问题）。甚至考虑一种极端情况，用户需要分片上传文件到服务器下，然后再由服务器将分片合并，这时如果用户的请求到达了不同的服务器，那么分片将存储于不同的服务器目录中，导致无法将分片合并。</p><h3 id="4-url-hash（第三方）"><a href="#4-url-hash（第三方）" class="headerlink" title="4.  url_hash（第三方）"></a>4.  url_hash（第三方）</h3><p>每个请求按访问url的hash结果分配，这样每个url请求固定访问一个后端服务器。<br>配置实例：</p><pre><code class="NGINX">upstream xd-project{        hash $request_uri;        server 172.16.25.44:8080;        server  192.168.1.138:8080;}</code></pre><p>应用场景：<br>一般来讲，要用到urlhash，是要配合缓存命中来使用。举一个我遇到的实例：有一个服务器集群A，需要对外提供文件下载，由于文件上传量巨大，没法存储到服务器磁盘中，所以用到了第三方云存储来做文件存储。服务器集群A收到客户端请求之后，需要从云存储中下载文件然后返回，为了省去不必要的网络带宽和下载耗时，在服务器集群A上做了一层临时缓存（缓存一个月）。由于是服务器集群，所以同一个资源多次请求，可能会到达不同的服务器上，导致不必要的多次下载，缓存命中率不高，以及一些资源时间的浪费。在此类场景下，为了使得缓存命中率提高，很适合使用url_hash策略，同一个url（也就是同一个资源请求）会到达同一台机器，一旦缓存住了资源，再此收到请求，就可以从缓存中读取，既减少了带宽，也减少的下载时间。</p><h3 id="5-fair（第三方）"><a href="#5-fair（第三方）" class="headerlink" title="5.  fair（第三方）"></a>5.  fair（第三方）</h3><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><h2 id="负载均衡session会话保持方法"><a href="#负载均衡session会话保持方法" class="headerlink" title="负载均衡session会话保持方法"></a>负载均衡session会话保持方法</h2><p>负载均衡时，为了保证同一用户session会被分配到同一台服务器上，可以使用以下方法：</p><ol><li> 使用cookie</li></ol><p>将用户的session存入cookie里，当用户分配到不同的服务器时，先判断服务器是否存在该用户的session，如果没有就先把cookie里面的sessoin存入该服务器，实现session会话保持。缺点是存入cookie有安全隐患。</p><ol start="2"><li> 使用缓存</li></ol><p>利用memcache，redis等缓存分布式的特点，可以将所有服务器产生的session存入同一台服务器的缓存中，实现session共享。这样安全性比较高，而且从内存中读取session比从文件中读取速度快。</p><ol start="3"><li> 使用ip_hash</li></ol><p>如果是nginx服务器的负载均衡，可以在upstream里设置ip_hash，每个请求按访问ip的hash结果分配，映射到固定某一台的服务器。缺点是可能导致负载不均衡。</p><h2 id="upstream中的down和backup"><a href="#upstream中的down和backup" class="headerlink" title="upstream中的down和backup"></a>upstream中的down和backup</h2><p><img src="/My-Blogs/images/Nginx%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E4%BE%8B%EF%BC%8C%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%EF%BC%8Csession%E4%BF%9D%E6%8C%81%E6%96%B9%E6%A1%88-01.png" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> devops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim基础篇——快速移动</title>
      <link href="/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/vim%E5%BF%AB%E9%80%9F%E7%A7%BB%E5%8A%A8/"/>
      <url>/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/vim%E5%BF%AB%E9%80%9F%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>最初使用Vim时，初学者经常会感到不适应，因为它的移动方式和一般的编辑器差别很大。但是Vim的魅力就在于，当你学会Vim的移动方式后，你能迅速的把光标移动到你想要的位置。</p><p>本文介绍Vim中的移动方式：Vim中熟练的移动并不是指用hjkl移动，当你越熟练的掌握vim的移动方式，你会越少的使用hjkl移动方式。</p><a id="more"></a><blockquote><p>hjkl are the tip of the top of the iceberg and very rarely used, at least in my case.</p></blockquote><br><h3 id="1、行内移动"><a href="#1、行内移动" class="headerlink" title="1、行内移动"></a>1、行内移动</h3><blockquote><p>Test: This is a line with example text </p></blockquote><br><h4 id="最基础的移动方式是w-e-b-ge"><a href="#最基础的移动方式是w-e-b-ge" class="headerlink" title="最基础的移动方式是w/e/b/ge"></a>最基础的移动方式是w/e/b/ge</h4><br><p>w是向前移动到下一个单词的第一个位置，大写的W表示只使用空格作为分隔</p><br><pre><code class="BASH">" * 代表了光标的初始位置" 每个字母代表了如果按下这个键会跳转的位置Test: This is a line with example text*   w w    w  w w    w    w       w*     W    W  W W    W    W       W</code></pre><p>w前面可以加上数字，表示w命令重复几次，比如3w等同于按下三次w</p><p>e是向前跳动到下一个【单词的末尾】，这意味着如果当前光标在单词的中间，按下e会跳转到当前单词的末尾。大写的E表示只使用空格作为分隔</p><pre><code class="BASH">" * 代表了光标的初始位置" 每个字母代表了如果按下这个键会跳转的位置Test: This is a line with example text*  ee    e  e e    e    e       e    e*   E    E  E E    E    E       E    E </code></pre><p>b是向后移动到上一个【单词的开头】，这意味着如果当前光标在单词的中间，按下b会跳转到当前单词的开头。大写的B表示只使用空格作为分隔</p><pre><code class="BASH">" * 代表了光标的初始位置" 每个字母代表了如果按下这个键会跳转的位置Test: This is a line with example textb   b b    b  b b    b    b       b *B     B    B  B B    B    B       B *</code></pre><p>ge是向后移动到上一个【单词的末尾】。大写的gE表示只使用空格作为分隔</p><pre><code class="BASH">" * 代表了光标的初始位置" 每个字母代表了如果按下这个键会跳转的位置" &amp; 表示按下gETest: This is a line with example text  ee    e  e e    e    e       e   *   &amp;    &amp;  &amp; &amp;    &amp;    &amp;       &amp;   * </code></pre><blockquote><p>Notice：w/e/b/ge都是可以跨行移动的！</p></blockquote><br><h4 id="快速移动到行的开始和结束"><a href="#快速移动到行的开始和结束" class="headerlink" title="快速移动到行的开始和结束"></a>快速移动到行的开始和结束</h4><br><pre><code class="BASH">$ 移动到行的末尾0 移动到行的开头^ 移动到第一个非空白字符g_ 移动到最后一个非空白字符</code></pre><br><blockquote><p>0不能使用数字参数；但是$可以，$等同于1$，2$表示移动到下一行的末尾，同理3$…</p></blockquote><br><h4 id="行内移动到特定字符"><a href="#行内移动到特定字符" class="headerlink" title="行内移动到特定字符"></a>行内移动到特定字符</h4><br><p>【f+字符】表示移动到行内当前光标后面的第一个这个字符</p><p>【t+字符】表示移动到行内当前光标后的的第一个这个字符的前一个位置</p><p>【F+字符】为【f+字符】的反向</p><p>【T+字符】为【t+字符】的反向</p><br><blockquote><p>这种移动方式不能跨行</p></blockquote><br><pre><code class="BASH">" * 代表了光标的初始位置" 每个字母代表了如果按下这个键会跳转的位置" &amp; 表示按下fe" ! 表示按下teTest: This is a line with example text*&amp;                 &amp;      &amp;     &amp;  &amp; +               !</code></pre><br><p>注意到一个奇怪的现象，在第二行操作中，按下te会定位到line中的e，光标会移动到e的前一个字符n，如果再一次按下te，会定位到line中的e，光标会移动到e的前一个字符n，也就是说光标不会移动。</p><br><p>这样就告诉我们：连续按下两次【t+字符】和按下一次到达的位置一定是一样的。</p><blockquote><p>f/t/F/T均可以接受数字参数，3fe相当于按下三次fe</p></blockquote><p>事实上，重复操作有另一种方式：【; 】代表了重复查找字符，【, 】是【; 】的反向：</p><blockquote><p>【fe; 】等同于【fefe】等同于【2fe】【fe, 】等同于【feFe】</p></blockquote><br><h3 id="2、行间移动"><a href="#2、行间移动" class="headerlink" title="2、行间移动"></a>2、行间移动</h3><br><h4 id="滚动屏幕"><a href="#滚动屏幕" class="headerlink" title="滚动屏幕"></a>滚动屏幕</h4><pre><code class="BASH">&lt;Ctrl-b&gt; 向下移动一个屏幕&lt;Ctrl-f&gt; 向上移动一个屏幕&lt;Ctrl-u&gt; 向下移动半个屏幕&lt;Ctrl-d&gt; 向上移动半个屏幕</code></pre><h4 id="文件位置移动"><a href="#文件位置移动" class="headerlink" title="文件位置移动"></a>文件位置移动</h4><br><p>【数字+G】表示移动到文件的特定行</p><p>比如30G表示移动到第三十行</p><p>gg表示移动到文件的第一行</p><p>G表示移动到文件的最后一行</p><br><h3 id="3、其他移动方式"><a href="#3、其他移动方式" class="headerlink" title="3、其他移动方式"></a>3、其他移动方式</h3><br><p>【%】：找到当前光标 下或者之后 的第一个括号，并移动到它匹配的括号的位置</p><blockquote><p>括号包括：</p></blockquote><p>([{}])<br>/* */<br>#if, #ifdef, #else, #elif, #endif</p><br><pre><code class="BASH">" * 代表了光标的初始位置" 每个字母代表了如果按下这个键会跳转的位置int f(1, g(2, 3))*              %   %          *     *      %       % *</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sftp命令基本使用</title>
      <link href="/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/sftp%E5%91%BD%E4%BB%A4%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/sftp%E5%91%BD%E4%BB%A4%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><code>sftp</code> 是 SSH 提供的一个客户端应用程序，主要用来安全地访问 FTP。因为 FTP 是不加密协议，很不安全，<code>sftp</code>就相当于将 FTP 放入了 SSH。</p><a id="more"></a><p>下面的命令连接 FTP 主机</p><pre><code class="BASH">sftp username@hostname</code></pre><p>执行上面的命令，会要求输入 FTP 的密码。密码验证成功以后，就会出现 FTP 的提示符<code>sftp&gt;</code>，下面是一个例子。</p><pre><code class="BASH">sftp USER@penguin.example.comUSER@penguin.example.com's password:Connected to penguin.example.com.sftp&gt;</code></pre><p>FTP 的提示符下面，就可以输入各种 FTP 命令了，这部分完全跟传统的 FTP 用法完全一样。</p><ul><li><code>ls [directory]</code>: 列出一个远程目录的内容。如果没有指定目标目录，则默认列出当前目录。</li><li><code>cd directory</code>: 从当前目录改到指定目录。</li><li><code>mkdir directory</code>: 创建一个远程目录。</li><li><code>rmdir path</code>: 删除一个远程目录。</li><li><code>put localfile [remotefile]</code>: 本地文件传输到远程主机。</li><li><code>get remotefile [localfile]</code>: 远程文件传输到本地。</li><li><code>help</code>: 显示帮助信息。</li><li><code>bye</code>: 退出 sftp。</li><li><code>quit</code>: 退出 sftp。</li><li><code>exit</code>: 退出 sftp。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scp命令的基本使用</title>
      <link href="/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/scp%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/scp%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><code>scp</code> 是 secure copy 的缩写，相当于 <code>cp</code> 命令 + SSH。它的底层是 SSH 协议，默认端口是22，相当于先使用 <code>ssh</code> 命令登录远程主机，然后再执行拷贝操作</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>scp</code> 主要用于以下三种复制操作。</p><ul><li>本地复制到远程。</li><li>远程复制到本地。</li><li>两个远程系统之间的复制。</li></ul><p>使用 <code>scp</code> 传输数据时，文件和密码都是加密的，不会泄漏敏感信息。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><code>scp</code> 的语法类似 <code>cp</code> 的语法。</p><pre><code class="BASH">scp source destination</code></pre><p>上面命令中， <code>source</code> 是文件当前的位置， <code>destination</code> 是文件所要复制到的位置。它们都可以包含用户名和主机名。</p><pre><code class="BASH">scp user@host:foo.txt bar.txt</code></pre><p>上面命令将远程主机（ <code>user@host</code> ）用户主目录下的 <code>foo.txt</code> ，复制为本机当前目录的 <code>bar.txt</code> 。可以看到，主机与文件之间要使用冒号（ <code>:</code> ）分隔。</p><p><code>scp</code> 会先用 SSH 登录到远程主机，然后在加密连接之中复制文件。客户端发起连接后，会提示用户输入密码，这部分是跟 SSH 的用法一致的。</p><p>用户名和主机名都是可以省略的。用户名的默认值是本机的当前用户名，主机名默认为当前主机。注意， <code>scp</code> 会使用 SSH 客户端的配置文件 <code>.ssh/config</code> ，如果配置文件里面定义了主机的别名，这里也可以使用别名连接。</p><p><code>scp</code> 支持一次复制多个文件。</p><pre><code class="BASH">scp source1 source2 destination</code></pre><p>上面命令会将 <code>source1</code> 和 <code>source2</code> 两个文件，复制到 <code>destination</code> 。</p><p>注意，如果所要复制的文件，在目标位置已经存在同名文件， <code>scp</code> 会在没有警告的情况下覆盖同名文件。</p><h2 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h2><h3 id="本地文件复制到远程"><a href="#本地文件复制到远程" class="headerlink" title="本地文件复制到远程"></a>本地文件复制到远程</h3><p>复制本机文件到远程系统的用法如下。</p><pre><code class="BASH"># 语法$ scp SourceFile user@host:directory/TargetFile# 示例$ scp file.txt remote_username@10.10.0.2:/remote/directory</code></pre><p>下面是复制整个目录的例子。</p><pre><code class="BASH"># 将本机的 documents 目录拷贝到远程主机，# 会在远程主机创建 documents 目录$ scp -r documents username@server_ip:/path_to_remote_directory# 将本机整个目录拷贝到远程目录下$ scp -r localmachine/path_to_the_directory username@server_ip:/path_to_remote_directory/# 将本机目录下的所有内容拷贝到远程目录下$ scp -r localmachine/path_to_the_directory/* username@server_ip:/path_to_remote_directory/</code></pre><h3 id="远程文件复制到本地"><a href="#远程文件复制到本地" class="headerlink" title="远程文件复制到本地"></a>远程文件复制到本地</h3><p>从远程主机复制文件到本地的用法如下。</p><pre><code class="BASH"># 语法$ scp user@host:directory/SourceFile TargetFile# 示例$ scp remote_username@10.10.0.2:/remote/file.txt /local/directory</code></pre><p>下面是复制整个目录的例子。</p><pre><code class="BASH"># 拷贝一个远程目录到本机目录下$ scp -r username@server_ip:/path_to_remote_directory local-machine/path_to_the_directory/# 拷贝远程目录下的所有内容，到本机目录下$ scp -r username@server_ip:/path_to_remote_directory/* local-machine/path_to_the_directory/$ scp -r user@host:directory/SourceFolder TargetFolder</code></pre><h3 id="两个远程系统之间的复制"><a href="#两个远程系统之间的复制" class="headerlink" title="两个远程系统之间的复制"></a>两个远程系统之间的复制</h3><p>本机发出指令，从远程主机 A 拷贝到远程主机 B 的用法如下。</p><pre><code class="BASH"># 语法$ scp user@host1:directory/SourceFile user@host2:directory/SourceFile# 示例$ scp user1@host1.com:/files/file.txt user2@host2.com:/files</code></pre><p>系统将提示你输入两个远程帐户的密码。数据将直接从一个远程主机传输到另一个远程主机。</p><h2 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h2><h3 id="c"><a href="#c" class="headerlink" title="-c"></a>-c</h3><p><code>-c</code>参数用来指定文件拷贝数据传输的加密算法</p><pre><code class="BASH">scp -c blowfish some_file your_username@remotehost.edu:~</code></pre><p>上面代码指定加密算法为 <code>blowfish</code> 。</p><h3 id="C"><a href="#C" class="headerlink" title="-C"></a>-C</h3><p><code>-C</code> 参数表示是否在传输时压缩文件。</p><pre><code class="BASH">scp -c blowfish -C local_file your_username@remotehost.edu:~</code></pre><h3 id="F"><a href="#F" class="headerlink" title="-F"></a>-F</h3><p><code>-F</code> 参数用来指定 ssh_config 文件，供 ssh 使用。</p><pre><code class="BASH">scp -F /home/pungki/proxy_ssh_config Label.pdf root@172.20.10.8:/root</code></pre><h3 id="i"><a href="#i" class="headerlink" title="-i"></a>-i</h3><p><code>-i</code> 参数用来指定密钥。</p><pre><code class="BASH">scp -vCq -i private_key.pem ~/test.txt root@192.168.1.3:/some/path/test.txt</code></pre><h3 id="l"><a href="#l" class="headerlink" title="-l"></a>-l</h3><p><code>-l</code> 参数用来限制传输数据的带宽速率，单位是 Kbit/sec。对于多人分享的带宽，这个参数可以留出一部分带宽供其他人使用。</p><pre><code class="BASH">scp -l 80 yourusername@yourserver:/home/yourusername/* .</code></pre><p>上面代码中， <code>scp</code> 命令占用的带宽限制为每秒 80K 比特位，即每秒 10K 字节。</p><h3 id="p"><a href="#p" class="headerlink" title="-p"></a>-p</h3><p><code>-p</code> 参数用来保留修改时间（modification time）、访问时间（access time）、文件状态（mode）等原始文件的信息。</p><pre><code class="BASH">scp -p ~/test.txt root@192.168.1.3:/some/path/test.txt</code></pre><h3 id="P"><a href="#P" class="headerlink" title="-P"></a>-P</h3><p><code>-P</code> 参数用来指定远程主机的 SSH 端口。如果远程主机使用默认端口22，可以不用指定，否则需要用-P参数在命令中指定。</p><pre><code class="BASH">scp -P 2222 user@host:directory/SourceFile TargetFile</code></pre><h3 id="q"><a href="#q" class="headerlink" title="-q"></a>-q</h3><p><code>-q</code> 参数用来关闭显示拷贝的进度条。</p><pre><code class="BASH">scp -q Label.pdf mrarianto@202.x.x.x:.</code></pre><h3 id="r"><a href="#r" class="headerlink" title="-r"></a>-r</h3><p><code>-r</code> 参数表示是否以递归方式复制目录。</p><h3 id="v"><a href="#v" class="headerlink" title="-v"></a>-v</h3><p><code>-v</code> 参数用来显示详细的输出。</p><pre><code class="BASH">scp -v ~/test.txt root@192.168.1.3:/root/help2356.txt</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rsync的基本使用</title>
      <link href="/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/rsync%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/rsync%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><code>rsync</code> 可以用于本地计算机的两个目录之间的同步。下面就用本地同步举例，顺便讲解 <code>rsync</code> 几个主要参数的用法。</p><a id="more"></a><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="r-参数"><a href="#r-参数" class="headerlink" title="-r 参数"></a><code>-r</code> 参数</h3><p>本机使用 <code>rsync</code> 命令时，可以作为 <code>cp</code> 和 <code>mv</code> 命令的替代方法，将源目录拷贝到目标目录。</p><pre><code class="BASH">rsync -r source destination</code></pre><p>上面命令中， <code>-r</code> 表示递归，即包含子目录。注意， <code>-r</code> 是必须的，否则 rsync 运行不会成功。 <code>source</code> 目录表示源目录， <code>destination</code> 表示目标目录。上面命令执行以后，目标目录下就会出现 <code>destination/source</code> 这个子目录</p><p>如果有多个文件或目录需要同步，可以写成下面这样</p><pre><code class="BASH">rsync -r source1 source2 destination</code></pre><p>上面命令中， <code>source1</code> 、 <code>source2</code> 都会被同步到 <code>destination</code> 目录</p><h3 id="a-参数"><a href="#a-参数" class="headerlink" title="-a 参数"></a><code>-a</code> 参数</h3><p><code>-a</code> 参数可以替代 <code>-r</code> ，除了可以递归同步以外，还可以同步元信息（比如修改时间、权限等）。由于 rsync 默认使用文件大小和修改时间决定文件是否需要更新，所以 <code>-a</code> 比 <code>-r</code> 更有用。下面的用法才是常见的写法</p><pre><code class="BASH">rsync -a source destination</code></pre><p>目标目录 <code>destination</code> 如果不存在，rsync 会自动创建。执行上面的命令后，源目录 <code>source</code> 被完整地复制到了目标目录 <code>destination</code> 下面，即形成了 <code>destination/source</code> 的目录结构。</p><p>如果只想同步源目录 <code>source</code> 里面的内容到目标目录 <code>destination</code> ，则需要在源目录后面加上斜杠.</p><pre><code class="BASH">rsync -a source/ destination</code></pre><p>上面命令执行后， <code>source</code> 目录里面的内容，就都被复制到了 <code>destination</code> 目录里面，并不会在 <code>destination</code> 下面创建一个 <code>source</code> 子目录。</p><h3 id="n-参数"><a href="#n-参数" class="headerlink" title="-n 参数"></a><code>-n</code> 参数</h3><p>如果不确定 rsync 执行后会产生什么结果，可以先用-n或–dry-run参数模拟执行的结果</p><pre><code class="BASH">rsync -anv source/ destination</code></pre><p>上面命令中， <code>-n</code> 参数模拟命令执行的结果，并不真的执行命令。 <code>-v</code> 参数则是将结果输出到终端，这样就可以看到哪些内容会被同步</p><h3 id="–delete参数"><a href="#–delete参数" class="headerlink" title="–delete参数"></a>–delete参数</h3><p>默认情况下，rsync 只确保源目录的所有内容（明确排除的文件除外）都复制到目标目录。它不会使两个目录保持相同，并且不会删除文件。如果要使得目标目录成为源目录的镜像副本，则必须使用–delete参数，这将删除只存在于目标目录、不存在于源目录的文件。</p><pre><code class="BASH">rsync -av --delete source/ destination</code></pre><p>上面命令中， <code>--delete</code> 参数会使得 <code>destination</code> 成为 <code>source</code> 的一个镜像</p><h3 id="–exclude参数"><a href="#–exclude参数" class="headerlink" title="–exclude参数"></a>–exclude参数</h3><p>有时，我们希望同步时排除某些文件或目录，这时可以用–exclude参数指定排除模式</p><pre><code class="BASH">$ rsync -av --exclude='*.txt' source/ destination# 或者$ rsync -av --exclude '*.txt' source/ destination</code></pre><p>上面命令排除了所有 TXT 文件。</p><p>注意，rsync 会同步以“点”开头的隐藏文件，如果要排除隐藏文件，可以这样写 <code>--exclude=".*"</code> 。</p><p>如果要排除某个目录里面的所有文件，但不希望排除目录本身，可以写成下面这样。</p><pre><code class="BASH">$ rsync -av --exclude 'dir1/*' source/ destination</code></pre><p>多个排除模式，可以用多个 <code>--exclude</code> 参数</p><pre><code class="BASH">rsync -av --exclude 'file1.txt' --exclude 'dir1/*' source/ destination</code></pre><p>多个排除模式也可以利用 Bash 的大扩号的扩展功能，只用一个 <code>--exclude</code> 参数</p><pre><code class="BASH">rsync -av --exclude={'file1.txt','dir1/*'} source/ destination</code></pre><p>如果排除模式很多，可以将它们写入一个文件，每个模式一行，然后用 <code>--exclude-from</code> 参数指定这个文件。</p><pre><code class="BASH">rsync -av --exclude-from='exclude-file.txt' source/ destination</code></pre><h3 id="–include参数"><a href="#–include参数" class="headerlink" title="–include参数"></a>–include参数</h3><p><code>--include</code> 参数用来指定必须同步的文件模式，往往与 <code>--exclude</code> 结合使用</p><pre><code class="BASH">rsync -av --include="*.txt" --exclude='*' source/ destination</code></pre><p>上面命令指定同步时，排除所有文件，但是会包括 TXT 文件</p><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><h3 id="SSH-协议"><a href="#SSH-协议" class="headerlink" title="SSH 协议"></a>SSH 协议</h3><p>rsync 除了支持本地两个目录之间的同步，也支持远程同步。它可以将本地内容，同步到远程服务器</p><pre><code class="BASH">rsync -av source/ username@remote_host:destination</code></pre><p>也可以将远程内容同步到本地</p><pre><code class="BASH">rsync -av username@remote_host:source/ destination</code></pre><p>rsync 默认使用 SSH 进行远程登录和数据传输。</p><p>由于早期 rsync 不使用 SSH 协议，需要用 <code>-e</code> 参数指定协议，后来才改的。所以，下面 <code>-e ssh</code> 可以省略</p><pre><code class="BASH">rsync -av -e ssh source/ user@remote_host:/destination</code></pre><p>但是，如果 ssh 命令有附加的参数，则必须使用 <code>-e</code> 参数指定所要执行的 SSH 命令</p><pre><code class="BASH">rsync -av -e 'ssh -p 2234' source/ user@remote_host:/destination</code></pre><p>上面命令中， <code>-e</code> 参数指定 SSH 使用2234端口</p><h3 id="rsync-协议"><a href="#rsync-协议" class="headerlink" title="rsync 协议"></a>rsync 协议</h3><p>除了使用 SSH，如果另一台服务器安装并运行了 rsync 守护程序，则也可以用 <code>rsync://</code> 协议（默认端口873）进行传输。具体写法是服务器与目标目录之间使用双冒号分隔 <code>::</code></p><pre><code class="BASH">rsync -av source/ 192.168.122.32::module/destination</code></pre><p>注意，上面地址中的 <code>module</code> 并不是实际路径名，而是 rsync 守护程序指定的一个资源名，由管理员分配。</p><p>如果想知道 rsync 守护程序分配的所有 module 列表，可以执行下面命令。</p><pre><code class="BASH">rsync rsync://192.168.122.32</code></pre><p>rsync 协议除了使用双冒号，也可以直接用rsync://协议指定地址。</p><pre><code class="BASH">rsync -av source/ rsync://192.168.122.32/module/destination</code></pre><h2 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h2><p>rsync 的最大特点就是它可以完成增量备份，也就是默认只复制有变动的文件。</p><p>除了源目录与目标目录直接比较，rsync 还支持使用基准目录，即将源目录与基准目录之间变动的部分，同步到目标目录。</p><p>具体做法是，第一次同步是全量备份，所有文件在基准目录里面同步一份。以后每一次同步都是增量备份，只同步源目录与基准目录之间有变动的部分，将这部分保存在一个新的目标目录。这个新的目标目录之中，也是包含所有文件，但实际上，只有那些变动过的文件是存在于该目录，其他没有变动的文件都是指向基准目录文件的硬链接。</p><p><code>--link-dest</code> 参数用来指定同步时的基准目录</p><pre><code class="BASH">rsync -a --delete --link-dest /compare/path /source/path /target/path</code></pre><p>上面命令中， <code>--link-dest</code> 参数指定基准目录 <code>/compare/path</code> ，然后源目录 <code>/source/path</code> 跟基准目录进行比较，找出变动的文件，将它们拷贝到目标目录 <code>/target/path</code> 。那些没变动的文件则会生成硬链接。这个命令的第一次备份时是全量备份，后面就都是增量备份了</p><p>下面是一个脚本示例，备份用户的主目录。</p><pre><code class="BASH">#!/bin/bash# A script to perform incremental backups using rsyncset -o errexitset -o nounsetset -o pipefailreadonly SOURCE_DIR="${HOME}"readonly BACKUP_DIR="/mnt/data/backups"readonly DATETIME="$(date '+%Y-%m-%d_%H:%M:%S')"readonly BACKUP_PATH="${BACKUP_DIR}/${DATETIME}"readonly LATEST_LINK="${BACKUP_DIR}/latest"mkdir -p "${BACKUP_DIR}"rsync -av --delete \  "${SOURCE_DIR}/" \  --link-dest "${LATEST_LINK}" \  --exclude=".cache" \  "${BACKUP_PATH}"rm -rf "${LATEST_LINK}"ln -s "${BACKUP_PATH}" "${LATEST_LINK}"</code></pre><p>上面脚本中，每一次同步都会生成一个新目录 <code>${BACKUP_DIR}/${DATETIME}</code> ，并将软链接 <code>${BACKUP_DIR}/latest</code> 指向这个目录。下一次备份时，就将 <code>${BACKUP_DIR}/latest</code> 作为基准目录，生成新的备份目录。最后，再将软链接 <code>${BACKUP_DIR}/latest</code> 指向新的备份目录</p><h2 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h2><p><code>-a</code> 、 <code>--archive</code> 参数表示存档模式，保存所有的元数据，比如修改时间（modification time）、权限、所有者等，并且软链接也会同步过去。</p><p><code>--append</code> 参数指定文件接着上次中断的地方，继续传输。</p><p><code>--append-verify</code> 参数跟 <code>--append</code> 参数类似，但会对传输完成后的文件进行一次校验。如果校验失败，将重新发送整个文件。</p><p><code>-b</code> 、 <code>--backup</code> 参数指定在删除或更新目标目录已经存在的文件时，将该文件更名后进行备份，默认行为是删除。更名规则是添加由 <code>--suffix</code> 参数指定的文件后缀名，默认是~。</p><p><code>--backup-dir</code> 参数指定文件备份时存放的目录，比如 <code>--backup-dir=/path/to/backups</code> 。</p><p><code>--bwlimit</code> 参数指定带宽限制，默认单位是 KB/s，比如 <code>--bwlimit=100</code> 。</p><p><code>-c</code> 、 <code>--checksum</code> 参数改变rsync的校验方式。默认情况下，rsync 只检查文件的大小和最后修改日期是否发生变化，如果发生变化，就重新传输；使用这个参数以后，则通过判断文件内容的校验和，决定是否重新传输。</p><p><code>--delete</code> 参数删除只存在于目标目录、不存在于源目标的文件，即保证目标目录是源目标的镜像。</p><p><code>-e</code> 参数指定使用 SSH 协议传输数据。</p><p><code>--exclude</code> 参数指定排除不进行同步的文件，比如 <code>--exclude="*.iso"</code> 。</p><p><code>--exclude-from</code> 参数指定一个本地文件，里面是需要排除的文件模式，每个模式一行。</p><p><code>--existing</code> 、 <code>--ignore-non-existing</code> 参数表示不同步目标目录中不存在的文件和目录。</p><p><code>-h</code> 参数表示以人类可读的格式输出。</p><p><code>-h</code> 、 <code>--help</code> 参数返回帮助信息。</p><p><code>-i</code> 参数表示输出源目录与目标目录之间文件差异的详细情况。</p><p><code>--ignore-existing</code> 参数表示只要该文件在目标目录中已经存在，就跳过去，不再同步这些文件。</p><p><code>--include</code> 参数指定同步时要包括的文件，一般与 <code>--exclude</code> 结合使用。</p><p><code>--link-dest</code> 参数指定增量备份的基准目录。</p><p><code>-m</code> 参数指定不同步空目录。</p><p><code>--max-size</code> 参数设置传输的最大文件的大小限制，比如不超过200KB（ <code>--max-size='200k'</code> ）。</p><p><code>--min-size</code> 参数设置传输的最小文件的大小限制，比如不小于10KB（ <code>--min-size=10k</code> ）。</p><p><code>-n</code> 参数或 <code>--dry-run</code> 参数模拟将要执行的操作，而并不真的执行。配合 <code>-v</code> 参数使用，可以看到哪些内容会被同步过去。</p><p><code>-P</code> 参数是 <code>--progress</code> 和 <code>--partial</code> 这两个参数的结合。</p><p><code>--partial</code> 参数允许恢复中断的传输。不使用该参数时，rsync会删除传输到一半被打断的文件；使用该参数后，传输到一半的文件也会同步到目标目录，下次同步时再恢复中断的传输。一般需要与 <code>--append</code> 或 <code>--append-verify</code> 配合使用。</p><p><code>--partial-dir</code> 参数指定将传输到一半的文件保存到一个临时目录，比如 <code>--partial-dir=.rsync-partial</code> 。一般需要与 <code>--append</code> 或 <code>--append-verify</code> 配合使用。</p><p><code>--progress</code> 参数表示显示进展。</p><p><code>-r</code> 参数表示递归，即包含子目录。</p><p><code>--remove-source-files</code> 参数表示传输成功后，删除发送方的文件。</p><p><code>--size-only</code> 参数表示只同步大小有变化的文件，不考虑文件修改时间的差异。</p><p><code>--suffix</code> 参数指定文件名备份时，对文件名添加的后缀，默认是~。</p><p><code>-u</code> 、 <code>--update</code> 参数表示同步时跳过目标目录中修改时间更新的文件，即不同步这些有更新的时间戳的文件。</p><p><code>-v</code> 参数表示输出细节。 <code>-vv</code> 表示输出更详细的信息， <code>-vvv</code> 表示输出最详细的信息。</p><p><code>--version</code> 参数返回 <code>rsync</code> 的版本。</p><p><code>-z</code> 参数指定同步时压缩数据</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.digitalocean.com/community/tutorials/how-to-use-rsync-to-sync-local-and-remote-directories-on-a-vps">How To Use Rsync to Sync Local and Remote Directories on a VPS</a>, Justin Ellingwood</li><li><a href="https://www.howtoforge.com/mirroring_with_rsync">Mirror Your Web Site With rsync</a>, Falko Timme</li><li><a href="https://linuxconfig.org/examples-on-how-to-use-rsync-for-local-and-remote-data-backups-and-synchonization">Examples on how to use Rsync</a>, Egidio Docile</li><li><a href="https://linuxconfig.org/how-to-create-incremental-backups-using-rsync-on-linux">How to create incremental backups using rsync on Linux</a>, Egidio Docile</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>awk统计文本中同一数据出现的次数排序</title>
      <link href="/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/awk%E7%BB%9F%E8%AE%A1%E6%96%87%E6%9C%AC%E4%B8%AD%E5%90%8C%E4%B8%80%E6%95%B0%E6%8D%AE%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <url>/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/awk%E7%BB%9F%E8%AE%A1%E6%96%87%E6%9C%AC%E4%B8%AD%E5%90%8C%E4%B8%80%E6%95%B0%E6%8D%AE%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>突然发现awk原来可以统计同一数据在要处理的文件中所出现的次数. 原来的时候 为了分析数据还自己写程序, 哎, 无语, 当时还以为自己多强, 手工分析不过来的东西写程序处理. 现在想来实在是年少轻狂. 解决问题嘛, 不讲究方式, 只要快速 高效的完成任务就OK了.</p><a id="more"></a><p>好, 今天小试牛刀统计了一下passwd文件中shell部分重复的shell名和出现的次数, 看命令:</p><pre><code class="BASH">$awk -F: '{a[$7]++}END{for (i in a) print i" "a[i]}' /etc/passwd/bin/false 13/bin/sh 18/bin/bash 2/usr/sbin/nologin 1/bin/sync 1</code></pre><h3 id="解说一下"><a href="#解说一下" class="headerlink" title="解说一下"></a>解说一下</h3><ul><li>-F: 以: 分割字段</li><li>a[7]++定义了个名称为a的数组7]++定义了个名称为a的数组7在passwd文件中是shell名，在这里是数组索引.awk的数据- 索引可以是是字符类型这点真 是太帅了.</li><li>for (i in a) print i” “a[i]</li><li>用for循环取出数据来, 这时候i取的时下标, a[i]是里面存储的数据</li><li>是$7出现的次数, 狠!</li><li>郁闷了, 这办法太强了, 以后再遇到问题还是先baidu, 再google然后再自己动手吧!</li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>后来发现，如果awk玩得不咋熟悉的话，用命令组合也可以实现同样的功能</p><pre><code class="BASH"> awk -F: '{print $7}'|sort|uniq -c /etc/passwd</code></pre><p><strong>快速统计日志文件里点击量前十位的URL</strong></p><p>关于shell命令，网上流传着很多奇技淫巧，比如说快速统计日志文件里点击量前十位的URL：</p><pre><code class="BASH">awk ‘{print $7}’ /path/to/log | sort | uniq -c | sort -nr | head -n 10</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>awk命令的基本使用</title>
      <link href="/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/awk%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/My-Blogs/2021/01/08/Linux/shell/%E6%96%87%E4%BB%B6/awk%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Awk  pattern scanning and processing language，对文本和数据进行处理。</p><p>awk 是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输(stdin)、一个或多个文件，或其它命令的输出。它在命令行中使用，但更多是作为脚本来使用。awk有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。</p><a id="more"></a><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><pre><code class="BASH">awk&nbsp;[options]&nbsp;'scripts'&nbsp;var=value&nbsp;filename</code></pre><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><pre><code class="BASH">-F&nbsp;指定分隔符（可以是字符串或正则表达式）-f&nbsp;从脚本文件中读取awk命令-v&nbsp;var=value&nbsp;赋值变量，将外部变量传递给awk</code></pre><h2 id="脚本基本结构"><a href="#脚本基本结构" class="headerlink" title="脚本基本结构"></a>脚本基本结构</h2><pre><code class="BASH">awk&nbsp;'BEGIN{&nbsp;print&nbsp;"start"&nbsp;}&nbsp;pattern{&nbsp;commands&nbsp;}&nbsp;END{&nbsp;print&nbsp;"end"&nbsp;}'&nbsp;filename</code></pre><p>一个awk脚本通常由BEGIN语句+模式匹配+END语句三部分组成, 这三部分都是可选项.</p><p>工作原理:</p><ul><li>第一步执行BEGIN 语句</li><li>第二步从文件或标准输入读取一行，然后再执行pattern语句，逐行扫描文件到文件全部被读取</li><li>第三步执行END语句</li></ul><p>实例展示:</p><pre><code class="BASH">echo&nbsp;"hello&nbsp;"&nbsp;|&nbsp;awk&nbsp;'BEGIN{&nbsp;print&nbsp;"welcome"&nbsp;}&nbsp;END{&nbsp;print&nbsp;"2017-08-08"&nbsp;}'welcome2017-08-08echo&nbsp;-e&nbsp;"hello"&nbsp;|&nbsp;awk&nbsp;'BEGIN{&nbsp;print&nbsp;"welcome"&nbsp;}&nbsp;{print}&nbsp;END{&nbsp;print&nbsp;"2017-08-08"&nbsp;}'welcomehello2017-08-08#不加print参数时默认只打印当前的行echo|awk&nbsp;'{&nbsp;a="hello";&nbsp;b="nihao";&nbsp;c="mingongge";&nbsp;print&nbsp;a,b,c;&nbsp;}'hello&nbsp;nihao&nbsp;mingongge#使用print以逗号分隔时，打印则是以空格分界echo|awk&nbsp;'{&nbsp;a="mgg";&nbsp;b="mingg";&nbsp;c="mingongge";&nbsp;print&nbsp;a"&nbsp;is&nbsp;"b"&nbsp;or&nbsp;"c;&nbsp;}'mgg&nbsp;is&nbsp;mingg&nbsp;or&nbsp;mingongge#awk的print语句中双引号其实就是个拼接作用</code></pre><h2 id="Awk的变量"><a href="#Awk的变量" class="headerlink" title="Awk的变量"></a>Awk的变量</h2><h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h3><pre><code class="BASH">$0&nbsp;&nbsp;&nbsp;#当前记录$1~$n&nbsp;#当前记录的第N个字段FS&nbsp;&nbsp;&nbsp;#输入字段分隔符（-F相同作用）默认空格RS&nbsp;&nbsp;&nbsp;#输入记录分割符，默认换行符NF&nbsp;&nbsp;&nbsp;#字段个数就是列 NR&nbsp;&nbsp;&nbsp;#记录数，就是行号，默认从1开始OFS&nbsp;&nbsp;#输出字段分隔符，默认空格ORS&nbsp;&nbsp;#输出记录分割符，默认换行符 </code></pre><p>外部变量</p><pre><code class="BASH">[mingongge@&nbsp;~]#a=100[mingongge@&nbsp;~]#b=100[mingongge@&nbsp;~]#echo&nbsp;|awk&nbsp;'{print&nbsp;v1*v2&nbsp;}'&nbsp;v1=$a&nbsp;v2=$b10000</code></pre><h2 id="Awk运算与判断"><a href="#Awk运算与判断" class="headerlink" title="Awk运算与判断"></a>Awk运算与判断</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><pre><code class="BASH">+&nbsp;-&nbsp;加减*&nbsp;/&nbsp;&amp;&nbsp;乘&nbsp;除&nbsp;求余^&nbsp;*&nbsp;&nbsp;求幂++&nbsp;--&nbsp;增加或减少，作为前缀或后缀</code></pre><pre><code class="BASH">[mingongge@&nbsp;~]#awk&nbsp;'BEGIN{a="b";print&nbsp;a,a++,a--,++a;}'b&nbsp;0&nbsp;1&nbsp;1[mingongge@&nbsp;~]#awk&nbsp;'BEGIN{a="0";print&nbsp;a,a++,a--,++a;}'0&nbsp;0&nbsp;1&nbsp;1[mingongge@&nbsp;~]#awk&nbsp;'BEGIN{a="0";print&nbsp;a,a++,--a,++a;}'0&nbsp;0&nbsp;0&nbsp;1#和其它编程语言一样，所有用作算术运算符进行操作，操作数自动转为数值，所有非数值都变为0</code></pre><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><pre><code class="BASH">=&nbsp;+=&nbsp;-=&nbsp;*=&nbsp;/=&nbsp;%=&nbsp;^=&nbsp;**=</code></pre><h3 id="正则运算符"><a href="#正则运算符" class="headerlink" title="正则运算符"></a>正则运算符</h3><pre><code class="BASH">~&nbsp;!~&nbsp;&nbsp;匹配正则表达式/不匹配正则表达式</code></pre><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><pre><code class="BASH">||&nbsp;&nbsp;&amp;&amp;&nbsp;&nbsp;逻辑或&nbsp;&nbsp;逻辑与</code></pre><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><pre><code class="BASH">&lt;&nbsp;&lt;=&nbsp;&gt;&nbsp;&gt;=&nbsp;!=&nbsp;= </code></pre><h3 id="其它运算符"><a href="#其它运算符" class="headerlink" title="其它运算符"></a>其它运算符</h3><pre><code class="BASH">$&nbsp;&nbsp;&nbsp;字段引用&nbsp;空格&nbsp;字符串链接符?:&nbsp;&nbsp;&nbsp;三目运算符ln&nbsp;&nbsp;&nbsp;数组中是否存在某键值</code></pre><h2 id="Awk正则"><a href="#Awk正则" class="headerlink" title="Awk正则"></a>Awk正则</h2><pre><code class="BASH">^&nbsp;&nbsp;&nbsp;&nbsp;行首定位符$&nbsp;&nbsp;&nbsp;&nbsp;行尾定位符.&nbsp;&nbsp;&nbsp;&nbsp;匹配任意单个字符*&nbsp;&nbsp;&nbsp;&nbsp;匹配0个或多个前导字符（包括回车）+&nbsp;&nbsp;&nbsp;&nbsp;匹配1个或多个前导字符?&nbsp;&nbsp;&nbsp;&nbsp;匹配0个或1个前导字符&nbsp;[]&nbsp;&nbsp;&nbsp;匹配指定字符组内的任意一个字符/^[ab][^]&nbsp;&nbsp;匹配不在指定字符组内的任意一个字符()&nbsp;&nbsp;&nbsp;子表达式|&nbsp;&nbsp;&nbsp;&nbsp;或者&nbsp;&nbsp;&nbsp;&nbsp;转义符~,!~&nbsp;匹配或不匹配的条件语句x{m}&nbsp;x字符重复m次x{m,}&nbsp;x字符至少重复m次X{m,n}&nbsp;x字符至少重复m次但不起过n次（需指定参数-posix或--re-interval）</code></pre><h2 id="Awk实例介绍"><a href="#Awk实例介绍" class="headerlink" title="Awk实例介绍"></a>Awk实例介绍</h2><pre><code class="BASH">awk&nbsp;–F&nbsp;:&nbsp;‘{print&nbsp;$2}’&nbsp;datafile#以:分隔打印第二列awk&nbsp;–F&nbsp;:&nbsp;‘/^Dan/{print&nbsp;$2}’&nbsp;datafile#以:分隔打印以Dan开头行的第二列内容awk&nbsp;–F&nbsp;:&nbsp;‘/^[CE]/{print&nbsp;$1}’&nbsp;datafile&nbsp;#打印以C或E开头行的第一列awk&nbsp;–F&nbsp;:&nbsp;‘{if(length($1)&nbsp;==&nbsp;4)&nbsp;print&nbsp;$1}’&nbsp;datafile&nbsp;#打印以:分隔且长度为4字符的第一列内容awk&nbsp;–F&nbsp;:&nbsp;‘/[916]/{print&nbsp;$1}’&nbsp;datafile#匹配916的行以:分隔打印第一列awk&nbsp;-F&nbsp;:&nbsp;'/^Vinh/{print&nbsp;"a"$5}'&nbsp;2.txt#显示以Dan开头行并在第五列前加上aawk&nbsp;–F&nbsp;:&nbsp;‘{print&nbsp;$2”,”$1}’&nbsp;&nbsp;datafile#打印第二列第一列并以,分隔awk&nbsp;-F&nbsp;:&nbsp;'($5&nbsp;==&nbsp;68900)&nbsp;{print&nbsp;$1}'&nbsp;2.txt#以:分隔打印第五列是68900的行第一列 awk&nbsp;-F&nbsp;:&nbsp;'{if(length($1)&nbsp;==&nbsp;11)&nbsp;print&nbsp;$1}'&nbsp;2.txt#打印以:分隔且长度为4字符的第一列内容awk&nbsp;-F&nbsp;:&nbsp;'$1~/Tommy&nbsp;Savage/&nbsp;{print&nbsp;$5}'&nbsp;2.txtawk&nbsp;-F&nbsp;:&nbsp;'($1&nbsp;==&nbsp;"Tommy&nbsp;Savage")&nbsp;{print&nbsp;$5}'&nbsp;2.txt#打印以:分隔且第一列为Tommy&nbsp;Savage的第五列内容ll&nbsp;|awk&nbsp;'BEGIN&nbsp;{size=0;}&nbsp;{size=size+$5;}&nbsp;END{print&nbsp;"[end]size&nbsp;is&nbsp;",size}'#统计目录个的文件所有的字节数awk&nbsp;'BEGIN{size=0;}&nbsp;{size=size+$5;}&nbsp;END{print&nbsp;"[end]size&nbsp;is&nbsp;",size/1024/1024,"M"}'&nbsp;#以M为单位显示目录下的所有字节数awk&nbsp;'BEGIN{a=10;a+=10;print&nbsp;a}'20&nbsp;#a+10等价于&nbsp;a=a+10echo|awk&nbsp;'BEGIN{a="100testaaa"}a~/test/{print&nbsp;"ok"}'&nbsp;#正则匹配a&nbsp;是否有test字符，成立打印okawk&nbsp;'BEGIN{a="b";print&nbsp;a=="b"?"ok":"err"}'okawk&nbsp;'BEGIN{a="b";print&nbsp;a=="c"?"ok":"err"}'err#三目运算符?:awk&nbsp;'/root/{print&nbsp;$0}'&nbsp;passwd&nbsp;#匹配所有包含root的行awk&nbsp;-F:&nbsp;'$5~/root/{print&nbsp;$0}'&nbsp;passwd&nbsp;#&nbsp;以分号作为分隔符，匹配第5个字段是root的行ifconfig&nbsp;eth0|awk&nbsp;'BEGIN{FS="[[:space:]:]+"}&nbsp;NR==2{print&nbsp;$4}'#打印IP地址awk&nbsp;'{print&nbsp;toupper($0)}'&nbsp;test.txt#toupper是awk内置函数，将所小写字母转换成大写</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cron基本的使用</title>
      <link href="/My-Blogs/2021/01/08/Linux/shell/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/cron%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/My-Blogs/2021/01/08/Linux/shell/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/cron%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>先来看一张图</p><a id="more"></a><p><img src="/My-Blogs/images/cron%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-01.png"></p><pre><code class="BASH">#编辑crontab任务vim /etc/crontab# 启动crontabsudo /etc/init.d/cron start#停止crontabsudo /etc/init.d/cron stop#重启crontabsudo /etc/init.d/cron restart#重载/etc/crontab配置sudo /etc/init.d/cron reload# 强制重载/etc/crontab配置sudo /etc/init.d/cron force-reload# 查看crontab服务状态sudo /etc/init.d/cron status# 查看crontab运行记录tail -f /var/log/cron.log# 查看最近十行crontab运行记录tail -n /var/log/cron.log</code></pre><h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><h3 id="crontab不运行"><a href="#crontab不运行" class="headerlink" title="crontab不运行"></a>crontab不运行</h3><ol><li> 查看配置是否正确 比如有没’等特殊符号 时间设置是否有错</li><li> 查看crontab服务状态</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes 组件介绍</title>
      <link href="/My-Blogs/2021/01/08/k8s/Kubernetes%E7%BB%84%E4%BB%B6/"/>
      <url>/My-Blogs/2021/01/08/k8s/Kubernetes%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Kubernetes-组件"><a href="#Kubernetes-组件" class="headerlink" title="Kubernetes 组件"></a>Kubernetes 组件</h2><a id="more"></a><p><strong>Kubernetes 集群由代表控制平面的组件和一组称为节点的机器组成。</strong></p><p>当你部署完 Kubernetes, 即拥有了一个完整的集群。</p><p>一个 Kubernetes 集群包含 集群由一组被称作节点的机器组成。这些节点上运行 Kubernetes 所管理的容器化应用。集群具有至少一个工作节点。</p><p>工作节点托管作为应用负载的组件的 Pod 。控制平面管理集群中的工作节点和 Pod 。 为集群提供故障转移和高可用性，这些控制平面一般跨多主机运行，集群跨多个节点运行。</p><p>本文档概述了交付正常运行的 Kubernetes 集群所需的各种组件。</p><p>这张图表展示了包含所有相互关联组件的 Kubernetes 集群。</p><p>![Kubernetes 组件](/images/Kubernetes 组件-01.svg)</p><h3 id="控制平面组件（Control-Plane-Components）"><a href="#控制平面组件（Control-Plane-Components）" class="headerlink" title="控制平面组件（Control Plane Components）"></a>控制平面组件（Control Plane Components）<a href="#control-plane-components"></a></h3><p>控制平面的组件对集群做出全局决策(比如调度)，以及检测和响应集群事件（例如，当不满足部署的 <code>replicas</code> 字段时，启动新的 <a href="/docs/concepts/workloads/pods/pod-overview/">pod</a>）。</p><p>控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件，并且不会在此计算机上运行用户容器。 请参阅<a href="/zh/docs/setup/production-environment/tools/kubeadm/high-availability/">构建高可用性集群</a> 中对于多主机 VM 的设置示例。</p><h4 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver<a href="#kube-apiserver"></a></h4><p>API 服务器是 Kubernetes <a href="/zh/docs/reference/glossary/?all=true#term-control-plane">控制面</a>的组件， 该组件公开了 Kubernetes API。 API 服务器是 Kubernetes 控制面的前端。</p><p>Kubernetes API 服务器的主要实现是 <a href="/zh/docs/reference/command-line-tools-reference/kube-apiserver/">kube-apiserver</a>。 kube-apiserver 设计上考虑了水平伸缩，也就是说，它可通过部署多个实例进行伸缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。</p><h4 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd<a href="#etcd"></a></h4><p>etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。</p><p>您的 Kubernetes 集群的 etcd 数据库通常需要有个备份计划。</p><p>要了解 etcd 更深层次的信息，请参考 <a href="https://etcd.io/docs/">etcd 文档</a>。</p><h4 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler<a href="#kube-scheduler"></a></h4><p>主节点上的组件，该组件监视那些新创建的未指定运行节点的 Pod，并选择节点让 Pod 在上面运行。</p><p>调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。</p><h4 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager<a href="#kube-controller-manager"></a></h4><p>在主节点上运行 <a href="/zh/docs/concepts/architecture/controller/">控制器</a> 的组件。</p><p>从逻辑上讲，每个<a href="/zh/docs/concepts/architecture/controller/">控制器</a>都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。</p><p>这些控制器包括:</p><ul><li>  节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应。</li><li>  副本控制器（Replication Controller）: 负责为系统中的每个副本控制器对象维护正确数量的 Pod。</li><li>  端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)。</li><li>  服务帐户和令牌控制器（Service Account &amp; Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌.</li></ul><h4 id="cloud-controller-manager"><a href="#cloud-controller-manager" class="headerlink" title="cloud-controller-manager"></a>cloud-controller-manager<a href="#cloud-controller-manager"></a></h4><p>云控制器管理器是指嵌入特定云的控制逻辑的 <a href="/zh/docs/reference/glossary/?all=true#term-control-plane">控制平面</a>组件。 云控制器管理器允许您链接聚合到云提供商的应用编程接口中， 并分离出相互作用的组件与您的集群交互的组件。</p><p><code>cloud-controller-manager</code> 仅运行特定于云平台的控制回路。 如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的环境中不需要云控制器管理器。</p><p>与 <code>kube-controller-manager</code> 类似， <code>cloud-controller-manager</code> 将若干逻辑上独立的 控制回路组合到同一个可执行文件中，供你以同一进程的方式运行。 你可以对其执行水平扩容（运行不止一个副本）以提升性能或者增强容错能力。</p><p>下面的控制器都包含对云平台驱动的依赖：</p><ul><li>  节点控制器（Node Controller）: 用于在节点终止响应后检查云提供商以确定节点是否已被删除</li><li>  路由控制器（Route Controller）: 用于在底层云基础架构中设置路由</li><li>  服务控制器（Service Controller）: 用于创建、更新和删除云提供商负载均衡器</li></ul><h3 id="Node-组件"><a href="#Node-组件" class="headerlink" title="Node 组件"></a>Node 组件<a href="#node-components"></a></h3><p>节点组件在每个节点上运行，维护运行的 Pod 并提供 Kubernetes 运行环境。</p><h4 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet<a href="#kubelet"></a></h4><p>一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。</p><p>kubelet 接收一组通过各类机制提供给它的 PodSpecs，确保这些 PodSpecs 中描述的容器处于运行状态且健康。kubelet 不会管理不是由 Kubernetes 创建的容器。</p><h4 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy<a href="#kube-proxy"></a></h4><p><a href="/zh/docs/reference/command-line-tools-reference/kube-proxy/">kube-proxy</a> 是集群中每个节点上运行的网络代理， 实现 Kubernetes <a href="/zh/docs/concepts/services-networking/service/">服务（Service）</a> 概念的一部分。</p><p>kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p><p>如果操作系统提供了数据包过滤层并可用的话，kube-proxy 会通过它来实现网络规则。否则， kube-proxy 仅转发流量本身。</p><h4 id="容器运行时（Container-Runtime）"><a href="#容器运行时（Container-Runtime）" class="headerlink" title="容器运行时（Container Runtime）"></a>容器运行时（Container Runtime）<a href="#container-runtime"></a></h4><p>容器运行环境是负责运行容器的软件。</p><p>Kubernetes 支持多个容器运行环境: <a href="/zh/docs/reference/kubectl/docker-cli-to-kubectl/">Docker</a>、 <a href="https://containerd.io/docs/">containerd</a>、<a href="https://cri-o.io/#what-is-cri-o">CRI-O</a> 以及任何实现 <a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md">Kubernetes CRI (容器运行环境接口)</a>。</p><h3 id="插件（Addons）"><a href="#插件（Addons）" class="headerlink" title="插件（Addons）"></a>插件（Addons）<a href="#addons"></a></h3><p>插件使用 Kubernetes 资源（<a href="/zh/docs/concepts/workloads/controllers/daemonset/">DaemonSet</a>、 <a href="/zh/docs/concepts/workloads/controllers/deployment/">Deployment</a>等）实现集群功能。 因为这些插件提供集群级别的功能，插件中命名空间域的资源属于 <code>kube-system</code> 命名空间。</p><p>下面描述众多插件中的几种。有关可用插件的完整列表，请参见 <a href="/zh/docs/concepts/cluster-administration/addons/">插件（Addons）</a>。</p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS<a href="#dns"></a></h4><p>尽管其他插件都并非严格意义上的必需组件，但几乎所有 Kubernetes 集群都应该 有<a href="/zh/docs/concepts/services-networking/dns-pod-service/">集群 DNS</a>， 因为很多示例都需要 DNS 服务。</p><p>集群 DNS 是一个 DNS 服务器，和环境中的其他 DNS 服务器一起工作，它为 Kubernetes 服务提供 DNS 记录。</p><p>Kubernetes 启动的容器自动将此 DNS 服务器包含在其 DNS 搜索列表中。</p><h4 id="Web-界面（仪表盘）"><a href="#Web-界面（仪表盘）" class="headerlink" title="Web 界面（仪表盘）"></a>Web 界面（仪表盘）<a href="#web-%E7%95%8C%E9%9D%A2-%E4%BB%AA%E8%A1%A8%E7%9B%98"></a></h4><p><a href="/zh/docs/tasks/access-application-cluster/web-ui-dashboard/">Dashboard</a> 是Kubernetes 集群的通用的、基于 Web 的用户界面。 它使用户可以管理集群中运行的应用程序以及集群本身并进行故障排除。</p><h4 id="容器资源监控"><a href="#容器资源监控" class="headerlink" title="容器资源监控"></a>容器资源监控<a href="#%E5%AE%B9%E5%99%A8%E8%B5%84%E6%BA%90%E7%9B%91%E6%8E%A7"></a></h4><p><a href="/zh/docs/tasks/debug-application-cluster/resource-usage-monitoring/">容器资源监控</a> 将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中，并提供用于浏览这些数据的界面。</p><h4 id="集群层面日志"><a href="#集群层面日志" class="headerlink" title="集群层面日志"></a>集群层面日志<a href="#%E9%9B%86%E7%BE%A4%E5%B1%82%E9%9D%A2%E6%97%A5%E5%BF%97"></a></h4><p><a href="/zh/docs/concepts/cluster-administration/logging/">集群层面日志</a> 机制负责将容器的日志数据 保存到一个集中的日志存储中，该存储能够提供搜索和浏览接口。</p>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七张图了解k8s内部的架构</title>
      <link href="/My-Blogs/2021/01/08/k8s/%E4%B8%83%E5%BC%A0%E5%9B%BE%E4%BA%86%E8%A7%A3k8s%E5%86%85%E9%83%A8%E7%9A%84%E6%9E%B6%E6%9E%84/"/>
      <url>/My-Blogs/2021/01/08/k8s/%E4%B8%83%E5%BC%A0%E5%9B%BE%E4%BA%86%E8%A7%A3k8s%E5%86%85%E9%83%A8%E7%9A%84%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>七张图，带你走进k8s的世界</p><a id="more"></a><h3 id="Kubernetes架构和组成"><a href="#Kubernetes架构和组成" class="headerlink" title="Kubernetes架构和组成"></a>Kubernetes架构和组成</h3><p><code>Kubernetes</code> 具有去中心化的架构，不会线性处理任务。它基于声明性模型运行并实现”所需状态”的概念。下面这些步骤说明了 <code>Kubernetes</code> 的基本过程:</p><ul><li>管理员创建应用程序的所需状态并将其放入清单文件manifest.yml中。</li><li>使用CLI或提供的用户界面将清单文件提供给 <code>Kubernetes API Server</code>。 <code>Kubernetes</code>的默认命令行工具称为kubectl。</li><li><code>Kubernetes</code>将清单文件（描述了应用程序的期望状态）存储在称为键值存储（etcd）的数据库中。</li><li><code>Kubernetes</code>随后在集群内的所有相关应用程序上实现所需的状态。</li><li><code>Kubernetes</code>持续监控集群的元素，以确保应用程序的当前状态不会与所需状态有所不同。</li></ul><p><img src="/My-Blogs/images/%E4%B8%83%E5%BC%A0%E5%9B%BE%E4%BA%86%E8%A7%A3k8s%E5%86%85%E9%83%A8%E7%9A%84%E6%9E%B6%E6%9E%84-01.png" alt="image"></p><h3 id="主节点"><a href="#主节点" class="headerlink" title="主节点"></a>主节点</h3><p><code>Kubernetes</code> 的主节点通过API从CLI（命令行界面）或UI（用户界面）接收输入。这些是你提供给 <code>Kubernetes</code> 的命令。</p><p>你可以定义想要让 <code>Kubernetes</code> 维护的Pod，副本集和Service。例如，要使用的容器镜像，要公开的端口以及要运行的Pod副本数量。还可以为该集群中运行的应用程序提供”所需状态”的参数。</p><p><img src="/My-Blogs/images/%E4%B8%83%E5%BC%A0%E5%9B%BE%E4%BA%86%E8%A7%A3k8s%E5%86%85%E9%83%A8%E7%9A%84%E6%9E%B6%E6%9E%84-02.png" alt="image"></p><h4 id="API-Server"><a href="#API-Server" class="headerlink" title="API Server"></a>API Server</h4><p>API Server是Kubernetes控制程序的前端，也是用户唯一可以直接进行交互的Kubernetes组件，内部系统组件以及外部用户组件均通过相同的API进行通信。</p><h4 id="键值存储etcd"><a href="#键值存储etcd" class="headerlink" title="键值存储etcd"></a>键值存储etcd</h4><p>键值存储（也称为etcd）是Kubernetes用来备份所有集群数据的数据库。它存储集群的整个配置和状态。主节点查询etcd以检索节点，容器和容器的状态参数。</p><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><p>控制器的作用是从API Server获得所需状态。它检查要控制的节点的当前状态，确定是否与所需状态存在任何差异，并解决它们（如果有）。</p><h4 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h4><p>调度程序会监视来自API Server的新请求，并将其分配给运行状况良好的节点。它对节点的质量进行排名，并将Pod部署到最适合的节点。如果没有合适的节点，则将Pod置于挂起状态，直到出现合适的节点。</p><blockquote><p>注意：最好不要在主节点上运行用户应用程序。让Kubernetes主节点可以完全专注于管理集群。</p></blockquote><h3 id="工作节点"><a href="#工作节点" class="headerlink" title="工作节点"></a>工作节点</h3><p>工作节点监听API Server发送过来的新的工作分配；他们会执行分配给他们的工作，然后将结果报告给Kubernetes主节点。</p><p><img src="/My-Blogs/images/%E4%B8%83%E5%BC%A0%E5%9B%BE%E4%BA%86%E8%A7%A3k8s%E5%86%85%E9%83%A8%E7%9A%84%E6%9E%B6%E6%9E%84-03.png" alt="image"></p><h4 id="Kubelet"><a href="#Kubelet" class="headerlink" title="Kubelet"></a>Kubelet</h4><p>kubelet在群集中的每个节点上运行。它是Kubernetes内部的主要代理。通过安装kubelet，节点的CPU，RAM和存储成为所处集群的一部分。它监视从API Server发送来的任务，执行任务，并报告给主节点。它还会监视Pod，如果Pod不能完全正常运行，则会向控制程序报告。然后，基于该信息，主服务器可以决定如何分配任务和资源以达到所需状态。</p><h4 id="Container-Runtime"><a href="#Container-Runtime" class="headerlink" title="Container Runtime"></a>Container Runtime</h4><p>容器运行时从容器镜像库中拉取镜像，然后启动和停止容器。容器运行时由第三方软件或插件（例如Docker）担当。</p><h4 id="Kube-proxy"><a href="#Kube-proxy" class="headerlink" title="Kube-proxy"></a>Kube-proxy</h4><p>kube-proxy确保每个节点都获得其IP地址，实现本地iptables和规则以处理路由和流量负载均衡。</p><h4 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h4><p>在Kubernetes中，Pod是调度的最小元素。没有它，容器就不能成为集群的一部分。如果你需要扩展应用程序，则只能通过添加或删除Pod来实现。</p><p>Pod是Kubernetes中一个抽象化概念，由一个或多个容器组合在一起得共享资源。根据资源的可用性，主节点会把Pod调度到特定工作节点上，并与容器运行时协调以启动容器。</p><p><img src="/My-Blogs/images/%E4%B8%83%E5%BC%A0%E5%9B%BE%E4%BA%86%E8%A7%A3k8s%E5%86%85%E9%83%A8%E7%9A%84%E6%9E%B6%E6%9E%84-04.png" alt="image"></p><p>在Pod意外无法执行任务的情况下，Kubernetes不会尝试修复它们。相反，它会在其位置创建并启动一个新Pod。这个新Pod是原来的副本，除了DNS和IP地址都和以前的Pod一样。此功能对开发人员设计应用程序的方式产生了深远的影响。</p><p>由于Kubernetes架构的灵活性，不再需要将应用程序绑定到Pod的特定实例。取而代之的是，需要对应用程序进行设计，以便在集群内任何位置创建的全新Pod可以无缝取代旧Pod。Kubernetes会使用Service来协助此过程。</p><h3 id="Kubernetes-Service"><a href="#Kubernetes-Service" class="headerlink" title="Kubernetes Service"></a>Kubernetes Service</h3><p>Pod不是恒定的。 Kubernetes提供的最佳功能之一是无法正常运行的Pod会自动被新的Pod取代。</p><p>但是，这些新的Pod具有一组不同的IP。这可能导致处理问题，并且由于IP不再匹配，IP流失。如果无人看管，此属性将使吊舱高度不可靠。</p><p>为了将稳定的IP地址和DNS名称引入到不稳定的Pod世界中，Kubernetes引入了Service来提供可靠的网络连接。</p><p>通过控制进出Pod的流量，Service提供了稳定的网络终结点-固定的IP，DNS和端口。有了Service，可以添加或删除任何Pod，而不必担心基本网络信息会改变。</p><h4 id="Service是怎么工作的"><a href="#Service是怎么工作的" class="headerlink" title="Service是怎么工作的"></a>Service是怎么工作的</h4><p>Pod通过称为标签（Label）和选择器（Selector）的键值对与Service相关联。Service会自动发现带有与选择器匹配的标签的新Pod。</p><p>此过程无缝地将新的Pod添加到Service，同时，从群集中删除已终止的Pod。</p><p>例如，如果所需状态定义了需要一个Pod的三个副本，而运行一个副本的节点发生故障，则当前状态将减少为两个Pod。Kubernetes观察到所需的状态是三个Pod。然后，它会调度一个新副本来代替发生故障的Pod，并将其分配给集群中的另一个节点。</p><p>通过添加或删除容器来更新或缩放应用程序时，同样适用。一旦我们更新了所需状态的定义，Kubernetes就会注意到差异并添加或删除Pod以匹配清单文件manifest.yml里定义的所需状态。Kubernetes控制面板记录，实现和运行后台协调循环，该循环会不断检查环境是否符合用户定义的环境要求</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/My-Blogs/images/%E4%B8%83%E5%BC%A0%E5%9B%BE%E4%BA%86%E8%A7%A3k8s%E5%86%85%E9%83%A8%E7%9A%84%E6%9E%B6%E6%9E%84-05.svg" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊前端大文件上传</title>
      <link href="/My-Blogs/2021/01/08/JavaScript/%E8%81%8A%E8%81%8A%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/My-Blogs/2021/01/08/JavaScript/%E8%81%8A%E8%81%8A%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<p>前端文件上传似乎是个说不完的话题，让我们来总结下目前主要的一些上传方式吧</p><a id="more"></a><h2 id="文件上传的几种方式"><a href="#文件上传的几种方式" class="headerlink" title="文件上传的几种方式"></a>文件上传的几种方式</h2><h3 id="普通表单上传"><a href="#普通表单上传" class="headerlink" title="普通表单上传"></a>普通表单上传</h3><p>使用PHP来展示常规的表单上传是一个不错的选择。首先构建文件上传的表单，并指定表单的提交内容类型为enctype=”multipart/form-data”，表明表单需要上传二进制数据。</p><pre><code class="HTML">&lt;form action="/index.php" method="POST" enctype="multipart/form-data"&gt;  &lt;input type="file" name="myfile"&gt;  &lt;input type="submit"&gt;&lt;/form&gt;</code></pre><p>然后编写index.php上传文件接收代码，使用move_uploaded_file方法即可(php大法好…)</p><pre><code class="PHP">$imgName = 'IMG'.time().'.'.str_replace('image/','',$_FILES["myfile"]['type']);$fileName =  'upload/'.$imgName;// 移动上传文件至指定upload文件夹下，并根据返回值判断操作是否成功if (move_uploaded_file($_FILES['myfile']['tmp_name'], $fileName)){    echo $fileName;}else {    echo "nonn";}</code></pre><p>form表单上传大文件时，很容易遇见服务器超时的问题。通过xhr，前端也可以进行异步上传文件的操作，一般由两个思路。</p><h3 id="文件编码上传"><a href="#文件编码上传" class="headerlink" title="文件编码上传"></a>文件编码上传</h3><p>第一个思路是将文件进行编码，然后在服务端进行解码，之前写过一篇在前端实现图片压缩上传的博客，其主要实现原理就是将图片转换成base64进行传递</p><pre><code class="js">var imgURL = URL.createObjectURL(file);ctx.drawImage(imgURL, 0, 0);// 获取图片的编码，然后将图片当做是一个很长的字符串进行传递var data = canvas.toDataURL("image/jpeg", 0.5); </code></pre><p>在服务端需要做的事情也比较简单，首先解码base64，然后保存图片即可</p><pre><code class="PHP">$imgData = $_REQUEST['imgData'];$base64 = explode(',', $imgData)[1];$img = base64_decode($base64);$url = './test.jpg';if (file_put_contents($url, $img)) {    exit(json_encode(array(        url =&gt; $url    )));}</code></pre><p>base64编码的缺点在于其体积比原图片更大（因为Base64将三个字节转化成四个字节，因此编码后的文本，会比原文本大出三分之一左右），对于体积很大的文件来说，上传和解析的时间会明显增加。</p><p>更多关于base64的知识，可以参考Base64笔记。</p><p>除了进行base64编码，还可以在前端直接读取文件内容后以二进制格式上传</p><pre><code class="JS">// 读取二进制文件function readBinary(text){   var data = new ArrayBuffer(text.length);   var ui8a = new Uint8Array(data, 0);   for (var i = 0; i &lt; text.length; i++){      ui8a[i] = (text.charCodeAt(i) &amp; 0xff);   }   console.log(ui8a)}var reader = new FileReader();reader.onload = function(){      readBinary(this.result) // 读取result或直接上传}// 把从input里读取的文件内容，放到fileReader的result字段里reader.readAsBinaryString(file);</code></pre><h3 id="formData异步上传"><a href="#formData异步上传" class="headerlink" title="formData异步上传"></a>formData异步上传</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/Using_FormData_Objects">FormData</a><br>对象主要用来组装一组用 XMLHttpRequest发送请求的键/值对，可以更加灵活地发送Ajax请求。可以使用FormData来模拟表单提交。</p><pre><code class="JS">let files = e.target.files // 获取input的file对象let formData = new FormData();formData.append('file', file);axios.post(url, formData);</code></pre><p>服务端处理方式与直接form表单请求基本相同。</p><h3 id="iframe无刷新页面"><a href="#iframe无刷新页面" class="headerlink" title="iframe无刷新页面"></a>iframe无刷新页面</h3><p>在低版本的浏览器（如IE）上，xhr是不支持直接上传formdata的，因此只能用form来上传文件，而form提交本身会进行页面跳转，这是因为form表单的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/form">target</a>属性导致的，其取值有</p><ul><li>_self，默认值，在相同的窗口中打开响应页面</li><li>_blank，在新窗口打开</li><li>_parent，在父窗口打开</li><li>_top，在最顶层的窗口打开</li><li>framename，在指定名字的iframe中打开</li></ul><p>如果需要让用户体验异步上传文件的感觉，可以通过framename指定<code>iframe</code>来实现。把form的target属性设置为一个看不见的iframe，那么返回的数据就会被这个iframe接受，因此只有该iframe会被刷新，至于返回结果，也可以通过解析这个iframe内的文本来获取。</p><pre><code class="JS">function upload(){    var now = +new Date()    var id = 'frame' + now    $("body").append(`&lt;iframe  name="${id}" id="${id}" /&gt;`);    var $form = $("#myForm")    $form.attr({        "action": '/index.php',        "method": "post",        "enctype": "multipart/form-data",        "encoding": "multipart/form-data",        "target": id    }).submit()    $("#"+id).on("load", function(){        var content = $(this).contents().find("body").text()        try{            var data = JSON.parse(content)        }catch(e){            console.log(e)        }    })}</code></pre><h2 id="大文件上传"><a href="#大文件上传" class="headerlink" title="大文件上传"></a>大文件上传</h2><p>现在来看看在上面提到的几种上传方式中实现大文件上传会遇见的超时问题，</p><ul><li>表单上传和iframe无刷新页面上传，实际上都是通过form标签进行上传文件，这种方式将整个请求完全交给浏览器处理，当上传大文件时，可能会遇见请求超时的情形</li><li>通过fromData，其实际也是在xhr中封装一组请求参数，用来模拟表单请求，无法避免大文件上传超时的问题</li><li>编码上传，我们可以比较灵活地控制上传的内容</li></ul><p>大文件上传最主要的问题就在于：<strong>在同一个请求中，要上传大量的数据，导致整个过程会比较漫长，且失败后需要重头开始上传</strong>。试想，如果我们将这个请求拆分成多个请求，每个请求的时间就会缩短，且如果某个请求失败，只需要重新发送这一次请求即可，无需从头开始，这样是否可以解决大文件上传的问题呢？</p><p>综合上面的问题，看来大文件上传需要实现下面几个需求</p><ul><li>支持拆分上传请求(即切片)</li><li>支持断点续传</li><li>支持显示上传进度和暂停上传</li></ul><p>接下来让我们依次实现这些功能，看起来最主要的功能应该就是切片了</p><h3 id="文件切片"><a href="#文件切片" class="headerlink" title="文件切片"></a>文件切片</h3><p>参考： <a href="https://blog.csdn.net/baochao95/article/details/52812876">大文件切割上传</a></p><p>编码方式上传中，在前端我们只要先获取文件的二进制内容，然后对其内容进行拆分，最后将每个切片上传到服务端即可。</p><p>在JavaScript中，文件FIle对象是Blob对象的子类，Blob对象包含一个重要的方法<code>slice</code>，通过这个方法，我们就可以对二进制文件进行拆分。</p><p>下面是一个拆分文件的示例</p><pre><code class="JS">function slice(file, piece = 1024 * 1024 * 5) {  let totalSize = file.size; // 文件总大小  let start = 0; // 每次上传的开始字节  let end = start + piece; // 每次上传的结尾字节  let chunks = []  while (start &lt; totalSize) {    // 根据长度截取每次需要上传的数据    // File对象继承自Blob对象，因此包含slice方法    let blob = file.slice(start, end);     chunks.push(blob)    start = end;    end = start + piece;  }  return chunks}</code></pre><p>将文件拆分成<code>piece</code>大小的分块，然后每次请求只需要上传这一个部分的分块即可</p><pre><code class="JS">let file =  document.querySelector("[name=file]").files[0];const LENGTH = 1024 * 1024 * 0.1;let chunks = slice(file, LENGTH); // 首先拆分切片chunks.forEach(chunk=&gt;{  let fd = new FormData();  fd.append("file", chunk);  post('/mkblk.php', fd)})</code></pre><p>服务器接收到这些切片后，再将他们拼接起来就可以了，下面是PHP拼接切片的示例代码</p><pre><code class="JS">$filename = './upload/' . $_POST['filename'];//确定上传的文件名//第一次上传时没有文件，就创建文件，此后上传只需要把数据追加到此文件中if(!file_exists($filename)){    move_uploaded_file($_FILES['file']['tmp_name'],$filename);}else{    file_put_contents($filename,file_get_contents($_FILES['file']['tmp_name']),FILE_APPEND);    echo $filename;}</code></pre><p>测试时记得修改nginx的server配置，否则大文件可能会提示<code>413 Request Entity Too Large</code>的错误。</p><pre><code class="NGINX">server {    // ...    client_max_body_size 50m;}</code></pre><p>上面这种方式来存在一些问题</p><ul><li>无法识别一个切片是属于哪一个切片的，当同时发生多个请求时，追加的文件内容会出错</li><li>切片上传接口是异步的，无法保证服务器接收到的切片是按照请求顺序拼接的<br>因此接下来我们来看看应该如何在服务端还原切片。</li></ul><h3 id="还原切片"><a href="#还原切片" class="headerlink" title="还原切片"></a>还原切片</h3><p>在后端需要将多个相同文件的切片还原成一个文件，上面这种处理切片的做法存在下面几个问题</p><ul><li><p>如何识别多个切片是来自于同一个文件的，这个可以在每个切片请求上传递一个相同文件的<code>context</code>参数</p></li><li><p>如何将多个切片还原成一个文件</p><ul><li>确认所有切片都已上传，这个可以通过客户端在切片全部上传后调用mkfile接口来通知服务端进行拼接</li><li>找到同一个context下的所有切片，确认每个切片的顺序，这个可以在每个切片上标记一个位置索引值</li><li>按顺序拼接切片，还原成文件<br>上面有一个重要的参数，即<code>context</code>，我们需要获取为一个文件的唯一标识，可以通过下面两种方式获取</li></ul></li><li><p>根据文件名、文件长度等基本信息进行拼接，为了避免多个用户上传相同的文件，可以再额外拼接用户信息如uid等保证唯一性</p></li><li><p>根据文件的二进制内容计算文件的hash，这样只要文件内容不一样，则标识也会不一样，缺点在于计算量比较大.</p></li></ul><p>修改上传代码，增加相关参数</p><pre><code class="JS">// 获取context，同一个文件会返回相同的值function createContext(file) {     return file.name + file.length}let file = document.querySelector("[name=file]").files[0];const LENGTH = 1024 * 1024 * 0.1;let chunks = slice(file, LENGTH);// 获取对于同一个文件，获取其的contextlet context = createContext(file);let tasks = [];chunks.forEach((chunk, index) =&gt; {  let fd = new FormData();  fd.append("file", chunk);  // 传递context  fd.append("context", context);  // 传递切片索引值  fd.append("chunk", index + 1);  tasks.push(post("/mkblk.php", fd));});// 所有切片上传完毕后，调用mkfile接口Promise.all(tasks).then(res =&gt; {  let fd = new FormData();  fd.append("context", context);  fd.append("chunks", chunks.length);  post("/mkfile.php", fd).then(res =&gt; {    console.log(res);  });});</code></pre><p>在<code>mkblk.php</code>接口中，我们通过<code>context</code>来保存同一个文件相关的切片</p><pre><code class="PHP">// mkblk.php$context = $_POST['context'];$path = './upload/' . $context;if(!is_dir($path)){    mkdir($path);}// 把同一个文件的切片放在相同的目录下$filename = $path .'/'. $_POST['chunk'];$res = move_uploaded_file($_FILES['file']['tmp_name'],$filename);</code></pre><p>除了上面这种简单通过目录区分切片的方法之外，还可以将切片信息保存在数据库来进行索引。接下来是<code>mkfile.php</code>接口的实现，这个接口会在所有切片上传后调用</p><pre><code class="PHP">// mkfile.php$context = $_POST['context'];$chunks = (int)$_POST['chunks'];//合并后的文件名$filename = './upload/' . $context . '/file.jpg'; for($i = 1; $i &lt;= $chunks; ++$i){    $file = './upload/'.$context. '/' .$i; // 读取单个切块    $content = file_get_contents($file);    if(!file_exists($filename)){        $fd = fopen($filename, "w+");    }else{        $fd = fopen($filename, "a");    }    fwrite($fd, $content); // 将切块合并到一个文件上}echo $filename;</code></pre><p>这样就解决了上面的两个问题：</p><ul><li>识别切片来源</li><li>保证切片拼接顺序</li></ul><h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p>即使将大文件拆分成切片上传，我们仍需等待所有切片上传完毕，在等待过程中，可能发生一系列导致部分切片上传失败的情形，如网络故障、页面关闭等。由于切片未全部上传，因此无法通知服务端合成文件。这种情况下可以通过<strong>断点续传</strong>来进行处理。</p><p>断点续传指的是：可以从已经上传部分开始继续上传未完成的部分，而没有必要从头开始上传，节省上传时间。</p><p>由于整个上传过程是按切片维度进行的，且<code>mkfile</code>接口是在所有切片上传完成后由客户端主动调用的，因此断点续传的实现也十分简单：</p><ul><li>在切片上传成功后，保存已上传的切片信息</li><li>当下次传输相同文件时，遍历切片列表，只选择未上传的切片进行上传</li><li>所有切片上传完毕后，再调用<code>mkfile</code>接口通知服务端进行文件合并</li></ul><p>因此问题就落在了如何保存已上传切片的信息了，保存一般有两种策略</p><ul><li>可以通过locaStorage等方式保存在前端浏览器中，这种方式不依赖于服务端，实现起来也比较方便，缺点在于如果用户清除了本地文件，会导致上传记录丢失</li><li>服务端本身知道哪些切片已经上传，因此可以由服务端额外提供一个根据文件context查询已上传切片的接口，在上传文件前调用该文件的历史上传记录</li></ul><p>下面让我们通过在本地保存已上传切片记录，来实现断点上传的功能</p><pre><code class="JS"> // 获取已上传切片记录function getUploadSliceRecord(context){  let record = localStorage.getItem(context)  if(!record){    return []  }else {    try{      return JSON.parse(record)    }catch(e){}  }}// 保存已上传切片function saveUploadSliceRecord(context, sliceIndex){  let list = getUploadSliceRecord(context)  list.push(sliceIndex)  localStorage.setItem(context, JSON.stringify(list))}</code></pre><p>然后对上传逻辑稍作修改，主要是增加上传前检测是已经上传、上传后保存记录的逻辑</p><pre><code class="JS">let context = createContext(file);// 获取上传记录let record = getUploadSliceRecord(context);let tasks = [];chunks.forEach((chunk, index) =&gt; {  // 已上传的切片则不再重新上传  if(record.includes(index)){    return  }  let fd = new FormData();  fd.append("file", chunk);  fd.append("context", context);  fd.append("chunk", index + 1);  let task = post("/mkblk.php", fd).then(res=&gt;{    // 上传成功后保存已上传切片记录    saveUploadSliceRecord(context, index)    record.push(index)  })  tasks.push(task);});</code></pre><p>此时上传时刷新页面或者关闭浏览器，再次上传相同文件时，之前已经上传成功的切片就不会再重新上传了。</p><p>服务端实现断点续传的逻辑基本相似，只要在<code>getUploadSliceRecord</code>内部调用服务端的查询接口获取已上传切片的记录即可，因此这里不再展开。</p><p>此外断点续传还需要考虑切片过期的情况：如果调用了<code>mkfile</code>接口，则磁盘上的切片内容就可以清除掉了，如果客户端一直不调用<code>mkfile</code>的接口，放任这些切片一直保存在磁盘显然是不可靠的，一般情况下，切片上传都有一段时间的有效期，超过该有效期，就会被清除掉。基于上述原因，断点续传也必须同步切片过期的实现逻辑。</p><h3 id="上传进度和暂停"><a href="#上传进度和暂停" class="headerlink" title="上传进度和暂停"></a>上传进度和暂停</h3><p>通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/upload">xhr.upload</a>中的progress方法可以实现监控每一个切片上传进度。</p><p>上传暂停的实现也比较简单，通过xhr.abort可以取消当前未完成上传切片的上传，实现上传暂停的效果，恢复上传就跟断点续传类似，先获取已上传的切片列表，然后重新发送未上传的切片。</p><p>由于篇幅关系，上传进度和暂停的功能这里就先不实现了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>目前社区已经存在一些成熟的大文件上传解决方案，如<a href="https://github.com/qiniu">七牛SDK</a>，<a href="https://cloud.tencent.com/document/product/266/9239">腾讯云SDK</a>等，也许并不需要我们手动去实现一个简陋的大文件上传库，但是了解其原理还是十分有必要的。</p><p>本文首先整理了前端文件上传的几种方式，然后讨论了大文件上传的几种场景，以及大文件上传需要实现的几个功能</p><p>通过Blob对象的<code>slice</code>方法将文件拆分成切片<br>整理了服务端还原文件所需条件和参数，演示了PHP将切片还原成文件<br>通过保存已上传切片的记录来实现断点续传<br>还留下了一些问题，如：合并文件时避免内存溢出、切片失效策略、上传进度暂停等功能，并没有去深入或一一实现，继续学习吧~</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冷知识之JS篇</title>
      <link href="/My-Blogs/2021/01/08/JavaScript/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BJS%E7%AF%87/"/>
      <url>/My-Blogs/2021/01/08/JavaScript/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BJS%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>关于JavaScript的冷知识又有哪些呢？让我们一起看看吧</p><a id="more"></a><h3 id="浮点数快速向下取整"><a href="#浮点数快速向下取整" class="headerlink" title="浮点数快速向下取整"></a>浮点数快速向下取整</h3><p>JavaScript中是没有整型概念的，但利用好位操作符可以轻松处理，同时获得效率上的提升。</p><br><p>|0和~~是很好的一个例子，使用这两者可以将浮点转成整型且效率方面要比同类的parseInt, Math.round 要快。在处理像素及动画位移等效果的时候会很有用。</p><pre><code class="JavaScript">(12.4 / 4.13) | 0    // =&gt; 3    ~~(12.4 / 4.13)// =&gt; 3</code></pre><h3 id="生成随机字符串"><a href="#生成随机字符串" class="headerlink" title="生成随机字符串"></a>生成随机字符串</h3><p>生成随机字符串，我们第一想到的，可能是先定义一个字符串数组，然后通过随机取数组中的字符进而拼接成一个随机长度的字符串。<br>但是下面还有一个更简单的方法，代码如下：</p><pre><code class="js">function generateRandomAlphaNum(len) {    var rdmString = "";    for (; rdmString.length &lt; len; rdmString += Math.random().toString(36).substr(2));    return rdmString.substr(0, len);}</code></pre><blockquote><p>主要是利用了toString() 方法的特性</p></blockquote><p><img src="/My-Blogs/images/toString.png" alt="image"></p><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>利用copy方法复制Console控制台的变量</p><pre><code class="js">var temp1 = 1111;copy(temp1);</code></pre><h3 id="console-table"><a href="#console-table" class="headerlink" title="console.table"></a>console.table</h3><p>Chrome专属，IE绕道的console方法。可以将JavaScript关联数组以表格形式输出到浏览器console，效果很惊赞，界面很美观。</p><pre><code class="js">//采购情况var data = [{    '品名': '杜雷斯',    '数量': 4}, {    '品名': '冈本',    '数量': 3}];console.table(data);</code></pre><p><img src="/My-Blogs/images/console.table.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Intersection Observer接口实现可视区域渲染</title>
      <link href="/My-Blogs/2021/01/08/JavaScript/%E4%BD%BF%E7%94%A8Intersection%20Observer%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%BA%E5%9F%9F%E6%B8%B2%E6%9F%93/"/>
      <url>/My-Blogs/2021/01/08/JavaScript/%E4%BD%BF%E7%94%A8Intersection%20Observer%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%BA%E5%9F%9F%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API">Intersection Observer</a>大家有了解过么？</p><a id="more"></a><h2 id="使用Intersection-Observer接口实现可视区域渲染"><a href="#使用Intersection-Observer接口实现可视区域渲染" class="headerlink" title="使用Intersection Observer接口实现可视区域渲染"></a>使用Intersection Observer接口实现可视区域渲染</h2><p>由于客户端使用的webview内核在较低配置的Android手机上打开多图页面时出现内存暴涨，无法回收导致客户端崩溃的情况，我们使用Android studio进行分析发现，问题出在了webview的图层渲染引擎。<br>我们发现，随着我们下拉加载越多，图片量增多时，图层渲染<br>Graphics部分内存持续上涨，且不存在回收的情况。因此，这种情况下，使用图片懒加载已经<br>不能解决问题了。<br>经过调研，我们采用了<code>Intersection Observer</code> 实现虚拟渲染的方案，即<br>只在可视区域才进行图片的渲染。</p><h2 id="为什么使用Intersection-Observer-接口"><a href="#为什么使用Intersection-Observer-接口" class="headerlink" title="为什么使用Intersection Observer 接口"></a>为什么使用Intersection Observer 接口</h2><p><code>Intersection Observer</code> API提供了一种异步检测目标元素与祖先元素或viewport相交变化情况的方法（MDN）。<br>换句话说，之前检测元素是否可见，元素与元素是否相交是不容易的，可能的几个方法是基于监听滚动事件，再结合使用元素的宽高属性，以计算元素当前所处位置这种耗性能的方式。前述类型的方法，在监听滚动事件的过程中, 频繁调用Element.getBoundingClientRect方法，会使得浏览器重复多次计算元素的宽高属性。<br>事件监听和调用Element.getBoundingClientRect都是在主线程上运行，这样 可能会阻塞后续js代码的执行，造成性能问题。<br>如果使用<code>Intersection Observer</code>接口，我们不但省去了自己编写代码计算位<br>置的功夫，而且因该接口是异步的，还使得我们在执行该接口进行监测的时候不会阻塞js线程的执行，可以说是一举两得。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><code>Intersection Observer</code> 接口通过观测根元素和目标元素的相对位置，在开发者设定的目标元素与根元素相交触发点<br>触发回调函数，以实现开发者的业务目的。开发者可以设置一些数值来指定目标元素进入到根元素的百分之几时触发回调函数。</p><p><img src="/My-Blogs/images/%E4%BD%BF%E7%94%A8IntersectionObserver%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%BA%E5%9F%9F%E6%B8%B2%E6%9F%93-01.gif" alt="img"></p><p>在上面的gif中，根元素是白色的视窗，目标元素为绿色的小方块。可以看到，当滚动屏幕时，绿色方块逐渐出现在视口中，分别在绿色方块与视口相交比例达到25%, 50%, 75%, 100%时触发了回调函数。<br>当然，我们可以把任意一个目标元素的祖先元素当作根元素，这对于懒加载，视频播放等都有重要的意义。</p><h2 id="怎么使用-Intersection-Observer-API"><a href="#怎么使用-Intersection-Observer-API" class="headerlink" title="怎么使用 Intersection Observer API"></a>怎么使用 Intersection Observer API</h2><p>1、新建一个观察器</p><pre><code class="JS">const callback = (entries) =&gt; {};const options = () =&gt; {};const observer = new IntersectionObserver(callback, options);</code></pre><p>callback 为相交时的处理函数, 每当被观测的元素与指定的根元素或视窗相交时便会被执行。其参数为IntersectionObserverEntry对象，该对象记录了相交时的一些状态信息，如元素的宽高，相交比率<br>等信息。<br>options, 用于指定回调函数执行时被观测元素的的环境。如指定根元素root, 指定被观测元素位于哪个位置时触发相交处理函数rootMargin, 具体可见<a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API">MDN</a></p><p>2、指定相交时的处理函数</p><pre><code class="JS">const callback = (entries) =&gt; {  entries.forEach(entry =&gt; {    if (entry.isIntersecting) { // 当true时，表示被观测元素与指定元素相交了      // 执行你要的操作    }  })}</code></pre><p>3、对目标元素进行观察</p><pre><code class="JS">const ele = document.getElementById('target');observer.observe(ele);</code></pre><p>4、<code>Intersection Observer</code>可用的方法</p><pre><code class="JS">1. observe(ele): 用于开始观察某个指定的目标元素， 观察者可以多次调用此方法对不同的元素进行观测。2. unobserve(ele): 可用来取消对某个元素的观察。3. disconnect(): 使用该方法， 可以取消对所有元素的观测， 即之前通过observer方法观测的元素不再受到观测，相应的处理函数也不会得到执行。</code></pre><h2 id="实现可视区域渲染"><a href="#实现可视区域渲染" class="headerlink" title="实现可视区域渲染"></a>实现可视区域渲染</h2><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>我们把视口当作根元素，将头像容器元素作为目标元素，设定当头像容器的面积出现在视口（即与视口相交）的比例超过50%时， 就触发一次我们的回调函数，离开时也触发我们的回调函数。<br>回调函数的功能为，当相交且目标元素可见时，将头像url地址赋值给头像元素的背景（你也可以用img来实现）url，当离开时则将目标元素的背景url置空，以保证图像渲染层保存的图片仅是目前可视区域的图片，以达到控制图像渲染引擎内存占用的目的。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ol><li> 首先，新建一个观察者</li></ol><pre><code class="JS">let hasInterSection;try {  require('intersection-observer');  hasInterSection = true;} catch (e) {  hasInterSection = false;  console.log(e);}const observer = hasInterSection &amp;&amp; (new IntersectionObserver((entries, options) =&gt; {  entries.forEach(isIntersectHandler);}, {  rootMargin: '0px 0px 0px 0px',  threshold: [0.5],  trackVisibility: true,  delay: 300}));</code></pre><blockquote><p>在新建一个observer之前，先尝试引入intersection-observer插件，这是<code>Intersection Observer</code><br>的polyfill，是为了兼容一些暂时不支持该接口的浏览器。<br>引入后，在新建的观察器中，我们传入了一些配置，在这里，我们根元素就是视口元素，且没有对视口的范围进行扩充（rootMargin: ‘0px 0px 0px 0px’, ）, 如果要对视口的范围进行扩充或缩小，则可以改变rootMargin的值。<br>这里，相交比例达到0.5时，我们才让它显示头像，离开时也是达到0.5才会隐藏头像，关于threshold的理解，mdn有一<br>个很好的例子: <code>threshold</code>.<br>至于我们例子中为什么设置了0.5的比例，主要还是出于业务需要，因为在滚动屏幕过程中，当一个目标元素进入到视口时，如果没有达到50%的比例，则认为还没出现，则不对其头像进行赋值。trackVisibility设置为true，是因为我们有对元素是否可见进行一个判断的需要。回调函数中，我们对entries逐一进行处理，因为observer可以监测多个元素，所以entries是一个数组，需要逐一处理。</p></blockquote><ol start="2"><li> 回调函数的处理函数</li></ol><pre><code class="JS">function isIntersectHandler(entry) {  const target = entry.target;  const isIntersecting = entry.isIntersecting;  if (isIntersecting) {    const src = target.dataset.src;    const ele = target.getElementsByClassName('user-item-thump-icon')[0];    if (src &amp;&amp; entry.isVisible) {      const styleStr = `url(${src}), url("${defaultAvatar}")`;      ele.style.backgroundImage = styleStr;    } else {      ele.style.backgroundImage = '';    }  } else {    const ele = target.getElementsByClassName('user-item-thump-icon')[0];    ele &amp;&amp; (ele.style.backgroundImage = '');  }}</code></pre><blockquote><p>回调函数的处理函数中，我们对单个entry进行处理。首先我们判断元素是否相交（正常来说能触发这个函数的<br>都是已经相交了的），相交的时候则从目标元素的dataset中拿到头像url并判断是否可见，从而赋值到背景url, 以使得头像被渲染。当离开时，则对背景url进行置空操作，使得其不被渲染。</p></blockquote><ol start="3"><li> 开始观察元素</li></ol><pre><code class="JS">mounted() {  observer.observe(this.$refs.thump);}</code></pre><blockquote><p>开始监测后即可对元素的背景url进行自定义的操作了。</p></blockquote><ol start="4"><li> 停止观察元素</li></ol><pre><code class="JS">beforeDestroy() {  observer.unobserve(this.$refs.thump);}</code></pre><h3 id="几个注意点"><a href="#几个注意点" class="headerlink" title="几个注意点"></a>几个注意点</h3><p>虽然监测函数的执行是异步的，但是回调函数的执行是在主线程上。如果回调函数里面处理的逻辑比较复杂，则可能影响js线程的执行，此时建议采用 <code>window.requestIdleCallback</code> 。<br>对于目标元素的visible，受多个因素影响，如opacity, translation等属性都可能影响，具体可参考<a href="https://developers.google.com/web/updates/2019/02/intersectionobserver-v2">google</a>.</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的Blob</title>
      <link href="/My-Blogs/2021/01/08/JavaScript/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Blob/"/>
      <url>/My-Blogs/2021/01/08/JavaScript/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Blob/</url>
      
        <content type="html"><![CDATA[<p>如果你允许用户从你的网站上下载某些文件，那你可能会遇到 Blob 类型。为了实现上述的功能，你可以很容易从网上找到相关的示例，并根据实际需求进行适当的调整。对于部分开发者来说，在完成上述功能之后，他们并不会继续思考 Blob 是什么？</p><a id="more"></a><p>这就导致了一些开发者，还是停留在熟练使用 API 的层面，当遇到比较棘手的问题时，就束手无策。<strong>换句话说，如果当你在熟悉 API 的使用之后，还能继续多问几个为什么，继续探究下去，不仅能加深对知识的理解，还能触类旁通，拓展自己的知识面提高自己。</strong></p><p>好了，如果你想继续了解什么是 Blob，那么就跟上我的脚步，来一个 Blob Web API 探索之旅。还在犹豫什么，Let’s go！</p><p>读完本文你将了解到以下内容：</p><ul><li><p>Blob 是什么</p></li><li><p>Blob API 简介</p></li><li><p>构造函数</p></li><li><p>属性和方法</p></li><li><p>Blob 使用场景</p></li><li><p>分片上传</p></li><li><p>从互联网下载数据</p></li><li><p>Blob 用作 URL</p></li><li><p>Blob 转换为 Base64</p></li><li><p>图片压缩</p></li><li><p>生成 PDF</p></li><li><p>Blob 与 ArrayBuffer 的区别</p></li></ul><h3 id="一、Blob-是什么"><a href="#一、Blob-是什么" class="headerlink" title="一、Blob 是什么"></a><span style="display: none; "></span>一、Blob 是什么<span style="display: none; "></span></h3><p>Blob（Binary Large Object）表示二进制类型的大对象。在数据库管理系统中，将二进制数据存储为一个单一个体的集合。Blob 通常是影像、声音或多媒体文件。<strong>在 JavaScript 中 Blob 类型的对象表示不可变的类似文件对象的原始数据。</strong> 为了更直观的感受 Blob 对象，我们先来使用 Blob 构造函数，创建一个 myBlob 对象，具体如下图所示：</p><p><img src="/My-Blogs/images/blobInfo.webp"></p><p>如你所见，myBlob 对象含有两个属性：size 和 type。其中 <code>size</code> 属性用于表示数据的大小（以字节为单位）， <code>type</code> 是 MIME 类型的字符串。Blob 表示的不一定是 JavaScript 原生格式的数据。比如 <code>File</code> 接口基于 <code>Blob</code> ，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p><h3 id="二、Blob-API-简介"><a href="#二、Blob-API-简介" class="headerlink" title="二、Blob API 简介"></a><span style="display: none; "></span>二、Blob API 简介<span style="display: none; "></span></h3><p><code>Blob</code> 由一个可选的字符串 <code>type</code> （通常是 MIME 类型）和 <code>blobParts</code> 组成：</p><p><img src="/My-Blogs/images/blobInfo2.webp"></p><blockquote><p>MIME（Multipurpose Internet Mail Extensions）多用途互联网邮件扩展类型，是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。</p><p>常见的 MIME 类型有：超文本标记语言文本 .html text/html、PNG图像 .png image/png、普通文本 .txt text/plain 等。</p></blockquote><h4 id="2-1-构造函数"><a href="#2-1-构造函数" class="headerlink" title="2.1 构造函数"></a><span style="display: none; "></span>2.1 构造函数<span style="display: none; "></span></h4><p>Blob 构造函数的语法为：</p><pre><code class="js">var aBlob = new Blob(blobParts, options);</code></pre><p>相关的参数说明如下：</p><ul><li><p>blobParts：它是一个由 ArrayBuffer，ArrayBufferView，Blob，DOMString 等对象构成的数组。DOMStrings 会被编码为 UTF-8。</p></li><li><p>options：一个可选的对象，包含以下两个属性：</p></li><li><p>type —— 默认值为 <code>""</code>，它代表了将会被放入到 blob 中的数组内容的 MIME 类型。</p></li><li><p>endings —— 默认值为 <code>"transparent"</code>，用于指定包含行结束符 <code>\n</code> 的字符串如何被写入。它是以下两个值中的一个：<code>"native"</code>，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 <code>"transparent"</code>，代表会保持 blob 中保存的结束符不变。</p></li></ul><p><strong>示例一：从字符串创建 Blob</strong></p><pre><code class="js">let myBlobParts = ['&lt;html&gt;&lt;h2&gt;Hello&nbsp;Semlinker&lt;/h2&gt;&lt;/html&gt;']; //&nbsp;an&nbsp;array&nbsp;consisting&nbsp;of&nbsp;a&nbsp;single&nbsp;DOMStringlet myBlob = new Blob(myBlobParts, {    type: 'text/html',    endings: "transparent"}); //the&nbsp;blobconsole.log(myBlob.size + "&nbsp;bytes&nbsp;size"); //&nbsp;Output:&nbsp;37&nbsp;bytes&nbsp;sizeconsole.log(myBlob.type + "&nbsp;is&nbsp;the&nbsp;type"); //&nbsp;Output:&nbsp;text/html&nbsp;is&nbsp;the&nbsp;type</code></pre><p><strong>示例二：从类型化数组和字符串创建 Blob</strong></p><pre><code class="js">let hello = new Uint8Array([72, 101, 108, 108, 111]); //&nbsp;二进制格式的&nbsp;"hello"let blob = new Blob([hello, '&nbsp;', 'semlinker'], {    type: 'text/plain'});</code></pre><p>介绍完 Blob 构造函数，接下来我们来分别介绍 Blob 类的属性和方法：</p><p><img src="/My-Blogs/images/blobInfo3.webp"></p><h4 id="2-2-属性"><a href="#2-2-属性" class="headerlink" title="2.2 属性"></a><span style="display: none; "></span>2.2 属性<span style="display: none; "></span></h4><p>前面我们已经知道 Blob 对象包含两个属性：</p><ul><li><p>size（只读）：表示 <code>Blob</code> 对象中所包含数据的大小（以字节为单位）。</p></li><li><p>type（只读）：一个字符串，表明该 <code>Blob</code> 对象所包含数据的 MIME 类型。如果类型未知，则该值为空字符串。</p></li></ul><h4 id="2-3-方法"><a href="#2-3-方法" class="headerlink" title="2.3 方法"></a><span style="display: none; "></span>2.3 方法<span style="display: none; "></span></h4><ul><li><p>slice([start[, end[, contentType]]])：返回一个新的 Blob 对象，包含了源 Blob 对象中指定范围内的数据。</p></li><li><p>stream()：返回一个能读取 blob 内容的 <code>ReadableStream</code>。</p></li><li><p>text()：返回一个 Promise 对象且包含 blob 所有内容的 UTF-8 格式的 <code>USVString</code>。</p></li><li><p>arrayBuffer()：返回一个 Promise 对象且包含 blob 所有内容的二进制格式的 <code>ArrayBuffer</code>。</p></li></ul><p>这里我们需要注意的是，** <code>Blob</code> 对象是不可改变的**。我们不能直接在一个 Blob 中更改数据，但是我们可以对一个 Blob 进行分割，从其中创建新的 Blob 对象，将它们混合到一个新的 Blob 中。这种行为类似于 JavaScript 字符串：我们无法更改字符串中的字符，但可以创建新的更正后的字符串。</p><h3 id="三、Blob-使用场景"><a href="#三、Blob-使用场景" class="headerlink" title="三、Blob 使用场景"></a><span style="display: none; "></span>三、Blob 使用场景<span style="display: none; "></span></h3><h4 id="3-1-分片上传"><a href="#3-1-分片上传" class="headerlink" title="3.1 分片上传"></a><span style="display: none; "></span>3.1 分片上传<span style="display: none; "></span></h4><p>File 对象是特殊类型的 Blob，且可以用在任意的 Blob 类型的上下文中。所以针对大文件传输的场景，我们可以使用 slice 方法对大文件进行切割，然后分片进行上传，具体示例如下：</p><pre><code class="js">const file = new File(["a".repeat(1000000)], "test.txt");const chunkSize = 40000;const url = "https://httpbin.org/post";async function chunkedUpload() {    for (let start = 0; start &lt; file.size; start += chunkSize) {        const chunk = file.slice(start, start + chunkSize + 1);        const fd = new FormData();        fd.append("data", chunk);        await fetch(url, {            method: "post",            body: fd        }).then((res) =&gt; res.text());    }}</code></pre><h4 id="3-2-从互联网下载数据"><a href="#3-2-从互联网下载数据" class="headerlink" title="3.2 从互联网下载数据"></a><span style="display: none; "></span>3.2 从互联网下载数据<span style="display: none; "></span></h4><p>我们可以使用以下方法从互联网上下载数据并将数据存储到 Blob 对象中，比如：</p><pre><code class="js">const downloadBlob = (url, callback) =&gt; {    const xhr = new XMLHttpRequest()    xhr.open('GET', url)    xhr.responseType = 'blob'    xhr.onload = () =&gt; {        callback(xhr.response)    }    xhr.send(null)}</code></pre><p>当然除了使用 <code>XMLHttpRequest</code> API 之外，我们也可以使用 <code>fetch</code> API 来实现以流的方式获取二进制数据。这里我们来看一下如何使用 fetch API 获取线上图片并本地显示，具体实现如下：</p><pre><code class="js">const myImage = document.querySelector('img');const myRequest = new Request('flowers.jpg');fetch(myRequest)    .then(function(response) {        return response.blob();    })    .then(function(myBlob) {        let objectURL = URL.createObjectURL(myBlob);        myImage.src = objectURL;    });</code></pre><p>当 fetch 请求成功的时候，我们调用 response 对象的 <code>blob()</code> 方法，从 response 对象中读取一个 Blob 对象，然后使用 <code>createObjectURL()</code> 方法创建一个 objectURL，然后把它赋值给 <code>img</code> 元素的 <code>src</code> 属性从而显示这张图片。</p><h4 id="3-3-Blob-用作-URL"><a href="#3-3-Blob-用作-URL" class="headerlink" title="3.3 Blob 用作 URL"></a><span style="display: none; "></span>3.3 Blob 用作 URL<span style="display: none; "></span></h4><p>Blob 可以很容易的作为 <code>&lt;a&gt;</code> 、 <code>&lt;img&gt;</code> 或其他标签的 URL，多亏了 <code>type</code> 属性，我们也可以上传/下载 <code>Blob</code> 对象。下面我们将举一个 Blob 文件下载的示例，不过在看具体示例前我们得简单介绍一下 Blob URL。</p><p><strong>1. Blob URL/Object URL</strong></p><p>Blob URL/Object URL 是一种伪协议，允许 Blob 和 File 对象用作图像，下载二进制数据链接等的 URL 源。在浏览器中，我们使用 <code>URL.createObjectURL</code> 方法来创建 Blob URL，该方法接收一个 <code>Blob</code> 对象，并为其创建一个唯一的 URL，其形式为 <code>blob:&lt;origin&gt;/&lt;uuid&gt;</code> ，对应的示例如下：</p><pre><code class="html">blob:https://example.org/40a5fb5a-d56d-4a33-b4e2-0acf6a8e5f641</code></pre><p>浏览器内部为每个通过 <code>URL.createObjectURL</code> 生成的 URL 存储了一个 URL → Blob 映射。因此，此类 URL 较短，但可以访问 <code>Blob</code> 。生成的 URL 仅在当前文档打开的状态下才有效。它允许引用 <code>&lt;img&gt;</code> 、 <code>&lt;a&gt;</code> 中的 <code>Blob</code> ，但如果你访问的 Blob URL 不再存在，则会从浏览器中收到 404 错误。</p><p>上述的 Blob URL 看似很不错，但实际上它也有副作用。虽然存储了 URL → Blob 的映射，但 Blob 本身仍驻留在内存中，浏览器无法释放它。映射在文档卸载时自动清除，因此 Blob 对象随后被释放。</p><p>但是，如果应用程序寿命很长，那不会很快发生。因此，如果我们创建一个 Blob URL，即使不再需要该 Blob，它也会存在内存中。</p><p>针对这个问题，我们可以调用 <code>URL.revokeObjectURL(url)</code> 方法，从内部映射中删除引用，从而允许删除 Blob（如果没有其他引用），并释放内存。接下来，我们来看一下 Blob 文件下载的具体示例。</p><p><strong>2. Blob 文件下载示例</strong></p><p><strong>index.html</strong></p><pre><code class="html">&lt;!DOCTYPE&nbsp;html&gt;&lt;html&gt;&nbsp;&nbsp;&lt;head&gt;&nbsp;&nbsp;&nbsp;    &lt;meta&nbsp;charset="UTF-8"&nbsp; /&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;title&gt;Blob&nbsp;文件下载示例&lt;/title&gt;&nbsp;&nbsp;&lt;/head&gt;&nbsp;&nbsp;&lt;body&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;button&nbsp;id="downloadBtn"&gt;文件下载&lt;/button&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;script&nbsp;src="index.js"&gt;&lt;/script&gt;&nbsp;&nbsp;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>index.js</strong></p><pre><code class="js">const download = (fileName, blob) =&gt; {    const link = document.createElement("a");    link.href = URL.createObjectURL(blob);    link.download = fileName;    link.click();    link.remove();    URL.revokeObjectURL(link.href);};const downloadBtn = document.querySelector("#downloadBtn");downloadBtn.addEventListener("click", (event) =&gt; {    const fileName = "blob.txt";    const myBlob = new Blob(["一文彻底掌握&nbsp;Blob&nbsp;Web&nbsp;API"], {        type: "text/plain"    });    download(fileName, myBlob);});</code></pre><p>在示例中，我们通过调用 Blob 的构造函数来创建类型为 <strong>“text/plain”</strong> 的 Blob 对象，然后通过动态创建 <code>a</code> 标签来实现文件的下载。</p><h4 id="3-4-Blob-转换为-Base64"><a href="#3-4-Blob-转换为-Base64" class="headerlink" title="3.4 Blob 转换为 Base64"></a><span style="display: none; "></span>3.4 Blob 转换为 Base64<span style="display: none; "></span></h4><p><code>URL.createObjectURL</code> 的一个替代方法是，将 <code>Blob</code> 转换为 base64 编码的字符串。<strong>Base64</strong> 是一种基于 64 个可打印字符来表示二进制数据的表示方法，<strong>它常用于在处理文本数据的场合，表示、传输、存储一些二进制数据，包括 MIME 的电子邮件及 XML 的一些复杂数据。</strong></p><p>在 MIME 格式的电子邮件中，base64 可以用来将二进制的字节序列数据编码成 ASCII 字符序列构成的文本。使用时，在传输编码方式中指定 base64。使用的字符包括大小写拉丁字母各 26 个、数字 10 个、加号 + 和斜杠 /，共 64 个字符，等号 = 用来作为后缀用途。</p><p>下面我们来介绍如何在 HTML 中嵌入 base64 编码的图片。在编写 HTML 网页时，对于一些简单图片，通常会选择将图片内容直接内嵌在网页中，从而减少不必要的网络请求，但是图片数据是二进制数据，该怎么嵌入呢？绝大多数现代浏览器都支持一种名为 <code>Data URLs</code> 的特性，允许使用 base64 对图片或其他文件的二进制数据进行编码，将其作为文本字符串嵌入网页中。</p><p>Data URLs 由四个部分组成：前缀（ <code>data:</code> ）、指示数据类型的 MIME 类型、如果非文本则为可选的 <code>base64</code> 标记、数据本身：</p><pre><code class="html">data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</code></pre><p><code>mediatype</code> 是个 MIME 类型的字符串，例如 “ <code>image/jpeg</code> “ 表示 JPEG 图像文件。如果被省略，则默认值为 <code>text/plain;charset=US-ASCII</code> 。如果数据是文本类型，你可以直接将文本嵌入（根据文档类型，使用合适的实体字符或转义字符）。如果是二进制数据，你可以将数据进行 base64 编码之后再进行嵌入。比如嵌入一张图片：</p><pre><code class="html">&lt;img&nbsp;alt="logo"&nbsp;src="data:image /png;base64,iVBORw0KGgoAAAANSUhEUg..."&gt;</code></pre><p><strong>但需要注意的是：如果图片较大，图片的色彩层次比较丰富，则不适合使用这种方式，因为该图片经过 base64 编码后的字符串非常大，会明显增大 HTML 页面的大小，从而影响加载速度。</strong> 除此之外，利用 FileReader API，我们也可以方便的实现图片本地预览功能，具体代码如下：</p><pre><code class="html">&lt;input&nbsp;type="file"&nbsp;accept="image /*"&nbsp;onchange="loadFile(event)"&gt;&lt;img&nbsp;id="output" /&gt;&lt;script&gt;    const loadFile = function(event) {        const reader = new FileReader();        reader.onload = function() {            const output = document.querySelector('output');            output.src = reader.result;        };        reader.readAsDataURL(event.target.files[0]);    };&lt;/script&gt;</code></pre><p>在以上示例中，我们为 file 类型输入框绑定 <code>onchange</code> 事件处理函数 <code>loadFile</code> ，在该函数中，我们创建了一个 FileReader 对象并为该对象绑定 <code>onload</code> 相应的事件处理函数，然后调用 FileReader 对象的 <code>readAsDataURL()</code> 方法，把本地图片对应的 File 对象转换为 Data URL。</p><p>在完成本地图片预览之后，我们可以直接把图片对应的 Data URLs 数据提交到服务器。针对这种情形，服务端需要做一些相关处理，才能正常保存上传的图片，这里以 Express 为例，具体处理代码如下：</p><pre><code class="js">const app = require('express')();app.post('/upload', function(req, res) {    let imgData = req.body.imgData; //&nbsp;获取POST请求中的base64图片数据&nbsp;&nbsp;&nbsp;&nbsp;    let base64Data = imgData.replace(/^data:image\/\w+;base64,/, "");    let dataBuffer = Buffer.from(base64Data, 'base64');    fs.writeFile("image.png", dataBuffer, function(err) {        if (err) {            res.send(err);        } else {            res.send("图片上传成功！");        }    });});</code></pre><p>对于 FileReader 对象来说，除了支持把 Blob/File 对象转换为 Data URL 之外，它还提供了 <code>readAsArrayBuffer()</code> 和 <code>readAsText()</code> 方法，用于把 Blob/File 对象转换为其它的数据格式。这里我们来看个 <code>readAsArrayBuffer()</code> 的使用示例：</p><pre><code class="js">//&nbsp;从&nbsp;blob&nbsp;获取&nbsp;arrayBufferlet fileReader = new FileReader();fileReader.onload = function(event) {    let arrayBuffer = fileReader.result;};fileReader.readAsArrayBuffer(blob);</code></pre><h4 id="3-5-图片压缩"><a href="#3-5-图片压缩" class="headerlink" title="3.5 图片压缩"></a><span style="display: none; "></span>3.5 图片压缩<span style="display: none; "></span></h4><p>在一些场合中，我们希望在上传本地图片时，先对图片进行一定的压缩，然后再提交到服务器，从而减少传输的数据量。在前端要实现图片压缩，我们可以利用 Canvas 对象提供的 <code>toDataURL()</code> 方法，该方法接收 <code>type</code> 和 <code>encoderOptions</code> 两个可选参数。</p><p>其中 <code>type</code> 表示图片格式，默认为 <code>image/png</code> 。而 <code>encoderOptions</code> 用于表示图片的质量，在指定图片格式为 <code>image/jpeg</code> 或 <code>image/webp</code> 的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 <code>0.92</code> ，其他参数会被忽略。</p><p>下面我们来看一下具体如何实现图片压缩：</p><pre><code class="js">//&nbsp;compress.jsconst MAX_WIDTH = 800; //&nbsp;图片最大宽度function compress(base64, quality, mimeType) {    let canvas = document.createElement("canvas");    let img = document.createElement("img");    img.crossOrigin = "anonymous";    return new Promise((resolve, reject) =&gt; {        img.src = base64;        img.onload = () =&gt; {            let targetWidth, targetHeight;            if (img.width &gt; MAX_WIDTH) {                targetWidth = MAX_WIDTH;                targetHeight = (img.height * MAX_WIDTH) / img.width;            } else {                targetWidth = img.width;                targetHeight = img.height;            }            canvas.width = targetWidth;            canvas.height = targetHeight;            let ctx = canvas.getContext("2d");            ctx.clearRect(0, 0, targetWidth, targetHeight); //&nbsp;清除画布&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);            let imageData = canvas.toDataURL(mimeType, quality / 100);            resolve(imageData);        };    });}</code></pre><p>对于返回的 Data URL 格式的图片数据，为了进一步减少传输的数据量，我们可以把它转换为 Blob 对象：</p><pre><code class="js">function dataUrlToBlob(base64, mimeType) {    let bytes = window.atob(base64.split(",")[1]);    let ab = new ArrayBuffer(bytes.length);    let ia = new Uint8Array(ab);    for (let i = 0; i &lt; bytes.length; i++) {        ia[i] = bytes.charCodeAt(i);    }    return new Blob([ia], {        type: mimeType    });}</code></pre><p>在转换完成后，我们就可以压缩后的图片对应的 Blob 对象封装在 FormData 对象中，然后再通过 AJAX 提交到服务器上：</p><pre><code class="js">function uploadFile(url, blob) {    let formData = new FormData();    let request = new XMLHttpRequest();    formData.append("image", blob);    request.open("POST", url, true);    request.send(formData);}</code></pre><p>其实 Canvas 对象除了提供 <code>toDataURL()</code> 方法之外，它还提供了一个 <code>toBlob()</code> 方法，该方法的语法如下：</p><blockquote><p>canvas.toBlob(callback, mimeType, qualityArgument)</p></blockquote><p>和 <code>toDataURL()</code> 方法相比， <code>toBlob()</code> 方法是异步的，因此多了个 <code>callback</code> 参数，这个 <code>callback</code> 回调方法默认的第一个参数就是转换好的 <code>blob</code> 文件信息。</p><p>介绍完上述的内容，我们来看一下本地图片压缩完整的示例：</p><pre><code class="html">&lt;!DOCTYPE&nbsp;html&gt;&lt;html&gt;&nbsp;&nbsp;&lt;head&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;meta&nbsp;charset="UTF-8"&nbsp; /&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;meta&nbsp;name="viewport"&nbsp;content="width=device-width,&nbsp;initial-scale=1.0"&nbsp; /&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;title&gt;本地图片压缩&lt;/title&gt;&nbsp;&nbsp;&lt;/head&gt;&nbsp;&nbsp;&lt;body&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;input&nbsp;type="file"&nbsp;accept="image /*"&nbsp;onchange="loadFile(event)" &nbsp; /&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;script&nbsp;src=". /compress.js"&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;script&gt;        const loadFile = function(event) {            const reader = new FileReader();            reader.onload = async function() {                let compressedDataURL = await compress(                    reader.result,                    90,                    "image/jpeg"                );                let compressedImageBlob = dataUrlToBlob(compressedDataURL);                uploadFile("https://httpbin.org/post", compressedImageBlob);            };            reader.readAsDataURL(event.target.files[0]);        };    &lt;/script&gt;&nbsp;&nbsp;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="3-6-生成-PDF-文档"><a href="#3-6-生成-PDF-文档" class="headerlink" title="3.6 生成 PDF 文档"></a><span style="display: none; "></span>3.6 生成 PDF 文档<span style="display: none; "></span></h4><p>PDF（便携式文件格式，Portable Document Format）是由 Adobe Systems 在 1993 年用于文件交换所发展出的文件格式。在浏览器端，利用一些现成的开源库，比如 jsPDF，我们也可以方便地生成 PDF 文档。</p><pre><code class="html">&lt;!DOCTYPE&nbsp;html&gt;&lt;html&gt;&nbsp;&nbsp;&lt;head&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;meta&nbsp;charset="UTF-8"&nbsp; /&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;meta&nbsp;name="viewport"&nbsp;content="width=device-width,&nbsp;initial-scale=1.0"&nbsp; /&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;title&gt;客户端生成&nbsp;PDF&nbsp;示例&lt;/title&gt;&nbsp;&nbsp;&lt;/head&gt;&nbsp;&nbsp;&lt;body&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;h3&gt;客户端生成&nbsp;PDF&nbsp;示例&lt;/h3&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;script&nbsp;src="https: //unpkg.com/jspdf@latest/dist/jspdf.min.js"&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;    &lt;script&gt;        (function generatePdf() {            const doc = new jsPDF();            doc.text("Hello&nbsp;semlinker!", 66, 88);            const blob = new Blob([doc.output()], {                type: "application/pdf"            });            blob.text().then((blobAsText) =&gt; {                console.log(blobAsText);            });        })();    &lt;/script&gt;&nbsp;&nbsp;&lt;/body&gt;&lt;/html&gt;</code></pre><p>在以上示例中，我们首先创建 PDF 文档对象，然后调用该对象上的 <code>text()</code> 方法在指定的坐标点上添加 <code>Hello semlinker!</code> 文本，然后我们利用生成的 PDF 内容来创建对应的 Blob 对象，需要注意的是我们设置 Blob 的类型为 <code>application/pdf</code> ，最后我们把 Blob 对象中保存的内容转换为文本并输出到控制台。由于内容较多，这里我们只列出少部分输出结果：</p><pre><code class="js">% PDF - 1.3 % ºß¬ à3 0 obj &lt;&lt; /Type&nbsp;/Page / Parent 1 0 R / Resources 2 0 R / MediaBox[0 0 595.28 841.89] / Contents 4 0 R &gt;&gt; endobj....</code></pre><p>其实 jsPDF 除了支持纯文本之外，它也可以生成带图片的 PDF 文档，比如：</p><pre><code class="js">let imgData = 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/...';let doc = new jsPDF();doc.setFontSize(40);doc.text(35, 25, 'Paranyan&nbsp;loves&nbsp;jsPDF');doc.addImage(imgData, 'JPEG', 15, 40, 180, 160);</code></pre><p>Blob 的应用场景还很多，这里我们就不一一列举了，感兴趣的小伙伴可以自行查阅相关资料。</p><h3 id="四、Blob-与-ArrayBuffer-的区别"><a href="#四、Blob-与-ArrayBuffer-的区别" class="headerlink" title="四、Blob 与 ArrayBuffer 的区别"></a><span style="display: none; "></span>四、Blob 与 ArrayBuffer 的区别<span style="display: none; "></span></h3><p><strong>ArrayBuffer</strong> 对象用于表示通用的，固定长度的原始二进制数据缓冲区。你不能直接操纵 ArrayBuffer 的内容，而是需要创建一个类型化数组对象或 DataView 对象，该对象以特定格式表示缓冲区，并使用该对象读取和写入缓冲区的内容。</p><p><strong>Blob</strong> 类型的对象表示不可变的类似文件对象的原始数据。Blob 表示的不一定是 JavaScript 原生格式的数据。File 接口基于 Blob，继承了Blob 功能并将其扩展为支持用户系统上的文件。</p><h4 id="4-1-Blob-vs-ArrayBuffer"><a href="#4-1-Blob-vs-ArrayBuffer" class="headerlink" title="4.1 Blob vs ArrayBuffer"></a><span style="display: none; "></span>4.1 Blob vs ArrayBuffer<span style="display: none; "></span></h4><ul><li><p>除非你需要使用 ArrayBuffer 提供的写入/编辑的能力，否则 Blob 格式可能是最好的。</p></li><li><p>Blob 对象是不可变的，而 ArrayBuffer 是可以通过 TypedArrays 或 DataView 来操作。</p></li><li><p>ArrayBuffer 是存在内存中的，可以直接操作。而 Blob 可以位于磁盘、高速缓存内存和其他不可用的位置。</p></li><li><p>虽然 Blob 可以直接作为参数传递给其他函数，比如 <code>window.URL.createObjectURL()</code>。但是，你可能仍需要 FileReader 之类的 File API 才能与 Blob 一起使用。</p></li><li><p>Blob 与 ArrayBuffer 对象之间是可以相互转化的：</p></li><li><p>使用 FileReader 的 <code>readAsArrayBuffer()</code> 方法，可以把 Blob 对象转换为 ArrayBuffer 对象；</p></li><li><p>使用 Blob 构造函数，如 <code>new Blob([new Uint8Array(data]);</code>，可以把 ArrayBuffer 对象转换为 Blob 对象。</p></li></ul><p>对于 HTTP 的场景，比如在 AJAX 场景下，<strong>Blob</strong> 和 <strong>ArrayBuffer</strong> 可以通过以下方式来使用：</p><pre><code class="js">function GET(url, callback) {    let xhr = new XMLHttpRequest();    xhr.open('GET', url, true);    xhr.responseType = 'arraybuffer'; //&nbsp;or&nbsp;xhr.responseType&nbsp;=&nbsp;"blob";&nbsp;&nbsp;    xhr.send();    xhr.onload = function(e) {            if (xhr.status != 200) {                alert("Unexpected&nbsp;status&nbsp;code&nbsp;" + xhr.status + "&nbsp;for&nbsp;" + url);                return false;            }            callback(new Uint8Array(xhr.response)); //&nbsp;or&nbsp;new&nbsp;Blob([xhr.response]);&nbsp;&nbsp;};}</code></pre><p>对于 <strong>ArrayBuffer</strong> 和 <strong>Uint8Array</strong> 感兴趣的读者，可以阅读<a href="http://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;mid=2247484317&amp;idx=1&amp;sn=c0b397b6bd5fdfced0c1bebc187a7c0d&amp;chksm=ea47a2c5dd302bd37b285f65dd7a92df8ca1bc213465091e82a28be08ec5808b905e9fb69bec&amp;scene=21#wechat_redirect"><strong>Deno bytes 模块全解析</strong></a>这篇文章。</p><p>了解完上述的内容，相信有的读者可能会觉得意犹未尽。那么，对于 Blob 来说还有哪些内容可以继续深入学习的呢？本人下一步的计划是基于 Deno 的源码，来逐步分析 DenoBlob 的具体实现。当然也会顺便分析一下 <code>URL.createObjectURL()</code> 方法和 <code>revokeObjectURL()</code> 方法的实现。  </p><h3 id="五、参考资源"><a href="#五、参考资源" class="headerlink" title="五、参考资源"></a><span style="display: none; "></span>五、参考资源<span style="display: none; "></span></h3><ul><li><p>MDN - Blob</p></li><li><p>MDN - Data URLs</p></li><li><p>javascript.info - blob</p></li><li><p>flaviocopes - blob</p></li><li><p>arraybuffer-vs-blob</p></li><li><p>javascript-interview-question-what-is-a-blob</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Blob </tag>
            
            <tag> 二进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript模块化演进及原理浅析</title>
      <link href="/My-Blogs/2021/01/08/JavaScript/javascript%E6%A8%A1%E5%9D%97%E5%8C%96%E6%BC%94%E8%BF%9B%E5%8F%8A%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
      <url>/My-Blogs/2021/01/08/JavaScript/javascript%E6%A8%A1%E5%9D%97%E5%8C%96%E6%BC%94%E8%BF%9B%E5%8F%8A%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="模块化解决了什么问题"><a href="#模块化解决了什么问题" class="headerlink" title="模块化解决了什么问题"></a>模块化解决了什么问题</h3><a id="more"></a><p>我们仔细想一下，Javascript编程其实很多时候就是管理变量以及变量赋值这件事，比如把一个value赋值给一个变量，给一个变量加上一个value，或者把两个变量相加的结果赋值给另外一个变量，怎样去管理这些变量对日后如何维护这些代码就显得至关重要。</p><p>在开发中如果我们一次仅需要考虑几个变量，那么工作就会变得很简单。幸运的是，JavsScript有个作用域链来帮助我们解决变量过多的问题，因为作用域链的存在，在一个函数的内部无法访问另外一个函数内部的变量，这样就使得我们在编程的时候只需要关注自己函数内部的那几个变量就可以了，不需要过分去担心其他函数的影响，头发也可以少掉几根。</p><p>但是，很多时候我们不得不跟其他函数共享状态，这时候我们会将这些变量存储在全局（window/global）上，项目小的时候当然问题不大，但是当项目一大，变量一多，通过script引入代码的加载顺序等等问题就开始让后期维护变得很蛋疼，因此人们开始思考如何在没有模块的语言上去实现模块这一件事情。。。</p><h3 id="原始时期"><a href="#原始时期" class="headerlink" title="原始时期"></a>原始时期</h3><h4 id="直接定义依赖"><a href="#直接定义依赖" class="headerlink" title="直接定义依赖"></a>直接定义依赖</h4><pre><code class="js">function a() {}function b() {}</code></pre><p>在原始时期，“模块化”也就是直接定义函数，共享变量，这种做法最明显的缺点就是<strong>污染</strong>了全局变量，变量的重名会导致后面覆盖前面，并且各个模块成员之间看不出有什么直接的关系。</p><h4 id="闭包模块化"><a href="#闭包模块化" class="headerlink" title="闭包模块化"></a>闭包模块化</h4><pre><code class="js">var modules = (fuction(my, $) {    function privateMethod() {        // ...    }    my.moduleProperty = 1;    my.moduleMethod = function() {        //$()....        //privateMethod()...        // ...    };    return my;}(widnow.modules || {}, jQuery))</code></pre><p>通过立即执行函数（IIFE），外部函数无法调用到里面的<strong>privateMethod</strong>，解决了全局变量污染的问题。同时这种模式还可以将一个模块拆分，在闭包内可以调用或继承其他子模块、添加新的方法，新的变量，返回新的模块。但是同时缺点也很明显：</p><ul><li>  为了在模块内部调用其他全局变量，必须<strong>显示注入全局变量</strong>，比如上面注入了jQuery</li><li>  跨文件使用模块时，需要将模块挂载到全局变量上（window）上</li><li>  没有解决如何管理这些模块的问题，各个模块之间的依赖关系需要通过script的引入顺序来保证</li></ul><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>从1999年开始，js模块化的探索都是基于语言层面上的优化，真正的改变要从2009年CommonJS的引入开始，Node采用CommonJS模块规范，每个文件就是一个模块，有自己的作用域，在一个文件里面定义的变量、函数、类都是私有了。</p><pre><code class="js">// package/lib is a dependency we requireconst lib = require('package/lib');// some behaviour for our modulefunction foo() {    lib.log('hello world!');}// export (expose) foo to other modulesexports.foo = foo;</code></pre><h4 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h4><ul><li>  module模块本身，是Module的一个实例</li><li>  exports指向module.exports，可以通过exports向module.exports对象中添加变量</li><li>  require用于加载模块（核心）</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>  所有模块都运行在模块作用域，不会污染全局作用域</li><li>  模块加载的顺序，按照代码中出现的顺序执行（也就是同步）</li><li>  模块输入的值是复制（基础类型为复制，引用类型为值引用），第一次加载结果就被缓存了，之后再加载就直接读取缓存中的结果，如果要让模块再次运行，需要清除缓存。或者直接导出函数，每次调用函数重新计算。</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>由于篇幅有限，这里不讨论require的加载选择路径优先级的判断，也不讨论模块缓存的过程，并假定加载的文件都是js文件，主要实现代码如下<a href="https://github.com/joyent/node/blob/master/lib/module.js">源代码</a></p><pre><code class="js">function Module(id, parent) {    this.id = id;    this.expotrs = {};    this.parent = parent;    if (parent &amp;&amp; parent.children) {        parent.children.push(this);    }    this.fileanme = null;    this.loaded = false;    this.children = [];}// 这里的module是全局变量module.exports = Module;// 通过一个path加载模块，并返回exports属性Module.prototype.require = function(path) {    return Module._load(path, this);}Module._load = function(path, parent) {    const filename = path;    var module = new Module(filename, parent);    // 加载模块    module.load(filename);    // 输出模块的exports属性    return module.exports;}Module.prototype.load = function(filename) {    // 通过磁盘中读取文件    var content = fs.readFileSync(filename, 'utf8');    module._compile(content, filename);    this.loaded = true;}// 模块编译Module.prototype._compile = function(content, filename) {    const self = this;    const args = [self.exports, require, self, filename, dirname];    // 在沙箱中执行代码    return compiledWrapper.apply(self.exports, args);}</code></pre><p>从代码中可以看出，模块加载实质上就是注入了exports，require，module三个全局变量，然后执行模块的源码，最后将模块的exports的变量输入</p><pre><code class="js">(function(exports, require, module, __filename, __dirname) {    // 模块源码});</code></pre><h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><ul><li>  缺少模块封装的能力，CommonJS规范中每个模块都是一个文件，这意味着每个文件只有一个模块。这在服务器上是可行的，但是在浏览器中就不是很友好，浏览器中需要做到尽可能少的发起请求。</li><li>  使用同步的方式加载依赖，在浏览器中由于JS的加载会阻塞渲染，同步加载会导致长时间的白屏，对于用户体验是致命的。</li><li>  CommonJS规范中使用了<strong>export</strong>的对象来暴露模块，可以讲需要导出的变量附加到<strong>export</strong>上，但是要导出一个函数确是能使用<strong>module.export</strong>，这种语法容易让人感到困惑。</li></ul><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>AMD，全称是Asynchronous Module Definition，即异步模块加载机制，它采用异步方式加载模块，模块的加载不影响后面语句的运行，AMD规范定义了一个<strong>define</strong>全局方法用来定义和加载模块</p><pre><code class="js">define(id ? , dependencies ? , factory);</code></pre><ul><li>  id: 模块标识，可以省略</li><li>  dependences：所依赖的模块数组，可以省略</li><li>  factory：模块的实现，或者一个对象</li></ul><p>AMD也使用了使用<strong>require</strong>全局方法来加载模块，但不同于CommonJS，它要求两个参数，dependences是需要前置的依赖，只有所有前置依赖都加载完了才会触发回调函数，dependences的加载是<strong>通过动态创建sciprt和事件监听的方式来异步加载模块</strong>，解决了CommonJS同步加载的问题。</p><pre><code class="js">require([dependence], callback);</code></pre><h4 id="RequireJS使用"><a href="#RequireJS使用" class="headerlink" title="RequireJS使用"></a>RequireJS使用</h4><p>RequireJS 是 AMD 规范的代表之作，基本使用方式如下</p><pre><code class="js">define(['./a', './b'], function(moduleA, moduleB) {    // 依赖前置    moduleA.mehodA();    console.log(moduleB.dataB);    // 导出数据    return {};});</code></pre><h4 id="RequireJS的实现"><a href="#RequireJS的实现" class="headerlink" title="RequireJS的实现"></a>RequireJS的实现</h4><p>这里同样不讨论RequireJS的模块信息配置，缓存的过程，也不考虑各种链接补全的情况，只是简单实现模块的加载调用，以及所有依赖加载完毕触发callback回调的过程</p><blockquote><p>依赖的定义</p></blockquote><pre><code class="js">// 缓存定义的模块const defMap = {}define = (name, deps, callback) =&gt; {    defMap[name] = {        name,        deps,        callback    }}</code></pre><blockquote><p>依赖模块加载与调用</p></blockquote><p>模块加载的时候会首先通过<strong>Modules</strong>构造函数创建一个模块实例，然后调用初始化<strong>init</strong>的方法传入需要加载的依赖跟回调函数</p><pre><code class="js">// 全局require方法req = require = (name, deps, callback) =&gt; {    const mod = new Module(name)    mod.init(deps, callback)}// 模块加载构造函数class Modules {    constructor(name) {        this.name = name        this.depCount = 0        this.deps = []        this.depExports = []        this.callback = null        this.defineFn = () =&gt; {}    }    init(deps, callback) {        this.deps = deps        this.callback = callback        // 判断是否有依赖，有依赖先加载依赖        if (deps.length === 0) {            this.check()        } else {            this.enable()        }    }}</code></pre><p>其中<strong>enable</strong>函数用来遍历依赖，并绑定回调函数<strong>definedFn</strong></p><pre><code class="js">class Module {    ...    // 加载依赖    enabne() {        this.deps.forEach((name, i) =&gt; {            // 记录加载的模块数            this.depCount++            // 实例化依赖模块，绑定回调            const mod = new Module(name)            mod.definedFn = exports =&gt; {                this.depCount--                // 返回的代码，将模块代码存储起来，全部加载完毕后当作变量传递给父模块调用                this.depExports[i] = exports                // 每次返回一个回调都check一下是否所有依赖都加载完了                this.check()            }            // 通过script加载模块            loadModule(name)        })    }}</code></pre><p><strong>loadModule</strong>是源码的核心，通过动态创建scirpt异步加载依赖，加载完之后再循环加载子模块的依赖，直到全部依赖都加载完毕。</p><pre><code class="js">const loadModule = (name, url) =&gt; {    const head = document.getElementsByTagName('head')[0]    const node = document.createElement('script')    node.type = 'text/javascript'    node.async = true    // 设置一个 data 属性，便于依赖加载完毕后拿到模块名     node.setAttribute('data-module', name)    node.addEventListener('load', onScriptLoad, false)    node.src = url    head.appendChild(node)    return node}// 节点绑定的onload事件函数const onScriptLoad = evt =&gt; {    const node = evt.currentTarget    node.removeEventListener('load', onScriptLoad, false)    // 获取模块名    const name = node.getAttribute('data-module')    // 实例化子模块    const mod = new Module(name)    // 从全局变量defMap中获取模块的依赖和回调    const def = defMap[name]    // 循环加载子模块的依赖    mod.init(def.deps, def.callback)}</code></pre><p><strong>check</strong>函数检查依赖是否全部加载完毕了，加载完毕之后执行回调函数。</p><pre><code class="js">class Module {    ...    // 检查依赖是否加载完毕    check() {        // 依赖数小于1，表示依赖全部加载完        if (this.depCount &lt; 1) {            // 触发回调函数，并获取该模块的内容            this.exports = this.callback.apply(null, this.depExports)            // 激活defined回调，表示当前模块加载完成            this.definedFn(exports)        }    }}</code></pre><p>可以看出，RequireJS最核心的原理就是<strong>通过动态加载script并且监听load事件的方式来实现异步加载模块</strong></p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><blockquote><p>概述</p></blockquote><p>相对于AMD的异步加载，CMD更倾向于懒加载，而且CMD的写法跟CommonJS极为相近，只需要在CommonJS外增加一个函数调用即可，如下</p><pre><code class="js">// CMDdefine(function(require, exports, module) {    const $ = require('Jquery')    $('id')})</code></pre><p>AMD规范的代表作品sea.js在模块加载方式上与RequireJS的原理一致，都是<strong>通过动态加载script并且监听load事件的方式来实现异步加载模块</strong>，跟RequireJS的主要区别在与依赖声明跟加载的时机，其中RequireJS在声明的时候先优先加载了。sea.js则使用懒加载，按需加载的方式，只有在require的地方，才会真正加载运行该模块。</p><blockquote><p>sea.js实现原理</p></blockquote><p>sea.js看起来像是很神奇，JS不是异步的吗？但怎么sea.js调用模块看起来像是同步的？原理这里采用了知乎的一段回答<a href="https://www.zhihu.com/question/20342350/answer/14828786">卢勃</a></p><ol><li> 通过回调函数的Function.toString函数，使用正则表达式（后面改成了状态机进行词法分析的方式）来捕捉内部的require字段，找到require(‘jquery’)内部依赖的模块jquery</li><li> 根据配置文件，找到jquery的js文件的实际路径</li><li> 在dom中插入script标签，载入模块指定的js，绑定加载完成的事件，使得加载完成后将js文件绑定到require模块指定的id（这里就是jquery这个字符串）上</li><li> 回调函数内部依赖的js全部加载（暂不调用）完后，调用回调函数</li><li> 当回调函数调用require(‘jquery’)，即执行绑定在’jquery’这个id上的js文件，即刻执行，并将返回值传给$</li></ol><h3 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h3><p>UMD（Universal Module Definnition）通用模块定义模式，主要用来解决CommonJS模式和AMD模式代码不能在服务端跟Web端通用的问题，并同时还支持老式的全局变量规范。</p><pre><code class="js">(function(global, factory) {    typeof exports === 'object' &amp;&amp; typeof module !== 'undefined' ? module.exports = factory() :        typeof define === 'function' &amp;&amp; define.amd ? define(factory) :        (global = global || self, global.myBundle = factory());}(this, (function() {    const main = () =&gt; {        return 'hello world';    };    return main;})))</code></pre><p>上面代码做了3个判断</p><ol><li> 判断<strong>module</strong>是否为一个对象，并且是否存在<strong>module.exports</strong>来判断是否为<strong>CommonJS</strong>规范</li><li> 判断<strong>define</strong>是否为函数，并且是否存在<strong>define.amd</strong>，来判断是否为AMD规范</li><li> 如果以上两种都没有，则为原始的代码规范</li></ol><h3 id="ES-Modules"><a href="#ES-Modules" class="headerlink" title="ES Modules"></a>ES Modules</h3><h4 id="概述跟语法"><a href="#概述跟语法" class="headerlink" title="概述跟语法"></a>概述跟语法</h4><p>相对于CommonJS和AMD两种比较流行的社区模块加载方案，前者主要用于服务器层面，后者主要用于浏览器层面，ES 2015终于在语言标准层面上，实现了模块功能，而且语法更加简洁，更加人性化。</p><p>模块导出只有一个关键字<strong>export</strong>，可以直接导出变量，函数，或者通过大括号直接输出一组变量，更有独特的<strong>default</strong>可以用来直接导出默认值。</p><pre><code class="js">// moduleA// 直接导出某个变量跟函数export const name = 'chen'export function getName() {    return 'chen'}// 可以通过大括号输出一组变量const anotherName = 'nomad'constfunction getAnotherName() {    return 'nomad'}export {    anotherName,    getAnotherName}// 也可以直接导出默认值export default anotherName</code></pre><p>模块导入可以通过<strong>import</strong>命令加载其他JS文件中<strong>export</strong>的变量，同样可以同时导入其他文件中的默认值<strong>default</strong>（如果存在）跟其他变量</p><pre><code class="js">import defaultName, {    name,    getName,    anotherName,    getAnotherName} from './moduleA'</code></pre><p>具体语法包括导入变量的改名，导入并同时导出的复合写法等就不再赘述，具体可以查看网上的教程。</p><h4 id="CommonJS跟ES-Modules的差异"><a href="#CommonJS跟ES-Modules的差异" class="headerlink" title="CommonJS跟ES Modules的差异"></a>CommonJS跟ES Modules的差异</h4><p>CommonJS模块的<strong>require</strong>是同步加载模块，而ESM 会对静态代码分析，即在代码编译时进行模块的加载，在运行时之前就已经确定了依赖关系（可解决循环引用的问题，后面原理部分有解释）</p><p>CommonJS模块输入的是值拷贝（基础类型为复制，引用类型为值引用）</p><pre><code class="js">// CommonJS// ModuleAconst obj = {    a: 1}let b = 1setTimeout(() =&gt; {    obj.a++    b++});exports.obj = obj;exports.b = b;// ModuleBconst {    obj,    b} = require('./moduleA');console.log(`a: ${obj.a}`);console.log(`b: ${b}`);setTimeout(() =&gt; {    console.log(`a: ${obj.a}`);    console.log(`b: ${b}`);}, 100);// result// a: 1// b: 1// a: 2// b: 1</code></pre><p>ESM模块是动态引用，变量不会被缓存，而是成为一个指向加载模块的引用，只有真正取值的时候才会进行计算取值</p><pre><code class="js">// ESM// moduleAconst obj = {    a: 1}let b = 1setTimeout(() =&gt; {    obj.a++    b++});export {    obj,    b}// moduleBimport {    obj,    b} from './moduleA.mjs';console.log(`a: ${obj.a}`);console.log(`b: ${b}`);setTimeout(() =&gt; {    console.log(`a: ${obj.a}`);    console.log(`b: ${b}`);}, 100);// result// a: 1// b: 1// a: 2// b: 2</code></pre><h4 id="ESM加载的过程"><a href="#ESM加载的过程" class="headerlink" title="ESM加载的过程"></a>ESM加载的过程</h4><ol><li> 构造（Construction）：找到文件下载，并解析成模块记录（module record）</li><li> 实例化（Instantiation）：把所有<strong>export</strong>的变量放入到内存中（暂时不求值），然后把相关<strong>export</strong>跟<strong>import</strong>都指向同一个内存区域</li><li> 求值（Evaluation）：运行代码，把得到值放到指向的内存区域</li></ol><blockquote><p>构造（Construction）</p></blockquote><p>从入口文件开始，并通过代码解析（module specifiers）找到入口文件所依赖的模块，一步一步找到其他模块，并将所有模块解析成模块记录（module record），并缓存到<strong>module map</strong>中，遇到不同文件获取相同依赖，都会直接在<strong>module map</strong>缓存中获取，注意这里并不是要把所有模块的依赖关系全部解析完再开始下一步，因为浏览器一次性下载这么多文件会跟CommonJS一样阻塞主线程。所以这也就是为什么<strong>ESM spec</strong>要把3个加载过程区分开执行的原因。</p><p><img src="/My-Blogs/images/module_record.png" alt="image"></p><blockquote><p>实例化（Instantiation）</p></blockquote><p>实例化的过程就是将代码导出的变量一一指向内存。JS引擎通过<strong>优先深度后序遍历</strong>遍历整个模块关系图，即从依赖关系的最后一个模块（没有引入其他模块）开始实例化，并将所有模块导出的变量绑定在内存上，然后再将<strong>所有模块导入变量绑定到与导出变量同一个内存区域</strong>。所以一旦导出值发生变化，导入值也会变化。这也是ESM导出的是<strong>值引用</strong>的原理。同样也<strong>解决了循环调用</strong>的问题，为什么CommonJS无法解决循环调用的详细解释请查看<a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/">图解ES Modules</a></p><p><img src="/My-Blogs/images/module_bindings.png" alt="image"></p><blockquote><p>求值（Evaluation）</p></blockquote><p>求值步骤相对简单，只要运行代码把计算出来的值填入之前记录的内存地址就可以了，这里就不展开说明了。</p><h4 id="附录：参考-翻译"><a href="#附录：参考-翻译" class="headerlink" title="附录：参考/翻译"></a>附录：参考/翻译</h4><ul><li>  <a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/">ES modules: A cartoon deep-dive</a></li><li>  <a href="https://blog.shenfq.com/2019/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%89%8D%E4%B8%96/">前端模块化的前世</a></li><li>  <a href="http://www.ruanyifeng.com/blog/2015/05/require.html">require源码解读</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冷知识之HTML篇</title>
      <link href="/My-Blogs/2021/01/08/HTML/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BHTML%E7%AF%87/"/>
      <url>/My-Blogs/2021/01/08/HTML/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BHTML%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>这期让我们来看看关于HTML的冷知识都有哪些吧~</p><a id="more"></a><h3 id="浏览器秒变编辑器"><a href="#浏览器秒变编辑器" class="headerlink" title="浏览器秒变编辑器"></a>浏览器秒变编辑器</h3><p>这个还是在浏览器地址栏上面做文章，将以下代码复制粘贴到浏览器地址栏，运行后浏览器就变成了一个原始简单的编辑器，和window自带的notepad差不多，长见识了吧，话不多说，我们来试试。</p><pre><code class="JavaScript">data: text / html, &lt; html contenteditable &gt;</code></pre><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BHTML%E7%AF%87-01.png" alt="image"></p><blockquote><p>归根结底多亏了HTML5中新加的contenteditable属性，当元素指定了该属性后，元素的内容成为可编辑状态。</p></blockquote><p>同理，在控制台执行以下代码，同样可以将整个页面变得可以编辑。</p><blockquote><p>document.body.contentEditable=’true’; </p></blockquote><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BHTML%E7%AF%87-02.png" alt="image"></p><h3 id="实时编写样式的输入框"><a href="#实时编写样式的输入框" class="headerlink" title="实时编写样式的输入框"></a>实时编写样式的输入框</h3><br><p>同理，也是利用了HTML5中的contenteditable属性，巧妙的在body增加一个可编辑的style标签。</p><br><pre><code class="html">&lt;body&gt;  &lt;style style="display:block; position: fixed;" contentEditable&gt;    body {      background: red;    }  &lt;/style&gt;&lt;/body&gt;</code></pre><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BHTML%E7%AF%87-03.png" alt="image"></p><br><h3 id="利用a标签解析url"><a href="#利用a标签解析url" class="headerlink" title="利用a标签解析url"></a>利用a标签解析url</h3><br><p>很多时候我们有从一个URL中提取域名，查询关键字，变量参数值等的需要, 然而处理 url 字符串是比较麻烦的，可以使用 a 标签自动解析 url。</p><br><p>主要方法就是在JS中创建一个a标签，然后将需要处理的URL赋值给我们新创建的a标签的href属性，然后就可以得到我们想要的东西了。</p><br><pre><code class="javascript">var a = document.createElement('a');a.href = 'https://juejin.cn/user/2796746682939054/posts';console.log(a.host);</code></pre><br><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BHTML%E7%AF%87-04.png" alt="image"></p><br><p>利用这一方法，稍微进行封装一下，就可以得到一个非常实用的工具函数了，下面提供一个网上常见的封装示例。</p><pre><code class="javascript">function urlParse(url, key) {  var a = document.createElement('a')  a.href = url  var result = {    href: url,    protocol: a.protocol.replace(':', ''),    port: a.port,    query: a.search,    params: (function() {      var ret = {},        centArr,        seg = a.search.replace(/^\?/, '').replace(/^\?/, '').split('&amp;')      for (i = 0, len = seg.length; i &lt; len; i++) {        if (!seg[i]) {          continue        }        centArr = seg[i].split('=')        ret[centArr[0]] = centArr[1]      }      return ret    }()),    hash: a.hash,    file: (a.pathname.match(/\/([^\/?#]+)$/i) || [, ''])[1],    path: a.pathname.replace(/^([^\/])/, '/$1'),    relative: (a.href.match(/tps?:\/\/[^\/]+(.+)/) || [, ''])[1],    segments: a.pathname.replace(/^\//, '').split('/')  }  a = null  return key ? result[key] : result}</code></pre><br><blockquote><p>H5 有新的 API URL 也可以快速的处理一个链接</p></blockquote><br><pre><code class="JavaScript">var url = new URL('https://www.baidu.com/')url.hash  ...</code></pre>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> 冷知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单介绍2020Google开发者大会web亮点</title>
      <link href="/My-Blogs/2021/01/08/Google/%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D2020Google%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9Aweb%E4%BA%AE%E7%82%B9/"/>
      <url>/My-Blogs/2021/01/08/Google/%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D2020Google%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9Aweb%E4%BA%AE%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="sameSite"><a href="#sameSite" class="headerlink" title="sameSite"></a>sameSite</h3><blockquote><p>Chrome 51 开始，浏览器的 Cookie 新增加了一个SameSite属性，用来防止 CSRF 攻击和用户追踪，分为Strict ，Lax，None</p></blockquote><ul><li><code>Strict</code>最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie</li></ul><p><strong>这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态</strong></p><ul><li><code>Lax</code>规则稍稍放宽，允许同站请求发送Cookie，但大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。</li><li><code>None</code>允许跨站请求，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效</li></ul><table><thead><tr><th>sameSite</th><th>HTTP → HTTPS</th><th>HTTPS → HTTP</th></tr></thead><tbody><tr><td>SameSite=Strict</td><td>⛔ Blocked</td><td>⛔ Blocked</td></tr><tr><td>SameSite=Lax</td><td>✓ Allowed</td><td>✓ Allowed</td></tr><tr><td>SameSite=None; Secure</td><td>✓ Allowed</td><td>⛔ Blocked</td></tr></tbody></table><p><a href="https://web.dev/schemeful-samesite/">查看更多信息</a></p><h3 id="User-Agent-Client-Hints-UA-CH"><a href="#User-Agent-Client-Hints-UA-CH" class="headerlink" title="User-Agent Client Hints(UA-CH)"></a>User-Agent Client Hints(UA-CH)</h3><blockquote><p>从Chrome 85开始，正式发布</p></blockquote><table><thead><tr><th>⬇️ ResponseAccept-CH</th><th>⬆️ Requestheader</th><th>⬆️ RequestExample value</th><th>Description</th></tr></thead><tbody><tr><td>UA</td><td>Sec-CH-UA</td><td>“Chromium”; v=”84”, “Google Chrome”; v=”84”</td><td>List of browser brands and their significant version.</td></tr><tr><td>UA-Mobile</td><td>Sec-CH-UA-Mobile</td><td>?1</td><td>Boolean indicating if the browser is on a mobile device (?1&nbsp;for true) or not (?0&nbsp;for false).</td></tr><tr><td>UA-Full-Version</td><td>Sec-CH-UA-Full-Version</td><td>“84.0.4143.2”</td><td>The complete version for the browser.</td></tr><tr><td>UA-Platform</td><td>Sec-CH-UA-Platform</td><td>“Android”</td><td>The platform for the device, usually the operating system (OS).</td></tr><tr><td>UA-Platform-Version</td><td>Sec-CH-UA-Platform-Version</td><td>“10”</td><td>The version for the platform or OS.</td></tr><tr><td>UA-Arch</td><td>Sec-CH-UA-Arch</td><td>“ARM64”</td><td>The underlying architecture for the device. While this may not be relevant to displaying the page, the site may want to offer a download which defaults to the right format.</td></tr><tr><td>UA-Model</td><td>Sec-CH-UA-Model</td><td>“Pixel 3”</td><td>The device model.</td></tr></tbody></table><h3 id="JavaScript-API"><a href="#JavaScript-API" class="headerlink" title="JavaScript API"></a>JavaScript API</h3><p>Alongside the headers, the User-Agent can also be accessed in JavaScript via navigator.userAgentData. The default Sec-CH-UA and Sec-CH-UA-Mobile header information can be accessed via the brands and mobile properties, respectively:</p><pre><code class="JavaScript">// Log the brand dataconsole.log(navigator.userAgentData.brands);// output[{    brand: 'Chromium',    version: '84',  },  {    brand: 'Google Chrome',    version: '84',  },];// Log the mobile indicatorconsole.log(navigator.userAgentData.mobile);// outputfalse;</code></pre><p><a href="https://web.dev/user-agent-client-hints/">查看更多信息</a></p><h2 id="CSS布局"><a href="#CSS布局" class="headerlink" title="CSS布局"></a>CSS布局</h2><blockquote><p>介绍了一些grid新特性</p></blockquote><h3 id="强居中"><a href="#强居中" class="headerlink" title="强居中"></a>强居中</h3><img src="https://user-images.githubusercontent.com/5030910/100298195-71db5c00-2fcb-11eb-89a2-f4e5ed8a4e8d.png" align="center"><h3 id="三段式布局"><a href="#三段式布局" class="headerlink" title="三段式布局"></a>三段式布局</h3><img src="https://user-images.githubusercontent.com/5030910/100298209-7a339700-2fcb-11eb-95df-49fff7c11a46.png" align="center"><h3 id="经典布局"><a href="#经典布局" class="headerlink" title="经典布局"></a>经典布局</h3><img src="https://user-images.githubusercontent.com/5030910/100298312-c8e13100-2fcb-11eb-8631-d0aba105fa86.png" align="center"><p><a href="http://1linelayouts.glitch.me/">查看更多实例</a></p><p><strong>思考：优化运营后台页面，自适应布局？</strong></p><h2 id="搜索（高级SEO）"><a href="#搜索（高级SEO）" class="headerlink" title="搜索（高级SEO）"></a>搜索（高级SEO）</h2><blockquote><p>利用结构化数据获取 Google 搜索的自然流量</p></blockquote><h3 id="构建富媒体搜索数据，助力Bigo海外电商，直播，imoJobs等业务"><a href="#构建富媒体搜索数据，助力Bigo海外电商，直播，imoJobs等业务" class="headerlink" title="构建富媒体搜索数据，助力Bigo海外电商，直播，imoJobs等业务"></a>构建富媒体搜索数据，助力Bigo海外电商，直播，imoJobs等业务</h3><ul><li><p><strong><a href="https://developers.google.com/search/docs/data-types/product">电商</a></strong></p><img src="https://user-images.githubusercontent.com/5030910/100297927-bfa39480-2fca-11eb-8df7-99606a72f2cf.png" align="center"></li><li><p><strong><a href="https://developers.google.com/search/docs/data-types/video">直播</a></strong></p></li></ul><p><img src="https://user-images.githubusercontent.com/5030910/100444919-3a61d200-30e7-11eb-9fdb-bcf3f609608b.png" alt="image"></p><ul><li><p><strong><a href="https://developers.google.com/search/docs/data-types/job-posting">imojobs</a></strong></p><img src="https://user-images.githubusercontent.com/5030910/100225858-cfcf5b80-2f59-11eb-81fd-ecb766bfc198.png" align="center"></li></ul><p><a href="https://search.google.com/test/rich-results">测试地址</a></p><h3 id="下面是一个购物信息汇总网站页面示例"><a href="#下面是一个购物信息汇总网站页面示例" class="headerlink" title="下面是一个购物信息汇总网站页面示例"></a>下面是一个购物信息汇总网站页面示例</h3><pre><code class="html"> &lt;html&gt; &lt;head&gt;   &lt;title&gt;Executive Anvil&lt;/title&gt; &lt;/head&gt; &lt;body&gt;   &lt;div&gt;     &lt;div itemtype="http://schema.org/Product" itemscope&gt;       &lt;meta itemprop="mpn" content="925872" /&gt;       &lt;meta itemprop="name" content="Executive Anvil" /&gt;       &lt;link itemprop="image" href="https://example.com/photos/16x9/photo.jpg" /&gt;       &lt;link itemprop="image" href="https://example.com/photos/4x3/photo.jpg" /&gt;       &lt;link itemprop="image" href="https://example.com/photos/1x1/photo.jpg" /&gt;       &lt;meta itemprop="description" content="Sleeker than ACME's Classic Anvil, the Executive Anvil is perfect for the business traveler looking for something to drop from a height." /&gt;       &lt;div itemprop="offers" itemtype="http://schema.org/AggregateOffer" itemscope&gt;         &lt;meta itemprop="lowPrice" content="119.99" /&gt;         &lt;meta itemprop="highPrice" content="199.99" /&gt;         &lt;meta itemprop="offerCount" content="6" /&gt;         &lt;meta itemprop="priceCurrency" content="USD" /&gt;       &lt;/div&gt;       &lt;div itemprop="aggregateRating" itemtype="http://schema.org/AggregateRating" itemscope&gt;         &lt;meta itemprop="reviewCount" content="89" /&gt;         &lt;meta itemprop="ratingValue" content="4.4" /&gt;       &lt;/div&gt;       &lt;div itemprop="review" itemtype="http://schema.org/Review" itemscope&gt;         &lt;div itemprop="author" itemtype="http://schema.org/Person" itemscope&gt;           &lt;meta itemprop="name" content="Fred Benson" /&gt;         &lt;/div&gt;         &lt;div itemprop="reviewRating" itemtype="http://schema.org/Rating" itemscope&gt;           &lt;meta itemprop="ratingValue" content="4" /&gt;           &lt;meta itemprop="bestRating" content="5" /&gt;         &lt;/div&gt;       &lt;/div&gt;       &lt;meta itemprop="sku" content="0446310786" /&gt;       &lt;div itemprop="brand" itemtype="http://schema.org/Brand" itemscope&gt;         &lt;meta itemprop="name" content="ACME" /&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;</code></pre><p><strong>思考：可以利用Node+CDN服务搭建富媒体HTML直出平台，优化SEO？</strong></p><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><h3 id="PageSpeed-Insights-PSI"><a href="#PageSpeed-Insights-PSI" class="headerlink" title=" PageSpeed Insights(PSI)"></a><a href="https://developers.google.com/speed/pagespeed/insights/"> PageSpeed Insights(PSI)</a></h3><blockquote><p>PSI 作为一款专注于改进网页性能的开发者工具</p></blockquote><p><strong>它主要具有以下两个优势：</strong></p><ul><li>真实的网页运行速度。这是 PSI 2.0 中的新功能，PSI 结合 Chrome 用户体验报告中的数据，向开发者展示他们的网页的实际性能，这一点对于开发者来说是很有价值的。那么，PSI 则成为了用户获得真实的网页运行速度的窗口。</li><li>优化建议。根据一些常用的网页性能优化规则(如避免过多的重定向)，PSI 会基于该网页的优化空间为用户提供一些网页优化建议。</li></ul><h3 id="Puppeteer"><a href="#Puppeteer" class="headerlink" title="Puppeteer"></a><a href="https://github.com/puppeteer/puppeteer">Puppeteer</a></h3><blockquote><p>Nodejs工具库，它提供了高级的JavaScript API 来通过DevTools控制 Chromium与其他浏览器</p></blockquote><p><strong>Puppeteer能做什么？</strong></p><ul><li>生成页面的屏幕截图和PDF。</li><li>爬取SPA（单页应用程序）并生成预渲染的内容（即“ SSR”（服务器端渲染））。</li><li>高级爬虫，可以爬取大量异步渲染内容的网页。</li><li>自动进行表单提交，UI测试，键盘输入，模拟时区，改变深色主题等。</li><li>创建最新的自动化测试环境。使用最新的JavaScript和浏览器功能，直接在最新版本的Chrome中运行测试。</li><li>捕获站点的时间线跟踪，以帮助诊断性能问题。</li><li>测试Chrome扩展程序。</li></ul><p><strong>example.js</strong></p><pre><code class="js">const puppeteer = require('puppeteer');(async () =&gt; {  const browser = await puppeteer.launch();  const page = await browser.newPage();  await page.goto('https://example.com');  await page.screenshot({    path: 'example.png'  });  await browser.close();})();</code></pre><blockquote><p>node example.js</p></blockquote><p><strong>最新进展介绍</strong></p> <img src="https://user-images.githubusercontent.com/5030910/100229116-aebd3980-2f5e-11eb-8c5b-e85159a427d7.png " width="500" align="center"><p><strong>思考：可以构建Serveless服务，搭建FaaS平台，助力前端服务和运营服务？</strong></p><h3 id="Web-Vitals"><a href="#Web-Vitals" class="headerlink" title="Web Vitals"></a>Web Vitals</h3><blockquote><p>什么是 Web Vitals ，Google 给的定义是一个良好网站的基本指标 (Essential metrics for a healthy site)，为什么还要再定义一个新的指标集，原因是过去要衡量一个好的网站，需要使用的指标太多，推出 Web Vitals 是简化这个学习的曲线，站主只要观注 Web Vitals 指标表现即可。</p></blockquote><h4 id="三大指标"><a href="#三大指标" class="headerlink" title="三大指标"></a>三大指标</h4><p><img src="https://user-images.githubusercontent.com/5030910/100299467-bf0cfd00-2fce-11eb-972f-48b4b8c60a3c.png" alt="image"></p><p>使用<a href="https://github.com/GoogleChrome/web-vitals">web-vitals</a>库，测量每个指标就像调用单个函数一样简单（有关完整用法和 API详细信息，请参阅文档 ）：</p><pre><code class="js">import {  getCLS,  getFID,  getLCP} from 'web-vitals';function sendToAnalytics(metric) {  const body = JSON.stringify(metric);  // Use `navigator.sendBeacon()` if available, falling back to `fetch()`.  (navigator.sendBeacon &amp;&amp; navigator.sendBeacon('/analytics', body)) ||  fetch('/analytics', {    body,    method: 'POST',    keepalive: true  });}getCLS(sendToAnalytics);getFID(sendToAnalytics);getLCP(sendToAnalytics);</code></pre><table><thead><tr><th>Platform</th><th>LCP</th><th>FID</th><th>CLS</th></tr></thead><tbody><tr><td><a href="https://developers.google.com/web/tools/chrome-user-experience-report">Chrome User Experience Report</a></td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td><a href="https://developers.google.com/speed/pagespeed/insights/">PageSpeed Insights</a></td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td><a href="https://support.google.com/webmasters/answer/9205520">Search Console (Core Web Vitals report)</a></td><td>✔</td><td>✔</td><td>✔</td></tr></tbody></table><p><strong>思考：利用Web Vitals结合puppeteer，搭建网页自动化测试平台，爬虫工具？</strong></p><h2 id="Chrome相关（DevTools，Lighthouse）"><a href="#Chrome相关（DevTools，Lighthouse）" class="headerlink" title="Chrome相关（DevTools，Lighthouse）"></a>Chrome相关（DevTools，Lighthouse）</h2><h3 id="支持CSS-in-JS框架的样式编辑"><a href="#支持CSS-in-JS框架的样式编辑" class="headerlink" title="支持CSS-in-JS框架的样式编辑"></a><a href="https://developers.google.com/web/updates/images/2020/06/css-in-js.mp4">支持CSS-in-JS框架的样式编辑</a></h3><p><img src="https://user-images.githubusercontent.com/5030910/100299322-60e01a00-2fce-11eb-96b6-a37621b3180a.png" alt="image"></p><h3 id="模拟时区"><a href="#模拟时区" class="headerlink" title="模拟时区"></a>模拟时区</h3><p><img src="https://user-images.githubusercontent.com/5030910/100299410-92f17c00-2fce-11eb-8447-6eb810ec5a8d.png" alt="image"></p><h3 id="媒体面板"><a href="#媒体面板" class="headerlink" title="媒体面板"></a>媒体面板</h3><p><img src="https://user-images.githubusercontent.com/5030910/100299683-35a9fa80-2fcf-11eb-9a67-cf3927b48199.png" alt="image"></p><h3 id="一键修复文字的色彩对比"><a href="#一键修复文字的色彩对比" class="headerlink" title="一键修复文字的色彩对比"></a>一键修复文字的色彩对比</h3><p><img src="https://user-images.githubusercontent.com/5030910/100299746-638f3f00-2fcf-11eb-9e12-0e2a7017c6a9.png" alt="image"></p><h3 id="利用Lighthouse-生成性能报告"><a href="#利用Lighthouse-生成性能报告" class="headerlink" title="利用Lighthouse 生成性能报告"></a>利用Lighthouse 生成性能报告</h3><p><img src="https://user-images.githubusercontent.com/5030910/100299914-d0a2d480-2fcf-11eb-8500-a0fdc33c45c0.png" alt="image"></p><p><strong><a href="https://developers.google.com/web/updates">更多内容查看这里</a></strong></p><h2 id="PWA与WebPush"><a href="#PWA与WebPush" class="headerlink" title="PWA与WebPush"></a>PWA与WebPush</h2><h3 id="利用PWA解决以下问题"><a href="#利用PWA解决以下问题" class="headerlink" title="利用PWA解决以下问题"></a>利用PWA解决以下问题</h3><p><img src="https://user-images.githubusercontent.com/5030910/100417600-3cfb0200-30bc-11eb-8c5b-16148406d95c.png" alt="image"></p><h3 id="WebPush流程图"><a href="#WebPush流程图" class="headerlink" title="WebPush流程图"></a>WebPush流程图</h3><p><strong>授权流程</strong></p><p><img src="https://user-images.githubusercontent.com/5030910/100417630-50a66880-30bc-11eb-8ecc-2199dab3dc11.png" alt="Web push授权流程"></p><p><strong>通知流程</strong></p><p><img src="https://user-images.githubusercontent.com/5030910/100417986-eb06ac00-30bc-11eb-9ecf-6b3dd9b5a69e.png" alt="image"></p><p><strong>代码实现</strong></p><p><img src="https://user-images.githubusercontent.com/5030910/100418090-17bac380-30bd-11eb-8ca5-6fe9c18deddd.png" alt="image"></p><p><strong>成果</strong></p><p><img src="https://user-images.githubusercontent.com/5030910/100418205-505a9d00-30bd-11eb-9bda-9e12c38f60f1.png" alt="image"></p><p><strong>思考：利用Node，搭建PWA构建平台，助力海外电商业务，将营销推广类活动页封装成PWA</strong></p><h2 id="TensorFlow-js"><a href="#TensorFlow-js" class="headerlink" title="TensorFlow.js"></a>TensorFlow.js</h2><h3 id="来分享一个有意思的场景"><a href="#来分享一个有意思的场景" class="headerlink" title="来分享一个有意思的场景"></a>来分享一个有意思的场景</h3><p><strong><a href="https://blog.tensorflow.org/2020/09/bringing-mona-lisa-effect-to-life-tensorflow-js.html">交互式《蒙娜丽莎》画像</a></strong></p><blockquote><p>传说中，不管你从哪个角度看《蒙娜丽莎》画像，都会感到画像中的女子在看着你。TensorFlow 的官方博客，演示怎么用 TensorFlow.js，制作一个交互式的《蒙娜丽莎》画像，摄像头捕捉观看者的角度，然后自动改变画像的眼神。</p></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/202009/bg2020092603.jpg" alt="image"></p><p><img src="https://www.wangbase.com/blogimg/asset/202009/bg2020092604.jpg" alt="image"></p><h3 id="利用TensorFlow-Privacy-检查隐私保护措施"><a href="#利用TensorFlow-Privacy-检查隐私保护措施" class="headerlink" title="利用TensorFlow Privacy 检查隐私保护措施"></a>利用TensorFlow Privacy 检查隐私保护措施</h3><p><img src="https://user-images.githubusercontent.com/5030910/100418941-851b2400-30be-11eb-98cf-af0d5dbb1a5f.png" alt="image"></p><p><img src="https://user-images.githubusercontent.com/5030910/100419020-a3811f80-30be-11eb-9237-c33f9de6b58a.png" alt="image"></p><p><img src="https://user-images.githubusercontent.com/5030910/100419041-ada31e00-30be-11eb-88cd-0c5f8b2c89bd.png" alt="image"></p><p><strong>思考：或许可以利用Node+TensorFlow，对于用户上传的图片进行二次处理？</strong></p><ul><li><p><a href="https://www.tensorflow.org/js/?hl=zh_cn">官网</a></p></li><li><p><a href="https://www.icourse163.org/learn/youdao-1460578162?tid=1461280442#/learn/content">入门课程</a></p></li><li><p><a href="https://flutter.dev/web">Flutter Web</a></p></li><li><p><a href="https://space.bilibili.com/64169458/channel/detail?cid=156180">视频集合链接</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Google </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git远程操作详解【转载】</title>
      <link href="/My-Blogs/2021/01/08/Git/Git%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91/"/>
      <url>/My-Blogs/2021/01/08/Git/Git%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>Git有很多优势，其中之一就是远程操作非常简便。本文详细介绍5个Git命令，它们的概念和用法，理解了这些内容，你就会完全掌握Git远程操作。</p><a id="more"></a><pre><code class="BASH">git clonegit remotegit fetchgit pullgit push</code></pre><p>本文针对初级用户，从最简单的讲起，但是需要读者对Git的基本用法有所了解。同时，本文覆盖了上面5个命令的几乎所有的常用用法，所以对于熟练用户也有参考价值。</p><h3 id="一、git-clone"><a href="#一、git-clone" class="headerlink" title="一、git clone"></a>一、git clone</h3><p>远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。</p><pre><code class="BASH">$ git clone &amp;lt;版本库的网址&amp;gt;</code></pre><p>比如，克隆jQuery的版本库。</p><pre><code class="BASH">$ git clone https://github.com/jquery/jquery.git</code></pre><p>该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。</p><pre><code class="BASH">$ git clone &amp;lt;版本库的网址&amp;gt; &amp;lt;本地目录名&amp;gt;</code></pre><p>git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。</p><pre><code class="BASH">$ git clone http[s]://example.com/path/to/repo.git/$ git clone ssh://example.com/path/to/repo.git/$ git clone git://example.com/path/to/repo.git/$ git clone /opt/git/project.git $ git clone file:///opt/git/project.git$ git clone ftp[s]://example.com/path/to/repo.git/$ git clone rsync://example.com/path/to/repo.git/</code></pre><p>SSH协议还有另一种写法。</p><pre><code class="BASH">$ git clone [user@]example.com:path/to/repo.git/</code></pre><p>通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考官方文档。</p><h3 id="二、git-remote"><a href="#二、git-remote" class="headerlink" title="二、git remote"></a>二、git remote</h3><p>为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。</p><p>不带选项的时候，git remote命令列出所有远程主机。</p><pre><code class="BASH">$ git remote origin</code></pre><p>使用-v选项，可以参看远程主机的网址。</p><pre><code class="BASH">$ git remote -vorigin  git@github.com:jquery/jquery.git (fetch)origin  git@github.com:jquery/jquery.git (push)</code></pre><p>上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。</p><p>克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。</p><pre><code class="BASH">$ git clone -o jQuery https://github.com/jquery/jquery.git$ git remote</code></pre><p>jQuery</p><p>上面命令表示，克隆的时候，指定远程主机叫做jQuery。</p><pre><code class="BASH">git remote show命令加上主机名，可以查看该主机的详细信息。$ git remote show &lt;主机名&gt;git remote add命令用于添加远程主机。$ git remote add &lt;主机名&gt; &lt;网址&gt;git remote rm命令用于删除远程主机。$ git remote rm &lt;主机名&gt;git remote rename命令用于远程主机的改名。$ git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</code></pre><h3 id="三、git-fetch"><a href="#三、git-fetch" class="headerlink" title="三、git fetch"></a>三、git fetch</h3><p>一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。</p><pre><code class="BASH">$ git fetch &lt;远程主机名&gt;</code></pre><p>上面命令将某个远程主机的更新，全部取回本地。</p><p><code>git fetch</code> 命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。</p><p>默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。</p><pre><code class="BASH">$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;</code></pre><p>比如，取回origin主机的master分支。</p><pre><code class="BASH">$ git fetch origin master</code></pre><p>所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。</p><p>git branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。</p><pre><code class="BASH">$ git branch -rorigin/master$ git branch -a* master  remotes/origin/master</code></pre><p>上面命令表示，本地主机的当前分支是master，远程分支是origin/master。</p><p>取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。</p><pre><code class="BASH">$ git checkout -b newBrach origin/master</code></pre><p>上面命令表示，在origin/master的基础上，创建一个新分支。</p><p>此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。</p><pre><code class="BASH">$ git pull origin next:master</code></pre><p>上面命令表示在当前分支上，合并origin/master。</p><h3 id="四、git-pull"><a href="#四、git-pull" class="headerlink" title="四、git pull"></a>四、git pull</h3><p>git pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。</p><pre><code class="BASH">$ git pull &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;</code></pre><p>比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。</p><pre><code class="BASH">$ git pull origin next:master</code></pre><p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p><pre><code class="BASH">$ git pull origin next</code></pre><p>上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。</p><pre><code class="BASH">$ git fetch origin$ git merge origin/next</code></pre><p>在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。</p><p>Git也允许手动建立追踪关系。</p><pre><code class="BASH">git branch --set-upstream master origin/next</code></pre><p>上面命令指定master分支追踪origin/next分支。</p><p>如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。</p><pre><code class="BASH">$ git pull origin</code></pre><p>上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”（remote-tracking branch）进行合并。</p><p>如果当前分支只有一个追踪分支，连远程主机名都可以省略。</p><pre><code class="BASH">$ git pull</code></pre><p>上面命令表示，当前分支自动与唯一一个追踪分支进行合并。</p><p>如果合并需要采用rebase模式，可以使用–rebase选项。</p><pre><code class="BASH">$ git pull --rebase &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;</code></pre><p>如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。</p><p>但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。</p><pre><code class="BASH">$ git pull -p等同于下面的命令$ git fetch --prune origin $ git fetch -p</code></pre><h3 id="五、git-push"><a href="#五、git-push" class="headerlink" title="五、git push"></a>五、git push</h3><p>git push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。</p><pre><code class="BASH">$ git push &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名&amp;gt;:&amp;lt;远程分支名&amp;gt;</code></pre><p>注意，分支推送顺序的写法是&lt; 来源地&gt; :&lt; 目的地&gt; ，所以git pull是&lt; 远程分支&gt; :&lt; 本地分支&gt; ，而git push是&lt; 本地分支&gt; :&lt; 远程分支&gt; 。</p><p>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</p><pre><code class="BASH">$ git push origin master</code></pre><p>上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。</p><p>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p><pre><code class="BASH">$ git push origin :master等同于$ git push origin --delete master</code></pre><p>上面命令表示删除origin主机的master分支。</p><p>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</p><pre><code class="BASH">$ git push origin</code></pre><p>上面命令表示，将当前分支推送到origin主机的对应分支。</p><p>如果当前分支只有一个追踪分支，那么主机名都可以省略。</p><pre><code class="BASH">$ git push</code></pre><p>如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。</p><pre><code class="BASH">$ git push -u origin master</code></pre><p>上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。</p><p>不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。</p><pre><code class="BASH">$ git config --global push.default matching或者$ git config --global push.default simple</code></pre><p>还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用–all选项。</p><pre><code class="BASH">$ git push --all origin</code></pre><p>上面命令表示，将所有本地分支都推送到origin主机。</p><p>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用–force选项。</p><pre><code class="BASH">$ git push --force origin</code></pre><p>上面命令使用–force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用–force选项。</p><p>最后，git push不会推送标签（tag），除非使用–tags选项。</p><pre><code class="BASH">$ git push origin --tags</code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git回滚操作</title>
      <link href="/My-Blogs/2021/01/08/Git/git%E5%9B%9E%E6%BB%9A%E6%93%8D%E4%BD%9C/"/>
      <url>/My-Blogs/2021/01/08/Git/git%E5%9B%9E%E6%BB%9A%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>我们都知道万一提交错了代码，想要删除又想准确无误怎么办呢？下面介绍两种方式，看是否有适合你的呢</p><a id="more"></a><h2 id="git删除指定commit"><a href="#git删除指定commit" class="headerlink" title="git删除指定commit"></a>git删除指定commit</h2><ol><li> 使用git log 命令，查看已提交的记录。例如红色圈出的commit是本次要删除的commit。</li></ol><p><img src="/My-Blogs/images/git%E5%9B%9E%E6%BB%9A%E6%93%8D%E4%BD%9C-01.png"></p><br><ol start="2"><li><p> 先找到此次提交之前的一次提交的commit 1d6b81b138f89735265900b94fcd1ec39375e7b4</p></li><li><p> 执行git rebase -i 1d6b81b138f89735265900b94fcd1ec39375e7b4，弹出如下页面（不包含当前commit）：</p></li></ol><p><img src="/My-Blogs/images/git%E5%9B%9E%E6%BB%9A%E6%93%8D%E4%BD%9C-02.png"></p><br><p>按字母I键进入编辑模式，将需要删除的commit的pick改为drop，然后按esc退出编辑，：wq保存</p><p><img src="/My-Blogs/images/git%E5%9B%9E%E6%BB%9A%E6%93%8D%E4%BD%9C-03.png"></p><br><ol start="4"><li> 再次执行git log命令，查看已提交记录，之前红色圈出的commit记录已被删除。</li></ol><p><img src="/My-Blogs/images/git%E5%9B%9E%E6%BB%9A%E6%93%8D%E4%BD%9C-04.png"></p><p><strong>PS：以上方法不适用特定merge提交删除</strong></p><h2 id="优雅撤销中间某次merge提交"><a href="#优雅撤销中间某次merge提交" class="headerlink" title="优雅撤销中间某次merge提交"></a>优雅撤销中间某次merge提交</h2><pre><code class="BASH">git revert commit_id//如果commit_id是merge节点的话,-m是指定具体哪个提交点git revert commit_id -m 1//接着就是解决冲突git add -Agit commit -m ".."git revert commit_id -m 2//接着就是解决冲突git add -Agit commit -m ".."git push</code></pre><p>其中<code>git revert commit_id -m 数字</code>是针对，<code>merge</code>提交点的操作。<br>如果是普通的提交点，直接用rebase即可，不需要这么麻烦。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eslint使用规则</title>
      <link href="/My-Blogs/2021/01/08/eslint/%E5%85%B3%E4%BA%8Eeslint%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99%EF%BC%8C%E5%92%8C%E5%90%84%E7%A7%8D%E6%8A%A5%E9%94%99%E5%BA%94%E5%AF%B9%E4%B9%A6%E5%86%99%E8%A7%84%E5%88%99/"/>
      <url>/My-Blogs/2021/01/08/eslint/%E5%85%B3%E4%BA%8Eeslint%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99%EF%BC%8C%E5%92%8C%E5%90%84%E7%A7%8D%E6%8A%A5%E9%94%99%E5%BA%94%E5%AF%B9%E4%B9%A6%E5%86%99%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>整理了一些eslint常用规则，欢迎大家评阅</p><a id="more"></a><p><strong>为了方便查看和使用所以进行了整理，以下。</strong></p><blockquote><p>0=”off” 1=”warn” 2=”error”</p></blockquote><pre><code class="js">"no-alert": 0,//禁止使用alert confirm prompt"no-array-constructor": 2,//禁止使用数组构造器"no-bitwise": 0,//禁止使用按位运算符"no-caller": 1,//禁止使用arguments.caller或arguments.callee"no-catch-shadow": 2,//禁止catch子句参数与外部作用域变量同名"no-class-assign": 2,//禁止给类赋值"no-cond-assign": 2,//禁止在条件表达式中使用赋值语句"no-console": 2,//禁止使用console"no-const-assign": 2,//禁止修改const声明的变量"no-constant-condition": 2,//禁止在条件中使用常量表达式 if(true) if(1)"no-continue": 0,//禁止使用continue"no-control-regex": 2,//禁止在正则表达式中使用控制字符"no-debugger": 2,//禁止使用debugger"no-delete-var": 2,//不能对var声明的变量使用delete操作符"no-div-regex": 1,//不能使用看起来像除法的正则表达式/=foo/"no-dupe-keys": 2,//在创建对象字面量时不允许键重复 {a:1,a:1}"no-dupe-args": 2,//函数参数不能重复"no-duplicate-case": 2,//switch中的case标签不能重复"no-else-return": 2,//如果if语句里面有return,后面不能跟else语句"no-empty": 2,//块语句中的内容不能为空"no-empty-character-class": 2,//正则表达式中的[]内容不能为空"no-empty-label": 2,//禁止使用空label"no-eq-null": 2,//禁止对null使用==或!=运算符"no-eval": 1,//禁止使用eval"no-ex-assign": 2,//禁止给catch语句中的异常参数赋值"no-extend-native": 2,//禁止扩展native对象"no-extra-bind": 2,//禁止不必要的函数绑定"no-extra-boolean-cast": 2,//禁止不必要的bool转换"no-extra-parens": 2,//禁止非必要的括号"no-extra-semi": 2,//禁止多余的冒号"no-fallthrough": 1,//禁止switch穿透"no-floating-decimal": 2,//禁止省略浮点数中的0 .5 3."no-func-assign": 2,//禁止重复的函数声明"no-implicit-coercion": 1,//禁止隐式转换"no-implied-eval": 2,//禁止使用隐式eval"no-inline-comments": 0,//禁止行内备注"no-inner-declarations": [2, "functions"],//禁止在块语句中使用声明（变量或函数）"no-invalid-regexp": 2,//禁止无效的正则表达式"no-invalid-this": 2,//禁止无效的this，只能用在构造器，类，对象字面量"no-irregular-whitespace": 2,//不能有不规则的空格"no-iterator": 2,//禁止使用__iterator__ 属性"no-label-var": 2,//label名不能与var声明的变量名相同"no-labels": 2,//禁止标签声明"no-lone-blocks": 2,//禁止不必要的嵌套块"no-lonely-if": 2,//禁止else语句内只有if语句"no-loop-func": 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）"no-mixed-requires": [0, false],//声明时不能混用声明类型"no-mixed-spaces-and-tabs": [2, false],//禁止混用tab和空格"linebreak-style": [0, "windows"],//换行风格"no-multi-spaces": 1,//不能用多余的空格"no-multi-str": 2,//字符串不能用\换行"no-multiple-empty-lines": [1, {"max": 2}],//空行最多不能超过2行"no-native-reassign": 2,//不能重写native对象"no-negated-in-lhs": 2,//in 操作符的左边不能有!"no-nested-ternary": 0,//禁止使用嵌套的三目运算"no-new": 1,//禁止在使用new构造一个实例后不赋值"no-new-func": 1,//禁止使用new Function"no-new-object": 2,//禁止使用new Object()"no-new-require": 2,//禁止使用new require"no-new-wrappers": 2,//禁止使用new创建包装实例，new String new Boolean new Number"no-obj-calls": 2,//不能调用内置的全局对象，比如Math() JSON()"no-octal": 2,//禁止使用八进制数字"no-octal-escape": 2,//禁止使用八进制转义序列"no-param-reassign": 2,//禁止给参数重新赋值"no-path-concat": 0,//node中不能使用__dirname或__filename做路径拼接"no-plusplus": 0,//禁止使用++，--"no-process-env": 0,//禁止使用process.env"no-process-exit": 0,//禁止使用process.exit()"no-proto": 2,//禁止使用__proto__属性"no-redeclare": 2,//禁止重复声明变量"no-regex-spaces": 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/"no-restricted-modules": 0,//如果禁用了指定模块，使用就会报错"no-return-assign": 1,//return 语句中不能有赋值表达式"no-script-url": 0,//禁止使用javascript:void(0)"no-self-compare": 2,//不能比较自身"no-sequences": 0,//禁止使用逗号运算符"no-shadow": 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名"no-shadow-restricted-names": 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用"no-spaced-func": 2,//函数调用时 函数名与()之间不能有空格"no-sparse-arrays": 2,//禁止稀疏数组， [1,,2]"no-sync": 0,//nodejs 禁止同步方法"no-ternary": 0,//禁止使用三目运算符"no-trailing-spaces": 1,//一行结束后面不要有空格"no-this-before-super": 0,//在调用super()之前不能使用this或super"no-throw-literal": 2,//禁止抛出字面量错误 throw "error";"no-undef": 1,//不能有未定义的变量"no-undef-init": 2,//变量初始化时不能直接给它赋值为undefined"no-undefined": 2,//不能使用undefined"no-unexpected-multiline": 2,//避免多行表达式"no-underscore-dangle": 1,//标识符不能以_开头或结尾"no-unneeded-ternary": 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;"no-unreachable": 2,//不能有无法执行的代码"no-unused-expressions": 2,//禁止无用的表达式"no-unused-vars": [2, {"vars": "all", "args": "after-used"}],//不能有声明后未被使用的变量或参数"no-use-before-define": 2,//未定义前不能使用"no-useless-call": 2,//禁止不必要的call和apply"no-void": 2,//禁用void操作符"no-var": 0,//禁用var，用let和const代替"no-warning-comments": [1, { "terms": ["todo", "fixme", "xxx"], "location": "start" }],//不能有警告备注"no-with": 2,//禁用with"array-bracket-spacing": [2, "never"],//是否允许非空数组里面有多余的空格"arrow-parens": 0,//箭头函数用小括号括起来"arrow-spacing": 0,//=&gt;的前/后括号"accessor-pairs": 0,//在对象中使用getter/setter"block-scoped-var": 0,//块语句中使用var"brace-style": [1, "1tbs"],//大括号风格"callback-return": 1,//避免多次调用回调什么的"camelcase": 2,//强制驼峰法命名"comma-dangle": [2, "never"],//对象字面量项尾不能有逗号"comma-spacing": 0,//逗号前后的空格"comma-style": [2, "last"],//逗号风格，换行时在行首还是行尾"complexity": [0, 11],//循环复杂度"computed-property-spacing": [0, "never"],//是否允许计算后的键名什么的"consistent-return": 0,//return 后面是否允许省略"consistent-this": [2, "that"],//this别名"constructor-super": 0,//非派生类不能调用super，派生类必须调用super"curly": [2, "all"],//必须使用 if(){} 中的{}"default-case": 2,//switch语句最后必须有default"dot-location": 0,//对象访问符的位置，换行的时候在行首还是行尾"dot-notation": [0, { "allowKeywords": true }],//避免不必要的方括号"eol-last": 0,//文件以单一的换行符结束"eqeqeq": 2,//必须使用全等"func-names": 0,//函数表达式必须有名字"func-style": [0, "declaration"],//函数风格，规定只能使用函数声明/函数表达式"generator-star-spacing": 0,//生成器函数*的前后空格"guard-for-in": 0,//for in循环要用if语句过滤"handle-callback-err": 0,//nodejs 处理错误"id-length": 0,//变量名长度"indent": [2, 4],//缩进风格"init-declarations": 0,//声明时必须赋初值"key-spacing": [0, { "beforeColon": false, "afterColon": true }],//对象字面量中冒号的前后空格"lines-around-comment": 0,//行前/行后备注"max-depth": [0, 4],//嵌套块深度"max-len": [0, 80, 4],//字符串最大长度"max-nested-callbacks": [0, 2],//回调嵌套深度"max-params": [0, 3],//函数最多只能有3个参数"max-statements": [0, 10],//函数内最多有几个声明"new-cap": 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用"new-parens": 2,//new时必须加小括号"newline-after-var": 2,//变量声明后是否需要空一行"object-curly-spacing": [0, "never"],//大括号内是否允许不必要的空格"object-shorthand": 0,//强制对象字面量缩写语法"one-var": 1,//连续声明"operator-assignment": [0, "always"],//赋值运算符 += -=什么的"operator-linebreak": [2, "after"],//换行时运算符在行尾还是行首"padded-blocks": 0,//块语句内行首行尾是否要空行"prefer-const": 0,//首选const"prefer-spread": 0,//首选展开运算"prefer-reflect": 0,//首选Reflect的方法"quotes": [1, "single"],//引号类型 `` "" ''"quote-props":[2, "always"],//对象字面量中的属性名是否强制双引号"radix": 2,//parseInt必须指定第二个参数"id-match": 0,//命名检测"require-yield": 0,//生成器函数必须有yield"semi": [2, "always"],//语句强制分号结尾"semi-spacing": [0, {"before": false, "after": true}],//分号前后空格"sort-vars": 0,//变量声明时排序"space-after-keywords": [0, "always"],//关键字后面是否要空一格"space-before-blocks": [0, "always"],//不以新行开始的块{前面要不要有空格"space-before-function-paren": [0, "always"],//函数定义时括号前面要不要有空格"space-in-parens": [0, "never"],//小括号里面要不要有空格"space-infix-ops": 0,//中缀操作符周围要不要有空格"space-return-throw-case": 2,//return throw case后面要不要加空格"space-unary-ops": [0, { "words": true, "nonwords": false }],//一元运算符的前/后要不要加空格"spaced-comment": 0,//注释风格不要有空格什么的"strict": 2,//使用严格模式"use-isnan": 2,//禁止比较时使用NaN，只能用isNaN()"valid-jsdoc": 0,//jsdoc规则"valid-typeof": 2,//必须使用合法的typeof的值"vars-on-top": 2,//var必须放在作用域顶部"wrap-iife": [2, "inside"],//立即执行函数表达式的小括号风格"wrap-regex": 0,//正则表达式字面量用小括号包起来"yoda": [2, "never"]//禁止尤达条件</code></pre>]]></content>
      
      
      <categories>
          
          <category> eslint </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eslint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时序分析场景</title>
      <link href="/My-Blogs/2021/01/08/Elasticsearch/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90%E5%9C%BA%E6%99%AF/"/>
      <url>/My-Blogs/2021/01/08/Elasticsearch/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>时序数据是按时间顺序记录设备、系统状态变化的数据。典型的时序数据有传统的服务器监控指标数据、应用系统性能监控数据、智能硬件、工业物联网传感器数据等。</p><p>早在2017年我们也基于ES进行了时序分析场景的探索。时序分析场景具有高并发写入、低查询时延、多维分析的特点。</p><p>由于ES具有集群扩展、批量写入、读写带路由、数据分片等能力，目前已实现线上单集群最大规模达到600+ 节点、1000w/s的写入吞吐、单条曲线或单个时间线的查询延时可控制在10ms。</p><p>ES提供灵活、多维度的统计分析能力，实现查看监控按照地域、业务模块等灵活的进行统计分析。另外，ES支持列存储、高压缩比、副本数按需调整等能力，可实现较低存储成本。最后时序数据也可通过Kibana组件轻松实现可视化。</p><p><img src="/My-Blogs/images/%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90%E5%9C%BA%E6%99%AF-01.jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
            <tag> 应用场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志实时分析场景</title>
      <link href="/My-Blogs/2021/01/08/Elasticsearch/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E6%97%A5%E5%BF%97%E5%AE%9E%E6%97%B6%E5%88%86%E6%9E%90%E5%9C%BA%E6%99%AF/"/>
      <url>/My-Blogs/2021/01/08/Elasticsearch/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E6%97%A5%E5%BF%97%E5%AE%9E%E6%97%B6%E5%88%86%E6%9E%90%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>日志是互联网行业基础广泛的数据形式。典型日志有用来定位业务问题的运营日志，如慢日志、异常日志；用来分析用户行为的业务日志，如用户的点击、访问日志；以及安全行为分析的审计日志等。</p><p>Elastic生态提供了完整的日志解决方案。通过简单部署，即可搭建一个完整的日志实时分析服务。ES生态完美的解决了日志实时分析场景需求，这也是近几年ES快速发展的一个重要原因。</p><p>日志从产生到可访问一般在10s级，相比于传统大数据解决方案的几十分钟、小时级时效性非常高。</p><p>ES底层支持倒排索引、列存储等数据结构，使得在日志场景可以利用ES非常灵活的搜索分析能力。通过ES交互式分析能力，即使在万亿级日志的情况下，日志搜索响应时间也是秒级。</p><p>日志处理的基本流程包含：日志采集-&gt; 数据清洗-&gt; 存储-&gt; 可视化分析。ElasticStack通过完整的日志解决方案，帮助用户完成对日志处理全链路管理。</p><p><img src="/My-Blogs/images/%E6%97%A5%E5%BF%97%E5%AE%9E%E6%97%B6%E5%88%86%E6%9E%90%E5%9C%BA%E6%99%AF-01.jpeg"></p><p>其中：</p><ul><li>日志采集：通过轻量级日志采集组件FileBeat实时读取业务日志文件，发送数据至下游组件如Logstash。</li><li> 文本解析：利用正则解析等机制，将日志文本数据转换成结构化数据。可使用独立的Logstash服务或Elasticsearch内置的轻量级数据处理模块IngestPipe-line，完成数据清洗和转换。</li><li>数据存储：通过Elasticsearch搜索分析平台进行数据持久存储，提供全文搜索和分析能力。</li><li>可视化分析：通过功能丰富的图形界面，即可对日志数据进行搜索分析，如可视化组件Kibana。</li></ul><p><img src="/My-Blogs/images/%E6%97%A5%E5%BF%97%E5%AE%9E%E6%97%B6%E5%88%86%E6%9E%90%E5%9C%BA%E6%99%AF-02.jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
            <tag> 应用场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雪碧图mixin</title>
      <link href="/My-Blogs/2021/01/08/css/%E9%9B%AA%E7%A2%A7%E5%9B%BEmixin/"/>
      <url>/My-Blogs/2021/01/08/css/%E9%9B%AA%E7%A2%A7%E5%9B%BEmixin/</url>
      
        <content type="html"><![CDATA[<p>icon小图标</p><a id="more"></a><h2 id="调用icon小图标的方式是通过mixin方式进行调用的"><a href="#调用icon小图标的方式是通过mixin方式进行调用的" class="headerlink" title="调用icon小图标的方式是通过mixin方式进行调用的"></a>调用icon小图标的方式是通过mixin方式进行调用的</h2><pre><code class="CSS">@mixin Ricon($width, $height, $url, $important: '') {  @include background(#{$baseURL}#{$url}.png, $important);  display: inline-block;  width: $width;  height: $height;  background-size: 100% auto;  background-position: center center;}@mixin background($url: '', $important: '') {  @if $url !='' {    @if ($important !='') {      background-image: url($url) !important;    }    @else {      background-image: url($url);    }  }  background-repeat: no-repeat;  background-size: 100% auto;}</code></pre><p>考虑到改造成本以及雪碧图的接入成本，解决方案是在构建过程中接入了<a href="https://github.com/mixtur/webpack-spritesmith">webpack-spritesmith</a>，优点是</p><ol><li> 构建过程中可根据指定目录自动生成及更新雪碧图与scss文件</li><li> 自动生成的scss文件模版允许自定义化</li><li> 无需手动引入生成的scss文件，可在webpack配置中配置自动引入</li></ol><p>构建配置如下：</p><pre><code class="JS">// 配置代码new SpritesmithPlugin({  src: {    // icon小图标目录    cwd: './src/like/act_30083/assets/img/icon/',    // 合成图片格式    glob: '*.png'  },  target: {    // 合成雪碧图本地文件地址    image: path.resolve(__dirname, './assets/img/sprite-ignore.png'),    css: [      [        // 生成雪碧图样式文件地址        path.resolve(__dirname, './styles/mixins/_sprite-ignore.scss'),        {          // scss文件模板          format: 'function_based_template'        }      ]    ]  },  customTemplates: {    // 自定义模板    'function_based_template': templateFunction,  },  apiOptions: {    // 雪碧图引用地址    cssImageRef: '~@assets/img/sprite-ignore.png',  },  spritesmithOptions: {    // 合成规则    algorithm: 'binary-tree',    // icon之间的距离    padding: 10,  }});</code></pre>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 雪碧图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次伪元素动画引起的webview崩溃</title>
      <link href="/My-Blogs/2021/01/08/css/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BC%AA%E5%85%83%E7%B4%A0%E5%8A%A8%E7%94%BB%E5%BC%95%E8%B5%B7%E7%9A%84webview%E5%B4%A9%E6%BA%83/"/>
      <url>/My-Blogs/2021/01/08/css/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BC%AA%E5%85%83%E7%B4%A0%E5%8A%A8%E7%94%BB%E5%BC%95%E8%B5%B7%E7%9A%84webview%E5%B4%A9%E6%BA%83/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前不久做了一个年终盛典的 h5 移动端活动项目，活动主页有三个排行榜页面，以及任务页面。在测试过程中，测试同事反馈排行榜页面在 android 4.x 的系统下会引起 webview 的崩溃，而且是必现，而任务页面是正常的，这让我纠结了很久，因为本身页面也做了很多的优化，像图片的懒加载，组件的懒加载，排行榜列表虚拟滚动（只渲染屏幕显示部分数据），所以一时也不知道问题在哪里。</p><a id="more"></a><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><p>仔细 review 了一下项目代码，也没发现什么端倪，就只能一点一点注释代码来调试了，发现有一段 css 代码注释掉以后 android 4.x 就正常了。</p><p>于是 google 了一番，发现是伪元素做动画惹的祸，是旧版 chromium 的问题，可以查看<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=364222">官方 issue</a>，crash 代码如下。</p><pre><code class="CSS">@-webkit-keyframes crashChrome {  0% {    -webkit-transform: translateX(0rem);  }}.anim:before {  content: "";  width: 3rem;  height: 3rem;  border-radius: 3rem;  position: absolute;  left: 5rem;  top: 5rem;  background-color: #06839f;  -webkit-animation: crashChrome;}</code></pre><pre><code class="HTML">&lt;div class="anim"&gt;&lt;/div&gt;</code></pre><p>代码一看其实也比较正常，普普通通的的用法，就是一个 before 的伪元素做了一个 一动也不动的 animation 的动画，怎么就会奔溃了呢？</p><p>这个 bug 具体是怎么回事还没想明白，但是问题得解决呀，自己活动页面的奔溃八九不离十就是 before+animation 引起的，用 div 代替 before 先把 bug 解决了。</p><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>这段 crash 的 css 代码确实比较平常，而且写法完全符合 web 的标准，故不应该是代码本身的问题。且在自己本地的开发浏览器中，以及稍微不那么旧的手机里都是正常的，所以断定这个问题因该属于浏览器的 bug，并且在某些旧版浏览器里才有的 bug，后来的新版浏览器已经修复了这个问题。</p><p>拿着会 crash 的手机测试发现，只有满足以下三个条件：伪元素（before，after 等）+ animation + rem，才会 crash。</p><p>所以得出了以下结论，在伪元素里使用 animation 动画，并且动画里有 rem 的变化就会引起了某些版本 webview 的 crash。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个问题与浏览器的底层渲染有关，并且官方没有给出具体哪些版本会受到影响，而在移动段 rem 是比较常规的单位，所以各位同学做项目的时候，就不要在伪元素里写动画。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自适应布局的相关介绍</title>
      <link href="/My-Blogs/2021/01/08/css/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D/"/>
      <url>/My-Blogs/2021/01/08/css/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>我们都知道自适应布局有很多种方式可以实现，下面让我们来看看有哪些方式比较简单？</p><a id="more"></a><h3 id="利用clamp函数"><a href="#利用clamp函数" class="headerlink" title="利用clamp函数"></a>利用clamp函数</h3><p><code>clamp()</code> 通过“限制”或限制最小和最大范围之间的灵活值来工作</p><p>使用方法如下：</p><ul><li>最小值：例如 16px</li><li>弹性值：例如 5vw</li><li>最大值：例如 34px</li></ul><pre><code class="css">h1 {  font-size: clamp(16px, 5vw, 34px);}</code></pre><p>在此示例中，该 h1 font-size 值将是 5% 视口宽度。但前提是该值大于 16px 和小于 34px。</p><p>例如，如果您的视口宽度为 300px，则您的 5vw 值将等于 15px。但是，您将该 font-size 值限制为的最小值 16px，这样就可以了。</p><p>另一方面，如果您的视口宽度为 1400px，则您 5vw 将大声疾呼 70px！但幸运的是，您将该最大值限制为34px，因此它不会超过该最大值 。</p><p><img src="/My-Blogs/images/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D-01.gif" alt="iamge"></p><p>我可以为此模板添加此代码…</p><pre><code class="css">img {  width: clamp(15vw, 800%, 100%);}h1 {  font-size: clamp(20px, 5vw, 35px);}p {  font-size: clamp(10px, 4vw, 20px);}</code></pre><p>实际上，任何其他接受长度，频率，角度，时间，百分比，数字或整数的属性</p><p><img src="/My-Blogs/images/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D-02.png" alt="image"></p><br><h3 id="利用grid布局新特性"><a href="#利用grid布局新特性" class="headerlink" title="利用grid布局新特性"></a>利用<a href="http://1linelayouts.glitch.me/">grid布局新特性</a></h3><br><h4 id="强居中"><a href="#强居中" class="headerlink" title="强居中"></a>强居中</h4><p><img src="/My-Blogs/images/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D-03.png"></p><br><h4 id="三段式布局"><a href="#三段式布局" class="headerlink" title="三段式布局"></a>三段式布局</h4><p><img src="/My-Blogs/images/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D-04.png"></p><br><h4 id="经典布局"><a href="#经典布局" class="headerlink" title="经典布局"></a>经典布局</h4><p><img src="/My-Blogs/images/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D-05.png"></p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冷知识之CSS篇【竖行横书组合】</title>
      <link href="/My-Blogs/2021/01/08/css/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87%E3%80%90%E7%AB%96%E8%A1%8C%E6%A8%AA%E4%B9%A6%E7%BB%84%E5%90%88%E3%80%91/"/>
      <url>/My-Blogs/2021/01/08/css/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87%E3%80%90%E7%AB%96%E8%A1%8C%E6%A8%AA%E4%B9%A6%E7%BB%84%E5%90%88%E3%80%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我们都知道竖书成行，自右向左换行是古文中的一种书写方式。那么在CSS中writing-mode就定义了文本在水平或垂直方向上排列方式。下面我们通过writing-mode这个属性定义一个“竹简”书写方式，同时如果在竖行文本中穿插阿拉伯数字时又当如何？</p></blockquote><a id="more"></a><p>我们要定义竹简的书写方式前，首先回顾下 CSS <code>writing-mode</code> 属性，它是定义文本在水平或垂直方向上如何排列。</p><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87%E3%80%90%E7%AB%96%E8%A1%8C%E6%A8%AA%E4%B9%A6%E7%BB%84%E5%90%88%E3%80%91-01.jpg"></p><p>CSS text-combine-upright 竖行横书组合</p><h3 id="writing-mode语法"><a href="#writing-mode语法" class="headerlink" title="writing-mode语法"></a>writing-mode语法</h3><pre><code class="CSS">writing-mode: horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr</code></pre><ul><li>horizontal-tb：水平方向自上而下的书写方式。</li><li>vertical-rl：垂直方向自右而左的书写方式。</li><li>vertical-lr：垂直方向内内容从上到下，水平方向从左到右。</li><li>sideways-rl：内容垂直方向从上到下排列。</li></ul><p>由此，我们若要定义出“竹简”的书写模式，就可以运用<code>vertical-rl</code>值，垂直方向由右到左。</p><p><strong>示例</strong></p><p>先吟诗一首🤭以此为例开始</p><p>同在屋檐下，惟有偶遇。</p><p>犹如白驹过隙，言之不尽。</p><p>因有时不我与，爬耳搔腮，</p><p>心之不及也。</p><p>—— Lucas</p><pre><code class="CSS">div{  writing-mode: vertical-rl;}</code></pre><pre><code class="HTML">&lt;div&gt;  &lt;p&gt;同在屋檐下，&lt;/p&gt;  &lt;p&gt;惟有偶遇。&lt;/p&gt;  &lt;p&gt;犹如白驹过隙，&lt;/p&gt;  &lt;p&gt;言之不尽，&lt;/p&gt;  &lt;p&gt;因有时不我与，&lt;/p&gt;  &lt;p&gt;爬耳搔腮，&lt;/p&gt;  &lt;p&gt;心之不及也。&lt;/p&gt;  &lt;p&gt;—— DeathGhost&lt;/p&gt;&lt;/div&gt;</code></pre><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87%E3%80%90%E7%AB%96%E8%A1%8C%E6%A8%AA%E4%B9%A6%E7%BB%84%E5%90%88%E3%80%91-02.jpg"></p><p>CSS writing-mode 文本排布</p><p>接下来，我们看看竖行排布中的“意外”。看看下面的图例。</p><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87%E3%80%90%E7%AB%96%E8%A1%8C%E6%A8%AA%E4%B9%A6%E7%BB%84%E5%90%88%E3%80%91-03.jpg"></p><p>CSS 书写模式 <code>writing-mode: vertical-rl</code> （从右到左）</p><p>可以看出，若以中文描述还好，但若加入阿拉伯数字，就显得怪异。</p><p>那么可否将数字转为横向（常规）书写？</p><p>下面我们重点看看CSS中的另一个属性。</p><h3 id="text-combine-upright-竖行横书组合"><a href="#text-combine-upright-竖行横书组合" class="headerlink" title="text-combine-upright 竖行横书组合"></a>text-combine-upright 竖行横书组合</h3><pre><code class="CSS">/* Keyword values */text-combine-upright: none;text-combine-upright: all;/* Digits values */text-combine-upright: digits;text-combine-upright: digits 4;/* Global values */text-combine-upright: inherit;text-combine-upright: initial;text-combine-upright: unset;</code></pre><ul><li><code>none</code>: 没有特殊处理。</li><li><code>all</code>: 试图将元素内的字符水平排列，使其它们在竖行中占据单个字符空间。</li><li><code>digits</code>: 尝试显示一个连续的ASCII数字序列（U + 0030–U + 0039），该序列的字符数少于或等于指定的整数，以致于它在垂直行框中占据单个字符的空间。如果省略整数，则计算结果为2。2-4范围以外的整数无效。</li></ul><p>值 <code>digits</code> 目前浏览器上没有看到效果，这里预先搁置。</p><p>我们要将上述文本中的数字让其横向排列，按属性值就是将其水平排列，让其占据单个字符空间。</p><p>那么，样式文本定义就可以这样：</p><pre><code class="CSS">div{  writing-mode: vertical-rl;  letter-spacing: 1px;}div b{  text-combine-upright: all;  margin: 5px 0;}</code></pre><pre><code class="HTML">&lt;div&gt;  &lt;h1&gt;清朝&lt;/h1&gt;  &lt;p&gt;是中国历史上最后一个封建王朝，&lt;/p&gt;  &lt;p&gt;共传十二帝，&lt;/p&gt;  &lt;p&gt;统治者为满洲爱新觉罗氏。&lt;/p&gt;  &lt;p&gt;从努尔哈赤建立后金起，&lt;/p&gt;  &lt;p&gt;总计&lt;b&gt;296&lt;/b&gt;年。&lt;/p&gt;  &lt;p&gt;从皇太极改国号为清起，国祚&lt;b&gt;276&lt;/b&gt;年。&lt;/p&gt;  &lt;p&gt;建立全国性政权算起为&lt;b&gt;268&lt;/b&gt;年。&lt;/p&gt;&lt;/div&gt;</code></pre><p>对文本中的<b>标签定义<code>text-combine-upright</code>为<code>all</code>即可。</b></p><b><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87%E3%80%90%E7%AB%96%E8%A1%8C%E6%A8%AA%E4%B9%A6%E7%BB%84%E5%90%88%E3%80%91-04.jpg"></p><p>CSS text-combine-upright 竖行横书组合</p><p>虽然如此，但是，它也是有一定的局限性。</p><p>例如，我们将“数字+年”合为一起，或更多文本合为一起，就会看到段尾效果。</p><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87%E3%80%90%E7%AB%96%E8%A1%8C%E6%A8%AA%E4%B9%A6%E7%BB%84%E5%90%88%E3%80%91-05.jpg"></p><p>CSS text-combine-upright 竖行横书组合</p><p>所以，它占据单个字符空间压缩是有一定限制。</p><p>本示例于浏览器 <code>chrome87</code> 版本，详细可阅读<a href="https://drafts.csswg.org/css-writing-modes-4/#text-combine-upright">这里</a>。</p></b>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 冷知识 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冷知识之CSS篇</title>
      <link href="/My-Blogs/2021/01/08/css/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87/"/>
      <url>/My-Blogs/2021/01/08/css/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>CSS的冷知识，你又了解多少呢？</p><a id="more"></a><h3 id="文字模糊效果"><a href="#文字模糊效果" class="headerlink" title="文字模糊效果"></a>文字模糊效果</h3><p>只需要添加以下两行代码，即可达到将文字模糊处理的目的。</p><pre><code class="css">color: transparent;text-shadow: #111 0 0 5px;</code></pre><br><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87-01.png" alt="image"></p><br><h3 id="毛玻璃效果"><a href="#毛玻璃效果" class="headerlink" title="毛玻璃效果"></a>毛玻璃效果</h3><p>其实毛玻璃的模糊效果技术上比较简单，只是用到了 css 滤镜（filter）中的 blur 属性。但是要做一个好的毛玻璃效果，需要注意很多细节。下面提供一个简单示例：</p><pre><code class="css">.blur {  display: block;  width: 300px;  height: 300px;  margin: 100px auto;  filter: blur(10px);}&lt;img src="./img/test.png"class="blur"alt=""&gt;</code></pre><p><img src="/My-Blogs/images/%E5%86%B7%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87-02.png" alt="image"></p><h3 id="CSS中也可以做简单运算"><a href="#CSS中也可以做简单运算" class="headerlink" title="CSS中也可以做简单运算"></a>CSS中也可以做简单运算</h3><p>在日常开发中，我们时常会遇到这样的需求：</p><blockquote><p>左侧或者右侧宽度固定，然后剩余部分自动充满。</p></blockquote><p>可能很多小伙伴会想到用flex布局，通过设置flex:1; 使其自动充满，当然这个做法也是对的，但是我们还有更为简便的方法，那就是利用css的calc函数，示例代码如下：</p><pre><code class="css">.container {  width: calc(100% - 50px);}</code></pre><p><code>calc() </code> 函数用于动态计算长度值。</p><ul><li>需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)；</li><li>任何长度值都可以使用calc()函数进行计算；</li><li>calc()函数支持 “+”, “-“, “*”, “/“ 运算；</li><li>calc()函数使用标准的数学运算优先级规则；</li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 冷知识 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo theme cutie v2.x tutorial</title>
      <link href="/My-Blogs/2018/02/12/hexo/hexo-theme-cutie-v2-tutorial/"/>
      <url>/My-Blogs/2018/02/12/hexo/hexo-theme-cutie-v2-tutorial/</url>
      
        <content type="html"><![CDATA[<p><img src="/My-Blogs/images/tree.png" alt="$cover"></p><p>Theme cutie has evolved from v1.x to v2.x with a refreshed and fine tuned design and more features. Follow the following instruction to install and use it. You may navigate this website to experience the new look and interaction of v2.x.</p><p><strong>Thank you for your stars and support</strong>.</p><a id="more"></a><h1 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h1><h2 id="Install-for-a-new-site"><a href="#Install-for-a-new-site" class="headerlink" title="Install for a new site"></a>Install for a new site</h2><dl><dt>Prerequiste</dt><dd>Make sure you install <code>node.js</code> and <code>hexo</code> through command line. Refer to official Hexo doc for detailed instruction.</dd></dl><dl><dt>Working directory</dt><dd>Make sure your terminal (command line) is currently in the folder where you want to create the site.</dd></dl><dl><dt>Installation steps</dt><dd>The first step is the standard hexo installation step. If you have done them, skip to step 2.<br>    1. Initialize your site<br>    <code>bash     hexo init your-site-folder     cd your-site-folder     npm install     </code><br>    2. [<em>Optional</em>][<em>Recommended</em>] Uninstall <code>hexo-renderer-marked</code> and install <code>hexo-renderer-markdown-it</code> and associated plugins.<br>    <code>bash     npm un hexo-renderer-marked --save     npm i hexo-renderer-markdown-it --save     npm i markdown-it-emoji --save     npm i markdown-it-mark --save     npm i markdown-it-deflist --save     npm i markdown-it-container --save     </code></dd></dl><pre><code>3. Download [latest theme cutie](https://github.com/qutang/hexo-theme-cutie/releases/latest) and unzip it to `themes/` folder in your site. Then rename it to `cutie`.</code></pre><dl><dt>Initial configuration file</dt><dd><code>_config.yml</code> in the root path of your site.</dd></dl><dl><dt>Initial configuration</dt><dd>1. Follow standard hexo initial configuration: <a href="https://hexo.io/docs/configuration.html">https://hexo.io/docs/configuration.html</a><br>    2. Add variables or modify the variables in your <code>_config.yml</code> according to following snippet.</dd></dl><pre><code>    ```yml _config.yml    highlight:      enable: true      line_number: true      auto_detect: false      tab_replace:     markdown:      render:        html: true        xhtmlOut: false        breaks: false        linkify: true        typographer: true        quotes: '“”‘’'      plugins:        - markdown-it-abbr        - markdown-it-footnote        - markdown-it-ins        - markdown-it-sub        - markdown-it-sup        - markdown-it-deflist      anchors:        level: 1        collisionSuffix: 'v'        permalink: false        permalinkClass: header-anchor        permalinkSymbol: ""        permalinkBefore: false    date_format: ll    archive_generator:      per_page: 0      yearly: true      monthly: false      daily: false    theme: cutie    ```</code></pre><dl><dt>Bring site alive</dt><dd><code>bash     hexo s --debug     </code></dd></dl><h2 id="Install-for-an-existing-site"><a href="#Install-for-an-existing-site" class="headerlink" title="Install for an existing site"></a>Install for an existing site</h2><dl><dt>Working directory</dt><dd>Make sure your terminal (command line) is currently in the root folder of the site.</dd></dl><p>Installation steps<br>:</p><ol><li><p>[<em>Optional</em>][<em>Recommended</em>] Uninstall <code>hexo-renderer-marked</code> and install <code>hexo-renderer-markdown-it</code> and associated plugins.</p><pre><code> ```bash npm un hexo-renderer-marked --save npm i hexo-renderer-markdown-it --save npm i markdown-it-emoji --save npm i markdown-it-mark --save npm i markdown-it-deflist --save npm i markdown-it-container --save ```</code></pre></li><li><p>Download <a href="https://github.com/qutang/hexo-theme-cutie/releases/latest">latest theme cutie</a><br>and unzip it to <code>themes/</code> folder in your site. Then rename it to <code>cutie</code>.</p></li></ol><dl><dt>Initial configuration file</dt><dd><code>_config.yml</code> in the root path of your site.</dd></dl><dl><dt>Initial configuration</dt><dd>1. Follow standard hexo initial configuration: <a href="https://hexo.io/docs/configuration.html">https://hexo.io/docs/configuration.html</a><br>    2. Add variables or modify the variables in your <code>_config.yml</code> according to following snippet.</dd></dl><pre><code>    ```yml _config.yml    highlight:      enable: true      line_number: true      auto_detect: false      tab_replace:     markdown:      render:        html: true        xhtmlOut: false        breaks: false        linkify: true        typographer: true        quotes: '“”‘’'      plugins:        - markdown-it-abbr        - markdown-it-footnote        - markdown-it-ins        - markdown-it-sub        - markdown-it-sup        - markdown-it-deflist      anchors:        level: 1        collisionSuffix: 'v'        permalink: false        permalinkClass: header-anchor        permalinkSymbol: ""        permalinkBefore: false    date_format: ll    archive_generator:      per_page: 0      yearly: true      monthly: false      daily: false    theme: cutie    ```</code></pre><dl><dt>Bring site alive</dt><dd><code>bash     hexo s --debug     </code></dd></dl><h1 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h1><h2 id="From-v2-x"><a href="#From-v2-x" class="headerlink" title="From v2.x"></a>From v2.x</h2><dl><dt>Installation steps</dt><dd>1. Delete <code>themes/cutie/</code> folder in your site.<br>    2. Download the desired version of theme cutie from <a href="https://github.com/qutang/hexo-theme-cutie/releases">release page</a>, unzip it to <code>themes/</code> folder and rename it to <code>cutie</code>.</dd></dl><dl><dt>Notes</dt><dd>There is a mimimal version requirement for each configuration, make sure your installed version is above it to use the corresponding configuration.</dd></dl><h2 id="From-v1-x"><a href="#From-v1-x" class="headerlink" title="From v1.x"></a>From v1.x</h2><dl><dt>Installation steps</dt><dd>1. Delete <code>themes/cutie/</code> folder in your site.<br>    2. Download the desired version of theme cutie from <a href="https://github.com/qutang/hexo-theme-cutie/releases">release page</a>, unzip it to <code>themes/</code> folder and rename it to <code>cutie</code>.</dd></dl><dl><dt>Configuration</dt><dd>From v2.x, theme cutie uses <em>Hexo data file</em> (<code>sources/_data/cutie.yml</code>) to store all configurations, instead of using the <code>_config.yml</code> file of your site in v1.x. And the YAML structure has changed compared to v1.x. </dd></dl><pre><code>The recommendation is to configure the theme cutie from scratch using the following configuration guidelines.You may copy or reuse some configurations about theme cutie in your old `_config.yml` along the way. Please post an issue if you have hard time migrating your configurations from v1.x to v2.x.</code></pre><h1 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h1><h2 id="Language"><a href="#Language" class="headerlink" title="Language"></a>Language</h2><dl><dt>Minimal version</dt><dd><em>Taurus</em>: <code>v2.0.0-alpha</code></dd></dl><dl><dt>Configuration file</dt><dd><code>_config.yml</code> of site</dd></dl><dl><dt>Configuration format</dt><dd>Set <code>language</code> variable in your site’s <code>_config.yml</code> file.</dd></dl><pre><code>```yml _config.ymllanguage:- en- zh-cn- it```The first row will be your site's default language.</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted, the default setting is <code>en</code>. Site will be displayed in English.</dd></dl><dl><dt>Notes</dt><dd>Currently, theme cutie only supports three languages: English, Italian and 简体中文.</dd></dl><dl><dt>Contributions</dt><dd>1. Italian translation is contributed by <a href="https://github.com/Fastbyte01">@fastbyte01</a><br>    2. More translation is welcomed if you are interested in contribution. You may add new language files in <code>themes/cutie/languages</code> folder according to Hexo’s guideline: <a href="https://hexo.io/docs/internationalization.html">https://hexo.io/docs/internationalization.html</a> and feel free to send me pull request.</dd></dl><h2 id="Scheme"><a href="#Scheme" class="headerlink" title="Scheme"></a>Scheme</h2><p>This concept is from <code>hexo-theme-next</code>, the most popular theme for Hexo, in which it uses different themes for different layout design. In theme cutie, it follows the similar idea and provides the opportunity to choose different layout design using scheme.</p><dl><dt>Minimal version</dt><dd><em>Taurus</em>: <code>v2.0.0-alpha</code></dd></dl><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Set <code>scheme</code> variable to scheme name to enable a theme scheme.</dd></dl><pre><code>```yml source/_data/cutie.ymlglobal:  scheme: Taurus # Avaliable values: Taurus```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted, the default setting is <code>Taurus</code>, scheme <code>Taurus</code> is enabled.</dd></dl><dl><dt>Notes</dt><dd>Currently, theme cutie only has <code>Taurus</code> theme, which is a two-column text-icon-based layout. Contribution is welcomed from developers or designers for new schemes.</dd></dl><dl><dt>For contributors</dt><dd>1. To add a new scheme, create a new file <code>your-scheme-name.css</code> in folder <code>themes/cutie/source/css/</code> and add your own scheme style in it.<br>    2. The system will automatically search for this css file and load it using the theme name <code>your-scheme-name</code> when changing the scheme configuration to <code>your-scheme-name</code>.</dd></dl><h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><dl><dt>Minimal version</dt><dd><code>v2.0.5-beta</code></dd></dl><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Set <code>use_animation</code> to <code>true</code> or <code>false</code> to enable or disable site animations.</dd></dl><pre><code>```yml source/_data/cutie.ymlglobal:  use_animation: true # Avaliable values: true, false```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted, the default setting is <code>true</code>, animation is enabled.</dd></dl><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><p>Theme cutie uses in-site search for the site. Use following steps to setup search page. Google custom search has been discarded since <code>v2.0.7</code>.</p><dl><dt>Minimal version</dt><dd><code>v2.0.7</code></dd></dl><dl><dt>Configuration steps</dt><dd>1. No need for configuration, work out of box.<br>    2. If you are upgrading from versions below <code>v2.0.7</code>, delete the old search page you created for your site.</dd></dl><h2 id="404-Page"><a href="#404-Page" class="headerlink" title="404 Page"></a>404 Page</h2><p>Theme cutie uses built-in 404 page. It supports a custom 404 art or tencent 404 charity page (腾讯404公益).</p><dl><dt>Minimal version</dt><dd><code>v2.0.7</code></dd></dl><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration steps</dt><dd>1. Delete the old <code>404.md</code> file of your site if you are upgrading from versions before <code>v2.0.7</code>.<br>    2. No need for configuration, work out of box.<br>    3. You may configure the built-in 404 page to use 腾讯公益404 or not, by default it is NOT using 腾讯公益404.</dd></dl><pre><code>```yml source/_data/cutie.yml# set true to enable 腾讯公益404page_404:  tencent_404: true```</code></pre><h2 id="Social-network-links"><a href="#Social-network-links" class="headerlink" title="Social network links"></a>Social network links</h2><dl><dt>Minimal version</dt><dd><code>v2.0.0-alpha</code></dd></dl><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Add social network names and links in the following format. Make sure the social network name matches the corresponding font awesome icon name. See <a href="https://fontawesome.com/icons?d=gallery&amp;s=brands">here</a> for the supported names and their icons.</dd></dl><pre><code>```yml source/_data/cutie.yml# As long as the name matches the font awesome icon name, you can add even more social linkssocial:  github: https://github.com/qutang  linkedin: https://www.linkedin.com/in/qutang```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted. No icons will be shown at the bottom right corner in the footer.</dd></dl><h2 id="Site-announcement"><a href="#Site-announcement" class="headerlink" title="Site announcement"></a>Site announcement</h2><dl><dt>Minimal version</dt><dd><code>v2.0.7</code></dd></dl><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration steps</dt><dd>1. Site announcement will display at the bottom left corner of home page as a purple box.<br>    2. Add following snippets to the configuration file to use, if omitted, site announcement is disabled.</dd></dl><pre><code>```yml source/_data/cutie.ymlglobal:  announcement:    text: This is a sample site announcement.```</code></pre><dl><dt>Notes</dt><dd>* The timeout duration for site announcement is 10s. The announcement popup will dismiss on click or on timeout.<br>    * You may use HTML markups in the announcement text. For example, you may add a link to the text.</dd></dl><h2 id="Site-header"><a href="#Site-header" class="headerlink" title="Site header"></a>Site header</h2><h3 id="Setup-site-logo"><a href="#Setup-site-logo" class="headerlink" title="Setup site logo"></a>Setup site logo</h3><dl><dt>Minimal version</dt><dd><code>v2.0.0-alpha</code></dd></dl><dl><dt>Configuration file</dt><dd><code>sources/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Set variable <code>logo</code> to your own icon’s link. Link can be either an external image link, or a relative link.</dd></dl><pre><code>```yml source/_data/cutie.ymllogo: /images/logo.svg```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted. the following image will be used as the logo image.</dd></dl><pre><code>![theme-icon](/images/logo.svg)</code></pre><h3 id="Setup-site-name-and-subtitle"><a href="#Setup-site-name-and-subtitle" class="headerlink" title="Setup site name and subtitle"></a>Setup site name and subtitle</h3><dl><dt>Minimal version</dt><dd><code>v2.0.0-alpha</code></dd></dl><dl><dt>Configuration file</dt><dd><code>_config.yml</code> of your site</dd></dl><dl><dt>Configuration format</dt><dd>Make sure your subtitle is not too log (better less than 30 characters).</dd></dl><pre><code>`title` is a standard Hexo configuration.`subtitle` is theme cutie's own configuration.```yml source/_data/cutie.ymltitle: Your site's titlesubtitle: Your site's subtitle```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted. You will not see any texts in the header.</dd></dl><dl><dt>Note</dt><dd>This configuration requires restarting the server.</dd></dl><h3 id="Setup-navigation-menu"><a href="#Setup-navigation-menu" class="headerlink" title="Setup navigation menu"></a>Setup navigation menu</h3><dl><dt>Minimal version</dt><dd><code>v2.0.0-alpha</code></dd></dl><dl><dt>Configuration file</dt><dd><code>sources/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Add navigation item in the following format. link and icon can be external or internal. You can literally add any link to it.</dd></dl><pre><code>```yml source/_data/cutie.ymlmenu:  Resume:     link: /resume/  "Menu item":    link: /aaa/```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted. No text links will show up in the header navigation menu or in the dropdown menu on any view.</dd></dl><dl><dt>Notes</dt><dd>1. If there are more than four menu items, only the first four will be shown in the header (on desktop view). However, you can find all menu items in the last dropdown menu.<br>    2. Do not use a very long menu item name. No more than three words, because there is some display issue when the name gets long.<br>    3. Compared with <code>v1.x</code>, menu icon is no longer supported.</dd></dl><h2 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h2><h3 id="Use-Light-Gallery"><a href="#Use-Light-Gallery" class="headerlink" title="Use Light Gallery"></a>Use Light Gallery</h3><p>Theme cutie uses <a href="">Light Gallery</a> to support image modal display for <em>posts</em>. By default, it is enabled, but if you want to use other hexo plugins with similar functionality, you may want to disable it.</p><dl><dt>Minimal version</dt><dd><code>v2.0.5-beta</code></dd></dl><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Set <code>use_lightgallery</code> to be <code>true</code> or <code>false</code> to enable or disable light gallery display for post images.</dd></dl><pre><code>```yml source/_data/cutie.ymlpost:  use_lightgallery: true```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted, by default light gallery is enabled for all posts.</dd></dl><dl><dt>Notes</dt><dd>It is currently not supported to enable or disable light gallery for an individual post.</dd></dl><h3 id="Use-post-version"><a href="#Use-post-version" class="headerlink" title="Use post version"></a>Use post version</h3><p>Theme cutie supports versioned post. Whenever the content of your post changes after you push your site, your visitors will see an unread badge on the post card in home page and archive pages.</p><p>Theme cutie uses Hashing and Cookie to track the post content change and the post content a visitor has last read. This feature does NOT use <code>leancloud</code> backend.</p><dl><dt>Minimal version</dt><dd><code>v2.0.8</code></dd></dl><h4 id="For-all-posts"><a href="#For-all-posts" class="headerlink" title="For all posts"></a>For all posts</h4><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Set <code>enable_unread_badge</code> to be <code>true</code> to enable post versioning and unread badge or <code>false</code> to disable this feature for all the posts.</dd></dl><pre><code>```yml source/_data/cutie.yml---post:  enable_unread_badge: false---```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted, by default this feature is <strong>disabled</strong> for all posts.</dd></dl><h4 id="For-an-individual-post"><a href="#For-an-individual-post" class="headerlink" title="For an individual post"></a>For an individual post</h4><dl><dt>Configuration file</dt><dd>A post’s front matter</dd></dl><dl><dt>Configuration format</dt><dd>Set <code>enable_unread_badge</code> to be <code>true</code> to enable post versioning and unread badge or <code>false</code> to disable this feature for the individual post.</dd></dl><pre><code>```yml post's front matter---enable_unread_badge: true---```</code></pre><dl><dt>Default configuration</dt><dd>If configuration is omitted, the setting will roll back to the unread badge setting for all the posts.</dd></dl><dl><dt>Notes</dt><dd>This setting has higher priority than the setting for all the posts.</dd></dl><h3 id="Setup-TOC-level"><a href="#Setup-TOC-level" class="headerlink" title="Setup TOC level"></a>Setup TOC level</h3><p>*[TOC]: Table of content</p><dl><dt>Minimal version</dt><dd><code>v2.0.5-beta</code></dd></dl><h4 id="For-all-posts-1"><a href="#For-all-posts-1" class="headerlink" title="For all posts"></a>For all posts</h4><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Set <code>toc_level</code> under <code>post</code> to set the maximum level of headings in TOC for <em>all posts</em>. Allowed value is from <code>1</code> to <code>6</code>.</dd></dl><pre><code>```yml source/_data/cutie.ymlpost:  toc_level: 2```</code></pre><dl><dt>Default configuration</dt><dd>If this configuration is omitted, by default maximum TOC level is set to 2 (meaning <code>##</code> in markdown).</dd></dl><h4 id="For-an-individual-post-1"><a href="#For-an-individual-post-1" class="headerlink" title="For an individual post"></a>For an individual post</h4><dl><dt>Configuration file</dt><dd>A post’s front matter</dd></dl><dl><dt>Configuration format</dt><dd>Use variable <code>toc_level</code> to set the maximum level of headings in TOC for <em>an individual posts</em>. Allowed value is from <code>1</code> to <code>6</code>.</dd></dl><pre><code>```yml---toc_level: 2---```</code></pre><dl><dt>Default configuration</dt><dd>If variable is omitted in the post front matter, setting will fall back to the <a href="#for-all-posts">all-post-toc-setting</a>.</dd></dl><h3 id="Setup-post-comment"><a href="#Setup-post-comment" class="headerlink" title="Setup post comment"></a>Setup post comment</h3><dl><dt>Minimal version</dt><dd><code>v2.0.5-beta</code></dd></dl><h4 id="For-all-posts-2"><a href="#For-all-posts-2" class="headerlink" title="For all posts"></a>For all posts</h4><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Set <code>allow_comment</code> to be <code>true</code> or <code>false</code> to enable or disable comment section to be displayed for <em>all posts</em>.</dd></dl><pre><code>```yml source/_data/cutie.ymlpost:  allow_comment: true```</code></pre><dl><dt>Default configuration</dt><dd>If this configuration is omitted, by default comment section is enabled for all posts.</dd></dl><h4 id="For-an-individual-post-2"><a href="#For-an-individual-post-2" class="headerlink" title="For an individual post"></a>For an individual post</h4><dl><dt>Configuration file</dt><dd>A post’s front matter</dd></dl><dl><dt>Configuration format</dt><dd>Use variable <code>allow_comment</code> to enable or disable comment section.</dd></dl><pre><code>```yml---allow_comment: true---```</code></pre><dl><dt>Default configuration</dt><dd>If variable is omitted in the post front matter, setting will fall back to the <a href="#for-all-posts-v2">all-post-comment-setting</a>.</dd></dl><h3 id="Setup-post-copyright"><a href="#Setup-post-copyright" class="headerlink" title="Setup post copyright"></a>Setup post copyright</h3><dl><dt>Minimal version</dt><dd><code>v2.0.5-beta</code></dd></dl><p>Theme cutie uses Creative Commons licenses for copyright configuration. We use three nested variables to cover the major licenses in Creative Commons.</p><ul><li><code>allow_share</code>: allow post to be shared (<code>true</code>) or not (<code>false</code>).<ul><li><code>allow_modification</code>: allow post to be modified while sharing when <code>true</code>.</li><li><code>allow_commercial</code>: allow post to be used for commercial purpose while sharing when <code>true</code>.</li></ul></li></ul><p>if <code>allow_share</code> is <code>false</code>, the other two variables will be ignored.</p><h4 id="For-all-posts-3"><a href="#For-all-posts-3" class="headerlink" title="For all posts"></a>For all posts</h4><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Use the three variables under <code>post</code> to configure the all-post copyright setting.</dd></dl><pre><code>```yml source/_data/cutie.ymlpost:  allow_share: true  allow_modification: false  allow_commercial: false```</code></pre><dl><dt>Default configuration</dt><dd>If any of these configurations is omitted, the default setting for each one will fall back to following settings,<br>    * <code>allow_share: true</code>, by default allowing sharing all posts.<br>        * <code>allow_modification: false</code>, by default post is not allowed to be modified while sharing.<br>        * <code>allow_commercial: false</code>, by default post is not allowed to be used for commercial purposes while sharing.</dd></dl><pre><code>The corresponding default Creative Commons license is _CC BY-NC-ND 4.0_.</code></pre><h4 id="For-an-individual-post-3"><a href="#For-an-individual-post-3" class="headerlink" title="For an individual post"></a>For an individual post</h4><dl><dt>Configuration file</dt><dd>A post’s front matter</dd></dl><dl><dt>Configuration format</dt><dd>Use the same three variables to configure copyright setting for a specific post.</dd></dl><pre><code>```yml---allow_share: trueallow_modification: falseallow_commercial: false---```</code></pre><dl><dt>Default configuration</dt><dd>If any of these variables is omitted in the post front matter, setting will fall back to the <a href="#for-all-posts-v3">all-post copyright setting</a>.</dd></dl><h3 id="Enable-post-visit-and-comment-counts"><a href="#Enable-post-visit-and-comment-counts" class="headerlink" title="Enable post visit and comment counts"></a>Enable post visit and comment counts</h3><dl><dt>Minimal version</dt><dd><code>v2.0.5-beta</code></dd></dl><dl><dt>Prerequiste</dt><dd>This functionality only works when you use <code>valine</code> as <a href="#comment-systems">comment system</a> and use <code>leancloud</code> as backend.</dd></dl><dl><dt>Configuration steps</dt><dd>1. Configure <code>valine</code> comment system as described <a href="#configuration-for-valine-comment-system">here</a>.<br>    2. You are all set and post visit counts and post comment counts will appear in all related pages.</dd></dl><dl><dt>Notes</dt><dd>* <em>If backend is not set up properly, icons that show post visit and comment counts will be hidden.</em><br>    * Post visit counts only <strong>unique</strong> visitors (meaning visitors with unique IPs).</dd></dl><h3 id="Enable-post-thumb-up"><a href="#Enable-post-thumb-up" class="headerlink" title="Enable post thumb up"></a>Enable post thumb up</h3><dl><dt>Minimal version</dt><dd><code>v2.1.0</code></dd></dl><dl><dt>Prerequiste</dt><dd>This functionality only works when you use <code>valine</code> as <a href="#comment-systems">comment system</a> and use <code>leancloud</code> as backend.</dd></dl><dl><dt>Configuration steps</dt><dd>1. Configure <code>valine</code> comment system as described <a href="#configuration-for-valine-comment-system">here</a>.<br>    2. You are all set and post thumb up and thumb up counts will appear in all related pages.</dd></dl><dl><dt>Notes</dt><dd>* <em>If backend is not set up properly, icons that show post thumbup status and counts will be hidden.</em><br>    * Post thumb up counts only <strong>unique</strong> visitors (meaning visitors with unique IPs).</dd></dl><h3 id="Use-post-announcement"><a href="#Use-post-announcement" class="headerlink" title="Use post announcement"></a>Use post announcement</h3><dl><dt>Minimal version</dt><dd><code>v2.0.7</code></dd></dl><dl><dt>Configuration file</dt><dd>post’s front matter</dd></dl><dl><dt>Configuration steps</dt><dd>Use following snippet to add your post annoucement</dd></dl><pre><code>```yml post's front matter---announcement:  text: This is a sample post announcement!---```</code></pre><dl><dt>Notes</dt><dd>* The default timeout for the announcement is 10 seconds. Note configurable for now.<br>    * You may use HTML markups in the announcement text.</dd></dl><h3 id="Set-post-excerpt"><a href="#Set-post-excerpt" class="headerlink" title="Set post excerpt"></a>Set post excerpt</h3><p>The post excerpt, displayed in the index page card on hover, may be manually set through front matter or adding the <code>&lt;!-- more --&gt;</code> tag plugin in the post.</p><dl><dt>Minimal version</dt><dd><code>v2.0.11</code></dd></dl><dl><dt>Configuration file</dt><dd>post’s front matter, or tag plugin</dd></dl><dl><dt>Configuration waterfall</dt><dd><code>abstract</code> variable in the front matter has the highest priority if set.</dd></dl><pre><code>```yml post's front matter---abstract: A sample excerpt.---```If `abstract` is not set, theme cutie will search `&lt;!-- more --&gt;` tag in the post content to identify the excerpt section and cut off the first 150 characters to be used as excerpt.If both `abstract` and `&lt;!-- more --&gt;` are omitted, theme cutie will automatically chunk the first 150 characters in the post content to be used as excerpt.</code></pre><h3 id="Set-post-icon"><a href="#Set-post-icon" class="headerlink" title="Set post icon"></a>Set post icon</h3><p>The post icon, displayed on the top left cornder of the index page card, may be manually set through front matter in the post.</p><dl><dt>Minimal version</dt><dd><code>v2.0.0</code></dd></dl><dl><dt>Configuration file</dt><dd>post’s front matter</dd></dl><dl><dt>Configuration waterfall</dt><dd>If <code>icon</code> variable in the post front matter is set, the system will use this icon for post.</dd></dl><pre><code>```yml post's front matter---icon: /your/post/icon/path---```I recommend you to use absolute path (starting with `/`) for the image path.If `icon` variable is not set, but post belongs to category `notes` or `projects`, the system will use the default category icon for the post.If both conditions are not satisified, the system will use a randomly generated texture image for the post.</code></pre><h2 id="Icon-sets"><a href="#Icon-sets" class="headerlink" title="Icon sets"></a>Icon sets</h2><h3 id="Select-an-icon-set"><a href="#Select-an-icon-set" class="headerlink" title="Select an icon set"></a>Select an icon set</h3><dl><dt>Minimal version</dt><dd><code>v2.0.5-beta</code></dd></dl><dl><dt>Configuration file</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd>Change icon set by changing the name of the icon set in the following snippet. There are three available icon sets in the theme by default: <code>blue-line</code>, <code>blue-shadow</code>, and <code>colorful-outlined</code>.</dd></dl><pre><code>```yml source/_data/cutie.ymlglobal:  icon_set: blue-line # Available values in theme: blue-line, blue-shadow, colorful-outlined```</code></pre><dl><dt>Default configuration</dt><dd><code>blue-line</code></dd></dl><p>Illustration</p><h3 id="Add-a-new-icon-set"><a href="#Add-a-new-icon-set" class="headerlink" title="Add a new icon set"></a>Add a new icon set</h3><dl><dt>Minimal version</dt><dd><code>v2.0.5-beta</code></dd></dl><dl><dt>Configuration path</dt><dd><code>source/images/</code></dd></dl><dl><dt>Configuration steps</dt><dd>1. Create a folder named <code>icons</code> in <code>source/images/</code> folder.<br>    2. Create an icon set folder <code>icon-set-name</code>(change it to your desired name) in <code>source/images/icons/</code> folder.<br>    3. Add your own four icons (keep the filename consistent) in <code>svg</code> format to <code>source/images/icons/icon-set-name/</code> folder.<br>        1. <code>search.svg</code><br>        2. <code>archive.svg</code><br>        3. <code>menu.svg</code><br>        4. <code>toc.svg</code><br>    4. Use your new icon set name <code>icon-set-name</code> in <a href="#select-an-existing-icon-set">Select an existing icon set</a></dd></dl><h2 id="Comment-systems"><a href="#Comment-systems" class="headerlink" title="Comment systems"></a>Comment systems</h2><h3 id="Select-comment-systems"><a href="#Select-comment-systems" class="headerlink" title="Select comment systems"></a>Select comment systems</h3><dl><dt>Minimal version</dt><dd><code>v2.0.0-alpha</code></dd></dl><dl><dt>User configuration location</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd><code>yml comment system     global:       comment_system: valine # Available values: valine, gitment, disqus     </code></dd></dl><dl><dt>Possible values</dt><dd><code>valine</code>(default), <code>gitment</code>, <code>disqus</code>, <code>livere</code></dd></dl><p>After selecting one of the comment systems, you need to further configure it.</p><h3 id="Configuration-for-valine-comment-system"><a href="#Configuration-for-valine-comment-system" class="headerlink" title="Configuration for valine comment system"></a>Configuration for valine comment system</h3><dl><dt>Minimal version</dt><dd><code>v2.0.0-alpha</code></dd></dl><dl><dt>User configuration location</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd><code>yml valine configuration     valine:       appId:       appKey:       placeholder:     </code><br>    See <a href="https://valine.js.org/">https://valine.js.org</a> to setup the backend and fill the values.</dd></dl><dl><dt>Default values</dt><dd>No default values, must fill if using the system.</dd></dl><h3 id="Configuration-for-gitment-comment-system"><a href="#Configuration-for-gitment-comment-system" class="headerlink" title="Configuration for gitment comment system"></a>Configuration for gitment comment system</h3><dl><dt>Minimal version</dt><dd><code>v2.0.0-alpha</code></dd></dl><dl><dt>User configuration location</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd><code>yml gitment configuration     gitment:       owner:       repo:       client_id:       client_secret:     </code><br>    See <a href="https://github.com/imsun/gitment">https://github.com/imsun/gitment</a> to setup the backend and fill the values.</dd></dl><dl><dt>Default values</dt><dd>No default values, must fill if using the system.</dd></dl><h3 id="Configuration-for-Disqus-comment-system"><a href="#Configuration-for-Disqus-comment-system" class="headerlink" title="Configuration for Disqus comment system"></a>Configuration for Disqus comment system</h3><dl><dt>Minimal version</dt><dd><code>v2.0.0-alpha</code></dd></dl><dl><dt>User configuration location</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd><code>yml disqus configuration     disqus:       shortname:     </code><br>    See <a href="https://help.disqus.com/customer/portal/articles/466208-what-s-a-shortname-">https://help.disqus.com/customer/portal/articles/466208-what-s-a-shortname-</a> to setup the backend and fill the value.</dd></dl><dl><dt>Default values</dt><dd>No default values, must fill if using the system.</dd></dl><h3 id="Configuration-for-Livere-comment-system"><a href="#Configuration-for-Livere-comment-system" class="headerlink" title="Configuration for Livere comment system"></a>Configuration for Livere comment system</h3><dl><dt>Minimal version</dt><dd><code>v2.0.11</code></dd></dl><dl><dt>User configuration location</dt><dd><code>source/_data/cutie.yml</code></dd></dl><dl><dt>Configuration format</dt><dd><code>yml livere configuration     livere:       id: 'city' # use 'city' if using free version or `premium` if using paid version       uid:      </code><br>    The <code>uid</code> is the string you will see in the snippet provided by livere during installation, as shown in the following screenshot.</dd></dl><pre><code>![Livere setup screenshot](livere_setup.png)</code></pre><dl><dt>Default values</dt><dd>No default values, must fill if using the system.</dd></dl>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> cutie </tag>
            
            <tag> tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typography and tags</title>
      <link href="/My-Blogs/2017/12/20/hexo/Typography%20and%20tags/"/>
      <url>/My-Blogs/2017/12/20/hexo/Typography%20and%20tags/</url>
      
        <content type="html"><![CDATA[<p><img src="/My-Blogs/images/lake.png" alt="$cover"></p><h1 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h1><hr><p>This post uses <code>hexo-renderer-markdown-it</code> plugin as markdown processor, so please install it to achieve the effect.</p><pre><code class="bash">npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --savenpm i markdown-it-emoji --savenpm i markdown-it-mark --savenpm i markdown-it-deflist --savenpm i markdown-it-container --save</code></pre><h1 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h1><p>Add following to <code>_config.yml</code> of your site.</p><pre><code class="yml">markdown:  render:    html: true    xhtmlOut: false    breaks: false    linkify: true    typographer: true    quotes: '“”‘’'  plugins:    - markdown-it-abbr    - markdown-it-footnote    - markdown-it-ins    - markdown-it-sub    - markdown-it-sup    - markdown-it-deflist  anchors:    level: 2    collisionSuffix: 'v'    permalink: false    permalinkClass: header-anchor    permalinkSymbol: " "    permalinkBefore: false</code></pre><h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><hr><h2 id="Headings"><a href="#Headings" class="headerlink" title="Headings"></a>Headings</h2><pre><code class="markdown"># h1 Heading 8-)## h2 Heading### h3 Heading#### h4 Heading##### h5 Heading###### h6 Heading</code></pre><h1 id="h1-Heading-8"><a href="#h1-Heading-8" class="headerlink" title="h1 Heading 8-)"></a>h1 Heading 8-)</h1><h2 id="h2-Heading"><a href="#h2-Heading" class="headerlink" title="h2 Heading"></a>h2 Heading</h2><h3 id="h3-Heading"><a href="#h3-Heading" class="headerlink" title="h3 Heading"></a>h3 Heading</h3><h4 id="h4-Heading"><a href="#h4-Heading" class="headerlink" title="h4 Heading"></a>h4 Heading</h4><h5 id="h5-Heading"><a href="#h5-Heading" class="headerlink" title="h5 Heading"></a>h5 Heading</h5><h6 id="h6-Heading"><a href="#h6-Heading" class="headerlink" title="h6 Heading"></a>h6 Heading</h6><h2 id="Horizontal-Rules"><a href="#Horizontal-Rules" class="headerlink" title="Horizontal Rules"></a>Horizontal Rules</h2><pre><code class="markdown">___---***</code></pre><hr><hr><hr><h2 id="Typographic-replacements"><a href="#Typographic-replacements" class="headerlink" title="Typographic replacements"></a>Typographic replacements</h2><pre><code class="markdown">(c) (C) (r) (R) (tm) (TM) (p) (P) +-test.. test... test..... test?..... test!....!!!!!! ???? ,,  -- ---"Smartypants, double quotes" and 'single quotes'</code></pre><p>(c) (C) (r) (R) (tm) (TM) (p) (P) +-</p><p>test.. test… test….. test?….. test!….</p><p>!!!!!! ???? ,,  – —</p><p>“Smartypants, double quotes” and ‘single quotes’</p><h2 id="Emphasis"><a href="#Emphasis" class="headerlink" title="Emphasis"></a>Emphasis</h2><pre><code class="markdown">**This is bold text**__This is bold text__*This is italic text*_This is italic text_~~Strikethrough~~</code></pre><p><strong>This is bold text</strong></p><p><strong>This is bold text</strong></p><p><em>This is italic text</em></p><p><em>This is italic text</em></p><p><del>Strikethrough</del></p><h2 id="Blockquotes"><a href="#Blockquotes" class="headerlink" title="Blockquotes"></a>Blockquotes</h2><pre><code class="markdown">&gt; Blockquotes can also be nested...&gt;&gt; ...by using additional greater-than signs right next to each other...&gt; &gt; &gt; ...or with spaces between arrows.</code></pre><blockquote><p>Blockquotes can also be nested…</p><blockquote><p>…by using additional greater-than signs right next to each other…</p><blockquote><p>…or with spaces between arrows.</p></blockquote></blockquote></blockquote><h2 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h2><h3 id="Unordered"><a href="#Unordered" class="headerlink" title="Unordered"></a>Unordered</h3><pre><code class="markdown">+ Create a list by starting a line with `+`, `-`, or `*`+ Sub-lists are made by indenting 2 spaces:  - Marker character change forces new list start:    * Ac tristique libero volutpat at    + Facilisis in pretium nisl aliquet    - Nulla volutpat aliquam velit+ Very easy!</code></pre><ul><li>Create a list by starting a line with <code>+</code>, <code>-</code>, or <code>*</code></li><li>Sub-lists are made by indenting 2 spaces:<ul><li>Marker character change forces new list start:<ul><li>Ac tristique libero volutpat at</li></ul><ul><li>Facilisis in pretium nisl aliquet</li></ul><ul><li>Nulla volutpat aliquam velit</li></ul></li></ul></li><li>Very easy!</li></ul><h3 id="Ordered"><a href="#Ordered" class="headerlink" title="Ordered"></a>Ordered</h3><pre><code class="markdown">1. Lorem ipsum dolor sit amet  1. Indented list    1. Another level  2. Indent2. Consectetur adipiscing elit3. Integer molestie lorem at massa</code></pre><ol><li>Lorem ipsum dolor sit amet</li><li>Indented list<ol><li>Another level</li></ol></li><li>Indent</li><li>Consectetur adipiscing elit</li><li>Integer molestie lorem at massa</li></ol><pre><code class="markdown">1. You can use sequential numbers...1. ...or keep all the numbers as `1.`</code></pre><ol><li>You can use sequential numbers…</li><li>…or keep all the numbers as <code>1.</code></li></ol><h4 id="Start-numbering-with-offset"><a href="#Start-numbering-with-offset" class="headerlink" title="Start numbering with offset:"></a>Start numbering with offset:</h4><pre><code class="markdown">57. foo1. bar</code></pre><ol start="57"><li>foo</li><li>bar</li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="markdown">Inline `code`</code></pre><p>Inline <code>code</code></p><h3 id="Indented-code"><a href="#Indented-code" class="headerlink" title="Indented code"></a>Indented code</h3><pre><code class="markdown">// Some comments    line 1 of code    line 2 of code    line 3 of code</code></pre><pre><code>// Some commentsline 1 of codeline 2 of codeline 3 of code</code></pre><h3 id="Block-code-“fences”"><a href="#Block-code-“fences”" class="headerlink" title="Block code “fences”"></a>Block code “fences”</h3><pre><code class="markdown">```Sample text here...```</code></pre><pre><code>Sample text here...</code></pre><p>Syntax highlighting</p><pre><code class="markdown">``` js sample.jsvar foo = function (bar) {  return bar++;};console.log(foo(5));```</code></pre><pre><code class="js">var foo = function (bar) {  return bar++;};console.log(foo(5));</code></pre><h2 id="Tables"><a href="#Tables" class="headerlink" title="Tables"></a>Tables</h2><pre><code class="markdown">| Option | Description |Description | Description | Description | Description || ------ | ----------- |----------- | ----------- | ----------- | ----------- || data   | path to data files to supply the data that will be passed into templates. || engine | engine to be used for processing templates. Handlebars is the default. || ext    | extension to be used for dest files. |</code></pre><table><thead><tr><th>Option</th><th>Description</th><th>Description</th><th>Description</th><th>Description</th><th>Description</th></tr></thead><tbody><tr><td>data</td><td>path to data files to supply the data that will be passed into templates.</td><td></td><td></td><td></td><td></td></tr><tr><td>engine</td><td>engine to be used for processing templates. Handlebars is the default.</td><td></td><td></td><td></td><td></td></tr><tr><td>ext</td><td>extension to be used for dest files.</td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="Right-aligned-columns"><a href="#Right-aligned-columns" class="headerlink" title="Right aligned columns"></a>Right aligned columns</h3><pre><code class="markdown">| Option | Description || ------:| -----------:|| data   | path to data files to supply the data that will be passed into templates. || engine | engine to be used for processing templates. Handlebars is the default. || ext    | extension to be used for dest files. |</code></pre><table><thead><tr><th align="right">Option</th><th align="right">Description</th></tr></thead><tbody><tr><td align="right">data</td><td align="right">path to data files to supply the data that will be passed into templates.</td></tr><tr><td align="right">engine</td><td align="right">engine to be used for processing templates. Handlebars is the default.</td></tr><tr><td align="right">ext</td><td align="right">extension to be used for dest files.</td></tr></tbody></table><h2 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h2><pre><code class="markdown">[link text](http://dev.nodeca.com)</code></pre><p><a href="http://dev.nodeca.com/">link text</a></p><pre><code class="markdown">[link with title](http://nodeca.github.io/pica/demo/ "title text!")</code></pre><p><a href="http://nodeca.github.io/pica/demo/" title="title text!">link with title</a></p><pre><code class="markdown">Autoconverted link https://github.com/nodeca/pica (enabled linkify)</code></pre><p>Autoconverted link <a href="https://github.com/nodeca/pica">https://github.com/nodeca/pica</a> (enabled linkify)</p><h2 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h2><pre><code class="markdown">![Minion](https://octodex.github.com/images/minion.png)![Stormtroopocat](https://octodex.github.com/images/stormtroopocat.jpg "The Stormtroopocat")</code></pre><p><img src="https://octodex.github.com/images/minion.png" alt="Minion"><br><img src="https://octodex.github.com/images/stormtroopocat.jpg" alt="Stormtroopocat" title="The Stormtroopocat"></p><p>Like links, Images also have a footnote style syntax</p><pre><code class="markdown">![Alt text][id]With a reference later in the document defining the URL location:[id]: https://octodex.github.com/images/dojocat.jpg  "The Dojocat"</code></pre><p><img src="https://octodex.github.com/images/dojocat.jpg" alt="Alt text" title="The Dojocat"></p><p>With a reference later in the document defining the URL location:</p><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p>The killer feature of <code>markdown-it</code> is very effective support of<br><a href="https://www.npmjs.org/browse/keyword/markdown-it-plugin">syntax plugins</a>. The sample <a href="#configuration">configuration snippet</a></p><h3 id="Emojies"><a href="#Emojies" class="headerlink" title="Emojies"></a><a href="https://github.com/markdown-it/markdown-it-emoji">Emojies</a></h3><pre><code class="markdown">Classic markup: :wink: :crush: :cry: :tear: :laughing: :yum:Shortcuts (emoticons): :-) :-( 8-) ;)</code></pre><p>Classic markup: <span class="github-emoji"><span>😉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f609.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> :crush: <span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> :tear: <span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>Shortcuts (emoticons): :-) :-( 8-) ;)</p><h3 id="Subscript-Superscript"><a href="#Subscript-Superscript" class="headerlink" title="Subscript / Superscript"></a><a href="https://github.com/markdown-it/markdown-it-sub">Subscript</a> / <a href="https://github.com/markdown-it/markdown-it-sup">Superscript</a></h3><pre><code class="markdown">Superscript: 19^th^Subscript: H~2~O</code></pre><p>Superscript: 19^th^</p><p>Subscript: H<del>2</del>O</p><h3 id="lt-ins-gt"><a href="#lt-ins-gt" class="headerlink" title="<ins>"></a><a href="https://github.com/markdown-it/markdown-it-ins">&lt;ins&gt;</a></h3><pre><code class="markdown">++Inserted text++</code></pre><p>++Inserted text++</p><h3 id="lt-mark-gt"><a href="#lt-mark-gt" class="headerlink" title="<mark>"></a><a href="https://github.com/markdown-it/markdown-it-mark">&lt;mark&gt;</a></h3><pre><code class="markdown">==Marked text==</code></pre><p>==Marked text==</p><h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a><a href="https://github.com/markdown-it/markdown-it-footnote">Footnotes</a></h3><pre><code class="markdown">Footnote 1 link[^first].Footnote 2 link[^second].Inline footnote^[Text of inline footnote] definition.Duplicated footnote reference[^second].[^first]: Footnote **can have markup**    and multiple paragraphs.[^second]: Footnote text.</code></pre><p>Footnote 1 link[^first].</p><p>Footnote 2 link[^second].</p><p>Inline footnote^[Text of inline footnote] definition.</p><p>Duplicated footnote reference[^second].</p><p>[^first]: Footnote <strong>can have markup</strong></p><pre><code>and multiple paragraphs.</code></pre><p>[^second]: Footnote text.</p><h3 id="Definition-lists"><a href="#Definition-lists" class="headerlink" title="Definition lists"></a><a href="https://github.com/markdown-it/markdown-it-deflist">Definition lists</a></h3><pre><code class="markdown">Term 1:   Definition 1with lazy continuation.</code></pre><dl><dt>Term 1</dt><dd>Definition 1<br>with lazy continuation.</dd></dl><pre><code class="markdown">Term 2 with *inline markup*:   Definition 2        { some code, part of Definition 2 }    Third paragraph of definition 2.</code></pre><dl><dt>Term 2 with <em>inline markup</em></dt><dd>Definition 2</dd></dl><pre><code>    { some code, part of Definition 2 }Third paragraph of definition 2.</code></pre><p><em>Compact style:</em></p><pre><code class="markdown">Term 1  ~ Definition 1Term 2  ~ Definition 2a  ~ Definition 2b</code></pre><p>Term 1<br>  ~ Definition 1</p><p>Term 2<br>  ~ Definition 2a<br>  ~ Definition 2b</p><h3 id="Abbreviations"><a href="#Abbreviations" class="headerlink" title="Abbreviations"></a><a href="https://github.com/markdown-it/markdown-it-abbr">Abbreviations</a></h3><pre><code class="markdown">This is HTML abbreviation example.It converts "HTML", but keep intact partial entries like "xxxHTMLyyy" and so on.*[HTML]: Hyper Text Markup Language</code></pre><p>This is HTML abbreviation example.</p><p>It converts “HTML”, but keep intact partial entries like “xxxHTMLyyy” and so on.</p><p>*[HTML]: Hyper Text Markup Language</p><h3 id="Custom-containers"><a href="#Custom-containers" class="headerlink" title="Custom containers"></a><a href="https://github.com/markdown-it/markdown-it-container">Custom containers</a></h3><p>::: warning<br><em>here be dragons</em><br>:::</p><h2 id="Hexo-Built-in-Tags"><a href="#Hexo-Built-in-Tags" class="headerlink" title="Hexo Built-in Tags"></a>Hexo Built-in Tags</h2><h3 id="Blockquote-with-author"><a href="#Blockquote-with-author" class="headerlink" title="Blockquote with author"></a>Blockquote with author</h3><pre><code class="swig">{% blockquote David Levithan, Wide Awake %}Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.{% endblockquote %}</code></pre><blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p><footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote><h3 id="Blockquote-for-twitter"><a href="#Blockquote-for-twitter" class="headerlink" title="Blockquote for twitter"></a>Blockquote for twitter</h3><pre><code class="swig">{% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %}NEW: DevDocs now comes with syntax highlighting. http://devdocs.io{% endblockquote %}</code></pre><blockquote><p>NEW: DevDocs now comes with syntax highlighting. <a href="http://devdocs.io/">http://devdocs.io</a></p><footer><strong>@DevDocs</strong><cite><a href="https://twitter.com/devdocs/status/356095192085962752">twitter.com/devdocs/status/356095192085962752</a></cite></footer></blockquote><h3 id="Blockquote-for-weblink"><a href="#Blockquote-for-weblink" class="headerlink" title="Blockquote for weblink"></a>Blockquote for weblink</h3><pre><code class="swig">{% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %}Every interaction is both precious and an opportunity to delight.{% endblockquote %}</code></pre><blockquote><p>Every interaction is both precious and an opportunity to delight.</p><footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html">Welcome to Island Marketing</a></cite></footer></blockquote><h3 id="Pull-Quotes"><a href="#Pull-Quotes" class="headerlink" title="Pull Quotes"></a>Pull Quotes</h3><pre><code class="swig">{% pullquote %}content{% endpullquote %}</code></pre><blockquote class="pullquote"><p>content</p></blockquote><h3 id="jsFiddle"><a href="#jsFiddle" class="headerlink" title="jsFiddle"></a>jsFiddle</h3><pre><code class="swig">{% jsfiddle o2gxgz9r default light %}</code></pre><iframe scrolling="no" width="100%" height="300" src="https://jsfiddle.net/o2gxgz9r/embedded/js,resources,html,css,result/light" frameborder="0" loading="lazy" allowfullscreen=""></iframe><h3 id="Gist"><a href="#Gist" class="headerlink" title="Gist"></a>Gist</h3><pre><code class="swig">{% gist b6365e79be6052e7531e7ba6ea8caf23 'Sample gist' %}</code></pre><script src="//gist.github.com/b6365e79be6052e7531e7ba6ea8caf23.js?file=Sample gist"></script><h3 id="iFrame"><a href="#iFrame" class="headerlink" title="iFrame"></a>iFrame</h3><pre><code class="swig">{% iframe https://www.bing.com %}</code></pre><iframe src="https://www.bing.com/" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen=""></iframe><h3 id="Link-to-open-in-new-tab"><a href="#Link-to-open-in-new-tab" class="headerlink" title="Link to open in new tab"></a>Link to open in new tab</h3><pre><code class="swig">{% link Google https://www.google.com default Google %}</code></pre><a href="https://www.google.com/" title="default Google" target="">Google</a><h3 id="Youtube"><a href="#Youtube" class="headerlink" title="Youtube"></a>Youtube</h3><pre><code class="swig">{% youtube l_lblj8Cq0o %}</code></pre><div class="video-container"><iframe src="https://www.youtube.com/embed/l_lblj8Cq0o" frameborder="0" loading="lazy" allowfullscreen=""></iframe></div>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typography </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tag Plugins</title>
      <link href="/My-Blogs/2013/12/25/hexo/tag-plugins/"/>
      <url>/My-Blogs/2013/12/25/hexo/tag-plugins/</url>
      
        <content type="html"><![CDATA[<p>This post is used for testing tag plugins. See <a href="http://zespia.tw/hexo/docs/tag-plugins.html">docs</a> for more info.</p><h2 id="Block-Quote"><a href="#Block-Quote" class="headerlink" title="Block Quote"></a>Block Quote</h2><h3 id="Normal-blockquote"><a href="#Normal-blockquote" class="headerlink" title="Normal blockquote"></a>Normal blockquote</h3><blockquote><p>Praesent diam elit, interdum ut pulvinar placerat, imperdiet at magna.</p></blockquote><h3 id="Quote-from-a-book"><a href="#Quote-from-a-book" class="headerlink" title="Quote from a book"></a>Quote from a book</h3><blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p><footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote><h3 id="Quote-from-Twitter"><a href="#Quote-from-Twitter" class="headerlink" title="Quote from Twitter"></a>Quote from Twitter</h3><blockquote><p>NEW: DevDocs now comes with syntax highlighting. <a href="http://devdocs.io/">http://devdocs.io</a></p><footer><strong>@DevDocs</strong><cite><a href="https://twitter.com/devdocs/status/356095192085962752">twitter.com/devdocs/status/356095192085962752</a></cite></footer></blockquote><h3 id="Quote-from-an-article-on-the-web"><a href="#Quote-from-an-article-on-the-web" class="headerlink" title="Quote from an article on the web"></a>Quote from an article on the web</h3><blockquote><p>Every interaction is both precious and an opportunity to delight.</p><footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html">Welcome to Island Marketing</a></cite></footer></blockquote><h2 id="Code-Block"><a href="#Code-Block" class="headerlink" title="Code Block"></a>Code Block</h2><h3 id="Normal-code-block"><a href="#Normal-code-block" class="headerlink" title="Normal code block"></a>Normal code block</h3><pre><code>alert('Hello World!');</code></pre><h3 id="With-caption"><a href="#With-caption" class="headerlink" title="With caption"></a>With caption</h3><pre><code>array.map(callback[, thisArg])</code></pre><h3 id="With-caption-and-URL"><a href="#With-caption-and-URL" class="headerlink" title="With caption and URL"></a>With caption and URL</h3><pre><code>.compact([0, 1, false, 2, ‘’, 3]);=&gt; [1, 2, 3]</code></pre><h3 id="With-marked-lines"><a href="#With-marked-lines" class="headerlink" title="With marked lines"></a>With marked lines</h3><p>Line 1,7-8,10 should be marked with different color.</p><pre><code>const http = require('http');const hostname = '127.0.0.1';const port = 1337;http.createServer((req, res) =&gt; {  res.writeHead(200, { 'Content-Type': 'text/plain' });  res.end('Hello World\n');}).listen(port, hostname, () =&gt; {  console.log(`Server running at http://${hostname}:${port}/`);});</code></pre><p>Note: Theme’s style should support <code>.highlight.line.marked</code> (recommend to use the selection or current line color).</p><h3 id="Gist"><a href="#Gist" class="headerlink" title="Gist"></a>Gist</h3><script src="//gist.github.com/996818.js"></script><h3 id="jsFiddle"><a href="#jsFiddle" class="headerlink" title="jsFiddle"></a>jsFiddle</h3><iframe scrolling="no" width="100%" height="300" src="https://jsfiddle.net/ccWP7/embedded/js,resources,html,css,result/light" frameborder="0" loading="lazy" allowfullscreen=""></iframe><h2 id="Pullquote"><a href="#Pullquote" class="headerlink" title="Pullquote"></a>Pullquote</h2><h3 id="Left"><a href="#Left" class="headerlink" title="Left"></a>Left</h3><blockquote class="pullquote left"><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p></blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas tempus molestie arcu, et fringilla mauris placerat ac. Nullam luctus bibendum risus. Ut cursus sed ipsum feugiat egestas. Suspendisse elementum, velit eu consequat consequat, augue lorem dapibus libero, eget pulvinar dolor est sit amet nulla. Suspendisse a porta tortor, et posuere mi. Pellentesque ultricies, mi quis volutpat malesuada, erat felis vulputate nisl, ac congue ante tortor ut ante. Proin aliquam sem vel mauris tincidunt, eget scelerisque tortor euismod. Nulla tincidunt enim nec commodo dictum. Mauris id sapien et orci gravida luctus id ut dui. In vel vulputate odio. Duis vel turpis molestie, scelerisque enim eu, lobortis eros. Cras at ipsum gravida, sagittis ante vel, viverra tellus. Nunc mauris turpis, elementum ullamcorper nisl pretium, ultrices cursus justo. Mauris porttitor commodo eros, ac ornare orci interdum in. Cras fermentum cursus leo sed mattis. In dignissim lorem sem, sit amet elementum mauris venenatis ac.</p><h3 id="Right"><a href="#Right" class="headerlink" title="Right"></a>Right</h3><blockquote class="pullquote right"><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p></blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed ligula justo, lobortis sit amet semper vel, dignissim sit amet libero. Praesent ac tempus ligula. Maecenas at gravida odio. Etiam tristique volutpat lacus eu faucibus. Donec non tempus arcu. Phasellus adipiscing, mauris nec mollis egestas, ipsum nunc auctor velit, et rhoncus lorem ipsum at ante. Praesent et sem in velit volutpat auctor. Duis vel mauris nulla. Maecenas mattis interdum ante, quis sagittis nibh cursus et. Nulla facilisi. Morbi convallis gravida tortor, ut fermentum enim gravida et. Nunc vel dictum nisl, non ultrices libero. Proin vestibulum felis eget orci consectetur lobortis. Vestibulum augue nulla, iaculis vitae augue vehicula, dignissim ultrices libero. Sed imperdiet urna et quam ultrices tincidunt nec ac magna. Etiam vel pharetra elit.</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
