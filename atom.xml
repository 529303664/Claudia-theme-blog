<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>John Doe&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-12-22T06:03:57.110Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法篇-例题</title>
    <link href="http://example.com/2021/12/22/JavaScript/%E7%AE%97%E6%B3%95%E7%AF%87-%E4%BE%8B%E9%A2%98/"/>
    <id>http://example.com/2021/12/22/JavaScript/%E7%AE%97%E6%B3%95%E7%AF%87-%E4%BE%8B%E9%A2%98/</id>
    <published>2021-12-22T14:00:26.000Z</published>
    <updated>2021-12-22T06:03:57.110Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="JavaScript-算法与数据结构"><a href="#JavaScript-算法与数据结构" class="headerlink" title="JavaScript 算法与数据结构"></a>JavaScript 算法与数据结构</h1><p>本仓库包含了多种基于 JavaScript 的算法与数据结构。</p><p><em>注意：这个项目仅用于学习和研究，<strong>不是</strong>用于生产环境。</em></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据结构是在计算机中组织和存储数据的一种特殊方式，使得数据可以高效地被访问和修改。更确切地说，数据结构是数据值的集合，表示数据之间的关系，也包括了作用在数据上的函数或操作。</p><p><code>B</code> - 初学者， <code>A</code> - 进阶</p><ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/linked-list/README.zh-CN.md">链表</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/doubly-linked-list/README.zh-CN.md">双向链表</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/queue/README.zh-CN.md">队列</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/stack/README.zh-CN.md">栈</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/hash-table/README.zh-CN.md">哈希表(散列)</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/heap/README.zh-CN.md">堆</a> - 最大堆 &amp; 最小堆</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/priority-queue/README.zh-CN.md">优先队列</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/trie/README.zh-CN.md">字典树</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/tree/README.zh-CN.md">树</a><ul><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/tree/binary-search-tree">二叉查找树</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/tree/avl-tree">AVL 树</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/tree/red-black-tree">红黑树</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/tree/segment-tree">线段树</a> - 使用 <code>最小/最大/总和</code> 范围查询示例</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/tree/fenwick-tree">树状数组</a> (二叉索引树)</li></ul></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/graph/README.zh-CN.md">图</a> (有向图与无向图)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/disjoint-set">并查集</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/bloom-filter">布隆过滤器</a></li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法是如何解决一类问题的明确规范。算法是一组精确定义操作序列的规则。</p><p><code>B</code> - 初学者， <code>A</code> - 进阶</p><h3 id="算法主题"><a href="#算法主题" class="headerlink" title="算法主题"></a>算法主题</h3><ul><li><strong>数学</strong><ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/bits">位运算</a> - set/get/update/clear 位、乘以/除以二进制位 、变负等</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/factorial/README.zh-CN.md">阶乘</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/fibonacci">斐波那契数</a> - <code>经典</code> 和 <code>闭式</code> 版本</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/primality-test">素数检测</a> (排除法)</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/euclidean-algorithm">欧几里得算法</a> - 计算最大公约数 (GCD)</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/least-common-multiple">最小公倍数</a> (LCM)</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/sieve-of-eratosthenes">素数筛</a> - 查找任意给定范围内的所有素数</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/is-power-of-two">判断 2 次方数</a> - 检查数字是否为 2 的幂 (原生和按位算法)</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/pascal-triangle">杨辉三角形</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/complex-number">复数</a> - 复数及其基本运算</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/radian">弧度和角</a> - 弧度与角的相互转换</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/fast-powering">快速算次方</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/integer-partition">整数拆分</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/liu-hui">割圆术</a> - 基于 N-gons 的近似 π 计算</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/fourier-transform">离散傅里叶变换</a> - 把时间信号解析成构成它的频率</li></ul></li><li><strong>集合</strong><ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/cartesian-product">笛卡尔积</a> - 多集合结果</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/fisher-yates">洗牌算法</a> - 随机置换有限序列</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/power-set">幂集</a> - 该集合的所有子集</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/permutations">排列</a> (有/无重复)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/combinations">组合</a> (有/无重复)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/longest-common-subsequence">最长公共子序列</a> (LCS)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/longest-increasing-subsequence">最长递增子序列</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/shortest-common-supersequence">最短公共父序列</a> (SCS)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/knapsack-problem">背包问题</a> - <code>0/1</code> 和 <code>无边界</code> 问题</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/maximum-subarray">最大子数列问题</a> - <code>BF 算法</code> 和 <code>动态规划</code></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/combination-sum">组合求和</a> - 查找形成特定总和的所有组合</li></ul></li><li><strong>字符串</strong><ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/hamming-distance">汉明距离</a> - 符号不同的位置数</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/levenshtein-distance">莱温斯坦距离</a> - 两个序列之间的最小编辑距离</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/knuth-morris-pratt">Knuth–Morris–Pratt 算法</a> KMP 算法 - 子串搜索 (模式匹配)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/z-algorithm">字符串快速查找</a> - 子串搜索 (模式匹配)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/rabin-karp">Rabin Karp 算法</a> - 子串搜索</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/longest-common-substring">最长公共子串</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/regular-expression-matching">正则表达式匹配</a></li></ul></li><li><strong>搜索</strong><ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/search/linear-search">线性搜索</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/search/jump-search">跳转搜索/块搜索</a> - 搜索有序数组</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/search/binary-search">二分查找</a> - 搜索有序数组</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/search/interpolation-search">插值搜索</a> - 搜索均匀分布的有序数组</li></ul></li><li><strong>排序</strong><ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/bubble-sort">冒泡排序</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/selection-sort">选择排序</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/insertion-sort">插入排序</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/heap-sort">堆排序</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/merge-sort">归并排序</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/quick-sort">快速排序</a> - in-place (原地) 和 non-in-place 版本</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/shell-sort">希尔排序</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/counting-sort">计数排序</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/radix-sort">基数排序</a></li></ul></li><li><strong>链表</strong><ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/linked-list/traversal">正向遍历</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/linked-list/reverse-traversal">反向遍历</a></li></ul></li><li><strong>树</strong><ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/tree/depth-first-search">深度优先搜索</a> (DFS)</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/tree/breadth-first-search">广度优先搜索</a> (BFS)</li></ul></li><li><strong>图</strong><ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/depth-first-search">深度优先搜索</a> (DFS)</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/breadth-first-search">广度优先搜索</a> (BFS)</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/kruskal">克鲁斯克尔演算法</a> - 寻找加权无向图的最小生成树 (MST)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/dijkstra">戴克斯特拉算法</a> - 找到图中所有顶点的最短路径</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/bellman-ford">贝尔曼-福特算法</a> - 找到图中所有顶点的最短路径</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/floyd-warshall">弗洛伊德算法</a> - 找到所有顶点对 之间的最短路径</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/detect-cycle">判圈算法</a> - 对于有向图和无向图 (基于 DFS 和不相交集的版本)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/prim">普林演算法</a> - 寻找加权无向图的最小生成树 (MST)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/topological-sorting">拓扑排序</a> - DFS 方法</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/articulation-points">关节点</a> - Tarjan 算法 (基于 DFS)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/bridges">桥</a> - 基于 DFS 的算法</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/eulerian-path">欧拉回径与一笔画问题</a> - Fleury 的算法 - 一次访问每个边</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/hamiltonian-cycle">哈密顿图</a> - 恰好访问每个顶点一次</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/strongly-connected-components">强连通分量</a> - Kosaraju 算法</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/travelling-salesman">旅行推销员问题</a> - 尽可能以最短的路线访问每个城市并返回原始城市</li></ul></li><li><strong>加密</strong><ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/cryptography/polynomial-hash">多项式 hash</a> - 基于多项式的 rolling hash 函数</li></ul></li><li><strong>机器学习</strong><ul><li><code>B</code> <a href="https://github.com/trekhleb/nano-neuron">NanoNeuron</a> -7个简单的JS函数，说明机器如何实际学习（向前/向后传播）</li></ul></li><li><strong>未分类</strong><ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/hanoi-tower">汉诺塔</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/square-matrix-rotation">旋转矩阵</a> - 原地算法</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/jump-game">跳跃游戏</a> - 回溯,、动态编程 (自上而下+自下而上) 和贪婪的例子</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/unique-paths">独特(唯一) 路径</a> - 回溯、动态编程和基于 Pascal 三角形的例子</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/rain-terraces">雨水收集</a> - 诱捕雨水问题 (动态编程和暴力版本)</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/recursive-staircase">递归楼梯</a> - 计算有共有多少种方法可以到达顶层 (4 种解题方案)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/n-queens">八皇后问题</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/knight-tour">骑士巡逻</a></li></ul></li></ul><h3 id="算法范式"><a href="#算法范式" class="headerlink" title="算法范式"></a>算法范式</h3><p>算法范式是一种通用方法，基于一类算法的设计。这是比算法更高的抽象，就像算法是比计算机程序更高的抽象。</p><ul><li><strong>BF 算法</strong> - <code>查找/搜索</code> 所有可能性并选择最佳解决方案<ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/search/linear-search">线性搜索</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/rain-terraces">雨水收集</a> - 诱导雨水问题</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/recursive-staircase">递归楼梯</a> - 计算有共有多少种方法可以到达顶层 (4 种解题方案)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/maximum-subarray">最大子数列</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/travelling-salesman">旅行推销员问题</a> - 尽可能以最短的路线访问每个城市并返回原始城市</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/fourier-transform">离散傅里叶变换</a> - 把时间信号解析成构成它的频率</li></ul></li><li><strong>贪心法</strong> - 在当前选择最佳选项，不考虑以后情况<ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/jump-game">跳跃游戏</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/knapsack-problem">背包问题</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/dijkstra">戴克斯特拉算法</a> - 找到所有图顶点的最短路径</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/prim">普里姆算法</a> - 寻找加权无向图的最小生成树 (MST)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/kruskal">克鲁斯卡尔算法</a> - 寻找加权无向图的最小生成树 (MST)</li></ul></li><li><strong>分治法</strong> - 将问题分成较小的部分，然后解决这些部分<ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/search/binary-search">二分查找</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/hanoi-tower">汉诺塔</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/pascal-triangle">杨辉三角形</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/euclidean-algorithm">欧几里得算法</a> - 计算最大公约数 (GCD)</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/merge-sort">归并排序</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/quick-sort">快速排序</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/tree/depth-first-search">树深度优先搜索</a> (DFS)</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/depth-first-search">图深度优先搜索</a> (DFS)</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/jump-game">跳跃游戏</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/fast-powering">快速算次方</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/permutations">排列</a> (有/无重复)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/combinations">组合</a> (有/无重复)</li></ul></li><li><strong>动态编程</strong> - 使用以前找到的子解决方案构建解决方案<ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/fibonacci">斐波那契数</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/jump-game">跳跃游戏</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/unique-paths">独特路径</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/rain-terraces">雨水收集</a> - 疏导雨水问题</li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/recursive-staircase">递归楼梯</a> - 计算有共有多少种方法可以到达顶层 (4 种解题方案)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/levenshtein-distance">莱温斯坦距离</a> - 两个序列之间的最小编辑距离</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/longest-common-subsequence">最长公共子序列</a> (LCS)</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/longest-common-substring">最长公共子串</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/longest-increasing-subsequence">最长递增子序列</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/shortest-common-supersequence">最短公共子序列</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/knapsack-problem">0-1背包问题</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/integer-partition">整数拆分</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/maximum-subarray">最大子数列</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/bellman-ford">贝尔曼-福特算法</a> - 找到所有图顶点的最短路径</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/floyd-warshall">弗洛伊德算法</a> - 找到所有顶点对之间的最短路径</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/regular-expression-matching">正则表达式匹配</a></li></ul></li><li><strong>回溯法</strong> - 类似于 <code>BF 算法</code> 试图产生所有可能的解决方案，但每次生成解决方案测试如果它满足所有条件，那么只有继续生成后续解决方案。否则回溯并继续寻找不同路径的解决方案。<ul><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/jump-game">跳跃游戏</a></li><li><code>B</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/unique-paths">独特路径</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/power-set">幂集</a> - 该集合的所有子集</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/hamiltonian-cycle">哈密顿图</a> - 恰好访问每个顶点一次</li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/n-queens">八皇后问题</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/knight-tour">骑士巡逻</a></li><li><code>A</code> <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/combination-sum">组合求和</a> - 从规定的总和中找出所有的组合</li></ul></li><li><strong>Branch &amp; Bound</strong> - 记住在回溯搜索的每个阶段找到的成本最低的解决方案，并使用到目前为止找到的成本最小值作为下限。以便丢弃成本大于最小值的解决方案。通常，使用 BFS 遍历以及状态空间树的 DFS 遍历。</li></ul><h2 id="如何使用本仓库"><a href="#如何使用本仓库" class="headerlink" title="如何使用本仓库"></a>如何使用本仓库</h2><p><strong>安装依赖</strong></p><pre><code>npm install</code></pre><p><strong>运行 ESLint</strong></p><p>检查代码质量</p><pre><code>npm run lint</code></pre><p><strong>执行测试</strong></p><pre><code>npm test</code></pre><p><strong>按照名称执行测试</strong></p><pre><code>npm test -- 'LinkedList'</code></pre><p><strong>Playground</strong></p><p>你可以在 <code>./https://github.com/trekhleb/javascript-algorithms/blob/master/src/playground/playground.js</code> 文件中操作数据结构与算法，并在 <code>./https://github.com/trekhleb/javascript-algorithms/blob/master/src/playground/__test__/playground.test.js</code> 中编写测试。</p><p>然后，只需运行以下命令来测试你的 Playground 是否无误:</p><pre><code>npm test -- 'playground'</code></pre><h2 id="有用的信息"><a href="#有用的信息" class="headerlink" title="有用的信息"></a>有用的信息</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.youtube.com/playlist?list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8">▶ YouTube</a></p><h3 id="大O符号"><a href="#大O符号" class="headerlink" title="大O符号"></a>大O符号</h3><p>大O符号中指定的算法的增长顺序。</p><p><img src="/My-Blogs/./assets/big-o-graph.png" alt="Big O graphs"></p><p>源: <a href="http://bigocheatsheet.com/">Big O Cheat Sheet</a>.</p><p>以下是一些最常用的 大O标记法 列表以及它们与不同大小输入数据的性能比较。</p><table><thead><tr><th>大O标记法</th><th>计算10个元素</th><th>计算100个元素</th><th>计算1000个元素</th></tr></thead><tbody><tr><td><strong>O(1)</strong></td><td>1</td><td>1</td><td>1</td></tr><tr><td><strong>O(log N)</strong></td><td>3</td><td>6</td><td>9</td></tr><tr><td><strong>O(N)</strong></td><td>10</td><td>100</td><td>1000</td></tr><tr><td><strong>O(N log N)</strong></td><td>30</td><td>600</td><td>9000</td></tr><tr><td><strong>O(N^2)</strong></td><td>100</td><td>10000</td><td>1000000</td></tr><tr><td><strong>O(2^N)</strong></td><td>1024</td><td>1.26e+29</td><td>1.07e+301</td></tr><tr><td><strong>O(N!)</strong></td><td>3628800</td><td>9.3e+157</td><td>4.02e+2567</td></tr></tbody></table><h3 id="数据结构操作的复杂性"><a href="#数据结构操作的复杂性" class="headerlink" title="数据结构操作的复杂性"></a>数据结构操作的复杂性</h3><table><thead><tr><th>数据结构</th><th align="center">连接</th><th align="center">查找</th><th align="center">插入</th><th align="center">删除</th><th>备注</th></tr></thead><tbody><tr><td><strong>数组</strong></td><td align="center">1</td><td align="center">n</td><td align="center">n</td><td align="center">n</td><td></td></tr><tr><td><strong>栈</strong></td><td align="center">n</td><td align="center">n</td><td align="center">1</td><td align="center">1</td><td></td></tr><tr><td><strong>队列</strong></td><td align="center">n</td><td align="center">n</td><td align="center">1</td><td align="center">1</td><td></td></tr><tr><td><strong>链表</strong></td><td align="center">n</td><td align="center">n</td><td align="center">1</td><td align="center">1</td><td></td></tr><tr><td><strong>哈希表</strong></td><td align="center">-</td><td align="center">n</td><td align="center">n</td><td align="center">n</td><td>在完全哈希函数情况下，复杂度是 O(1）</td></tr><tr><td><strong>二分查找树</strong></td><td align="center">n</td><td align="center">n</td><td align="center">n</td><td align="center">n</td><td>在平衡树情况下，复杂度是 O(log(n))</td></tr><tr><td><strong>B 树</strong></td><td align="center">log(n)</td><td align="center">log(n)</td><td align="center">log(n)</td><td align="center">log(n)</td><td></td></tr><tr><td><strong>红黑树</strong></td><td align="center">log(n)</td><td align="center">log(n)</td><td align="center">log(n)</td><td align="center">log(n)</td><td></td></tr><tr><td><strong>AVL 树</strong></td><td align="center">log(n)</td><td align="center">log(n)</td><td align="center">log(n)</td><td align="center">log(n)</td><td></td></tr><tr><td><strong>布隆过滤器</strong></td><td align="center">-</td><td align="center">1</td><td align="center">1</td><td align="center">-</td><td>存在一定概率的判断错误（误判成存在）</td></tr></tbody></table><h3 id="数组排序算法的复杂性"><a href="#数组排序算法的复杂性" class="headerlink" title="数组排序算法的复杂性"></a>数组排序算法的复杂性</h3><table><thead><tr><th>名称</th><th align="center">最优</th><th align="center">平均</th><th align="center">最坏</th><th align="center">内存</th><th align="center">稳定</th><th>备注</th></tr></thead><tbody><tr><td><strong>冒泡排序</strong></td><td align="center">n</td><td align="center">n^2</td><td align="center">n^2</td><td align="center">1</td><td align="center">Yes</td><td></td></tr><tr><td><strong>插入排序</strong></td><td align="center">n</td><td align="center">n^2</td><td align="center">n^2</td><td align="center">1</td><td align="center">Yes</td><td></td></tr><tr><td><strong>选择排序</strong></td><td align="center">n^2</td><td align="center">n^2</td><td align="center">n^2</td><td align="center">1</td><td align="center">No</td><td></td></tr><tr><td><strong>堆排序</strong></td><td align="center">n log(n)</td><td align="center">n log(n)</td><td align="center">n log(n)</td><td align="center">1</td><td align="center">No</td><td></td></tr><tr><td><strong>归并排序</strong></td><td align="center">n log(n)</td><td align="center">n log(n)</td><td align="center">n log(n)</td><td align="center">n</td><td align="center">Yes</td><td></td></tr><tr><td><strong>快速排序</strong></td><td align="center">n log(n)</td><td align="center">n log(n)</td><td align="center">n^2</td><td align="center">log(n)</td><td align="center">No</td><td>在 in-place 版本下，内存复杂度通常是 O(log(n))</td></tr><tr><td><strong>希尔排序</strong></td><td align="center">n log(n)</td><td align="center">取决于差距序列</td><td align="center">n (log(n))^2</td><td align="center">1</td><td align="center">No</td><td></td></tr><tr><td><strong>计数排序</strong></td><td align="center">n + r</td><td align="center">n + r</td><td align="center">n + r</td><td align="center">n + r</td><td align="center">Yes</td><td>r - 数组里最大的数</td></tr><tr><td><strong>基数排序</strong></td><td align="center">n * k</td><td align="center">n * k</td><td align="center">n * k</td><td align="center">n + k</td><td align="center">Yes</td><td>k - 最长 key 的升序</td></tr></tbody></table><blockquote><p>ℹ️ A few more <a href="https://trekhleb.dev/projects/">projects</a> and <a href="https://trekhleb.dev/blog/">articles</a> about JavaScript and algorithms on <a href="https://trekhleb.dev/">trekhleb.dev</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;JavaScript-算法与数据结构&quot;&gt;&lt;a href=&quot;#JavaScript-算法与数据结构&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 算法与数据结构&quot;&gt;&lt;/a&gt;JavaScript 算法</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法篇-基础</title>
    <link href="http://example.com/2021/12/21/JavaScript/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2021/12/21/JavaScript/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%9F%BA%E7%A1%80/</id>
    <published>2021-12-21T10:02:59.000Z</published>
    <updated>2021-12-22T06:03:57.111Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="算法知识总结"><a href="#算法知识总结" class="headerlink" title="算法知识总结"></a>算法知识总结</h1><p>本部分主要是笔者在学习算法知识和一些相关面试题所做的笔记，如果出现错误，希望大家指出！</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93">常用算法和数据结构总结</a><ul><li><a href="#%E6%8E%92%E5%BA%8F">排序</a><ul><li><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a></li><li><a href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a></li><li><a href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a></li><li><a href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a></li><li><a href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a></li><li><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></li><li><a href="#%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></li><li><a href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基数排序</a></li><li><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%AF%B9%E4%BA%8E%E5%85%B6%E4%BB%96%E6%8E%92%E5%BA%8F%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98%E7%9A%84%E5%8E%9F%E5%9B%A0">快速排序相对于其他排序效率更高的原因</a></li><li><a href="#%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0">系统自带排序实现</a></li><li><a href="#%E7%A8%B3%E5%AE%9A%E6%80%A7">稳定性</a></li><li><a href="#%E6%8E%92%E5%BA%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93">排序面试题目总结</a></li></ul></li><li><a href="#%E6%A0%91">树</a><ul><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E6%80%A7%E8%B4%A8">二叉树相关性质</a></li><li><a href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91">满二叉树</a></li><li><a href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91">完全二叉树</a></li><li><a href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91avl">平衡二叉查找树（AVL）</a></li><li><a href="#b-%E6%A0%91">B-树</a></li><li><a href="#b%E6%A0%91">B 树</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95">数据库索引</a></li><li><a href="#%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a></li><li><a href="#huffman-%E6%A0%91">Huffman 树</a></li><li><a href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">二叉查找树</a></li><li><a href="#%E6%B1%82%E8%A7%A3%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E8%8A%82%E7%82%B9">求解二叉树中两个节点的最近公共祖先节点</a></li></ul></li><li><a href="#%E9%93%BE%E8%A1%A8">链表</a><ul><li><a href="#%E5%8F%8D%E8%BD%AC%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8">反转单向链表</a></li></ul></li><li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a><ul><li><a href="#%E7%88%AC%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98">爬楼梯问题</a></li><li><a href="#%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90">递归方法分析</a></li><li><a href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%96%B9%E6%B3%95">备忘录方法</a></li><li><a href="#%E8%BF%AD%E4%BB%A3%E6%B3%95">迭代法</a></li></ul></li><li><a href="#%E7%BB%8F%E5%85%B8%E7%AC%94%E8%AF%95%E9%A2%98">经典笔试题</a><ul><li><a href="#1-js-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%AE%8C%E6%88%90%E8%B6%85%E8%BF%87%E8%8C%83%E5%9B%B4%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%A4%A7%E6%95%B4%E6%95%B0%E7%9B%B8%E5%8A%A0%E5%8A%9F%E8%83%BD">1. js 实现一个函数，完成超过范围的两个大整数相加功能</a></li><li><a href="#2-js-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96">2. js 如何实现数组扁平化？</a></li><li><a href="#3-js-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D">3. js 如何实现数组去重？</a></li><li><a href="#4-%E5%A6%82%E4%BD%95%E6%B1%82%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC">4. 如何求数组的最大值和最小值？</a></li><li><a href="#5-%E5%A6%82%E4%BD%95%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0">5. 如何求两个数的最大公约数？</a></li><li><a href="#6-%E5%A6%82%E4%BD%95%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0">6. 如何求两个数的最小公倍数？</a></li><li><a href="#7-%E5%AE%9E%E7%8E%B0-indexof-%E6%96%B9%E6%B3%95">7. 实现 IndexOf 方法？</a></li><li><a href="#8-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2">8. 判断一个字符串是否为回文字符串？</a></li><li><a href="#9-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%B4%AF%E5%8A%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E6%AF%94%E5%A6%82-sum1232valueof">9. 实现一个累加函数的功能比如 sum(1,2,3)(2).valueOf()</a></li><li><a href="#10-%E4%BD%BF%E7%94%A8-reduce-%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0-foreachmapfilter">10. 使用 reduce 方法实现 forEach、map、filter</a></li><li><a href="#11-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E8%A6%81%E6%B1%82v%E5%88%86%E5%88%AB%E5%9C%A8-134-%E7%A7%92%E5%90%8E%E6%89%93%E5%8D%B0%E5%87%BA-1-2-3">11. 设计一个简单的任务队列，要求分别在 1,3,4 秒后打印出 “1”, “2”, “3”</a></li><li><a href="#12-%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E4%B8%80%E7%AF%87%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0%E4%B8%AD%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%9C%80%E9%AB%98%E7%9A%84%E5%8D%95%E8%AF%8D">12. 如何查找一篇英文文章中出现频率最高的单词？</a></li></ul></li></ul></li><li><a href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E6%99%BA%E5%8A%9B%E9%A2%98%E6%80%BB%E7%BB%93">常见面试智力题总结</a><ul><li><a href="#1-%E6%97%B6%E9%92%88%E4%B8%8E%E5%88%86%E9%92%88%E5%A4%B9%E8%A7%92%E5%BA%A6%E6%95%B0%E9%97%AE%E9%A2%98">1. 时针与分针夹角度数问题？</a></li><li><a href="#2-%E7%94%A83%E5%8D%875%E5%8D%87%E6%9D%AF%E5%AD%90%E6%80%8E%E4%B9%88%E9%87%8F%E5%87%BA4%E5%8D%87%E6%B0%B4">2. 用3升，5升杯子怎么量出4升水？</a></li><li><a href="#3-%E5%9B%9B%E4%B8%AA%E8%8D%AF%E7%BD%90%E4%B8%AD%E6%9C%89%E4%B8%80%E4%B8%AA%E6%B5%91%E6%B5%8A%E7%9A%84%E8%8D%AF%E7%BD%90%E6%B5%91%E6%B5%8A%E7%9A%84%E6%AF%8F%E7%89%87%E8%8D%AF%E7%89%87%E9%83%BD%E6%AF%94%E5%85%B6%E4%BB%96%E4%B8%89%E4%B8%AA%E5%B9%B2%E5%87%80%E7%9A%84%E8%8D%AF%E7%BD%90%E5%A4%9A%E4%B8%80%E5%85%8B%E5%A6%82%E4%BD%95%E5%8F%AA%E7%94%A8%E4%B8%80%E6%AC%A1%E5%A4%A9%E5%B9%B3%E6%89%BE%E5%87%BA%E6%B5%91%E6%B5%8A%E7%9A%84%E8%8D%AF%E7%BD%90">3. 浑浊药罐问题</a></li><li><a href="#4-%E5%9B%9B%E5%BC%A0%E5%8D%A1%E7%89%87%E5%8D%A1%E7%89%87%E6%AD%A3%E9%9D%A2%E6%98%AF%E6%95%B0%E5%AD%97%E5%8F%8D%E9%9D%A2%E6%98%AF%E5%AD%97%E6%AF%8D%E7%8E%B0%E5%9C%A8%E6%A1%8C%E4%B8%8A%E5%9B%9B%E5%BC%A0%E5%8D%A1%E7%89%87%E7%8A%B6%E6%80%81%E4%B8%BA-a-1-b-2-%E7%8E%B0%E5%9C%A8%E6%88%91%E6%83%B3%E8%A6%81%E8%AF%81%E6%98%8E-a-%E7%9A%84%E5%8F%8D%E9%9D%A2%E5%BF%85%E7%84%B6%E6%98%AF-1">4. 卡片证明问题</a></li><li><a href="#5-%E8%B5%9B%E9%A9%AC%E9%97%AE%E9%A2%9825-%E5%8C%B9%E9%A9%AC5-%E4%B8%AA%E8%B5%9B%E9%81%93%E6%9C%80%E5%B0%91%E5%87%A0%E6%AC%A1%E8%83%BD%E9%80%89%E5%87%BA%E6%9C%80%E5%BF%AB%E7%9A%84%E4%B8%89%E5%8C%B9%E9%A9%AC">5. 赛马问题，25 匹马，5 个赛道，最少几次能选出最快的三匹马？</a></li><li><a href="#6-%E4%BA%94%E9%98%9F%E5%A4%AB%E5%A6%87%E5%8F%82%E5%8A%A0%E8%81%9A%E4%BC%9A%E6%AF%8F%E4%B8%AA%E4%BA%BA%E4%B8%8D%E8%83%BD%E5%92%8C%E8%87%AA%E5%B7%B1%E7%9A%84%E9%85%8D%E5%81%B6%E6%8F%A1%E6%89%8B%E5%8F%AA%E8%83%BD%E6%9C%80%E5%A4%9A%E5%92%8C%E4%BB%96%E4%BA%BA%E6%8F%A1%E6%89%8B%E4%B8%80%E6%AC%A1a%E9%97%AE%E4%BA%86%E5%85%B6%E4%BB%96%E4%BA%BA%E5%8F%91%E7%8E%B0%E6%AF%8F%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%8F%A1%E6%89%8B%E6%AC%A1%E6%95%B0%E9%83%BD">6. 五队夫妇参加聚会握手问题</a></li><li><a href="#7-%E4%BD%A0%E5%8F%AA%E8%83%BD%E5%B8%A6%E8%A1%8C%E8%B5%B0-60-%E5%85%AC%E9%87%8C%E7%9A%84%E6%B2%B9%E5%8F%AA%E8%83%BD%E5%9C%A8%E8%B5%B7%E5%A7%8B%E7%82%B9%E5%8A%A0%E6%B2%B9%E5%A6%82%E4%BD%95%E7%A9%BF%E8%BF%87-80-%E5%85%AC%E9%87%8C%E7%9A%84%E6%B2%99%E6%BC%A0">7. 你只能带行走 60 公里的油，只能在起始点加油，如何穿过 80 公里的沙漠？</a></li><li><a href="#8-%E7%83%A7%E4%B8%80%E6%A0%B9%E4%B8%8D%E5%9D%87%E5%8C%80%E7%9A%84%E7%BB%B3%E8%A6%81%E7%94%A8%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%97%B6%E5%A6%82%E4%BD%95%E7%94%A8%E5%AE%83%E6%9D%A5%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%97%B6%E5%8D%81%E4%BA%94%E5%88%86%E9%92%9F">8. 烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？</a></li><li><a href="#9-%E6%9C%897%E5%85%8B2%E5%85%8B%E7%A0%9D%E7%A0%81%E5%90%84%E4%B8%80%E4%B8%AA%E5%A4%A9%E5%B9%B3%E4%B8%80%E5%8F%AA%E5%A6%82%E4%BD%95%E5%8F%AA%E7%94%A8%E8%BF%99%E4%BA%9B%E7%89%A9%E5%93%81%E4%B8%89%E6%AC%A1%E5%B0%86140%E5%85%8B%E7%9A%84%E7%9B%90%E5%88%86%E6%88%905090%E5%85%8B%E5%90%84%E4%B8%80%E4%BB%BD">9. 有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？</a></li><li><a href="#10-%E6%9C%89%E4%B8%80%E8%BE%86%E7%81%AB%E8%BD%A6%E4%BB%A5%E6%AF%8F%E5%B0%8F%E6%97%B615%E5%85%AC%E9%87%8C%E7%9A%84%E9%80%9F%E5%BA%A6%E7%A6%BB%E5%BC%80%E6%B4%9B%E6%9D%89%E7%9F%B6%E7%9B%B4%E5%A5%94%E7%BA%BD%E7%BA%A6%E5%8F%A6%E4%B8%80%E8%BE%86%E7%81%AB%E8%BD%A6%E4%BB%A5%E7%AC%AC%E5%B0%8F%E6%97%B620%E5%85%AC%E9%87%8C%E7%9A%84%E9%80%9F%E5%BA%A6%E4%BB%8E%E7%BA%BD%E7%BA%A6%E5%BC%80%E5%BE%80%E6%B4%9B%E6%9D%89%E7%9F%B6%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E5%8F%AA%E9%B8%9F%E4%BB%A5%E5%A4%9630%E5%85%AC%E9%87%8C%E6%AF%8F%E5%B0%8F%E6%97%B6%E7%9A%84%E9%80%9F%E5%BA%A6%E5%92%8C%E4%B8%A4%E8%BE%86%E7%81%AB%E8%BD%A6%E7%8E%B0%E6%97%B6%E5%90%AF%E5%8A%A8%E4%BB%8E%E6%B4%9B%E6%9D%89%E7%9F%B6%E5%87%BA%E5%8F%91%E7%A2%B0%E5%88%B0%E5%8F%A6%E8%BE%86%E8%BD%A6%E5%90%8E%E8%BF%94%E5%9B%9E%E4%BE%9D%E6%AC%A1%E5%9C%A8%E4%B8%A4%E8%BE%86%E7%81%AB%E8%BD%A6%E6%9D%A5%E5%9B%9E%E7%9A%84%E9%A3%9E%E8%A1%8C%E7%9B%B4%E9%81%93%E4%B8%A4%E9%9D%A2%E8%BE%86%E7%81%AB%E8%BD%A6%E7%9B%B8%E9%81%87%E8%AF%B7%E9%97%AE%E8%BF%99%E5%8F%AA%E5%B0%8F%E9%B8%9F%E9%A3%9E%E8%A1%8C%E4%BA%86%E5%A4%9A%E9%95%BF%E8%B7%9D%E7%A6%BB">10. 火车相对而行，小鸟飞行距离问题 </a></li><li><a href="#11-%E4%BD%A0%E6%9C%89%E4%B8%A4%E4%B8%AA%E7%BD%90%E5%AD%9050%E4%B8%AA%E7%BA%A2%E8%89%B2%E5%BC%B9%E7%90%8350%E4%B8%AA%E8%93%9D%E8%89%B2%E5%BC%B9%E7%90%83%E9%9A%8F%E6%9C%BA%E9%80%89%E5%87%BA%E4%B8%80%E4%B8%AA%E7%BD%90%E5%AD%90%E9%9A%8F%E6%9C%BA%E9%80%89%E5%8F%96%E5%87%BA%E4%B8%80%E4%B8%AA%E5%BC%B9%E7%90%83%E6%94%BE%E5%85%A5%E7%BD%90%E5%AD%90%E6%80%8E%E4%B9%88%E7%BB%99%E7%BA%A2%E8%89%B2%E5%BC%B9%E7%90%83%E6%9C%80%E5%A4%A7%E7%9A%84%E9%80%89%E4%B8%AD%E6%9C%BA%E4%BC%9A%E5%9C%A8%E4%BD%A0%E7%9A%84%E8%AE%A1%E5%88%92%E4%B8%AD%E5%BE%97%E5%88%B0%E7%BA%A2%E7%90%83%E7%9A%84%E5%87%86%E7%A1%AE%E5%87%A0%E7%8E%87%E6%98%AF%E5%A4%9A%E5%B0%91">11. 弹球拾取几率问题</a></li><li><a href="#12-%E5%81%87%E8%AE%BE%E4%BD%A0%E6%9C%898%E4%B8%AA%E7%90%83%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%95%A5%E5%BE%AE%E9%87%8D%E4%B8%80%E4%BA%9B%E4%BD%86%E6%98%AF%E6%89%BE%E5%87%BA%E8%BF%99%E4%B8%AA%E7%90%83%E7%9A%84%E6%83%9F%E4%B8%80%E6%96%B9%E6%B3%95%E6%98%AF%E5%B0%86%E4%B8%A4%E4%B8%AA%E7%90%83%E6%94%BE%E5%9C%A8%E5%A4%A9%E5%B9%B3%E4%B8%8A%E5%AF%B9%E6%AF%94%E6%9C%80%E5%B0%91%E8%A6%81%E7%A7%B0%E5%A4%9A%E5%B0%91%E6%AC%A1%E6%89%8D%E8%83%BD%E6%89%BE%E5%87%BA%E8%BF%99%E4%B8%AA%E8%BE%83%E9%87%8D%E7%9A%84%E7%90%83">12. 8个球使用天平称重问题</a></li><li><a href="#13-%E5%9C%A8%E6%88%BF%E9%87%8C%E6%9C%89%E4%B8%89%E7%9B%8F%E7%81%AF%E6%88%BF%E5%A4%96%E6%9C%89%E4%B8%89%E4%B8%AA%E5%BC%80%E5%85%B3%E5%9C%A8%E6%88%BF%E5%A4%96%E7%9C%8B%E4%B8%8D%E8%A7%81%E6%88%BF%E5%86%85%E7%9A%84%E6%83%85%E5%86%B5%E4%BD%A0%E5%8F%AA%E8%83%BD%E8%BF%9B%E9%97%A8%E4%B8%80%E6%AC%A1%E4%BD%A0%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E6%9D%A5%E5%8C%BA%E5%88%86%E9%82%A3%E4%B8%AA%E5%BC%80%E5%85%B3%E6%8E%A7%E5%88%B6%E9%82%A3%E4%B8%80%E7%9B%8F%E7%81%AF">13. 三盏灯区分开关问题</a></li><li><a href="#14-%E4%BB%96%E4%BB%AC%E9%83%BD%E5%90%84%E8%87%AA%E4%B9%B0%E4%BA%86%E4%B8%A4%E5%AF%B9%E9%BB%91%E8%A2%9C%E5%92%8C%E4%B8%A4%E5%AF%B9%E7%99%BD%E8%A2%9C%E5%85%AB%E5%AF%B9%E8%A2%9C%E5%AD%90%E7%9A%84%E5%B8%83%E8%B4%A8%E5%A4%A7%E5%B0%8F%E5%AE%8C%E5%85%A8%E7%9B%B8%E5%90%8C%E8%80%8C%E6%AF%8F%E5%AF%B9%E8%A2%9C%E5%AD%90%E9%83%BD%E6%9C%89%E4%B8%80%E5%BC%A0%E5%95%86%E6%A0%87%E7%BA%B8%E8%BF%9E%E7%9D%80%E4%B8%A4%E4%BD%8D%E7%9B%B2%E4%BA%BA%E4%B8%8D%E5%B0%8F%E5%BF%83%E5%B0%86%E5%85%AB%E5%AF%B9%E8%A2%9C%E5%AD%90%E6%B7%B7%E5%9C%A8%E4%B8%80%E8%B5%B7%E4%BB%96%E4%BB%AC%E6%AF%8F%E4%BA%BA%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E5%8F%96%E5%9B%9E%E9%BB%91%E8%A2%9C%E5%92%8C%E7%99%BD%E8%A2%9C%E5%90%84%E4%B8%A4%E5%AF%B9%E5%91%A2">14. 盲人黑白袜子问题</a></li><li><a href="#15-%E6%9C%89%E4%B8%89%E7%AD%90%E6%B0%B4%E6%9E%9C%E4%B8%80%E7%AD%90%E8%A3%85%E7%9A%84%E5%85%A8%E6%98%AF%E8%8B%B9%E6%9E%9C%E7%AC%AC%E4%BA%8C%E7%AD%90%E8%A3%85%E7%9A%84%E5%85%A8%E6%98%AF%E6%A9%98%E5%AD%90%E7%AC%AC%E4%B8%89%E7%AD%90%E6%98%AF%E6%A9%98%E5%AD%90%E4%B8%8E%E8%8B%B9%E6%9E%9C%E6%B7%B7%E5%9C%A8%E4%B8%80%E8%B5%B7%E7%AD%90%E4%B8%8A%E7%9A%84%E6%A0%87%E7%AD%BE%E9%83%BD%E6%98%AF%E9%AA%97%E4%BA%BA%E7%9A%84%E5%B0%B1%E6%98%AF%E8%AF%B4%E7%AD%90%E4%B8%8A%E7%9A%84%E6%A0%87%E7%AD%BE%E9%83%BD%E6%98%AF%E9%94%99%E7%9A%84%E4%BD%A0%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%98%AF%E6%8B%BF%E5%87%BA%E5%85%B6%E4%B8%AD%E4%B8%80%E7%AD%90%E4%BB%8E%E9%87%8C%E9%9D%A2%E5%8F%AA%E6%8B%BF%E4%B8%80%E5%8F%AA%E6%B0%B4%E6%9E%9C%E7%84%B6%E5%90%8E%E6%AD%A3%E7%A1%AE%E5%86%99%E5%87%BA%E4%B8%89%E7%AD%90%E6%B0%B4%E6%9E%9C%E7%9A%84%E6%A0%87%E7%AD%BE">15. 水果标签问题</a></li><li><a href="#16-%E4%B8%80%E4%B8%AA%E7%8F%AD%E7%BA%A760%E5%96%9C%E6%AC%A2%E8%B6%B3%E7%90%8370%E5%96%9C%E6%AC%A2%E7%AF%AE%E7%90%8380%E5%96%9C%E6%AC%A2%E6%8E%92%E7%90%83%E9%97%AE%E5%8D%B3%E4%B8%89%E7%A7%8D%E7%90%83%E9%83%BD%E5%96%9C%E6%AC%A2%E5%8D%A0%E6%AF%94%E6%9C%89%E5%A4%9A%E5%B0%91">16. 一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球，问即三种球都喜欢占比有多少？</a></li><li><a href="#17-%E4%BA%94%E5%8F%AA%E9%B8%A1%E4%BA%94%E5%A4%A9%E8%83%BD%E4%B8%8B%E4%BA%94%E4%B8%AA%E8%9B%8B%E4%B8%80%E7%99%BE%E5%A4%A9%E4%B8%8B%E4%B8%80%E7%99%BE%E4%B8%AA%E8%9B%8B%E9%9C%80%E8%A6%81%E5%A4%9A%E5%B0%91%E5%8F%AA%E9%B8%A1">17. 五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？</a></li></ul></li><li><a href="#%E5%89%91%E6%8C%87-offer-%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93">剑指 offer 思路总结</a><ul><li><a href="#%E9%A2%98%E7%9B%AE">题目</a><ul><li><a href="#1-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE">1. 二维数组中的查找</a></li><li><a href="#2-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC">2. 替换空格</a></li><li><a href="#3-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8">3. 从尾到头打印链表</a></li><li><a href="#4-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91">4. 重建二叉树</a></li><li><a href="#5-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">5. 用两个栈实现队列</a></li><li><a href="#6-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97">6. 旋转数组的最小数字</a></li><li><a href="#7-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">7. 斐波那契数列</a></li><li><a href="#8-%E8%B7%B3%E5%8F%B0%E9%98%B6">8. 跳台阶</a></li><li><a href="#9-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6">9. 变态跳台阶</a></li><li><a href="#10-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96">10. 矩形覆盖</a></li><li><a href="#11-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0">11. 二进制中1的个数</a></li><li><a href="#12-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9">12. 数值的整数次方</a></li><li><a href="#13-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2">13. 调整数组顺序使奇数位于偶数前面</a></li><li><a href="#14-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9">14. 链表中倒数第 k 个节点</a></li><li><a href="#15-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">15. 反转链表</a></li><li><a href="#16-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8">16. 合并两个排序的链表</a></li><li><a href="#17-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84">17. 树的子结构</a></li><li><a href="#18-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F">18. 二叉树的镜像</a></li><li><a href="#19-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5">19. 顺时针打印矩阵</a></li><li><a href="#20-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0-min-%E5%87%BD%E6%95%B0">20. 定义一个栈，实现 min 函数</a></li><li><a href="#21-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA">21. 栈的压入弹出</a></li><li><a href="#22-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91">22. 从上往下打印二叉树</a></li><li><a href="#23-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">23. 二叉搜索树的后序遍历</a></li><li><a href="#24-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E8%B7%AF%E5%BE%84">24. 二叉树中和为某一值路径</a></li><li><a href="#25-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6">25. 复杂链表的复制</a></li><li><a href="#26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8">26. 二叉搜索树与双向链表</a></li><li><a href="#27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97">27. 字符串的排列</a></li><li><a href="#28-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97">28. 数组中出现次数超过一半的数字</a></li><li><a href="#29-%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E4%B8%AA%E6%95%B0">29. 最小的 K 个数</a></li><li><a href="#30-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C">30. 连续子数组的最大和</a></li><li><a href="#31-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">31. 整数中1出现的次数（待深入理解）</a></li><li><a href="#32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0">32. 把数组排成最小的数</a></li><li><a href="#33-%E4%B8%91%E6%95%B0%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">33. 丑数（待深入理解）</a></li><li><a href="#34-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6">34. 第一个只出现一次的字符</a></li><li><a href="#35-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9">35. 数组中的逆序对</a></li><li><a href="#36-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9">36. 两个链表的第一个公共结点</a></li><li><a href="#37-%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0">37. 数字在排序数组中出现的次数</a></li><li><a href="#38-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6">38. 二叉树的深度</a></li><li><a href="#39-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">39. 平衡二叉树</a></li><li><a href="#40-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97">40. 数组中只出现一次的数字</a></li><li><a href="#41-%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97">41. 和为 S 的连续正数序列</a></li><li><a href="#42-%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97">42. 和为 S 的两个数字</a></li><li><a href="#43-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2">43. 左旋转字符串</a></li><li><a href="#44-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97">44. 翻转单词顺序列</a></li><li><a href="#45-%E6%89%91%E5%85%8B%E7%89%8C%E7%9A%84%E9%A1%BA%E5%AD%90">45. 扑克牌的顺子</a></li><li><a href="#46-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98">46. 圆圈中最后剩下的数字（约瑟夫环问题）</a></li><li><a href="#47-123n">47. 1 2 3 … n</a></li><li><a href="#48-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95">48. 不用加减乘除做加法</a></li><li><a href="#49-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0">49. 把字符串转换成整数。</a></li><li><a href="#50-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97">50. 数组中重复的数字</a></li><li><a href="#51-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84">51. 构建乘积数组</a></li><li><a href="#52-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8C%B9%E9%85%8D">52. 正则表达式的匹配</a></li><li><a href="#53-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2">53. 表示数值的字符串</a></li><li><a href="#54-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6">54. 字符流中第一个不重复的字符</a></li><li><a href="#55-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9">55. 链表中环的入口结点</a></li><li><a href="#56-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9">56. 删除链表中重复的结点</a></li><li><a href="#57-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9">57. 二叉树的下一个结点</a></li><li><a href="#58-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91">58. 对称二叉树</a></li><li><a href="#59-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">59. 按之字形顺序打印二叉树（待深入理解）</a></li><li><a href="#60-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%8C%89%E5%B1%82%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8C%E4%B8%80%E5%B1%82%E7%BB%93%E7%82%B9%E4%BB%8E%E5%B7%A6%E8%87%B3%E5%8F%B3%E8%BE%93%E5%87%BA%E6%AF%8F%E4%B8%80%E5%B1%82%E8%BE%93%E5%87%BA%E4%B8%80%E8%A1%8C">60. 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</a></li><li><a href="#61-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">61. 序列化二叉树（待深入理解）</a></li><li><a href="#62-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9">62. 二叉搜索树的第 K 个节点</a></li><li><a href="#63-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">63. 数据流中的中位数（待深入理解）</a></li><li><a href="#64-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">64. 滑动窗口中的最大值（待深入理解）</a></li><li><a href="#65-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">65. 矩阵中的路径（待深入理解）</a></li><li><a href="#66-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">66. 机器人的运动范围（待深入理解）</a></li></ul></li><li><a href="#%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98">相关算法题</a><ul><li><a href="#1-%E6%98%8E%E6%98%9F%E9%97%AE%E9%A2%98">1. 明星问题</a></li><li><a href="#2-%E6%AD%A3%E8%B4%9F%E6%95%B0%E7%BB%84%E6%B1%82%E5%92%8C">2. 正负数组求和</a></li></ul></li></ul></li></ul><h1 id="常用算法和数据结构总结"><a href="#常用算法和数据结构总结" class="headerlink" title="常用算法和数据结构总结"></a>常用算法和数据结构总结</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序的基本思想是，对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟会将最小或最大的元素“浮”到顶端，<br>最终达到完全有序。</p><p>代码实现：</p><pre><code class="js">function bubbleSort(arr) {    if (!Array.isArray(arr) || arr.length &lt;= 1) return;    let lastIndex = arr.length - 1;    while (lastIndex &gt; 0) { // 当最后一个交换的元素为第一个时，说明后面全部排序完毕        let flag = true, k = lastIndex;        for (let j = 0; j &lt; k; j++) {            if (arr[j] &gt; arr[j + 1]) {                flag = false;                  lastIndex = j; // 设置最后一次交换元素的位置                [arr[j], arr[j+1]] = [arr[j+1], arr[j]];            }        }          if (flag) break;    }}</code></pre><p>冒泡排序有两种优化方式。</p><p>一种是外层循环的优化，我们可以记录当前循环中是否发生了交换，如果没有发生交换，则说明该序列已经为有序序列了。<br>因此我们不需要再执行之后的外层循环，此时可以直接结束。</p><p>一种是内层循环的优化，我们可以记录当前循环中最后一次元素交换的位置，该位置以后的序列都是已排好的序列，因此下<br>一轮循环中无需再去比较。</p><p>优化后的冒泡排序，当排序序列为已排序序列时，为最好的时间复杂度为 O(n)。</p><p>冒泡排序的平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6103002.html">《图解排序算法(一)》</a><br><a href="http://bubkoo.com/2014/01/15/sort-algorithm/shaker-sort/">《常见排序算法 - 鸡尾酒排序 》</a><br><a href="https://juejin.im/post/5b72f0caf265da282809f3b5#heading-1">《前端笔试&amp;面试爬坑系列—算法》</a><br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc724af265da610f632e41">《前端面试之道》</a></p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序的基本思想为每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止。</p><p>在算法实现时，每一趟确定最小元素的时候会通过不断地比较交换来使得首位置为当前最小，交换是个比较耗时的操作。其实<br>我们很容易发现，在还未完全确定当前最小元素之前，这些交换都是无意义的。我们可以通过设置一个变量 min，每一次比较<br>仅存储较小元素的数组下标，当轮循环结束之后，那这个变量存储的就是当前最小元素的下标，此时再执行交换操作即可。</p><p>代码实现：</p><pre><code class="js">function selectSort(array) {  let length = array.length;  // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序   if (!Array.isArray(array) || length &lt;= 1) return;  for (let i = 0; i &lt; length - 1; i++) {    let minIndex = i; // 设置当前循环最小元素索引    for (let j = i + 1; j &lt; length; j++) {      // 如果当前元素比最小元素索引，则更新最小元素索引      if (array[minIndex] &gt; array[j]) {        minIndex = j;      }    }    // 交换最小元素到当前位置    // [array[i], array[minIndex]] = [array[minIndex], array[i]];    swap(array, i, minIndex);  }  return array;}// 交换数组中两个元素的位置function swap(array, left, right) {  var temp = array[left];  array[left] = array[right];  array[right] = temp;}</code></pre><p>选择排序不管初始序列是否有序，时间复杂度都为 O(n²)。</p><p>选择排序的平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，不是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6103002.html">《图解排序算法(一)》</a></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>直接插入排序基本思想是每一步将一个待排序的记录，插入到前面已经排好序的有序序列中去，直到插完所有元素为止。</p><p>插入排序核心–扑克牌思想： 就想着自己在打扑克牌，接起来一张，放哪里无所谓，再接起来一张，比第一张小，放左边，<br>继续接，可能是中间数，就插在中间….依次</p><p>代码实现：</p><pre><code class="js">function insertSort(array) {  let length = array.length;  // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序   if (!Array.isArray(array) || length &lt;= 1) return;  // 循环从 1 开始，0 位置为默认的已排序的序列  for (let i = 1; i &lt; length; i++) {    let temp = array[i]; // 保存当前需要排序的元素    let j = i;    // 在当前已排序序列中比较，如果比需要排序的元素大，就依次往后移动位置    while (j -1 &gt;= 0 &amp;&amp; array[j - 1] &gt; temp) {      array[j] = array[j - 1];      j--;    }    // 将找到的位置插入元素    array[j] = temp;  }  return array;}</code></pre><p>当排序序列为已排序序列时，为最好的时间复杂度 O(n)。</p><p>插入排序的平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6103002.html">《图解排序算法(一)》</a></p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序的基本思想是把数组按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的元<br>素越来越多，当增量减至1时，整个数组恰被分成一组，算法便终止。</p><p>代码实现：</p><pre><code class="js">function hillSort(array) {  let length = array.length;  // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序   if (!Array.isArray(array) || length &lt;= 1) return;  // 第一层确定增量的大小，每次增量的大小减半  for (let gap = parseInt(length &gt;&gt; 1); gap &gt;= 1; gap = parseInt(gap &gt;&gt; 1)) {    // 对每个分组使用插入排序，相当于将插入排序的1换成了 n    for (let i = gap; i &lt; length; i++) {      let temp = array[i];      let j = i;      while (j - gap &gt;= 0 &amp;&amp; array[j - gap] &gt; temp) {        array[j] = array[j - gap];        j -= gap;      }      array[j] = temp;    }  }  return array;}</code></pre><p>希尔排序是利用了插入排序对于已排序序列排序效果最好的特点，在一开始序列为无序序列时，将序列分为多个小的分组进行<br>基数排序，由于排序基数小，每次基数排序的效果较好，然后在逐步增大增量，将分组的大小增大，由于每一次都是基于上一<br>次排序后的结果，所以每一次都可以看做是一个基本排序的序列，所以能够最大化插入排序的优点。</p><p>简单来说就是，由于开始时每组只有很少整数，所以排序很快。之后每组含有的整数越来越多，但是由于这些数也越来越有序，<br>所以排序速度也很快。</p><p>希尔排序的时间复杂度根据选择的增量序列不同而不同，但总的来说时间复杂度是小于 O(n^2) 的。</p><p>插入排序是一个稳定排序，但是在希尔排序中，由于相同的元素可能在不同的分组中，所以可能会造成相同元素位置的变化，<br>所以希尔排序是一个不稳定的排序。</p><p>希尔排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(n^s) ，空间复杂度为 O(1) ，不是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6104371.html">《图解排序算法(二)之希尔排序》</a><br><a href="https://blog.csdn.net/u013630349/article/details/48250109">《数据结构基础 希尔排序 之 算法复杂度浅析》</a></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略。递归的将数组两两分开直到只包含一个元素，然后<br>将数组排序合并，最终合并为排序好的数组。</p><p>代码实现：</p><pre><code class="js">function mergeSort(array) {  let length = array.length;  // 如果不是数组或者数组长度小于等于0，直接返回，不需要排序   if (!Array.isArray(array) || length === 0) return;  if (length === 1) {    return array;  }  let mid = parseInt(length &gt;&gt; 1), // 找到中间索引值    left = array.slice(0, mid), // 截取左半部分    right = array.slice(mid, length); // 截取右半部分  return merge(mergeSort(left), mergeSort(right)); // 递归分解后，进行排序合并}function merge(leftArray, rightArray) {  let result = [],    leftLength = leftArray.length,    rightLength = rightArray.length,    il = 0,    ir = 0;  // 左右两个数组的元素依次比较，将较小的元素加入结果数组中，直到其中一个数组的元素全部加入完则停止  while (il &lt; leftLength &amp;&amp; ir &lt; rightLength) {    if (leftArray[il] &lt; rightArray[ir]) {      result.push(leftArray[il++]);    } else {      result.push(rightArray[ir++]);    }  }  // 如果是左边数组还有剩余，则把剩余的元素全部加入到结果数组中。  while (il &lt; leftLength) {    result.push(leftArray[il++]);  }  // 如果是右边数组还有剩余，则把剩余的元素全部加入到结果数组中。  while (ir &lt; rightLength) {    result.push(rightArray[ir++]);  }  return result;}</code></pre><p>归并排序将整个排序序列看成一个二叉树进行分解，首先将树分解到每一个子节点，树的每一层都是一个归并排序的过程，每<br>一层归并的时间复杂度为 O(n)，因为整个树的高度为 lgn，所以归并排序的时间复杂度不管在什么情况下都为O(nlogn)。</p><p>归并排序的空间复杂度取决于递归的深度和用于归并时的临时数组，所以递归的深度为 logn，临时数组的大小为 n，所以归<br>并排序的空间复杂度为 O(n)。</p><p>归并排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(nlogn) ，空间复杂度为 O(n) ，是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6194356.html">《图解排序算法(四)之归并排序》</a><br><a href="https://www.zhihu.com/question/27274006">《归并排序的空间复杂度？》</a></p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序的基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据<br>都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>代码实现：</p><pre><code class="js">function quickSort(array, start, end) {  let length = array.length;  // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序   if (!Array.isArray(array) || length &lt;= 1 || start &gt;= end) return;  let index = partition(array, start, end); // 将数组划分为两部分，并返回右部分的第一个元素的索引值  quickSort(array, start, index - 1); // 递归排序左半部分  quickSort(array, index + 1, end); // 递归排序右半部分}function partition(array, start, end) {  let pivot = array[start]; // 取第一个值为枢纽值，获取枢纽值的大小  // 当 start 等于 end 指针时结束循环  while (start &lt; end) {    // 当 end 指针指向的值大等于枢纽值时，end 指针向前移动    while (array[end] &gt;= pivot &amp;&amp; start &lt; end) {      end--;    }    // 将比枢纽值小的值交换到 start 位置    array[start] = array[end];    // 移动 start 值，当 start 指针指向的值小于枢纽值时，start 指针向后移动    while (array[start] &lt; pivot &amp;&amp; start &lt; end) {      start++;    }    // 将比枢纽值大的值交换到 end 位置，进入下一次循环    array[end] = array[start];  }  // 将枢纽值交换到中间点  array[start] = pivot;  // 返回中间索引值  return start;}</code></pre><p>这一种方法是填空法，首先将第一个位置的数作为枢纽值，然后 end 指针向前移动，当遇到比枢纽值小的值或者 end 值<br>等于 start 值的时候停止，然后将这个值填入 start 的位置，然后 start 指针向后移动，当遇到比枢纽值大的值或者<br>start 值等于 end 值的时候停止，然后将这个值填入 end 的位置。反复循环这个过程，直到 start 的值等于 end 的<br>值为止。将一开始保留的枢纽值填入这个位置，此时枢纽值左边的值都比枢纽值小，枢纽值右边的值都比枢纽值大。然后在递<br>归左右两边的的序列。</p><p>当每次换分的结果为含 ⌊n/2⌋和 ⌈n/2⌉−1 个元素时，最好情况发生，此时递归的次数为 logn，然后每次划分的时间复杂<br>度为 O(n)，所以最优的时间复杂度为 O(nlogn)。一般来说只要每次换分都是常比例的划分，时间复杂度都为 O(nlogn)。</p><p>当每次换分的结果为 n-1 和 0 个元素时，最坏情况发生。划分操作的时间复杂度为 O(n)，递归的次数为 n-1，所以最坏<br>的时间复杂度为 O(n²)。所以当排序序列有序的时候，快速排序有可能被转换为冒泡排序。</p><p>快速排序的空间复杂度取决于递归的深度，所以最好的时候为 O(logn)，最坏的时候为 O(n)。</p><p>快速排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(logn) ，不是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6262208.html">《图解排序算法(五)之快速排序——三数取中法》</a><br><a href="https://segmentfault.com/a/1190000004410119#articleHeader2">《关于快速排序的四种写法》</a><br><a href="https://harttle.land/2015/09/27/quick-sort.html">《快速排序的时间和空间复杂度》</a><br><a href="https://blog.csdn.net/weshjiness/article/details/8660583">《快速排序最好，最坏，平均复杂度分析》</a><br><a href="https://blog.csdn.net/qq_33758761/article/details/76782610">《快速排序算法的递归深度》</a></p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行<br>交换，此时末尾就为最大值。然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，<br>便能得到一个有序序列了。</p><pre><code class="js">function heapSort(array) {  let length = array.length;  // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序   if (!Array.isArray(array) || length &lt;= 1) return;  buildMaxHeap(array); // 将传入的数组建立为大顶堆  // 每次循环，将最大的元素与末尾元素交换，然后剩下的元素重新构建为大顶堆  for (let i = length - 1; i &gt; 0; i--) {    swap(array, 0, i);    adjustMaxHeap(array, 0, i); // 将剩下的元素重新构建为大顶堆  }  return array;}function adjustMaxHeap(array, index, heapSize) {  let iMax,    iLeft,    iRight;  while (true) {    iMax = index; // 保存最大值的索引    iLeft = 2 * index + 1; // 获取左子元素的索引    iRight = 2 * index + 2; // 获取右子元素的索引    // 如果左子元素存在，且左子元素大于最大值，则更新最大值索引    if (iLeft &lt; heapSize &amp;&amp; array[iMax] &lt; array[iLeft]) {      iMax = iLeft;    }    // 如果右子元素存在，且右子元素大于最大值，则更新最大值索引    if (iRight &lt; heapSize &amp;&amp; array[iMax] &lt; array[iRight]) {      iMax = iRight;    }    // 如果最大元素被更新了，则交换位置，使父节点大于它的子节点，同时将索引值跟新为被替换的值，继续检查它的子树    if (iMax !== index) {      swap(array, index, iMax);      index = iMax;    } else {      // 如果未被更新，说明该子树满足大顶堆的要求，退出循环      break;    }  }}// 构建大顶堆function buildMaxHeap(array) {  let length = array.length,    iParent = parseInt(length &gt;&gt; 1) - 1; // 获取最后一个非叶子点的元素  for (let i = iParent; i &gt;= 0; i--) {    adjustMaxHeap(array, i, length); // 循环调整每一个子树，使其满足大顶堆的要求  }}// 交换数组中两个元素的位置function swap(array, i, j) {  let temp = array[i];  array[i] = array[j];  array[j] = temp;}</code></pre><p>建立堆的时间复杂度为 O(n)，排序循环的次数为 n-1，每次调整堆的时间复杂度为 O(logn)，因此堆排序的时间复杂度在<br>不管什么情况下都是 O(nlogn)。</p><p>堆排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(nlogn) ，空间复杂度为 O(1) ，不是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6129630.html">《图解排序算法(三)之堆排序》</a><br><a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/">《常见排序算法 - 堆排序 (Heap Sort)》</a><br><a href="https://www.zhihu.com/question/20729324">《堆排序中建堆过程时间复杂度O(n)怎么来的？》</a><br><a href="https://blog.csdn.net/YuZhiHui_No1/article/details/44258297">《排序算法之 堆排序 及其时间复杂度和空间复杂度》</a><br><a href="https://blog.csdn.net/hrn1216/article/details/51465270">《最小堆 构建、插入、删除的过程图解》</a></p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。排序过程：将<br>所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样<br>从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p><p>代码实现：</p><pre><code class="js">function radixSort(array) {  let length = array.length;  // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序   if (!Array.isArray(array) || length &lt;= 1) return;  let bucket = [],    max = array[0],    loop;  // 确定排序数组中的最大值  for (let i = 1; i &lt; length; i++) {    if (array[i] &gt; max) {      max = array[i];    }  }  // 确定最大值的位数  loop = (max + '').length;  // 初始化桶  for (let i = 0; i &lt; 10; i++) {    bucket[i] = [];  }  for (let i = 0; i &lt; loop; i++) {    for (let j = 0; j &lt; length; j++) {      let str = array[j] + '';      if (str.length &gt;= i + 1) {        let k = parseInt(str[str.length - 1 - i]); // 获取当前位的值，作为插入的索引        bucket[k].push(array[j]);      } else {        // 处理位数不够的情况，高位默认为 0        bucket[0].push(array[j]);      }    }    array.splice(0, length); // 清空旧的数组    // 使用桶重新初始化数组    for (let i = 0; i &lt; 10; i++) {      let t = bucket[i].length;      for (let j = 0; j &lt; t; j++) {        array.push(bucket[i][j]);      }      bucket[i] = [];    }  }  return array;}</code></pre><p>基数排序的平均时间复杂度为 O(nk)，k 为最大元素的长度，最坏时间复杂度为 O(nk)，空间复杂度为 O(n) ，是稳定<br>排序。</p><p>详细资料可以参考：<br><a href="http://bubkoo.com/2014/01/15/sort-algorithm/radix-sort/">《常见排序算法 - 基数排序》</a><br><a href="https://blog.csdn.net/YuZhiHui_No1/article/details/44594415">《排序算法之 基数排序 及其时间复杂度和空间复杂度》</a></p><p>算法总结可以参考：<br><a href="https://blog.csdn.net/zolalad/article/details/11848739">《算法的时间复杂度和空间复杂度-总结》</a><br><a href="https://www.cnblogs.com/onepixel/p/7674659.html">《十大经典排序算法（动图演示）》</a><br><a href="https://blog.csdn.net/wangiijing/article/details/51485119">《各类排序算法的对比及实现》</a></p><h3 id="快速排序相对于其他排序效率更高的原因"><a href="#快速排序相对于其他排序效率更高的原因" class="headerlink" title="快速排序相对于其他排序效率更高的原因"></a>快速排序相对于其他排序效率更高的原因</h3><p>上面一共提到了8种排序的方法，在实际使用中，应用最广泛的是快速排序。快速排序相对于其他排序算法的优势在于在相同<br>数据量的情况下，它的运算效率最高，并且它额外所需空间最小。</p><p>我们首先从时间复杂度来判断，由于前面几种方法的时间复杂度平均情况下基本趋向于 O(n²)，因此只从时间复杂度上来看<br>的话，显然归并排序、堆排序和快速排序的时间复杂度最小。但是既然这几种方法的时间复杂度基本一致，并且快速排序在最<br>坏情况下时间的复杂度还会变为 O(n²)，那么为什么它的效率反而更高呢？</p><p>首先在对大数据量排序的时候，由于归并排序的空间复杂度为 O(n)，因此归并排序在这种情况下会需要过多的额外内存，因<br>此归并排序首先就被排除掉了。</p><p>接下来就剩下了堆排序和快速排序的比较。我认为堆排序相对于快速排序的效率不高的原因有两个方面。</p><p>第一个方面是对于比较操作的有效性来说。对于快速排序来说，每一次元素的比较都会确定该元素在数组中的位置，也就是在<br>枢纽值的左边或者右边，快速排序的每一次比较操作都是有意义的结果。而对于堆排序来说，在每一次重新调整堆的时候，我<br>们在迭代时，已经知道上层的节点值一定比下层的节点值大，因此当我们每次为了打乱堆结构而将最后一个元素与堆顶元素互<br>换时，互换后的元素一定是比下层元素小的，因此我们知道比较结果却还要在堆结构调整时去进行再一次的比较，这样的比较<br>是没有意义的，以此在堆排序中会产生大量的没有意义的比较操作。</p><p>第二个方面是对于缓存局部性原理的利用上来考虑的，我认为这应该是造成堆排序的效率不如快速排序的主要原因。在计算机<br>中利用了多级缓存的机制，来解决 cpu 计算速度与存储器数据读取速度间差距过大的问题。缓存的原理主要是基于局部性原<br>理，局部性原理简单来说就是，当前被访问过的数据，很有可能在一段时间内被再次访问，这被称为时间局部性。还有就是当<br>前访问的数据，那么它相邻的数据，也有可能在一段时间内被访问到，这被称为空间局部性。计算机缓存利用了局部性的原理<br>来对数据进行缓存，来尽可能少的减少磁盘的 I/O 次数，以此来提高执行效率。对于堆排序来说，它最大的问题就是它对于<br>空间局部性的违背，它在进行比较时，比较的并不是相邻的元素，而是与自己相隔很远的元素，这对于利用空间局部性来进行<br>数据缓存的计算机来说，它的很多缓存都是无效的。并且对于大数据量的排序来说，缓存的命中率就会变得很低，因此会明显<br>提高磁盘的 I/O 次数，并且由于堆排序的大量的无效比较，因此这样就造成了堆排序执行效率的低下。而相对来快速排序来<br>说，它的排序每一次都是在相邻范围内的比较，并且比较的范围越来越小，它很好的利用了局部性原理，因此它的执行效率更<br>高。简单来说就是在堆排序中获取一个元素的值所花费的时间比在快速排序获取一个元素的值所花费的时间要大。因此我们可<br>以看出，时间复杂度类似的算法，在计算机中实际执行可能会有很大的差别，因为决定算法执行效率的还有内存读取这样的其<br>他的因素。</p><p>相关资料可以参考：<br><a href="https://www.zhihu.com/question/23873747">《为什么在平均情况下快速排序比堆排序要优秀？》</a><br><a href="https://blog.csdn.net/qq_36770641/article/details/82669788">《为什么说快速排序是性能最好的排序算法？》</a></p><h3 id="系统自带排序实现"><a href="#系统自带排序实现" class="headerlink" title="系统自带排序实现"></a>系统自带排序实现</h3><p>每个语言的排序内部实现都是不同的。</p><p>对于 JS 来说，数组长度大于 10 会采用快排，否则使用插入排序。选择插入排序是因为虽然时间复杂度很差，但是在数据<br>量很小的情况下和 O(N * logN) 相差无几，然而插入排序需要的常数时间很小，所以相对别的排序来说更快。</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>稳定性的意思就是对于相同值来说，相对顺序不能改变。通俗的讲有两个相同的数 A 和 B，在排序之前 A 在 B 的前面，<br>而经过排序之后，B 跑到了 A 的前面，对于这种情况的发生，我们管他叫做排序的不稳定性。</p><p>稳定性有什么意义？个人理解对于前端来说，比如我们熟知框架中的虚拟 DOM 的比较，我们对一个<code>&lt;ul&gt;</code>列表进行渲染，<br>当数据改变后需要比较变化时，不稳定排序或操作将会使本身不需要变化的东西变化，导致重新渲染，带来性能的损耗。</p><h3 id="排序面试题目总结"><a href="#排序面试题目总结" class="headerlink" title="排序面试题目总结"></a>排序面试题目总结</h3><ol><li><p>快速排序在完全无序的情况下效果最好，时间复杂度为O(nlogn)，在有序情况下效果最差，时间复杂度为O(n^2)。</p></li><li><p>初始数据集的排列顺序对算法的性能无影响的有堆排序，直接选择排序，归并排序，基数排序。</p></li><li><p>合并 m 个长度为 n 的已排序数组的时间复杂度为 O(nmlogm)。</p></li><li><p>外部排序常用的算法是归并排序。</p></li><li><p>数组元素基本有序的情况下，插入排序效果最好，因为这样只需要比较大小，不需要移动，时间复杂度趋近于O(n)。</p></li><li><p>如果只想得到1000个元素组成的序列中第5个最小元素之前的部分排序的序列，用堆排序方法最快。</p></li><li><p>插入排序和优化后的冒泡在最优情况（有序）都只用比较 n-1 次。</p></li><li><p>对长度为 n 的线性表作快速排序，在最坏情况下，比较次数为 n(n-1)/2。</p></li><li><p>下标从1开始，在含有 n 个关键字的小根堆（堆顶元素最小）中，关键字最大的记录有可能存储在 [n/2]+2 位置上。<br>因为小根堆中最大的数一定是放在叶子节点上，堆本身是个完全二叉树，完全二叉树的叶子节点的位置大于 [n/2]。</p></li><li><p>拓扑排序的算法，每次都选择入度为0的结点从图中删去，并从图中删除该顶点和所有以它为起点的有向边。</p></li><li><p>任何一个基于”比较”的内部排序的算法，若对 n 个元素进行排序，则在最坏情况下所需的比较次数 k 满足 2^k &gt; n!，<br>时间下界为 O(nlogn)</p></li><li><p>m 个元素 k 路归并的归并趟数 s=logk(m)，代入数据：logk(100)≦3</p></li><li><p>对 n 个记录的线性表进行快速排序为减少算法的递归深度，每次分区后，先处理较短的部分。</p></li><li><p>在用邻接表表示图时，拓扑排序算法时间复杂度为 O(n+e)</p></li></ol><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树相关性质"><a href="#二叉树相关性质" class="headerlink" title="二叉树相关性质"></a>二叉树相关性质</h3><ol><li><p>节点的度：一个节点含有的子树的个数称为该节点的度；</p></li><li><p>叶节点或终端节点：度为零的节点； </p></li><li><p>节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推。 </p></li><li><p>树的高度或深度：树中节点的最大层次。</p></li><li><p>在非空二叉树中，第 i 层的结点总数不超过 2^(i-1)，i&gt;=1。 </p></li><li><p>深度为 h 的二叉树最多有 2^h-1个结点(h&gt;=1)，最少有 h 个结点。</p></li><li><p>对于任意一棵二叉树，如果其叶结点数为 N0，而度数为2的结点总数为 N2，则 N0 = N2+1； </p></li><li><p>给定 N 个节点，能构成 h(N) 种不同的二叉树。h(N)为卡特兰数的第 N 项。(2n)!/(n!(n+1)!)。</p></li><li><p>二叉树的前序遍历，首先访问根结点，然后遍历左子树，最后遍历右子树。简记根-左-右。 </p></li><li><p>二叉树的中序遍历，首先遍历左子树，然后访问根结点，最后遍历右子树。简记左-根-右。 </p></li><li><p>二叉树的后序遍历，首先遍历左子树，然后遍历右子树，最后访问根结点。简记左-右-根。</p></li><li><p>二叉树是非线性数据结构，但是顺序存储结构和链式存储结构都能存储。</p></li><li><p>一个带权的无向连通图的最小生成树的权值之和是唯一的。</p></li><li><p>只有一个结点的二叉树的度为 0 。</p></li><li><p>二叉树的度是以节点的最大的度数定义的。</p></li><li><p>树的后序遍历序列等同于该树对应的二叉树的中序序列。</p></li><li><p>树的先序遍历序列等同于该树对应的二叉树的先序序列。 </p></li><li><p>线索二叉树的线索实际上指向的是相应遍历序列特定结点的前驱结点和后继结点，所以先写出二叉树的中序遍历序列：<br>debxac，中序遍历中在x左边和右边的字符，就是它在中序线索化的左、右线索，即 b、a 。</p></li><li><p>递归式的先序遍历一个 n 节点，深度为 d 的二叉树，需要栈空间的大小为 O（d），因为二叉树并不一定是平衡的，<br>也就是深度d！=logn，有可能d&gt;&gt;logn。所以栈大小应该是O（d）</p></li><li><p>一棵具有 N 个结点的二叉树的前序序列和后序序列正好相反 ，则该二叉树一定满足该二叉树只有左子树或只有右子树，<br>即该二叉树一定是一条链（二叉树的高度为N，高度等于结点数）。</p></li><li><p>引入二叉线索树的目的是加快查找结点的前驱或后继的速度。</p></li><li><p>二叉树线索化后，先序线索化与后序线索化最多有1个空指针域，而中序线索化最多有2个空指针域。</p></li><li><p>不管是几叉树，节点数等于=分叉数+1</p></li><li><p>任何一棵二叉树的叶子结点在先序、中序和后序遍历中的相对次序不发生改变。</p></li></ol><p>详细资料可以参考：<br><a href="https://blog.csdn.net/adminabcd/article/details/46672759">《n 个节点的二叉树有多少种形态》</a><br><a href="https://www.cnblogs.com/guoyaohua/p/8595289.html">《数据结构二叉树知识点总结》</a><br><a href="https://www.jianshu.com/p/2943a21d2a99">《还原二叉树–已知先序中序或者后序中序》</a><br><a href="https://blog.csdn.net/linraise/article/details/11745559">《树、森林与二叉树的转换》</a></p><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>对于一棵二叉树，如果每一个非叶子节点都存在左右子树，并且二叉树中所有的叶子节点都在同一层中，这样的二叉树称为满<br>二叉树。</p><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>对于一棵具有 n 个节点的二叉树按照层次编号，同时，左右子树按照先左后右编号，如果编号为 i 的节点与同样深度的满<br>二叉树中编号为i的节点在满二叉树中的位置完全相同，则这棵二叉树称为完全二叉树。</p><p>性质：</p><ol><li><p>具有 n 个结点的完全二叉树的深度为 K =[log2n」+1(取下整数) </p></li><li><p>有 N 个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系： 若 I 为结点编号（从1开始编号）则<br>如果 I&gt;1，则其父结点的编号为 I/2；</p></li><li><p>完全二叉树，如果 2 * I &lt;= N，则其左儿子（即左子树的根结点）的编号为2 * I；若2 * I &gt; N，则无左儿子；如<br>果 2 * I + 1 &lt;= N，则其右儿子的结点编号为 2 * I + 1；若 2 * I + 1 &gt; N，则无右儿子。</p></li></ol><h3 id="平衡二叉查找树（AVL）"><a href="#平衡二叉查找树（AVL）" class="headerlink" title="平衡二叉查找树（AVL）"></a>平衡二叉查找树（AVL）</h3><p>平衡二叉查找树具有如下几个性质：</p><ol><li>可以是空树。</li><li>假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过1。</li></ol><p>平衡二叉树是为了解决二叉查找树中出现链式结构（只有左子树或只有右子树）的情况，这样的情况出现后对我们的查找没有<br>一点帮帮助，反而增加了维护的成本。</p><p>平衡因子使用两个字母来表示。第一个字母表示最小不平衡子树根结点的平衡因子，第二个字母表示最小不平衡子树较高子树<br>的根结点的平衡因子。根据不同的情况使用不同的方法来调整失衡的子树。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/suimeng/p/4560056.html">《平衡二叉树，AVL树之图解篇》</a></p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><p>B-树主要用于文件系统以及部分数据库索引，如 MongoDB。使用 B-树来作为数据库的索引主要是为了减少查找是磁盘的 I/O<br>次数。试想，如果我们使用二叉查找树来作为索引，那么查找次数的最坏情况等于二叉查找树的高度，由于索引存储在磁盘中，<br>我们每次都只能加载对应索引的磁盘页进入内存中比较，那么磁盘的 I/O 次数就等于索引树的高度。所以采用一种办法来减少<br>索引树的高度是提高索引效率的关键。</p><p>B-树是一种多路平衡查找树，它的每一个节点最多包含 K 个子节点，K 被称为 B-树的阶，K 的大小取决于磁盘页的大小。每<br>个节点中的元素从小到大排列，节点当中 k-1 个元素正好是 k 个孩子包含的元素的值域分划。简单来说就是以前一个磁盘页<br>只存储一个索引的值，但 B-树中一个磁盘页中存储了多个索引的值，因此在相同的比较范围内，B-树相对于一般的二叉查找树<br>的高度更小。其实它的主要目的就是每次尽可能多的将索引值加载入内存中进行比较，以此来减少磁盘的 I/O 次数，其实就查<br>找次数而言，和二叉查找树比较差不了多少，只是说这个比较过程是在内存中完成的，速度更快而已。</p><p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;mid=2650561220&amp;idx=1&amp;sn=2a6d8a0290f967027b1d54456f586405&amp;chksm=f1feec47c689655113fa65f7911a1f59bbd994030ad685152b30e53d643049f969eefaa13058&amp;scene=21#wechat_redirect">《漫画：什么是 B- 树？》</a></p><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h3><p>B+ 树相对于 B-树有着更好的查找性能，根据 B-树我们可以知道，要想加快索引速度的方法就是尽量减少磁盘 I/O 的次数。<br>B+ 树相对于 B-的主要变化是，每个中间节点中不再包含卫星数据，只有叶子节点包含卫星数据，每个父节点都出现在子节点<br>中，叶子节点依次相连，形成一个顺序链表。中间节点不包含卫星数据，只用来作为索引使用，这意味着每一个磁盘页中能够<br>包含更多的索引值。因此 B+ 树的高度相对于 B-来说更低，所以磁盘的 I/O 次数更少。由于叶子节点依次相连，并且包含<br>了父节点，所以可以通过叶子节点来找到对应的值。同时 B+ 树所有查询都要查找到叶子节点，查询性能比 B-树稳定。</p><p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;mid=2650561244&amp;idx=1&amp;sn=df3abafd3aa2f5a3abfe507bfc26982f&amp;chksm=f1feec5fc6896549f89cbb82ee3d8010c63da76814030b285fa29322795de512ccca207064ee&amp;scene=21#wechat_redirect">《漫画：什么是 B+ 树？》</a></p><h3 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h3><p>数据库以 B 树或者 B+ 树格式来储存的数据的，一张表是根据主键来构建的树的结构。因此如果想查找其他字段，就需要建<br>立索引，我对于索引的理解是它就是以某个字段为关键字的 B 树文件，通过这个 B 树文件就能够提高数据查找的效率。但是<br>由于我们需要维护的是平衡树的结构，因此对于数据的写入、修改、删除就会变慢，因为这有可能会涉及到树的平衡调整。</p><p>相关资料可以参考：<br><a href="https://zhuanlan.zhihu.com/p/23624390">《深入浅出数据库索引原理》</a><br><a href="http://www.ruanyifeng.com/blog/2014/07/database_implementation.html">《数据库的最简单实现》</a></p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树是一种自平衡的二叉查找树，它主要是为了解决不平衡的二叉查找树的查找效率不高的缺点。红黑树保证了从根到叶子<br>节点的最长路径不会超过最短路径的两倍。</p><p>红黑树的有具体的规则：</p><p>1.节点是红色或黑色。</p><p>2.根节点是黑色。</p><p>3.每个叶子节点都是黑色的空节点（NIL节点）。</p><p>4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</p><p>5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p><p>当红黑树发生删除和插入导致红黑树不满足这些规则时，需要通过处理，使其重新满足这些规则。</p><p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;mid=2650561574&amp;idx=1&amp;sn=edab54460a85c9686e0ec0f5d178907c&amp;chksm=f1feeaa5c68963b3689d23db68ab14a9c50a33dd5e9244a74d7765321b42af7ec14abfadf9ac&amp;scene=21#wechat_redirect">《漫画：什么是红黑树？》</a><br><a href="https://cloud.tencent.com/developer/article/1101517">《漫画算法等精选文章目录》</a></p><h3 id="Huffman-树"><a href="#Huffman-树" class="headerlink" title="Huffman 树"></a>Huffman 树</h3><p>给定 n 权值作为 n 个叶子节点，构造一棵二叉树，若这棵二叉树的带权路径长度达到最小，则称这样的二叉树为最优二叉<br>树，也称为 Huffman 树。</p><p>利用 Huffman 树对每一个字符编码，该编码又称为 Huffman 编码，Huffman 编码是一种前缀编码，即一个字符的编码<br>不是另一个字符编码的前缀。</p><p>性质：</p><ol><li><p>对应一组权重构造出来的 Huffman 树一般不是唯一的</p></li><li><p>Huffman 树具有最小的带权路径长度</p></li><li><p>Huffman 树中没有度为1的结点</p></li><li><p>哈夫曼树是带权路径长度最短的树，路径上权值较大的结点离根较近</p></li><li><p>Huffman 树的带权路径长度 WPL 等于各叶子结点的带权路径长度之和</p></li></ol><p>详细资料可以参考：</p><p><a href="https://blog.csdn.net/google19890102/article/details/54848262">《数据结构和算法—— Huffman 树和 Huffman 编码》</a><br><a href="https://blog.csdn.net/fx677588/article/details/70767446">《详细图解哈夫曼 Huffman 编码树》</a></p><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>二叉查找树是一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中，这一特性使得查找的效率很高，<br>对于数值型和非数值型数据，比如字母和字符串，都是如此。</p><p>实现树节点类：</p><pre><code class="js">// 节点类，树的节点class Node {  constructor(value) {    this.value = value;    this.left = null;    this.right = null;  }  show() {    console.log(this.value);  }}</code></pre><p>实现二叉查找树类：</p><pre><code class="js">class BinarySearchTree {  constructor() {    this.root = null  }}</code></pre><p>实现树的节点插入方法</p><p>节点插入的基本思想是将插入节点和当前节点做比较，如果比当前节点值小，并且没有左子树，那么将节点作为左叶子节点，<br>否则继续和左子树进行比较。如果比当前节点值大，并且没有右子树，则将节点作为右叶子节点，否则继续和右子树进行比较。<br>循环这个过程直到找到合适的插入位置。</p><pre><code class="js">  insert(value) {    let newNode = new Node(value);    // 判断根节点是否为空，如果不为空则递归插入到树中    if (this.root === null) {      this.root = newNode;    } else {      this.insertNode(this.root, newNode);    }  }  insertNode(node, newNode) {    // 将插入节点的值与当前节点的进行比较，如果比当前节点小，则递归判断左子树，如果比当前节点大，则递归判断右子树。    if (newNode.value &lt; node.value) {      if (node.left === null) {        node.left = newNode;      } else {        this.insertNode(node.left, newNode);      }    } else {      if (node.right === null) {        node.right = newNode;      } else {        this.insertNode(node.right, newNode);      }    }  }</code></pre><p>通过递归实现树的先序、中序、后序遍历</p><pre><code class="js"> // 先序遍历通过递归实现 // 先序遍历则先打印当前节点，再递归打印左子节点和右子节点。  preOrderTraverse() {    this.preOrderTraverseNode(this.root);  }  preOrderTraverseNode(node) {    if (node !== null) {      node.show();      this.preOrderTraverseNode(node.left);      this.preOrderTraverseNode(node.right);    }  }  // 中序遍历通过递归实现  // 中序遍历则先递归打印左子节点，再打印当前节点，最后再递归打印右子节点。  inOrderTraverse() {    this.inOrderTraverseNode(this.root);  }  inOrderTraverseNode(node) {    if (node !== null) {      this.inOrderTraverseNode(node.left);      node.show();      this.inOrderTraverseNode(node.right);    }  }  // 后序遍历通过递归实现  // 后序遍历则先递归打印左子节点和右子节点，最后再打印当前节点。  postOrderTraverse() {    this.postOrderTraverseNode(this.root);  }  postOrderTraverseNode(node) {    if (node !== null) {      this.postOrderTraverseNode(node.left);      this.postOrderTraverseNode(node.right);      node.show();    }  }</code></pre><p>通过循环实现树的先序、中序、后序遍历</p><pre><code class="js">  // 先序遍历通过循环实现  // 通过栈来实现循环先序遍历，首先将根节点入栈。然后进入循环，每次循环开始，当前节点出栈，打印当前节点，然后将  // 右子节点入栈，再将左子节点入栈，然后进入下一循环，直到栈为空结束循环。  preOrderTraverseByStack() {    let stack = [];    // 现将根节点入栈，开始遍历    stack.push(this.root);    while (stack.length &gt; 0) {      // 从栈中获取当前节点      let node = stack.pop();      // 执行节点操作      node.show();      // 判断节点是否还有左右子节点，如果存在则加入栈中，注意，由于中序遍历先序遍历是先访问根      // 再访问左和右子节点，因此左右子节点的入栈顺序应该是反过来的      if (node.right) {        stack.push(node.right);      }      if (node.left) {        stack.push(node.left);      }    }  }  // 中序遍历通过循环实现  // 中序遍历先将所有的左子节点入栈，如果左子节点为 null 时，打印栈顶元素，然后判断该元素是否有右子树，如果有  // 则将右子树作为起点重复上面的过程，一直循环直到栈为空并且节点为空时。  inOrderTraverseByStack() {    let stack = [],      node = this.root;    // 中序遍历是先左再根最后右    // 所以首先应该先把最左边节点遍历到底依次 push 进栈    // 当左边没有节点时，就打印栈顶元素，然后寻找右节点    while (stack.length &gt; 0 || node) {      if (node) {        stack.push(node);        node = node.left;      } else {        node = stack.pop();        node.show();        node = node.right;      }    }  }  // 后序遍历通过循环来实现  // 使用两个栈来是实现，先将根节点放入栈1中，然后进入循环，每次循环将栈顶元素加入栈2，再依次将左节点和右节点依次  // 加入栈1中，然后进入下一次循环，直到栈1的长度为0。最后再循环打印栈2的值。  postOrderTraverseByStack() {    let stack1 = [],      stack2 = [],      node = null;    // 后序遍历是先左再右最后根    // 所以对于一个栈来说，应该先 push 根节点    // 然后 push 右节点，最后 push 左节点    stack1.push(this.root);    while (stack1.length &gt; 0) {      node = stack1.pop();      stack2.push(node);        if (node.left) {        stack1.push(node.left);      }      if (node.right) {        stack1.push(node.right);      }    }    while (stack2.length &gt; 0) {      node = stack2.pop();      node.show();    }  }</code></pre><p>实现寻找最大最小节点值</p><pre><code class="js"> // 寻找最小值，在最左边的叶子节点上  findMinNode(root) {    let node = root;    while (node &amp;&amp; node.left) {      node = node.left;    }    return node;  }  // 寻找最大值，在最右边的叶子节点上  findMaxNode(root) {    let node = root;    while (node &amp;&amp; node.right) {      node = node.right;    }    return node;  }</code></pre><p>实现寻找特定大小节点值</p><pre><code class="js">  // 寻找特定值  find(value) {    return this.findNode(this.root, value);  }  findNode(node, value) {    if (node === null) {      return node;    }    if (value &lt; node.value) {      return this.findNode(node.left, value);    } else if (value &gt; node.value) {      return this.findNode(node.right, value);    } else {      return node;    }  }</code></pre><p>实现移除节点值</p><p>移除节点的基本思想是，首先找到需要移除的节点的位置，然后判断该节点是否有叶节点。如果没有叶节点，则直接删除，如<br>果有一个叶子节点，则用这个叶子节点替换当前的位置。如果有两个叶子节点，则去右子树中找到最小的节点来替换当前节点。</p><pre><code class="js">  // 移除指定值节点  remove(value) {    this.removeNode(this.root, value);  }  removeNode(node, value) {    if (node === null) {      return node;    }    // 寻找指定节点    if (value &lt; node.value) {      node.left = this.removeNode(node.left, value);      return node;    } else if (value &gt; node.value) {      node.right = this.removeNode(node.right, value);      return node;    } else { // 找到节点      // 第一种情况——没有叶节点      if (node.left === null &amp;&amp; node.right === null) {        node = null;        return node;      }      // 第二种情况——一个只有一个子节点的节点，将节点替换为节点的子节点      if (node.left === null) {        node = node.right;        return node;      } else if (node.right === null) {        node = node.left;      }      // 第三种情况——一个有两个子节点的节点，去右子树中找到最小的节点，用它的值来替换当前节点      // 的值，保持树的特性，然后将替换的节点去掉      let aux = this.findMinNode(node.right);      node.value = aux.value;      node.right = this.removeNode(node.right, aux);      return node;    }  }</code></pre><h3 id="求解二叉树中两个节点的最近公共祖先节点"><a href="#求解二叉树中两个节点的最近公共祖先节点" class="headerlink" title="求解二叉树中两个节点的最近公共祖先节点"></a>求解二叉树中两个节点的最近公共祖先节点</h3><pre><code>求解二叉树中的两个节点的最近公共祖先节点可以分为三种情况来考虑（1）该二叉树为搜索二叉树     解决办法，首先从根节点开始遍历。如果根节点的值比两个节点的值都大的情况下，则说明两个节点的共同祖先存在于    根节点的左子树中，因此递归遍历左子树。反之，则遍历右子树。当当前节点的值比其中一个节点的值大，比其中一个    节点的值小时，该节点则为两个节点的最近公共祖先节点。（2）该二叉树为普通二叉树，但是每个节点含有指向父节点的指针。    通过指向父节点的指针，我们可以通过节点得到它的所有父节点，该父节点列表可以看做是一个链表，因此求两个节点    的最近公共祖先节点就可以看做是求两个链表的最近公共节点，以此来找到两个节点的最近公共祖先节点。（3）该二叉树为普通二叉树，节点不含有指向父节点的指针。    这种情况下，我们可以从根节点出发，分别得到根节点到两个节点的路径。然后遍历两条路径，直到遇到第一个不相同    的节点为止，这个时候该节点前面的那个节点则为两个节点的最近公共祖先节点。</code></pre><p>详细资料可以参考：<br><a href="https://blog.csdn.net/xyzbaihaiping/article/details/52122885">《二叉树中两个节点的最近公共祖先节点》</a></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="反转单向链表"><a href="#反转单向链表" class="headerlink" title="反转单向链表"></a>反转单向链表</h3><p>需要将一个单向链表反转。思路很简单，使用三个变量分别表示当前节点和当前节点的前后节点，虽然这题很简单，但是却是<br>一道面试常考题。</p><p>思路是从头节点往后遍历，先获取下一个节点，然后将当前节点的 next 设置为前一个节点，然后再继续循环。</p><pre><code class="js">var reverseList = function(head) {    // 判断下变量边界问题    if (!head || !head.next) return head;    // 初始设置为空，因为第一个节点反转后就是尾部，尾部节点指向 null    let pre = null;    let current = head;    let next;    // 判断当前节点是否为空    // 不为空就先获取当前节点的下一节点    // 然后把当前节点的 next 设为上一个节点    // 然后把 current 设为下一个节点，pre 设为当前节点    while(current) {        next = current.next;        current.next = pre;        pre = current;        current = next;    }    return pre;};</code></pre><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="爬楼梯问题"><a href="#爬楼梯问题" class="headerlink" title="爬楼梯问题"></a>爬楼梯问题</h3><p>有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法？</p><h4 id="递归方法分析"><a href="#递归方法分析" class="headerlink" title="递归方法分析"></a>递归方法分析</h4><p>由分析可知，假设我们只差最后一步就能走上第10级阶梯，这个时候一共有两种情况，因为每一步只允许走1级或2级阶梯，<br>因此分别为从8级阶梯和从9九级阶梯走上去的情况。因此从0到10级阶梯的走法数量就等于从0到9级阶梯的走法数量加上<br>从0到8级阶梯的走法数量。依次类推，我们可以得到一个递归关系，递归结束的标志为从0到1级阶梯的走法数量和从0到<br>2级阶梯的走法数量。</p><p>代码实现</p><pre><code class="js">function getClimbingWays(n) {  if (n &lt; 1) {    return 0;  }  if (n === 1) {    return 1;  }  if (n === 2) {    return 2;  }  return getClimbingWays(n - 1) + getClimbingWays(n - 2);}</code></pre><p>使用这种方法时整个的递归过程是一个二叉树的结构，因此该方法的时间复杂度可以近似的看为 O(2^n)，空间复杂度<br>为递归的深度 O(logn)。</p><h4 id="备忘录方法"><a href="#备忘录方法" class="headerlink" title="备忘录方法"></a>备忘录方法</h4><p>分析递归的方法我们可以发现，其实有很多的计算过程其实是重复的，因此我们可以使用一个数组，将已经计算出的值给<br>保存下来，每次计算时，先判断计算结果是否已经存在，如果已经存在就直接使用。</p><p>代码实现</p><pre><code class="js">let map = new Map();function getClimbingWays(n) {  if (n &lt; 1) {    return 0;  }  if (n === 1) {    return 1;  }  if (n === 2) {    return 2;  }  if (map.has(n)) {    return map.get(n);  } else {    let value = getClimbingWays(n - 1) + getClimbingWays(n - 2);    map.set(n, value);    return value;  }}</code></pre><p>通过这种方式，我们将算法的时间复杂度降低为 O(n)，但是增加空间复杂度为 O(n)</p><h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><p>通过观察，我们可以发现每一个值其实都等于它的前面两个值的和，因此我们可以使用自底向上的方式来实现。</p><p>代码实现</p><pre><code class="js">function getClimbingWays(n) {  if (n &lt; 1) {    return 0;  }  if (n === 1) {    return 1;  }  if (n === 2) {    return 2;  }  let a = 1,    b = 2,    temp = 0;  for (let i = 3; i &lt;= n; i++) {    temp = a + b;    a = b;    b = temp;  }  return temp;}</code></pre><p>通过这种方式我们可以将算法的时间复杂度降低为 O(n)，并且将算法的空间复杂度降低为 O(1)。</p><p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;mid=2650561168&amp;idx=1&amp;sn=9d1c6f7ba6d651c75399c4aa5254a7d8&amp;chksm=f1feec13c6896505f7886d9455278ad39749d377a63908c59c1fdceb11241e577ff6d66931e4&amp;scene=21#wechat_redirect">《漫画：什么是动态规划？（整合版）》</a></p><h2 id="经典笔试题"><a href="#经典笔试题" class="headerlink" title="经典笔试题"></a>经典笔试题</h2><h4 id="1-js-实现一个函数，完成超过范围的两个大整数相加功能"><a href="#1-js-实现一个函数，完成超过范围的两个大整数相加功能" class="headerlink" title="1. js 实现一个函数，完成超过范围的两个大整数相加功能"></a>1. js 实现一个函数，完成超过范围的两个大整数相加功能</h4><pre><code class="js">主要思路是通过将数字转换为字符串，然后每个字符串在按位相加。function bigNumberAdd(number1, number2) {  let result = "", // 保存最后结果    carry = false; // 保留进位结果  // 将字符串转换为数组  number1 = number1.split("");  number2 = number2.split("");  // 当数组的长度都变为0，并且最终不再进位时，结束循环  while (number1.length || number2.length || carry) {    // 每次将最后的数字进行相加，使用~~的好处是，即使返回值为 undefined 也能转换为 0    carry += ~~number1.pop() + ~~number2.pop();    // 取加法结果的个位加入最终结果    result = carry % 10 + result;    // 判断是否需要进位，true 和 false 的值在加法中会被转换为 1 和 0    carry = carry &gt; 9;  }  // 返回最终结果  return result;}</code></pre><p>   详细资料可以参考：<br>   <a href="https://blog.csdn.net/fe_dev/article/details/80079372">《JavaScript实现超范围的数相加》</a><br>   <a href="https://blog.csdn.net/q1059081877q/article/details/80689194">《js 实现大整数加法》</a></p><h4 id="2-js-如何实现数组扁平化？"><a href="#2-js-如何实现数组扁平化？" class="headerlink" title="2. js 如何实现数组扁平化？"></a>2. js 如何实现数组扁平化？</h4><pre><code class="js">// 这一种方法通过递归来实现，当元素为数组时递归调用，兼容性好function flattenArray(array) {  if (!Array.isArray(array)) return;  let result = [];  result = array.reduce(function (pre, item) {    // 判断元素是否为数组，如果为数组则递归调用，如果不是则加入结果数组中    return pre.concat(Array.isArray(item) ? flattenArray(item) : item);  }, []);  return result;}// 这一种方法是利用了 toString 方法，它的一个缺点是改变了元素的类型，只适合于数组中元素都是整数的情况function flattenArray(array) {  return array.toString().split(",").map(function (item) {    return +item;  })}</code></pre><p>   详细资料可以参考：<br>   <a href="https://github.com/mqyqingfeng/Blog/issues/36">《JavaScript专题之数组扁平化》</a></p><h4 id="3-js-如何实现数组去重？"><a href="#3-js-如何实现数组去重？" class="headerlink" title="3. js 如何实现数组去重？"></a>3. js 如何实现数组去重？</h4><pre><code class="js">function unique(array) {  if (!Array.isArray(array) || array.length &lt;= 1) return;  var result = [];  array.forEach(function (item) {    if (result.indexOf(item) === -1) {      result.push(item);    }  })  return result;}function unique(array) {  if (!Array.isArray(array) || array.length &lt;= 1) return;  return [...new Set(array)];}</code></pre><p>   详细资料可以参考：<br>   <a href="https://github.com/mqyqingfeng/Blog/issues/27">《JavaScript专题之数组去重》</a></p><h4 id="4-如何求数组的最大值和最小值？"><a href="#4-如何求数组的最大值和最小值？" class="headerlink" title="4. 如何求数组的最大值和最小值？"></a>4. 如何求数组的最大值和最小值？</h4><pre><code class="js">var arr = [6, 4, 1, 8, 2, 11, 23];console.log(Math.max.apply(null, arr))</code></pre><p>   详细资料可以参考：<br>   <a href="https://github.com/mqyqingfeng/Blog/issues/35">《JavaScript专题之如何求数组的最大值和最小值》</a></p><h4 id="5-如何求两个数的最大公约数？"><a href="#5-如何求两个数的最大公约数？" class="headerlink" title="5. 如何求两个数的最大公约数？"></a>5. 如何求两个数的最大公约数？</h4><pre><code class="js">基本思想是采用辗转相除的方法，用大的数去除以小的那个数，然后再用小的数去除以的得到的余数，一直这样递归下去，直到余数为0时，最后的被除数就是两个数的最大公约数。function getMaxCommonDivisor(a, b) {  if (b === 0) return a;  return getMaxCommonDivisor(b, a % b);}</code></pre><h4 id="6-如何求两个数的最小公倍数？"><a href="#6-如何求两个数的最小公倍数？" class="headerlink" title="6. 如何求两个数的最小公倍数？"></a>6. 如何求两个数的最小公倍数？</h4><pre><code class="js">基本思想是采用将两个数相乘，然后除以它们的最大公约数function getMinCommonMultiple(a, b){  return a * b / getMaxCommonDivisor(a, b);}</code></pre><p>   详细资料可以参考：<br>   <a href="https://www.cnblogs.com/cssfirefly/archive/2012/10/23/2734936.html">《百度 web 前端面试题之求两个数的最大公约数和最小公倍数》</a></p><h4 id="7-实现-IndexOf-方法？"><a href="#7-实现-IndexOf-方法？" class="headerlink" title="7. 实现 IndexOf 方法？"></a>7. 实现 IndexOf 方法？</h4><pre><code class="js">function indexFun(array, val) {  if (!Array.isArray(array)) return;  let length = array.length;  for (let i = 0; i &lt; length; i++) {    if (array[i] === val) {      return i;    }  }  return -1;}   </code></pre><h4 id="8-判断一个字符串是否为回文字符串？"><a href="#8-判断一个字符串是否为回文字符串？" class="headerlink" title="8. 判断一个字符串是否为回文字符串？"></a>8. 判断一个字符串是否为回文字符串？</h4><pre><code class="js">function isPalindrome(str) {  let reg = /[\W_]/g, // 匹配所有非单词的字符以及下划线    newStr = str.replace(reg, "").toLowerCase(), // 替换为空字符并将大写字母转换为小写    reverseStr = newStr.split("").reverse().join(""); // 将字符串反转  return reverseStr === newStr;}</code></pre><h4 id="9-实现一个累加函数的功能比如-sum-1-2-3-2-valueOf"><a href="#9-实现一个累加函数的功能比如-sum-1-2-3-2-valueOf" class="headerlink" title="9. 实现一个累加函数的功能比如 sum(1,2,3)(2).valueOf()"></a>9. 实现一个累加函数的功能比如 sum(1,2,3)(2).valueOf()</h4><pre><code class="js">function sum(...args) {let result = 0;result = args.reduce(function (pre, item) {  return pre + item;}, 0);let add = function (...args) {  result = args.reduce(function (pre, item) {    return pre + item;  }, result);  return add;};add.valueOf = function () {  console.log(result);}return add;}</code></pre><h4 id="10-使用-reduce-方法实现-forEach、map、filter"><a href="#10-使用-reduce-方法实现-forEach、map、filter" class="headerlink" title="10. 使用 reduce 方法实现 forEach、map、filter"></a>10. 使用 reduce 方法实现 forEach、map、filter</h4><pre><code class="js"> // forEach function forEachUseReduce(array, handler) {   array.reduce(function (pre, item, index) {     handler(item, index);   }, null); } // map function mapUseReduce(array, handler) {   let result = [];   array.reduce(function (pre, item, index) {     let mapItem = handler(item, index);     result.push(mapItem);   }, null);   return result; } // filter function filterUseReduce(array, handler) {   let result = [];   array.reduce(function (pre, item, index) {     if (handler(item, index)) {       result.push(item);     }   }, null);   return result; }</code></pre><h4 id="11-设计一个简单的任务队列，要求分别在-1-3-4-秒后打印出-“1”-“2”-“3”"><a href="#11-设计一个简单的任务队列，要求分别在-1-3-4-秒后打印出-“1”-“2”-“3”" class="headerlink" title="11. 设计一个简单的任务队列，要求分别在 1,3,4 秒后打印出 “1”, “2”, “3”"></a>11. 设计一个简单的任务队列，要求分别在 1,3,4 秒后打印出 “1”, “2”, “3”</h4><pre><code class="js"> class Queue {   constructor() {     this.queue = [];     this.time = 0;   }   addTask(task, t) {     this.time += t;     this.queue.push([task, this.time]);     return this;   }   start() {     this.queue.forEach(item =&gt; {       setTimeout(() =&gt; {         item[0]();       }, item[1]);     })   } }</code></pre><h4 id="12-如何查找一篇英文文章中出现频率最高的单词？"><a href="#12-如何查找一篇英文文章中出现频率最高的单词？" class="headerlink" title="12. 如何查找一篇英文文章中出现频率最高的单词？"></a>12. 如何查找一篇英文文章中出现频率最高的单词？</h4><pre><code class="js"> function findMostWord(article) { // 合法性判断 if (!article) return; // 参数处理 article = article.trim().toLowerCase(); let wordList = article.match(/[a-z]+/g),  visited = [],  maxNum = 0,  maxWord = ""; article = " " + wordList.join("  ") + " "; // 遍历判断单词出现次数 wordList.forEach(function (item) {  if (visited.indexOf(item) &lt; 0) {    let word = new RegExp(" " + item + " ", "g"),      num = article.match(word).length;    if (num &gt; maxNum) {      maxNum = num;      maxWord = item;    }  } }); return maxWord + "  " + maxNum; }</code></pre><h1 id="常见面试智力题总结"><a href="#常见面试智力题总结" class="headerlink" title="常见面试智力题总结"></a>常见面试智力题总结</h1><h4 id="1-时针与分针夹角度数问题？"><a href="#1-时针与分针夹角度数问题？" class="headerlink" title="1. 时针与分针夹角度数问题？"></a>1. 时针与分针夹角度数问题？</h4><p>   分析：</p><pre><code>当时间为 m 点 n 分时，其时针与分针夹角的度数为多少？我们可以这样考虑，分针每走一格为 6 度，分针每走一格对应的时针会走 0.5 度。时针每走一格为 30 度。因此，时针走过的度数为 m * 30 + n * 0.5，分针走过的度数为 n * 6。因此时针与分针的夹角度数为 |m * 30 + n * 0.5 - n * 6|;</code></pre><p>   答案：</p><pre><code>因此时针与分针的夹角度数为 |m * 30 + n * 0.5 - n * 6|; </code></pre><p>   详细资料参考：<br>   <a href="https://blog.csdn.net/prstaxy/article/details/22210829">《面试智力题 — 时针与分针夹角度数问题》</a></p><h4 id="2-用3升，5升杯子怎么量出4升水？"><a href="#2-用3升，5升杯子怎么量出4升水？" class="headerlink" title="2. 用3升，5升杯子怎么量出4升水？"></a>2. 用3升，5升杯子怎么量出4升水？</h4><pre><code>（1）将 5 升杯子装满水，然后倒入 3 升杯子中，之后 5 升杯子还剩 2 升水。（2）将 3 升杯子的水倒出，然后将 5 升杯子中的 2 升水倒入 3 升杯子中。（3）将 5 升杯子装满水，然后向 3 升杯子中倒水，直到 3 升杯子装满为止，此时 5 升杯子中就还剩 4 升水。</code></pre><h4 id="3-四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？"><a href="#3-四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？" class="headerlink" title="3. 四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？"></a>3. 四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？</h4><pre><code>由于浑浊的每片药片比正常药片都多出了一克，因此我认为可以通过控制药片的数量来实现判断。（1）首先将每个药罐进行编号，分别标记为 1、2、3、4 号药罐。（2）然后从 1 号药罐中取出 1 片药片，从 2 号药罐中取出 2 片药片，从 3 号药罐中取出 3 片药片，从 4 号药罐中取出 4    片药片。（3）将 10 片药片使用天平称重，药片的重量比正常重量多出几克，就是哪一号药罐的问题。</code></pre><h4 id="4-四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为-a-1-b-2-现在我想要证明-a-的反面必然是-1-，我只能翻两张牌，我翻哪两张？"><a href="#4-四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为-a-1-b-2-现在我想要证明-a-的反面必然是-1-，我只能翻两张牌，我翻哪两张？" class="headerlink" title="4. 四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为 a 1 b 2 现在我想要证明 a 的反面必然是 1 ，我只能翻两张牌，我翻哪两张？"></a>4. 四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为 a 1 b 2 现在我想要证明 a 的反面必然是 1 ，我只能翻两张牌，我翻哪两张？</h4><pre><code>我认为证明 a 的反面一定是 1 的充要条件为 a 的反面为 1，并且 2 的反面不能为 a，因此应该翻 a 和 2 两张牌。</code></pre><h4 id="5-赛马问题，25-匹马，5-个赛道，最少几次能选出最快的三匹马？"><a href="#5-赛马问题，25-匹马，5-个赛道，最少几次能选出最快的三匹马？" class="headerlink" title="5. 赛马问题，25 匹马，5 个赛道，最少几次能选出最快的三匹马？"></a>5. 赛马问题，25 匹马，5 个赛道，最少几次能选出最快的三匹马？</h4><pre><code>我认为一共至少需要 7 次才能选出最快的三匹马。（1）首先，我们将 25 匹马分为 5 组，每组进行比赛，选出每组最快的三匹马，其余的马由于已经不可能成为前三了，因此可以直    接淘汰掉，那么我们现在还剩下了 15 匹马。（2）然后我们将 5 组中的第一名来进行一轮比赛，最终的结果能够确定最快的马一定是第一名，四五名的马以及它们对应组的其余    马就可以淘汰掉了，因为它们已经没有进入前三的机会了。并且第二名那一组的第三名和第三组的第二第三名都可以淘汰掉了，    它们也没有进入前三的机会了。因此我们最终剩下了第一名那一组的二三名和第二名那一组的一二名，以及第三名一共 5 匹马，    它们都有竞争最快第二第三的机会。（3）最后一次对最后的 5 匹马进行比赛，选择最快的一二名作为最终结果的二三名，因此就能够通过 7 次比较，选择出最快的马。</code></pre><h4 id="6-五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都不同，那么A的配偶握手了几次？"><a href="#6-五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都不同，那么A的配偶握手了几次？" class="headerlink" title="6. 五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都不同，那么A的配偶握手了几次？"></a>6. 五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都不同，那么A的配偶握手了几次？</h4><pre><code>（1）由于每个人不能和自己的配偶握手，并且最多只能和他人握手一次，因此一个人最多能握 8 次手。（2）因为 A 问了除自己配偶的其他人，每个人的握手次数都不同。因此一共有九种握手的情况，由于一个人最多只能握 8 次手，因    此握手的情况分别为 0、1、2、3、4、5、6、7、8 这九种情况。（3）我们首先分析握了 8 次手的人，由于他和除了自己配偶的每一个人都握了一次手，因此其他人的握手次数都不为 0，因此只有    他的配偶握手次数为0，由此我们可以知道握手次数为 8 的人和握手次数为 0 的人是配偶。（4）我们再来分析握了 7 次手的人，他和除了握了 0 次手以外的人都握了一次手，由于握了 8 次手的人和其余人也都握了一次手    ，因此其他人的握手次数至少为 2 ，因此只有他的配偶的握手次数才能为 1。由此我们可以知道握手次数为 7 的人和握手次数    为 1 的人是配偶。（5）依次可以类推，握手次数为 6 的人和握手次数为 2 的人为配偶，握手次数为 5 的人和握手次数为 3 的人为配偶。（6）最终剩下了握手次数为 4 的人，按照规律我们可以得知他的配偶的握手次数也为4。（7）由于 A 和其他人的握手次数都不同，因此我们可以得知握手次数为 4 的人就是 A。因此他的配偶的握手次数为 4 。</code></pre><h4 id="7-你只能带行走-60-公里的油，只能在起始点加油，如何穿过-80-公里的沙漠？"><a href="#7-你只能带行走-60-公里的油，只能在起始点加油，如何穿过-80-公里的沙漠？" class="headerlink" title="7. 你只能带行走 60 公里的油，只能在起始点加油，如何穿过 80 公里的沙漠？"></a>7. 你只能带行走 60 公里的油，只能在起始点加油，如何穿过 80 公里的沙漠？</h4><pre><code>（1）先走到离起点 20 公里的地方，然后放下 20 公里的油在这，然后返回起点加油。（2）当第二次到达这时，车还剩 40 公里的油，加上上一次放在这的 20 公里的油，一共就有 60 公里的油，能够走完剩下的路    程。</code></pre><h4 id="8-烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？"><a href="#8-烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？" class="headerlink" title="8. 烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？"></a>8. 烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？</h4><pre><code>一共需要三根绳子，假设分别为 1、2、3 号绳子，每个绳子一共有 A、B 两端。（1）首先点燃 1 号绳子的 A、B 两端，然后点燃 2 号绳子的 A 端。（2）当 1 号绳子燃尽时，此时过去了半小时，然后同时点燃 2 号绳子的 B 端。（3）当 2 号绳子燃尽时，此时又过去了 15 分钟，然后同时点燃 3 号绳子的 A、B 两端。（4）当 3 号绳子燃尽时，又过去了半小时，以此一共加起来过去了一个小时十五分钟。</code></pre><h4 id="9-有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？"><a href="#9-有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？" class="headerlink" title="9. 有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？"></a>9. 有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？</h4><pre><code>（1） 第一次用 7 克砝码和 2 克砝码称取 9 克盐。（2） 第二次再用第一次称取的盐和砝码称取 16 克盐。（3） 第三次再用前两次称取的盐和砝码称取 25 克盐，这样就总共称取了 50 克盐，剩下的就是 90 克。</code></pre><h4 id="10-有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第-小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和-两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？"><a href="#10-有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第-小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和-两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？" class="headerlink" title="10. 有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第&nbsp;小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和&nbsp;两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？&nbsp;"></a>10. 有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第&nbsp;小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和&nbsp;两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？&nbsp;</h4><pre><code> 由于小鸟一直都在飞，直到两车相遇时才停下来。因此小鸟飞行的时间为两车相遇的时间，由于两车是相向而行，因此 两车相遇的时间为总路程除以两车的速度之和，然后再用飞行的时间去乘以小鸟的速度，就能够得出小鸟飞行的距离。</code></pre><h4 id="11-你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？"><a href="#11-你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？" class="headerlink" title="11. 你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？"></a>11. 你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？</h4><pre><code> 第一个罐子里放一个红球，第二个罐子里放剩余的球，这样概率接近75%，这是概率最大的方法</code></pre><h4 id="12-假设你有8个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？"><a href="#12-假设你有8个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？" class="headerlink" title="12. 假设你有8个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？"></a>12. 假设你有8个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？</h4><pre><code> 最少两次可以称出。 首先将 8 个球分为 3 组，其中两组为 3 个球，一组为 2 个球。 第一次将两组三个的球进行比较，如果两边相等，则说明重的球在最后一组里。第二次将最后一组的球进行比较即可。如 果两边不等，则说明重的球在较重的一边，第二次只需从这一组中随机取两球出来比较即可判断。</code></pre><h4 id="13-在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？"><a href="#13-在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？" class="headerlink" title="13. 在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？"></a>13. 在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？</h4><pre><code> （1）首先打开一盏灯 10 分钟，然后打开第二盏。 （2）进入房间，看看那盏灯亮，摸摸那盏灯热，热的是第一个开关打开的，亮的是第二个开关打开的，而剩下的就是第三个开关打开     的。</code></pre><h4 id="14-他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？"><a href="#14-他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？" class="headerlink" title="14. 他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？"></a>14. 他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？</h4><pre><code> 将每一对袜子分开，一人拿一只袜子，因为袜子不分左右脚的，因此最后每个人都能取回白袜和黑袜两对。</code></pre><h4 id="15-有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签。"><a href="#15-有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签。" class="headerlink" title="15. 有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签。"></a>15. 有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签。</h4><pre><code> 从混合标签里取出一个水果，取出的是什么水果，就写上相应的标签。 对应水果标签的筐的标签改为另一种水果。 另一种水果标签的框改为混合。</code></pre><h4 id="16-一个班级60-喜欢足球，70-喜欢篮球，80-喜欢排球，问即三种球都喜欢占比有多少？"><a href="#16-一个班级60-喜欢足球，70-喜欢篮球，80-喜欢排球，问即三种球都喜欢占比有多少？" class="headerlink" title="16. 一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球，问即三种球都喜欢占比有多少？"></a>16. 一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球，问即三种球都喜欢占比有多少？</h4><pre><code> （1）首先确定最多的一种情况，就是 60% 喜欢足球的人同时也喜欢篮球和排球，此时为三种球都喜欢的人的最大比例。 （2）然后确定最小的一种情况，根据题目可以知道有 40%的人不喜欢足球，30%的人不喜欢篮球，20%的人不喜欢排球，因此有最多     90% 的人三种球中有一种球不喜欢，因此三种球都喜欢的人的最小比例为 10%。 因此三种球都喜欢的人占比为 10%-60%</code></pre><h4 id="17-五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？"><a href="#17-五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？" class="headerlink" title="17. 五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？"></a>17. 五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？</h4><pre><code> 五只鸡五天能下五个蛋，平均下来五只鸡每天能下一个蛋，因此五只鸡一百天就能够下一百个蛋。</code></pre><p>   更多的智力题可以参考：<br>   <a href="https://blog.csdn.net/hilyoo/article/details/4445858">《经典面试智力题200+题和解答》</a></p><h1 id="剑指-offer-思路总结"><a href="#剑指-offer-思路总结" class="headerlink" title="剑指 offer 思路总结"></a>剑指 offer 思路总结</h1><p>本部分主要是笔者在练习剑指 offer 时所做的笔记，如果出现错误，希望大家指出！</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h4 id="1-二维数组中的查找"><a href="#1-二维数组中的查找" class="headerlink" title="1. 二维数组中的查找"></a>1. 二维数组中的查找</h4><pre><code>题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。思路：（1）第一种方式是使用两层循环依次遍历，判断是否含有该整数。这一种方式最坏情况下的时间复杂度为 O(n^2)。（2）第二种方式是利用递增序列的特点，我们可以从二维数组的右上角开始遍历。如果当前数值比所求的数要小，则将位置向下移动    ，再进行判断。如果当前数值比所求的数要大，则将位置向左移动，再进行判断。这一种方式最坏情况下的时间复杂度为 O(n)。</code></pre><h4 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2. 替换空格"></a>2. 替换空格</h4><pre><code>题目：请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20Are%20Happy思路：使用正则表达式，结合字符串的 replace 方法将空格替换为 “%20”str.replace(/\s/g,"%20")</code></pre><h4 id="3-从尾到头打印链表"><a href="#3-从尾到头打印链表" class="headerlink" title="3. 从尾到头打印链表"></a>3. 从尾到头打印链表</h4><pre><code>题目：输入一个链表，从尾到头打印链表每个节点的值。思路：利用栈来实现，首先根据头结点以此遍历链表节点，将节点加入到栈中。当遍历完成后，再将栈中元素弹出并打印，以此来实现。栈的实现可以利用 Array 的 push 和 pop 方法来模拟。</code></pre><h4 id="4-重建二叉树"><a href="#4-重建二叉树" class="headerlink" title="4. 重建二叉树"></a>4. 重建二叉树</h4><pre><code>题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列 {1,2,4,7,3,5,6,8} 和中序遍历序列 {4,7,2,1,5,3,8,6}，则重建二叉树并返回。思路：利用递归的思想来求解，首先先序序列中的第一个元素一定是根元素。然后我们去中序遍历中寻找到该元素的位置，找到后该元素的左边部分就是根节点的左子树，右边部分就是根节点的右子树。因此我们可以分别截取对应的部分进行子树的递归构建。使用这种方式的时间复杂度为 O(n)，空间复杂度为 O(logn)。</code></pre><h4 id="5-用两个栈实现队列"><a href="#5-用两个栈实现队列" class="headerlink" title="5. 用两个栈实现队列"></a>5. 用两个栈实现队列</h4><pre><code>题目：用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。思路：队列的一个基本特点是，元素先进先出。通过两个栈来模拟时，首先我们将两个栈分为栈1和栈2。当执行队列的 push 操作时，直接将元素 push 进栈1中。当队列执行 pop 操作时，首先判断栈2是否为空，如果不为空则直接 pop 元素。如果栈2为空，则将栈1中的所有元素 pop 然后 push 到栈2中，然后再执行栈2的 pop 操作。扩展：当使用两个长度不同的栈来模拟队列时，队列的最大长度为较短栈的长度的两倍。</code></pre><h4 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6. 旋转数组的最小数字"></a>6. 旋转数组的最小数字</h4><pre><code>题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。思路：（1）我们输入的是一个非递减排序的数组的一个旋转，因此原始数组的值递增或者有重复。旋转之后原始数组的值一定和一个值相    邻，并且不满足递增关系。因此我们就可以进行遍历，找到不满足递增关系的一对值，后一个值就是旋转数组的最小数字。（2）二分法</code></pre><p>   相关资料可以参考：<br>   <a href="https://www.cnblogs.com/edisonchou/p/4746561.html">《旋转数组的最小数字》</a></p><h4 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7. 斐波那契数列"></a>7. 斐波那契数列</h4><pre><code>题目：大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项。 n&lt;=39思路：斐波那契数列的规律是，第一项为0，第二项为1，第三项以后的值都等于前面两项的和，因此我们可以通过循环的方式，不断通过叠加来实现第 n 项值的构建。通过循环而不是递归的方式来实现，时间复杂度降为了 O(n)，空间复杂度为 O(1)。</code></pre><h4 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8. 跳台阶"></a>8. 跳台阶</h4><pre><code>题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。思路：跳台阶的问题是一个动态规划的问题，由于一次只能够跳1级或者2级，因此跳上 n 级台阶一共有两种方案，一种是从 n-1 跳上，一种是从 n-2 级跳上，因此 f(n) = f(n-1) + f(n-2)。和斐波那契数列类似，不过初始两项的值变为了 1 和 2，后面每项的值等于前面两项的和。</code></pre><h4 id="9-变态跳台阶"><a href="#9-变态跳台阶" class="headerlink" title="9. 变态跳台阶"></a>9. 变态跳台阶</h4><pre><code>题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。思路：变态跳台阶的问题同上一个问题的思考方案是一样的，我们可以得到一个结论是，每一项的值都等于前面所有项的值的和。f(1) = 1f(2) = f(2-1) + f(2-2)         //f(2-2) 表示2阶一次跳2阶的次数。f(3) = f(3-1) + f(3-2) + f(3-3) ...f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n) 再次总结可得              | 1       ,(n=0 ) f(n) =        | 1       ,(n=1 )              | 2*f(n-1),(n&gt;=2)</code></pre><h4 id="10-矩形覆盖"><a href="#10-矩形覆盖" class="headerlink" title="10. 矩形覆盖"></a>10. 矩形覆盖</h4><pre><code> 题目： 我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共 有多少种方法？ 思路： 依旧是斐波那契数列的应用</code></pre><h4 id="11-二进制中1的个数"><a href="#11-二进制中1的个数" class="headerlink" title="11. 二进制中1的个数"></a>11. 二进制中1的个数</h4><pre><code> 题目： 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 思路： 一个不为 0 的整数的二进制表示，一定会有一位为1。我们找到最右边的一位1，当我们将整数减去1时，最右边的一位1变为0，它后 面的所有位都取反，因此将减一后的值与原值相与，我们就会能够消除最右边的一位1。因此判断一个二进制中1的个数，我们可以判 断这个数可以经历多少次这样的过程。 如：1100&amp;1011=1000 </code></pre><h4 id="12-数值的整数次方"><a href="#12-数值的整数次方" class="headerlink" title="12. 数值的整数次方"></a>12. 数值的整数次方</h4><pre><code> 题目： 给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的 exponent 次方。 思路： 首先我们需要判断 exponent 正负和零取值三种情况，根据不同的情况通过递归来实现。 </code></pre><h4 id="13-调整数组顺序使奇数位于偶数前面"><a href="#13-调整数组顺序使奇数位于偶数前面" class="headerlink" title="13. 调整数组顺序使奇数位于偶数前面"></a>13. 调整数组顺序使奇数位于偶数前面</h4><pre><code> 题目： 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半 部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 思路： 由于需要考虑到调整之后的稳定性，因此我们可以使用辅助数组的方式。首先对数组中的元素进行遍历，每遇到一个奇数就将它加入到 奇数辅助数组中，每遇到一个偶数，就将它将入到偶数辅助数组中。最后再将两个数组合并。这一种方法的时间复杂度为 O(n)，空间 复杂度为 O(n)。</code></pre><h4 id="14-链表中倒数第-k-个节点"><a href="#14-链表中倒数第-k-个节点" class="headerlink" title="14. 链表中倒数第 k 个节点"></a>14. 链表中倒数第 k 个节点</h4><pre><code> 题目： 输入一个链表，输出该链表中倒数第 k 个结点。 思路： 使用两个指针，先让第一个和第二个指针都指向头结点，然后再让第二个指针走 k-1 步，到达第 k 个节点。然后两个指针同时向后 移动，当第二个指针到达末尾时，第一个指针指向的就是倒数第 k 个节点了。</code></pre><h4 id="15-反转链表"><a href="#15-反转链表" class="headerlink" title="15. 反转链表"></a>15. 反转链表</h4><pre><code> 题目： 输入一个链表，反转链表后，输出链表的所有元素。 思路： 通过设置三个变量 pre、current 和 next，分别用来保存前继节点、当前节点和后继结点。从第一个节点开始向后遍历，首先将当 前节点的后继节点保存到 next 中，然后将当前节点的后继节点设置为 pre，然后再将 pre 设置为当前节点，current 设置为 ne xt 节点，实现下一次循环。</code></pre><h4 id="16-合并两个排序的链表"><a href="#16-合并两个排序的链表" class="headerlink" title="16. 合并两个排序的链表"></a>16. 合并两个排序的链表</h4><pre><code> 题目： 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 思路： 通过递归的方式，依次将两个链表的元素递归进行对比。</code></pre><h4 id="17-树的子结构"><a href="#17-树的子结构" class="headerlink" title="17. 树的子结构"></a>17. 树的子结构</h4><pre><code> 题目： 输入两棵二叉树A、B，判断 B 是不是 A 的子结构。（ps：我们约定空树不是任意一个树的子结构） 思路： 通过递归的思想来解决 第一步首先从树 A 的根节点开始遍历，在左右子树中找到和树 B 根结点的值一样的结点 R 。 第二步两棵树同时从 R 节点和根节点以相同的遍历方式进行遍历，依次比较对应的值是否相同，当树 B 遍历结束时，结束比较。</code></pre><h4 id="18-二叉树的镜像"><a href="#18-二叉树的镜像" class="headerlink" title="18. 二叉树的镜像"></a>18. 二叉树的镜像</h4><pre><code> 题目： 操作给定的二叉树，将其变换为源二叉树的镜像。  思路： 从根节点开始遍历，首先通过临时变量保存左子树的引用，然后将根节点的左右子树的引用交换。然后再递归左右节点的子树交换。</code></pre><h4 id="19-顺时针打印矩阵"><a href="#19-顺时针打印矩阵" class="headerlink" title="19. 顺时针打印矩阵"></a>19. 顺时针打印矩阵</h4><pre><code> 题目： 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字， 例如，如果输入如下矩阵： 1 2 3 4                                          5 6 7 8                                           9 10 11 12                                           13 14 15 16  则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10 思路： （1）根据左上角和右下角可以定位出一次要旋转打印的数据。一次旋转打印结束后，往对角分别前进和后退一个单位，可以确定下一     次需要打印的数据范围。 （2）使用模拟魔方逆时针解法，每打印一行，则将矩阵逆时针旋转 90 度，打印下一行，依次重复。</code></pre><h4 id="20-定义一个栈，实现-min-函数"><a href="#20-定义一个栈，实现-min-函数" class="headerlink" title="20. 定义一个栈，实现 min 函数"></a>20. 定义一个栈，实现 min 函数</h4><pre><code> 题目： 定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。 思路： 使用一个辅助栈，每次将数据压入数据栈时，就把当前栈里面最小的值压入辅助栈当中。这样辅助栈的栈顶数据一直是数据栈中最小 的值。</code></pre><h4 id="21-栈的压入弹出"><a href="#21-栈的压入弹出" class="headerlink" title="21. 栈的压入弹出"></a>21. 栈的压入弹出</h4><pre><code> 题目： 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如 序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序 列的弹出序列。（注意：这两个序列的长度是相等的） 思路： 我们可以使用一个辅助栈的方式来实现，首先遍历压栈顺序，依次将元素压入辅助栈中，每次压入元素后我们首先判断该元素是否与出 栈顺序中的此刻位置的元素相等，如果不相等，则将元素继续压栈，如果相等，则将辅助栈中的栈顶元素出栈，出栈后，将出栈顺序中 的位置后移一位继续比较。当压栈顺序遍历完成后，如果辅助栈不为空，则说明该出栈顺序不正确。</code></pre><h4 id="22-从上往下打印二叉树"><a href="#22-从上往下打印二叉树" class="headerlink" title="22. 从上往下打印二叉树"></a>22. 从上往下打印二叉树</h4><pre><code> 题目： 从上往下打印出二叉树的每个节点，同层节点从左至右打印。 思路： 本质上是二叉树的层序遍历，可以通过队列来实现。首先将根节点入队。然后对队列进行出队操作，每次出队时，将出队元素的左右子 节点依次加入到队列中，直到队列长度变为 0 时，结束遍历。</code></pre><h4 id="23-二叉搜索树的后序遍历"><a href="#23-二叉搜索树的后序遍历" class="headerlink" title="23. 二叉搜索树的后序遍历"></a>23. 二叉搜索树的后序遍历</h4><pre><code> 题目： 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出 Yes，否则输出 No。假设输入的数组的任意两 个数字都互不相同。 思路： 对于一个合法而二叉树的后序遍历来说，最末尾的元素为根元素。该元素前面的元素可以划分为两个部分，一部分为该元素的左子树， 所有元素的值比根元素小，一部分为该元素的右子树，所有的元素的值比该根元素大。并且每一部分都是一个合法的后序序列，因此我 们可以利用这些特点来递归判断。</code></pre><h4 id="24-二叉树中和为某一值路径"><a href="#24-二叉树中和为某一值路径" class="headerlink" title="24. 二叉树中和为某一值路径"></a>24. 二叉树中和为某一值路径</h4><pre><code> 题目： 输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经 过的结点形成一条路径。 思路： 通过对树进行深度优先遍历，遍历时保存当前节点的值并判断是否和期望值相等，如果遍历到叶节点不符合要求则回退处理。</code></pre><h4 id="25-复杂链表的复制"><a href="#25-复杂链表的复制" class="headerlink" title="25. 复杂链表的复制"></a>25. 复杂链表的复制</h4><pre><code> 题目： 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为 复制后复杂链表的 head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 思路： （1）第一种方式，首先对原有链表每个节点进行复制，通过 next 连接起来。然后当链表复制完成之后，再来设置每个节点的 ra     ndom 指针，这个时候每个节点的 random 的设置都需要从头结点开始遍历，因此时间的复杂度为 O(n^2)。 （2）第二种方式，首先对原有链表每个节点进行复制，并且使用 Map 以键值对的方式将原有节点和复制节点保存下来。当链表复     制完成之后，再来设置每个节点的 random 指针，这个时候我们通过 Map 中的键值关系就可以获取到对应的复制节点，因此     不必再从头结点遍历，将时间的复杂度降低为了 O(n)，但是空间复杂度变为了 O(n)。这是一种以空间换时间的做法。 （3）第三种方式，首先对原有链表的每个节点进行复制，并将复制后的节点加入到原有节点的后面。当链表复制完成之后，再进行     random 指针的设置，由于每个节点后面都跟着自己的复制节点，因此我们可以很容易的获取到 random 指向对应的复制节点     。最后再将链表分离，通过这种方法我们也能够将时间复杂度降低为 O(n)。</code></pre><h4 id="26-二叉搜索树与双向链表"><a href="#26-二叉搜索树与双向链表" class="headerlink" title="26. 二叉搜索树与双向链表"></a>26. 二叉搜索树与双向链表</h4><pre><code> 题目： 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 思路： 需要生成一个排序的双向列表，那么我们应该通过中序遍历的方式来调整树结构，因为只有中序遍历，返回才是一个从小到大的排序 序列。 基本的思路是我们首先从根节点开始遍历，先将左子树调整为一个双向链表，并将左子树双向链表的末尾元素的指针指向根节点，并 将根节点的左节点指向末尾节点。再将右子树调整为一个双向链表，并将右子树双向链表的首部元素的指针指向根元素，再将根节点 的右节点指向首部节点。通过对左右子树递归调整，因此来实现排序的双向链表的构建。</code></pre><h4 id="27-字符串的排列"><a href="#27-字符串的排列" class="headerlink" title="27. 字符串的排列"></a>27. 字符串的排列</h4><pre><code> 题目： 输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc，则打印出由字符 a,b,c 所能排列出来的所有 字符串 abc,acb,bac,bca,cab 和 cba。输入描述：输入一个字符串，长度不超过9（可能有字符重复），字符只包括大小写字母。 思路： 我们可以把一个字符串看做是两个部分，第一部分为它的第一个字符，第二部分是它后面的所有字符。求整个字符串的一个全排列，可 以看做两步，第一步是求所有可能出现在第一个位置的字符，即把第一个字符和后面的所有字符交换。第二步就是求后面所有字符的一 个全排列。因此通过这种方式，我们可以以递归的思路来求出当前字符串的全排列。</code></pre><p>   详细资料可以参考：<br>   <a href="https://wiki.jikexueyuan.com/project/for-offer/question-twenty-eight.html">《字符串的排列》</a></p><h4 id="28-数组中出现次数超过一半的数字"><a href="#28-数组中出现次数超过一半的数字" class="headerlink" title="28. 数组中出现次数超过一半的数字"></a>28. 数组中出现次数超过一半的数字</h4><pre><code> 题目： 数组中有一个数字出现的次数超过数组长度的一半。请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数 字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 思路： （1）对数组进行排序，排序后的中位数就是所求数字。这种方法的时间复杂度取决于我们采用的排序方法的时间复杂度，因此最快为     O(nlogn)。 （2）由于所求数字的数量超过了数组长度的一半，因此排序后的中位数就是所求数字。因此我们可以将问题简化为求一个数组的中     位数问题。其实数组并不需要全排序，只需要部分排序。我们通过利用快排中的 partition 函数来实现，我们现在数组中随     机选取一个数字，而后通过 partition 函数返回该数字在数组中的索引 index，如果 index 刚好等于 n/2，则这个数字     便是数组的中位数，也即是要求的数，如果 index 大于 n/2，则中位数肯定在 index的左边，在左边继续寻找即可，反之     在右边寻找。这样可以只在 index 的一边寻找，而不用两边都排序，减少了一半排序时间，这种方法的时间复杂度为 O(n)。 （3）由于该数字的出现次数比所有其他数字出现次数的和还要多，因此可以考虑在遍历数组时保存两个值：一个是数组中的一个数     字，一个是次数。当遍历到下一个数字时，如果下一个数字与之前保存的数字相同，则次数加1，如果不同，则次数减1，如果     次数为0，则需要保存下一个数字，并把次数设定为1。由于我们要找的数字出现的次数比其他所有数字的出现次数之和还要大，     则要找的数字肯定是最后一次把次数设为1时对应的数字。该方法的时间复杂度为O(n)，空间复杂度为 O(1)。</code></pre><p>   详细资料可以参考：<br>   <a href="https://blog.csdn.net/ns_code/article/details/26957383">《出现次数超过一半的数字》</a></p><h4 id="29-最小的-K-个数"><a href="#29-最小的-K-个数" class="headerlink" title="29. 最小的 K 个数"></a>29. 最小的 K 个数</h4><pre><code> 题目： 输入 n 个整数，找出其中最小的 K 个数。例如输入 4,5,1,6,2,7,3,8 这8个数字，则最小的4个数字是 1,2,3,4 。 思路： （1）第一种思路是首先将数组排序，排序后再取最小的 k 个数。这一种方法的时间复杂度取决于我们选择的排序算法的时间复杂     度，最好的情况下为 O(nlogn)。 （2）第二种思路是由于我们只需要获得最小的 k 个数，这 k 个数不一定是按序排序的。因此我们可以使用快速排序中的 part     ition函数来实现。每一次选择一个枢纽值，将数组分为比枢纽值大和比枢纽值小的两个部分，判断枢纽值的位置，如果该枢     纽值的位置为 k-1 的话，那么枢纽值和它前面的所有数字就是最小的 k 个数。如果枢纽值的位置小于 k-1 的话，假设枢     纽值的位置为 n-1，那么我们已经找到了前 n 小的数字了，我们就还需要到后半部分去寻找后半部分 k-n 小的值，进行划     分。当该枢纽值的位置比 k-1大时，说明最小的 k 个值还在左半部分，我们需要继续对左半部分进行划分。这一种方法的平     均时间复杂度为 O(n)。 （3）第三种方法是维护一个容量为 k 的最大堆。对数组进行遍历时，如果堆的容量还没有达到 k ，则直接将元素加入到堆中，这     就相当于我们假设前 k 个数就是最小的 k 个数。对 k 以后的元素遍历时，我们将该元素与堆的最大值进行比较，如果比最     大值小，那么我们则将最大值与其交换，然后调整堆。如果大于等于堆的最大值，则继续向后遍历，直到数组遍历完成。这一     种方法的平均时间复杂度为 O(nlogk)。</code></pre><p>   详细资料可以参考：<br>   <a href="https://www.kancloud.cn/kancloud/the-art-of-programming/41579">《寻找最小的 k 个数》</a></p><h4 id="30-连续子数组的最大和"><a href="#30-连续子数组的最大和" class="headerlink" title="30. 连续子数组的最大和"></a>30. 连续子数组的最大和</h4><pre><code> 题目： HZ 偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后，他又发话了:在古老的一维模式识别中，常常需要计 算连续子向量的最大和,当向量全为正数的时候，问题很好解决。但是，如果向量中包含负数，是否应该包含某个负数，并期望旁边的 正数会弥补它呢？例如：{6,-3,-2,7,-15,1,2,2}，连续子向量的最大和为8（从第0个开始，到第3个为止）。你会不会被他忽悠 住？（子向量的长度至少是1） 思路： （1）第一种思路是直接暴力求解的方式，先以第一个数字为首往后开始叠加，叠加的过程中保存最大的值。然后再以第二个数字为首     往后开始叠加，并与先前保存的最大的值进行比较。这一种方法的时间复杂度为 O(n^2)。 （2）第二种思路是，首先我们观察一个最大和的连续数组的规律，我们可以发现，子数组一定是以正数开头的，中间包含了正负数。     因此我们可以从第一个数开始向后叠加，每次保存最大的值。叠加的值如果为负数，则将叠加值初始化为0，因为后面的数加上负     数只会更小，因此需要寻找下一个正数开始下一个子数组的判断。一直往后判断，直到这个数组遍历完成为止，得到最大的值。     使用这一种方法的时间复杂度为 O(n)。</code></pre><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-one.html">《连续子数组的最大和》</a></p><h4 id="31-整数中1出现的次数（待深入理解）"><a href="#31-整数中1出现的次数（待深入理解）" class="headerlink" title="31. 整数中1出现的次数（待深入理解）"></a>31. 整数中1出现的次数（待深入理解）</h4><pre><code> 题目： 求出1~13的整数中1出现的次数，并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、 12、13因此共出现6次，但是对于后面问题他就没辙了。ACMer希望你们帮帮他，并把问题更加普遍化，可以很快的求出任意非负整 数区间中1出现的次数。 思路： （1）第一种思路是直接遍历每个数，然后将判断每个数中 1 的个数，一直叠加。 （2）第二种思路是求出1出现在每位上的次数，然后进行叠加。</code></pre><p>   详细资料可以参考：<br>   <a href="https://blog.csdn.net/yi_Afly/article/details/52012593">《从1到n整数中1出现的次数：O(logn)算法》</a></p><h4 id="32-把数组排成最小的数"><a href="#32-把数组排成最小的数" class="headerlink" title="32. 把数组排成最小的数"></a>32. 把数组排成最小的数</h4><pre><code> 题目： 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321 }，则打印出这三个数字能排成的最小数字为321323。 思路： （1）求出数组的全排列，然后对每个排列结果进行比较。 （2）利用排序算法实现，但是比较时，比较的并不是两个元素的大小，而是两个元素正序拼接和逆序拼接的大小，如果逆序拼接的     结果更小，则交换两个元素的位置。排序结束后，数组的顺序则为最小数的排列组合顺序。</code></pre><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-three.html">《把数组排成最小的数》</a></p><h4 id="33-丑数（待深入理解）"><a href="#33-丑数（待深入理解）" class="headerlink" title="33. 丑数（待深入理解）"></a>33. 丑数（待深入理解）</h4><pre><code> 题目： 把只包含质因子2、3和5的数称作丑数。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求 按从小到大的顺序的第 N 个丑数。 思路： （1）判断一个数是否为丑数，可以判断该数不断除以2，最后余数是否为1。判断该数不断除以3，最后余数是否为1。判断不断除以     5，最后余数是否为1。在不考虑时间复杂度的情况下，可以依次遍历找到第 N 个丑数。 （2）使用一个数组来保存已排序好的丑数，后面的丑数由前面生成。</code></pre><h4 id="34-第一个只出现一次的字符"><a href="#34-第一个只出现一次的字符" class="headerlink" title="34. 第一个只出现一次的字符"></a>34. 第一个只出现一次的字符</h4><pre><code> 题目： 在一个字符串（1&lt;=字符串长度&lt;=10000，全部由大写字母组成）中找到第一个只出现一次的字符，并返回它的位置。 思路： （1）第一种思路是，从前往后遍历每一个字符。每遍历一个字符，则将字符与后边的所有字符依次比较，判断是否含有相同字符。这     一种方法的时间复杂度为 O(n^2)。 （2）第二种思路是，首先对字符串进行一次遍历，将字符和字符出现的次数以键值对的形式存储在 Map 结构中。然后第二次遍历时     ，去 Map 中获取对应字符出现的次数，找到第一个只出现一次的字符。这一种方法的时间复杂度为 O(n)。</code></pre><h4 id="35-数组中的逆序对"><a href="#35-数组中的逆序对" class="headerlink" title="35. 数组中的逆序对"></a>35. 数组中的逆序对</h4><pre><code> 题目： 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对 的总数 P。 思路： （1）第一种思路是直接求解的方式，顺序扫描整个数组。每扫描到一个数字的时候，逐个比较该数字和它后面的数字的大小。如果     后面的数字比它小，则这两个数字就组成了一个逆序对。假设数组中含有 n 个数字。由于每个数字都要和 O(n）个数字作比     较，因此这个算法的时间复杂度是 O(n^2)。 （2）第二种方式是使用归并排序的方式，通过利用归并排序分解后进行合并排序时，来进行逆序对的统计，这一种方法的时间复杂     度为 O(nlogn)。</code></pre><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-six.html">《数组中的逆序对》</a></p><h4 id="36-两个链表的第一个公共结点"><a href="#36-两个链表的第一个公共结点" class="headerlink" title="36. 两个链表的第一个公共结点"></a>36. 两个链表的第一个公共结点</h4><pre><code> 题目： 输入两个链表，找出它们的第一个公共结点。 思路： （1）第一种方法是在第一个链表上顺序遍历每个结点，每遍历到一个结点的时候，在第二个链表上顺序遍历每个结点。如果在第二     个链表上有一个结点和第一个链表上的结点一样，说明两个链表在这个结点上重合，于是就找到了它们的公共结点。如果第一     个链表的长度为 m，第二个链表的长度为 n。这一种方法的时间复杂度是 O(mn）。 （2）第二种方式是利用栈的方式，通过观察我们可以发现两个链表的公共节点，都位于链表的尾部，以此我们可以分别使用两个栈     ，依次将链表元素入栈。然后在两个栈同时将元素出栈，比较出栈的节点，最后一个相同的节点就是我们要找的公共节点。这     一种方法的时间复杂度为 O(m+n)，空间复杂度为 O(m+n)。 （3）第三种方式是，首先分别遍历两个链表，得到两个链表的长度。然后得到较长的链表与较短的链表长度的差值。我们使用两个     指针来分别对两个链表进行遍历，首先将较长链表的指针移动 n 步，n 为两个链表长度的差值，然后两个指针再同时移动，     判断所指向节点是否为同一节点。这一种方法的时间复杂度为 O(m+n)，相同对于上一种方法不需要额外的空间。</code></pre><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-seven.html">《两个链表的第一个公共结点》</a></p><h4 id="37-数字在排序数组中出现的次数"><a href="#37-数字在排序数组中出现的次数" class="headerlink" title="37. 数字在排序数组中出现的次数"></a>37. 数字在排序数组中出现的次数</h4><pre><code> 题目： 统计一个数字：在排序数组中出现的次数。例如输入排序数组｛ 1, 2, 3, 3, 3, 3, 4, 5｝和数字 3 ，由于 3 在这个数组中出 现了 4 次，因此输出 4 。 思路： （1）第一种方法是直接对数组顺序遍历的方式，通过这种方法来统计数字的出现次数。这种方法的时间复杂度为 O(n)。 （2）第二种方法是使用二分查找的方法，由于数组是排序好的数组，因此相同数字是排列在一起的。统计数字出现的次数，我们需要     去找到该段数字开始和结束的位置，以此来确定数字出现的次数。因此我们可以使用二分查找的方式来确定该数字的开始和结束     位置。如果我们第一次我们数组的中间值为 k ，如果 k 值比所求值大的话，那么我们下一次只需要判断前面一部分就行了，如     果 k值比所求值小的话，那么我们下一次就只需要判断后面一部分就行了。如果 k 值等于所求值的时候，我们则需要判断该值     是否为开始位置或者结束位置。如果是开始位置，那么我们下一次需要到后半部分去寻找结束位置。如果是结束位置，那么我们     下一次需要到前半部分去寻找开始位置。如果既不是开始位置也不是结束位置，那么我们就分别到前后两个部分去寻找开始和结     束位置。这一种方法的平均时间复杂度为 O(logn)。</code></pre><h4 id="38-二叉树的深度"><a href="#38-二叉树的深度" class="headerlink" title="38. 二叉树的深度"></a>38. 二叉树的深度</h4><pre><code> 题目： 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深 度。 思路： 根节点的深度等于左右深度较大值加一，因此可以通过递归遍历来实现。</code></pre><h4 id="39-平衡二叉树"><a href="#39-平衡二叉树" class="headerlink" title="39. 平衡二叉树"></a>39. 平衡二叉树</h4><pre><code> 题目： 输入一棵二叉树，判断该二叉树是否是平衡二叉树。 思路： （1）在遍历树的每个结点的时候，调用函数得到它的左右子树的深度。如果每个结点的左右子树的深度相差都不超过 1 ，那么它     就是一棵平衡的二叉树。使用这种方法时，节点会被多次遍历，因此会造成效率不高的问题。 （2）在求一个节点的深度时，同时判断它是否平衡。如果不平衡则直接返回 -1，否则返回树高度。如果一个节点的一个子树的深     度为-1，那么就直接向上返回 -1 ，该树已经是不平衡的了。通过这种方式确保了节点只能够被访问一遍。</code></pre><h4 id="40-数组中只出现一次的数字"><a href="#40-数组中只出现一次的数字" class="headerlink" title="40. 数组中只出现一次的数字"></a>40. 数组中只出现一次的数字</h4><pre><code> 题目： 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 思路： （1）第一种方式是依次遍历数组，记录下数字出现的次数，从而找出两个只出现一次的数字。 （2）第二种方式，根据位运算的异或的性质，我们可以知道两个相同的数字异或等于0，一个数和 0 异或还是它本身。由于数组中     的其他数字都是成对出现的，因此我们可以将数组中的所有数依次进行异或运算。如果只有一个数出现一次的话，那么最后剩下     的就是落单的数字。如果是两个数只出现了一次的话，那么最后剩下的就是这两个数异或的结果。这个结果中的1表示的是 A 和     B 不同的位。我们取异或结果的第一个1所在的位数，假如是第3位，接着通过比较第三位来将数组分为两组，相同数字一定会     被分到同一组。分组完成后再按照依次异或的思路，求得剩余数字即为两个只出现一次的数字。</code></pre><h4 id="41-和为-S-的连续正数序列"><a href="#41-和为-S-的连续正数序列" class="headerlink" title="41. 和为 S 的连续正数序列"></a>41. 和为 S 的连续正数序列</h4><pre><code> 题目： 小明很喜欢数学，有一天他在做数学作业时，要求计算出9~16的和，他马上就写出了正确答案是100。但是他并不满足于此，他在想究 竟有多少种连续的正数序列的和为100（至少包括两个数）。没多久，他就得到另一组连续正数和为100的序列：18,19,20,21,22。 现在把问题交给你，你能不能也很快的找出所有和为 S 的连续正数序列？Good Luck!输出描述：输出所有和为S的连续正数序列。序 列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序。 思路： 维护一个正数序列数组，数组中初始只含有值1和2，然后从3依次往后遍历，每遍历到一个元素则将这个元素加入到序列数组中，然后 判断此时序列数组的和。如果序列数组的和大于所求值，则将第一个元素（最小的元素弹出）。如果序列数组的和小于所求值，则继续 往后遍历，将元素加入到序列中继续判断。当序列数组的和等于所求值时，打印出此时的正数序列，然后继续往后遍历，寻找下一个连 续序列，直到数组遍历完成终止。</code></pre><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-forty-one.html">《和为 s 的连续正数序列》</a></p><h4 id="42-和为-S-的两个数字"><a href="#42-和为-S-的两个数字" class="headerlink" title="42. 和为 S 的两个数字"></a>42. 和为 S 的两个数字</h4><pre><code> 题目： 输入一个递增排序的数组和一个数字 S，在数组中查找两个数，是的他们的和正好是 S，如果有多对数字的和等于 S，输出两个数 的乘积最小的。输出描述：对应每个测试案例，输出两个数，小的先输出。 思路： 首先我们通过规律可以发现，和相同的两个数字，两个数字的差值越大，乘积越小。因此我们只需要从数组的首尾开始找到第一对和 为 s 的数字对进行了。因此我们可以使用双指针的方式，左指针初始指向数组的第一个元素，右指针初始指向数组的最后一个元素 。然后首先判断两个指针指向的数字的和是否为 s ，如果为 s ，两个指针指向的数字就是我们需要寻找的数字对。如果两数的和 比 s 小，则将左指针向左移动一位后继续判断。如果两数的和比 s 大，则将右指针向右移动一位后继续判断。</code></pre><p>   详细资料可以参考：<br>   <a href="https://www.cnblogs.com/wuguanglin/p/FindNumbersWithSum.html">《和为 S 的字符串》</a></p><h4 id="43-左旋转字符串"><a href="#43-左旋转字符串" class="headerlink" title="43. 左旋转字符串"></a>43. 左旋转字符串</h4><pre><code> 题目： 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的 字符序列 S，请你把其循环左移 K 位后的序列输出。例如，字符序列 S=”abcXYZdef”，要求输出循环左移3位后的结果，即 “X YZdefabc”。是不是很简单？OK，搞定它！ 思路： 字符串裁剪后拼接</code></pre><h4 id="44-翻转单词顺序列"><a href="#44-翻转单词顺序列" class="headerlink" title="44. 翻转单词顺序列"></a>44. 翻转单词顺序列</h4><pre><code> 题目： 牛客最近来了一个新员工 Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事 Cat 对 Fish 写的内容颇感兴趣，有 一天他向 Fish 借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了 ，正确的句子应该是“I am a student.”。Cat 对一一的翻转这些单词顺序可不在行，你能帮助他么？ 思路： 通过空格将单词分隔，然后将数组反序后，重新拼接为字符串。</code></pre><h4 id="45-扑克牌的顺子"><a href="#45-扑克牌的顺子" class="headerlink" title="45. 扑克牌的顺子"></a>45. 扑克牌的顺子</h4><pre><code> 题目： LL 今天心情特别好，因为他去买了一副扑克牌，发现里面居然有2个大王，2个小王（一副牌原本是54张^_^）...他随机从中抽出 了5张牌，想测测自己的手气，看看能不能抽到顺子，如果抽到的话，他决定去买体育彩票，嘿嘿！！“红心 A，黑桃3，小王，大王 ，方片5”，“Oh My God!”不是顺子..... LL 不高兴了，他想了想，决定大\小王可以看成任何数字，并且 A 看作1，J 为11， Q 为12，K 为13。上面的5张牌就可以变成“1,2,3,4,5”（大小王分别看作2和4），“So Lucky!”。LL 决定去买体育彩票啦。 现在，要求你使用这幅牌模拟上面的过程，然后告诉我们 LL 的运气如何。为了方便起见，你可以认为大小王是0。 思路： 首先判断5个数字是不是连续的，最直观的方法是把数组排序。值得注意的是，由于 0 可以当成任意数字，我们可以用 0 去补满数 组中的空缺。如果排序之后的数组不是连续的，即相邻的两个数字相隔若干个数字，但只要我们有足够的。可以补满这两个数字的空 缺，这个数组实际上还是连续的。 于是我们需要做 3 件事情：首先把数组排序，再统计数组中 0 的个数，最后统计排序之后的数组中相邻数字之间的空缺总数。如 果空缺的总数小于或者等于 0 的个数，那么这个数组就是连续的：反之则不连续。最后，我们还需要注意一点：如果数组中的非 0 数字重复出现，则该数组不是连续的。换成扑克牌的描述方式就是如果一副牌里含有对子，则不可能是顺子。</code></pre><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-forty-four.html">《扑克牌的顺子》</a></p><h4 id="46-圆圈中最后剩下的数字（约瑟夫环问题）"><a href="#46-圆圈中最后剩下的数字（约瑟夫环问题）" class="headerlink" title="46. 圆圈中最后剩下的数字（约瑟夫环问题）"></a>46. 圆圈中最后剩下的数字（约瑟夫环问题）</h4><pre><code> 题目： 0, 1, … , n-1 这 n 个数字排成一个圈圈，从数字 0 开始每次从圆圏里删除第 m 个数字。求出这个圈圈里剩下的最后一个数 字。 思路： （1）使用环形链表进行模拟。 （2）根据规律得出（待深入理解）</code></pre><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-forty-five.html">《圆圈中最后剩下的数字》</a></p><h4 id="47-1-2-3-…-n"><a href="#47-1-2-3-…-n" class="headerlink" title="47. 1+2+3+…+n"></a>47. 1+2+3+…+n</h4><pre><code> 题目： 求 1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。 思路： 由于不能使用循环语句，因此我们可以通过递归来实现。并且由于不能够使用条件判断运算符，我们可以利用 &amp;&amp; 操作符的短路特 性来实现。</code></pre><h4 id="48-不用加减乘除做加法"><a href="#48-不用加减乘除做加法" class="headerlink" title="48. 不用加减乘除做加法"></a>48. 不用加减乘除做加法</h4><pre><code> 题目： 写一个函数，求两个整数之和，要求在函数体内不得使用 ＋、－、×、÷ 四则运算符号。 思路： 通过位运算，递归来实现。</code></pre><h4 id="49-把字符串转换成整数。"><a href="#49-把字符串转换成整数。" class="headerlink" title="49. 把字符串转换成整数。"></a>49. 把字符串转换成整数。</h4><pre><code> 题目： 将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。数值为0或者字符串不是一个合法的数值则返回 0。输入描 述：输入一个字符串，包括数字字母符号，可以为空。输出描述：如果是合法的数值表达则返回该数字，否则返回0。 思路： 首先需要进行符号判断，其次我们根据字符串的每位通过减0运算转换为整数和，依次根据位数叠加。</code></pre><h4 id="50-数组中重复的数字"><a href="#50-数组中重复的数字" class="headerlink" title="50. 数组中重复的数字"></a>50. 数组中重复的数字</h4><pre><code> 题目： 在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知 道每个数字重复了几次。请找出数组中任意一个重复的数字。 思路： （1）首先将数组排序，排序后再进行判断。这一种方法的时间复杂度为 O(nlogn)。 （2）使用 Map 结构的方式，依次记录下每一个数字出现的次数，从而可以判断是否出现重复数字。这一种方法的时间复杂度为 O     (n)，空间复杂度为 O(n)。 （3）从数组首部开始遍历，每遍历一个数字，则将该数字和它的下标相比较，如果数字和下标不等，则将该数字和它对应下标的值     交换。如果对应的下标值上已经是正确的值了，那么说明当前元素是一个重复数字。这一种方法相对于上一种方法来说不需要     额外的内存空间。</code></pre><h4 id="51-构建乘积数组"><a href="#51-构建乘积数组" class="headerlink" title="51. 构建乘积数组"></a>51. 构建乘积数组</h4><pre><code> 题目： 给定一个数组 A[0,1,...,n-1]，请构建一个数组 B[0,1,...,n-1]，其中 B 中的元素 B[i]=A[0]*A[1]*...*A[i-1]*A [i+1]*...*A[n-1]。不能使用除法。 思路： （1）  C[i]=A[0]×A[1]×...×A[i-1]=C[i-1]×A[i-1]        D[i]=A[i+1]×...×A[n-1]=D[i+1]×A[i+1]        B[i]=C[i]×D[i]       将乘积分为前后两个部分，分别循环求出后，再进行相乘。 （2）上面的方法需要额外的内存空间，我们可以引入中间变量的方式，来降低空间复杂度。（待深入理解）</code></pre><p>   详细资料可以参考：<br>   <a href="https://zhuanlan.zhihu.com/p/34804711">《构建乘积数组》</a></p><h4 id="52-正则表达式的匹配"><a href="#52-正则表达式的匹配" class="headerlink" title="52. 正则表达式的匹配"></a>52. 正则表达式的匹配</h4><pre><code> 题目： 请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任 意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配， 但是与"aa.a"和"ab*a"均不匹配。 思路： （1）状态机思路（待深入理解）</code></pre><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-fifty-three.html">《正则表达式匹配》</a></p><h4 id="53-表示数值的字符串"><a href="#53-表示数值的字符串" class="headerlink" title="53. 表示数值的字符串"></a>53. 表示数值的字符串</h4><pre><code> 题目： 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E- 16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。、 思路： 利用正则表达式实现</code></pre><h4 id="54-字符流中第一个不重复的字符"><a href="#54-字符流中第一个不重复的字符" class="headerlink" title="54. 字符流中第一个不重复的字符"></a>54. 字符流中第一个不重复的字符</h4><pre><code> 题目： 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 "go" 时，第一个只出现一次 的字符是 "g" 。当从该字符流中读出前六个字符 "google" 时，第一个只出现一次的字符是 "l"。 输出描述：如果当前字符流 没有存在出现一次的字符，返回#字符。 思路： 同第 34 题</code></pre><h4 id="55-链表中环的入口结点"><a href="#55-链表中环的入口结点" class="headerlink" title="55. 链表中环的入口结点"></a>55. 链表中环的入口结点</h4><pre><code> 题目： 一个链表中包含环，如何找出环的入口结点？ 思路： 首先使用快慢指针的方式我们可以判断链表中是否存在环，当快慢指针相遇时，说明链表中存在环。相遇点一定存在于环中，因此我 们可以从使用一个指针从这个点开始向前移动，每移动一个点，环的长度加一，当指针再次回到这个点的时候，指针走了一圈，因此 通过这个方法我们可以得到链表中的环的长度，我们将它记为 n 。 然后我们设置两个指针，首先分别指向头结点，然后将一个指针先移动 n 步，然后两个指针再同时移动，当两个指针相遇时，相遇 点就是环的入口节点。</code></pre><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-fifty-six.html">《链表中环的入口结点》</a><br>   <a href="https://blog.csdn.net/shansusu/article/details/50285735">《《剑指offer》——链表中环的入口结点》</a></p><h4 id="56-删除链表中重复的结点"><a href="#56-删除链表中重复的结点" class="headerlink" title="56. 删除链表中重复的结点"></a>56. 删除链表中重复的结点</h4><pre><code> 题目： 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。例如，链表1-&gt;2-&gt;3- &gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 思路： 解决这个问题的第一步是确定删除的参数。当然这个函数需要输入待删除链表的头结点。头结点可能与后面的结点重复，也就是说头 结点也可能被删除，所以在链表头额外添加一个结点。 接下来我们从头遍历整个链表。如果当前结点的值与下一个结点的值相同，那么它们就是重复的结点，都可以被删除。为了保证删除 之后的链表仍然是相连的而没有中间断开，我们要把当前的前一个结点和后面值比当前结点的值要大的结点相连。我们要确保 prev 要始终与下一个没有重复的结点连接在一起。</code></pre><h4 id="57-二叉树的下一个结点"><a href="#57-二叉树的下一个结点" class="headerlink" title="57. 二叉树的下一个结点"></a>57. 二叉树的下一个结点</h4><pre><code> 题目： 给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？树中的结点除了有两个分别指向左右子结点的指针以外， 还有一个指向父节点的指针。 思路： 这个问题我们可以分为三种情况来讨论。 第一种情况，当前节点含有右子树，这种情况下，中序遍历的下一个节点为该节点右子树的最左子节点。因此我们只要从右子节点 出发，一直沿着左子节点的指针，就能找到下一个节点。 第二种情况是，当前节点不含有右子树，并且当前节点为父节点的左子节点，这种情况下中序遍历的下一个节点为当前节点的父节 点。 第三种情况是，当前节点不含有右子树，并且当前节点为父节点的右子节点，这种情况下我们沿着父节点一直向上查找，直到找到 一个节点，该节点为父节点的左子节点。这个左子节点的父节点就是中序遍历的下一个节点。</code></pre><h4 id="58-对称二叉树"><a href="#58-对称二叉树" class="headerlink" title="58. 对称二叉树"></a>58. 对称二叉树</h4><pre><code> 题目： 请实现一个函数来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 思路： 我们对一颗二叉树进行前序遍历的时候，是先访问左子节点，然后再访问右子节点。因此我们可以定义一种对称的前序遍历的方式 ，就是先访问右子节点，然后再访问左子节点。通过比较两种遍历方式最后的结果是否相同，以此来判断该二叉树是否为对称二叉 树。</code></pre><h4 id="59-按之字形顺序打印二叉树（待深入理解）"><a href="#59-按之字形顺序打印二叉树（待深入理解）" class="headerlink" title="59. 按之字形顺序打印二叉树（待深入理解）"></a>59. 按之字形顺序打印二叉树（待深入理解）</h4><pre><code> 题目： 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，即第一行按照 从左到右的顺序打印，第二层按照从右到左顺序打印，第三行再按照从左到右的顺序打印，其他以此类推。 思路： 按之字形顺序打印二叉树需要两个栈。我们在打印某一行结点时，把下一层的子结点保存到相应的栈里。如果当前打印的是奇数层 ，则先保存左子结点再保存右子结点到一个栈里；如果当前打印的是偶数层，则先保存右子结点再保存左子结点到第二个栈里。每 一个栈遍历完成后进入下一层循环。</code></pre><p>   详细资料可以参考：<br>   <a href="https://www.cnblogs.com/wuguanglin/p/Print.html">《按之字形顺序打印二叉树》</a></p><h4 id="60-从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。"><a href="#60-从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。" class="headerlink" title="60. 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。"></a>60. 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</h4><pre><code> 题目： 从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印一行。 思路： 用一个队列来保存将要打印的结点。为了把二叉树的每一行单独打印到一行里，我们需要两个变量：一个变量表示在当前的层中还 没有打印的结点数，另一个变量表示下一次结点的数目。</code></pre><h4 id="61-序列化二叉树（待深入理解）"><a href="#61-序列化二叉树（待深入理解）" class="headerlink" title="61. 序列化二叉树（待深入理解）"></a>61. 序列化二叉树（待深入理解）</h4><pre><code> 题目： 请实现两个函数，分别用来序列化和反序列化二叉树。 思路： 数组模拟</code></pre><h4 id="62-二叉搜索树的第-K-个节点"><a href="#62-二叉搜索树的第-K-个节点" class="headerlink" title="62. 二叉搜索树的第 K 个节点"></a>62. 二叉搜索树的第 K 个节点</h4><pre><code> 题目： 给定一颗二叉搜索树，请找出其中的第 k 小的结点。 思路： 对一颗树首先进行中序遍历，在遍历的同时记录已经遍历的节点数，当遍历到第 k 个节点时，这个节点即为第 k 大的节点。</code></pre><h4 id="63-数据流中的中位数（待深入理解）"><a href="#63-数据流中的中位数（待深入理解）" class="headerlink" title="63. 数据流中的中位数（待深入理解）"></a>63. 数据流中的中位数（待深入理解）</h4><pre><code> 题目： 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有值排序之后位于中间的数值。如果数据 流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</code></pre><h4 id="64-滑动窗口中的最大值（待深入理解）"><a href="#64-滑动窗口中的最大值（待深入理解）" class="headerlink" title="64. 滑动窗口中的最大值（待深入理解）"></a>64. 滑动窗口中的最大值（待深入理解）</h4><pre><code> 题目： 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的 大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下 6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2 ,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 思路： 使用队列的方式模拟</code></pre><h4 id="65-矩阵中的路径（待深入理解）"><a href="#65-矩阵中的路径（待深入理解）" class="headerlink" title="65. 矩阵中的路径（待深入理解）"></a>65. 矩阵中的路径（待深入理解）</h4><pre><code> 题目： 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每 一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子 。例如 a b c e s f c s a d e e 矩阵中包含一条字符串"bcced"的路径，但是矩阵中不包含"abcb"路径，因为字符串的 第一个字符 b 占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</code></pre><h4 id="66-机器人的运动范围（待深入理解）"><a href="#66-机器人的运动范围（待深入理解）" class="headerlink" title="66. 机器人的运动范围（待深入理解）"></a>66. 机器人的运动范围（待深入理解）</h4><pre><code> 题目： 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能 进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是 ，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</code></pre><p>剑指 offer 相关资料可以参考：<br><a href="https://blog.csdn.net/zzl819954692/article/details/79648054">《剑指 offer 题目练习及思路分析》</a><br><a href="https://www.cnblogs.com/wuguanglin/p/code-interview.html">《JS 版剑指 offer》</a><br><a href="https://wiki.jikexueyuan.com/project/for-offer/">《剑指 Offer 学习心得》</a></p><h2 id="相关算法题"><a href="#相关算法题" class="headerlink" title="相关算法题"></a>相关算法题</h2><h4 id="1-明星问题"><a href="#1-明星问题" class="headerlink" title="1. 明星问题"></a>1. 明星问题</h4><pre><code>题目：有 n 个人，其中一个明星和 n-1 个群众，群众都认识明星，明星不认识任何群众，群众和群众之间的认识关系不知道，现有一个函数 foo(A, B)，若 A 认识 B 返回 true，若 A 不认识 B 返回 false，试设计一种算法找出明星，并给出时间复杂度。思路：（1）第一种方法我们可以直接使用双层循环遍历的方式，每一个人都和其他人进行判断，如果一个人谁都不认识，那么他就是明星。    这一种方法的时间复杂度为 O(n^2)。（2）上一种方法没有充分利用题目所给的条件，其实我们每一次比较，都可以排除一个人的可能。比如如果 A 认识 B，那么说明    A 就不会是明星，因此 A 就可以从数组中移除。如果 A 不认识 B，那么说明 B 不可能是明星，因此 B 就可以从数组中移    除。因此每一次判断都能够减少一个可能性，我们只需要从数组从前往后进行遍历，每次移除一个不可能的人，直到数组中只剩    一人为止，那么这个人就是明星。这一种方法的时间复杂度为 O(n)。</code></pre><p>   详细资料可以参考：<br>   <a href="https://www.nowcoder.com/questionTerminal/fd3caff374c945fb9ea5f107016bcd4f">《一个明星和 n-1 个群众》</a></p><h4 id="2-正负数组求和"><a href="#2-正负数组求和" class="headerlink" title="2. 正负数组求和"></a>2. 正负数组求和</h4><pre><code>题目：有两个数组，一个数组里存放的是正整数，另一个数组里存放的是负整数，都是无序的，现在从两个数组里各拿一个，使得它们的和最接近零。思路：（1）首先我们可以对两个数组分别进行排序，正数数组按从小到大排序，负数数组按从大到小排序。排序完成后我们使用两个指针分    别指向两个数组的首部，判断两个指针的和。如果和大于0，则负数指针往后移动一个位置，如果和小于0，则正数指针往后移动    一个位置，每一次记录和的值，和当前保存下来的最小值进行比较。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;算法知识总结&quot;&gt;&lt;a href=&quot;#算法知识总结&quot; class=&quot;headerlink&quot; title=&quot;算法知识总结&quot;&gt;&lt;/a&gt;算法知识总结&lt;/h1&gt;&lt;p&gt;本部分主要是笔者在学习算法知识和一些相关面试题所做的笔记，如果出现错误</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>https证书自动续签</title>
    <link href="http://example.com/2021/12/20/%E5%AE%89%E5%85%A8/https%E8%AF%81%E4%B9%A6%E8%87%AA%E5%8A%A8%E7%BB%AD%E7%AD%BE/"/>
    <id>http://example.com/2021/12/20/%E5%AE%89%E5%85%A8/https%E8%AF%81%E4%B9%A6%E8%87%AA%E5%8A%A8%E7%BB%AD%E7%AD%BE/</id>
    <published>2021-12-20T17:58:58.000Z</published>
    <updated>2021-12-22T06:03:57.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装说明"><a href="#安装说明" class="headerlink" title="安装说明"></a><a href="https://github.com/acmesh-official/acme.sh/wiki/%E8%AF%B4%E6%98%8E">安装说明</a></h2><h2 id="续签代码"><a href="#续签代码" class="headerlink" title="续签代码"></a>续签代码</h2><pre><code class="BASH">acme.sh --install-cert -d eth2app.com -d test.eth2app.com -d api.eth2app.com -d h5.eth2app.com  -d h5admin.eth2app.com -d rpc.eth2app.com  --key-file       /etc/nginx/ssl/eth2app.com/key.pem  --fullchain-file /etc/nginx/ssl/eth2app.com/cert.pemacme.sh --issue --dns dns_gd -d eth2app.com -d test.eth2app.com -d api.eth2app.com -d h5.eth2app.com -d h5admin.eth2app.com -d rpc.eth2app.com</code></pre><h2 id="DNS-API"><a href="#DNS-API" class="headerlink" title="DNS API"></a><a href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi">DNS API</a></h2><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;安装说明&quot;&gt;&lt;a href=&quot;#安装说明&quot; class=&quot;headerlink&quot; title=&quot;安装说明&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/acmesh-official/acme.sh/wiki/%E8%AF%B4%E6%98%8E&quot;&gt;安装说明&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;续签代码&quot;&gt;&lt;a href=&quot;#续签代码&quot; class=&quot;headerlink&quot; title=&quot;续签代码&quot;&gt;&lt;/a&gt;续签代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;BASH&quot;&gt;acme.sh --install-cert -d eth2app.com -d test.eth2app.com -d api.eth2app.com -d h5.eth2app.com  -d h5admin.eth2app.com -d rpc.eth2app.com  --key-file       /etc/nginx/ssl/eth2app.com/key.pem  --fullchain-file /etc/nginx/ssl/eth2app.com/cert.pem

acme.sh --issue --dns dns_gd -d eth2app.com -d test.eth2app.com -d api.eth2app.com -d h5.eth2app.com -d h5admin.eth2app.com -d rpc.eth2app.com&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;DNS-API&quot;&gt;&lt;a href=&quot;#DNS-API&quot; class=&quot;headerlink&quot; title=&quot;DNS API&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/acmesh-official/acme.sh/wiki/dnsapi&quot;&gt;DNS API&lt;/a&gt;&lt;/h2&gt;</summary>
    
    
    
    <category term="安全" scheme="http://example.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="安全" scheme="http://example.com/tags/%E5%AE%89%E5%85%A8/"/>
    
    <category term="证书" scheme="http://example.com/tags/%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Git常见问题</title>
    <link href="http://example.com/2021/12/18/Git/Git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/12/18/Git/Git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2021-12-18T10:04:28.000Z</published>
    <updated>2021-12-22T06:03:57.107Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="git-pull-和-git-fetch-的区别"><a href="#git-pull-和-git-fetch-的区别" class="headerlink" title="git pull 和 git fetch 的区别"></a>git pull 和 git fetch 的区别</h2><pre><code class="BASH">git fetch 只是将远程仓库的变化下载下来，并没有和本地分支合并。git pull 会将远程仓库的变化下载下来，并和当前分支合并。</code></pre><h2 id="git-rebase-和-git-merge-的区别"><a href="#git-rebase-和-git-merge-的区别" class="headerlink" title="git rebase 和 git merge 的区别"></a>git rebase 和 git merge 的区别</h2><pre><code class="BASH">git merge 和 git rebase 都是用于分支合并，关键在 commit 记录的处理上不同。git merge 会新建一个新的 commit 对象，然后两个分支以前的 commit 记录都指向这个新 commit 记录。这种方法会保留之前每个分支的 commit 历史。git rebase 会先找到两个分支的第一个共同的 commit 祖先记录，然后将提取当前分支这之后的所有 commit 记录，然后将这个 commit 记录添加到目标分支的最新提交后面。经过这个合并后，两个分支合并后的 commit 记录就变为了线性的记录了。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;git-pull-和-git-fetch-的区别&quot;&gt;&lt;a href=&quot;#git-pull-和-git-fetch-的区别&quot; class=&quot;headerlink&quot; title=&quot;git pull 和 git fetch 的区别&quot;</summary>
      
    
    
    
    <category term="git" scheme="http://example.com/categories/git/"/>
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>面试总结-JavaScript篇</title>
    <link href="http://example.com/2021/12/07/JavaScript/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/12/07/JavaScript/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</id>
    <published>2021-12-07T17:22:55.000Z</published>
    <updated>2021-12-22T06:03:57.112Z</updated>
    
    <content type="html"><![CDATA[<p>本章节是<a href="https://github.com/h5bp/Front-end-Developer-Interview-Questions/blob/master/src/questions/javascript-questions.md">前端开发者面试问题 - JS 部分</a>的参考答案。 欢迎提出 PR 进行建议和指正！</p><a id="more"></a><h2 id="请简述JavaScript中的this。​"><a href="#请简述JavaScript中的this。​" class="headerlink" title="请简述JavaScript中的this。​"></a>请简述JavaScript中的this。​</h2><p>JS 中的<code>this</code>是一个相对复杂的概念，不是简单几句能解释清楚的。粗略地讲，函数的调用方式决定了<code>this</code>的值。我阅读了网上很多关于<code>this</code>的文章，<a href="https://medium.com/@arnav_aggarwal">Arnav Aggrawal</a> 写的比较清楚。this取值符合以下规则：</p><ol><li> 在调用函数时使用new关键字，函数内的this是一个全新的对象。</li><li> 如果<code>apply</code>、<code>call</code>或<code>bind</code>方法用于调用、创建一个函数，函数内的 <code>this</code> 就是作为参数传入这些方法的对象。</li><li> 当函数作为对象里的方法被调用时，函数内的this是调用该函数的对象。比如当<code>obj.method()</code>被调用时，函数内的 <code>this</code> 将绑定到obj对象。</li><li> 如果调用函数不符合上述规则，那么this的值指向全局对象（<code>global object</code>）。浏览器环境下this的值指向window对象，但是在严格模式下(<code>'use strict'</code>)，<code>this</code>的值为<code>undefined</code>。</li><li> 如果符合上述多个规则，则较高的规则（1 号最高，4 号最低）将决定<code>this</code>的值。</li><li> 如果该函数是 ES2015 中的箭头函数，将忽略上面的所有规则，<code>this</code>被设置为它被创建时的上下文。</li></ol><h2 id="Object-is-与原来的比较操作符-“-”、“-”-的区别？"><a href="#Object-is-与原来的比较操作符-“-”、“-”-的区别？" class="headerlink" title="Object.is() 与原来的比较操作符 “===”、“==” 的区别？"></a>Object.is() 与原来的比较操作符 “===”、“==” 的区别？</h2><pre><code class="JS">两等号判等，会在比较时进行类型转换。三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回false）。Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true.Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。</code></pre><h2 id="介绍一下-js-的节流与防抖？"><a href="#介绍一下-js-的节流与防抖？" class="headerlink" title="介绍一下 js 的节流与防抖？"></a>介绍一下 js 的节流与防抖？</h2><pre><code class="JS">// 函数防抖： 在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。// 函数节流： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。// 函数防抖的实现function debounce(fn, wait) {  var timer = null;  return function() {    var context = this,      args = arguments;    // 如果此时存在定时器的话，则取消之前的定时器重新记时    if (timer) {      clearTimeout(timer);      timer = null;    }    // 设置定时器，使事件间隔指定事件后执行    timer = setTimeout(() =&gt; {      fn.apply(context, args);    }, wait);  };}// 函数节流的实现;function throttle(fn, delay) {  var preTime = Date.now();  return function() {    var context = this,      args = arguments,      nowTime = Date.now();    // 如果两次时间间隔超过了指定时间，则执行函数。    if (nowTime - preTime &gt;= delay) {      preTime = Date.now();      return fn.apply(context, args);    }  };}</code></pre><h2 id="escape-encodeURI-encodeURIComponent-有什么区别？"><a href="#escape-encodeURI-encodeURIComponent-有什么区别？" class="headerlink" title="escape,encodeURI,encodeURIComponent 有什么区别？"></a>escape,encodeURI,encodeURIComponent 有什么区别？</h2><pre><code class="JS">encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。</code></pre><h2 id="js-的事件循环是什么？"><a href="#js-的事件循环是什么？" class="headerlink" title="js 的事件循环是什么？"></a>js 的事件循环是什么？</h2><h3 id="相关知识点："><a href="#相关知识点：" class="headerlink" title="相关知识点："></a>相关知识点：</h3><pre><code>  事件队列是一个存储着待执行任务的队列，其中的任务严格按照时间先后顺序执行，排在队头的任务将会率先执行，而排在队尾的任务会最后执行。事件队列每次仅执行一个任务，在该任务执行完毕之后，再执行下一个任务。执行栈则是一个类似于函数调用栈的运行容器，当执行栈为空时，JS 引擎便检查事件队列，如果不为空的话，事件队列便将第一个任务压入执行栈中运行。</code></pre><h3 id="回答："><a href="#回答：" class="headerlink" title="回答："></a>回答：</h3><blockquote><p>因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</p></blockquote><blockquote><p>微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。</p></blockquote><blockquote><p>宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。</p></blockquote><h2 id="js-中的深浅拷贝实现？"><a href="#js-中的深浅拷贝实现？" class="headerlink" title="js 中的深浅拷贝实现？"></a>js 中的深浅拷贝实现？</h2><pre><code class="JS">// 浅拷贝的实现;function shallowCopy(object) {  // 只拷贝对象  if (!object || typeof object !== "object") return;  // 根据 object 的类型判断是新建一个数组还是对象  let newObject = Array.isArray(object) ? [] : {};  // 遍历 object，并且判断是 object 的属性才拷贝  for (let key in object) {    if (object.hasOwnProperty(key)) {      newObject[key] = object[key];    }  }  return newObject;}// 深拷贝的实现;function deepCopy(object) {  if (!object || typeof object !== "object") return object;  let newObject = Array.isArray(object) ? [] : {};  for (let key in object) {    if (object.hasOwnProperty(key)) {      newObject[key] = deepCopy(object[key]);    }  }  return newObject;}</code></pre><h3 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h3><blockquote><p>浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用  Object.assign 和展开运算符来实现。深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。</p></blockquote><h2 id="手写-call、apply-及-bind-函数"><a href="#手写-call、apply-及-bind-函数" class="headerlink" title="手写 call、apply 及 bind 函数"></a>手写 call、apply 及 bind 函数</h2><pre><code class="JS">// call函数实现Function.prototype.myCall = function(context) {  // 判断调用对象  if (typeof this !== "function") {    console.error("type error");  }  // 获取参数  let args = [...arguments].slice(1),    result = null;  // 判断 context 是否传入，如果未传入则设置为 window  context = context || window;  // 将调用函数设为对象的方法  context.fn = this;  // 调用函数  result = context.fn(...args);  // 将属性删除  delete context.fn;  return result;};// apply 函数实现Function.prototype.myApply = function(context) {  // 判断调用对象是否为函数  if (typeof this !== "function") {    throw new TypeError("Error");  }  let result = null;  // 判断 context 是否存在，如果未传入则为 window  context = context || window;  // 将函数设为对象的方法  context.fn = this;  // 调用方法  if (arguments[1]) {    result = context.fn(...arguments[1]);  } else {    result = context.fn();  }  // 将属性删除  delete context.fn;  return result;};// bind 函数实现Function.prototype.myBind = function(context) {  // 判断调用对象是否为函数  if (typeof this !== "function") {    throw new TypeError("Error");  }  // 获取参数  var args = [...arguments].slice(1),    fn = this;  return function Fn() {    // 根据调用方式，传入不同绑定值    return fn.apply(      this instanceof Fn ? this : context,      args.concat(...arguments)    );  };};</code></pre><h2 id="函数柯里化的实现"><a href="#函数柯里化的实现" class="headerlink" title="函数柯里化的实现"></a>函数柯里化的实现</h2><pre><code class="JS">// 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。function curry(fn, args) {  // 获取函数需要的参数长度  let length = fn.length;  args = args || [];  return function() {    let subArgs = args.slice(0);    // 拼接得到现有的所有参数    for (let i = 0; i &lt; arguments.length; i++) {      subArgs.push(arguments[i]);    }    // 判断参数的长度是否已经满足函数所需参数的长度    if (subArgs.length &gt;= length) {      // 如果满足，执行函数      return fn.apply(this, subArgs);    } else {      // 如果不满足，递归返回科里化的函数，等待参数的传入      return curry.call(this, fn, subArgs);    }  };}// es6 实现function curry(fn, ...args) {  return fn.length &lt;= args.length ? fn(...args) : curry.bind(null, fn, ...args);}</code></pre><h2 id="什么是-XSS-攻击？如何防范-XSS-攻击？"><a href="#什么是-XSS-攻击？如何防范-XSS-攻击？" class="headerlink" title="什么是 XSS 攻击？如何防范 XSS 攻击？"></a>什么是 XSS 攻击？如何防范 XSS 攻击？</h2><pre><code>XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。XSS 一般分为存储型、反射型和 DOM 型。存储型指的是恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为 HTML 后返回给了用户，从而导致了恶意代码的执行。反射型指的是攻击者构建了特殊的 URL，当服务器接收到请求后，从 URL 中获取数据，拼接到 HTML 后返回，从而导致了恶意代码的执行。DOM 型指的是攻击者构建了特殊的 URL，用户打开网站后，js 脚本从 URL 中获取数据，从而导致了恶意代码的执行。XSS 攻击的预防可以从两个方面入手，一个是恶意代码提交的时候，一个是浏览器执行恶意代码的时候。对于第一个方面，如果我们对存入数据库的数据都进行的转义处理，但是一个数据可能在多个地方使用，有的地方可能不需要转义，由于我们没有办法判断数据最后的使用场景，所以直接在输入端进行恶意代码的处理，其实是不太可靠的。因此我们可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，我们对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。还有一些方式，比如使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。还可以对一些敏感信息进行保护，比如 cookie 使用 http-only ，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。</code></pre><h2 id="什么是-CSP？"><a href="#什么是-CSP？" class="headerlink" title="什么是 CSP？"></a>什么是 CSP？</h2><pre><code class="HTML">CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 &lt;meta http-equiv="Content-Security-Policy"&gt; &lt;/meta&gt;</code></pre><h2 id="什么是-CSRF-攻击？如何防范-CSRF-攻击？"><a href="#什么是-CSRF-攻击？如何防范-CSRF-攻击？" class="headerlink" title="什么是 CSRF 攻击？如何防范 CSRF 攻击？"></a>什么是 CSRF 攻击？如何防范 CSRF 攻击？</h2><pre><code>CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。CSRF 攻击的本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。一般的 CSRF 攻击类型有三种：第一种是 GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。第二种是 POST 类型的 CSRF 攻击，比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。第三种是链接类型的 CSRF 攻击，比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。CSRF 可以用下面几种方法来防护：第一种是同源检测的方法，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。第二种方法是使用 CSRF Token 来进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。第三种方式使用双重 Cookie 验证的办法，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。第四种方式是使用在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</code></pre><h2 id="什么是-Samesite-Cookie-属性？"><a href="#什么是-Samesite-Cookie-属性？" class="headerlink" title="什么是 Samesite Cookie 属性？"></a>什么是 Samesite Cookie 属性？</h2><pre><code>Samesite Cookie 表示同站 cookie，避免 cookie 被第三方所利用。将 Samesite 设为 strict ，这种称为严格模式，表示这个 cookie 在任何情况下都不可能作为第三方 cookie。将 Samesite 设为 Lax ，这种模式称为宽松模式，如果这个请求是个 GET 请求，并且这个请求改变了当前页面或者打开了新的页面，那么这个 cookie 可以作为第三方 cookie，其余情况下都不能作为第三方 cookie。使用这种方法的缺点是，因为它不支持子域，所以子域没有办法与主域共享登录信息，每次转入子域的网站，都回重新登录。还有一个问题就是它的兼容性不够好。</code></pre><h2 id="什么是点击劫持？如何防范点击劫持？"><a href="#什么是点击劫持？如何防范点击劫持？" class="headerlink" title="什么是点击劫持？如何防范点击劫持？"></a>什么是点击劫持？如何防范点击劫持？</h2><pre><code>点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。我们可以在 http 相应头中设置 X-FRAME-OPTIONS 来防御用 iframe 嵌套的点击劫持攻击。通过不同的值，可以规定页面在特定的一些情况才能作为 iframe 来使用。</code></pre><h2 id="什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？"><a href="#什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？" class="headerlink" title="什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？"></a>什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</h2><pre><code>我对 Virtual DOM 的理解是，首先对我们将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后我们将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。当页面的状态发生改变，我们需要对页面的 DOM 的结构进行调整的时候，我们首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。我认为 Virtual DOM 这种方法对于我们需要有大量的 DOM 操作的时候，能够很好的提高我们的操作效率，通过在操作前确定需要做的最小修改，尽可能的减少 DOM 操作带来的重流和重绘的影响。其实 Virtual DOM 并不一定比我们真实的操作 DOM 要快，这种方法的目的是为了提高我们开发时的可维护性，在任意的情况下，都能保证一个尽量小的性能消耗去进行操作。</code></pre><h2 id="如何比较两个-DOM-树的差异？"><a href="#如何比较两个-DOM-树的差异？" class="headerlink" title="如何比较两个 DOM 树的差异？"></a>如何比较两个 DOM 树的差异？</h2><pre><code>两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)。算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样我们才能够复用老的 DOM 树上的节点。</code></pre><h2 id="URL-和-URI-的区别？"><a href="#URL-和-URI-的区别？" class="headerlink" title="URL 和 URI 的区别？"></a>URL 和 URI 的区别？</h2><pre><code>URI: Uniform Resource Identifier      指的是统一资源标识符URL: Uniform Resource Location        指的是统一资源定位符URN: Universal Resource Name          指的是统一资源名称URI 指的是统一资源标识符，用唯一的标识来确定一个资源，它是一种抽象的定义，也就是说，不管使用什么方法来定义，只要能唯一的标识一个资源，就可以称为 URI。URL 指的是统一资源定位符，URN 指的是统一资源名称。URL 和 URN 是 URI 的子集，URL 可以理解为使用地址来标识资源，URN 可以理解为使用名称来标识资源。</code></pre><h2 id="let-和-const-的注意点？"><a href="#let-和-const-的注意点？" class="headerlink" title="let 和 const 的注意点？"></a>let 和 const 的注意点？</h2><ol><li> 声明的变量只在声明时的代码块内有效</li><li> 不存在声明提升</li><li> 存在暂时性死区，如果在变量声明前使用，会报错</li><li> 不允许重复声明，重复声明会报错</li></ol><h2 id="require-模块引入的查找方式？"><a href="#require-模块引入的查找方式？" class="headerlink" title="require 模块引入的查找方式？"></a>require 模块引入的查找方式？</h2><pre><code>当 Node 遇到 require(X) 时，按下面的顺序处理。（1）如果 X 是内置模块（比如 require('http')）　　a. 返回该模块。　　b. 不再继续执行。（2）如果 X 以 "./" 或者 "/" 或者 "../" 开头　　a. 根据 X 所在的父模块，确定 X 的绝对路径。　　b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。    X    X.js    X.json    X.node　　c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。    X/package.json（main字段）    X/index.js    X/index.json    X/index.node（3）如果 X 不带路径　　a. 根据 X 所在的父模块，确定 X 可能的安装目录。　　b. 依次在每个目录中，将 X 当成文件名或目录名加载。（4）抛出 "not found"</code></pre><h2 id="手写一个-Promise"><a href="#手写一个-Promise" class="headerlink" title="手写一个 Promise"></a>手写一个 Promise</h2><pre><code class="JS">const PENDING = "pending";const RESOLVED = "resolved";const REJECTED = "rejected";function MyPromise(fn) {  // 保存初始化状态  var self = this;  // 初始化状态  this.state = PENDING;  // 用于保存 resolve 或者 rejected 传入的值  this.value = null;  // 用于保存 resolve 的回调函数  this.resolvedCallbacks = [];  // 用于保存 reject 的回调函数  this.rejectedCallbacks = [];  // 状态转变为 resolved 方法  function resolve(value) {    // 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变    if (value instanceof MyPromise) {      return value.then(resolve, reject);    }    // 保证代码的执行顺序为本轮事件循环的末尾    setTimeout(() =&gt; {      // 只有状态为 pending 时才能转变，      if (self.state === PENDING) {        // 修改状态        self.state = RESOLVED;        // 设置传入的值        self.value = value;        // 执行回调函数        self.resolvedCallbacks.forEach(callback =&gt; {          callback(value);        });      }    }, 0);  }  // 状态转变为 rejected 方法  function reject(value) {    // 保证代码的执行顺序为本轮事件循环的末尾    setTimeout(() =&gt; {      // 只有状态为 pending 时才能转变      if (self.state === PENDING) {        // 修改状态        self.state = REJECTED;        // 设置传入的值        self.value = value;        // 执行回调函数        self.rejectedCallbacks.forEach(callback =&gt; {          callback(value);        });      }    }, 0);  }  // 将两个方法传入函数执行  try {    fn(resolve, reject);  } catch (e) {    // 遇到错误时，捕获错误，执行 reject 函数    reject(e);  }}MyPromise.prototype.then = function(onResolved, onRejected) {  // 首先判断两个参数是否为函数类型，因为这两个参数是可选参数  onResolved =    typeof onResolved === "function"      ? onResolved      : function(value) {          return value;        };  onRejected =    typeof onRejected === "function"      ? onRejected      : function(error) {          throw error;        };  // 如果是等待状态，则将函数加入对应列表中  if (this.state === PENDING) {    this.resolvedCallbacks.push(onResolved);    this.rejectedCallbacks.push(onRejected);  }  // 如果状态已经凝固，则直接执行对应状态的函数  if (this.state === RESOLVED) {    onResolved(this.value);  }  if (this.state === REJECTED) {    onRejected(this.value);  }};</code></pre><h2 id="开发中常用的几种-Content-Type-？"><a href="#开发中常用的几种-Content-Type-？" class="headerlink" title="开发中常用的几种 Content-Type ？"></a>开发中常用的几种 Content-Type ？</h2><pre><code>（1）application/x-www-form-urlencoded浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。（2）multipart/form-data该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。（3）application/json告诉服务器消息主体是序列化后的 JSON 字符串。（4）text/xml该种方式主要用来提交 XML 格式的数据。</code></pre><h2 id="如何封装一个-javascript-的类型判断函数？"><a href="#如何封装一个-javascript-的类型判断函数？" class="headerlink" title="如何封装一个 javascript 的类型判断函数？"></a>如何封装一个 javascript 的类型判断函数？</h2><pre><code class="JS">function getType(value) {  // 判断数据是 null 的情况  if (value === null) {    return value + "";  }  // 判断数据是引用类型的情况  if (typeof value === "object") {    let valueClass = Object.prototype.toString.call(value),      type = valueClass.split(" ")[1].split("");    type.pop();    return type.join("").toLowerCase();  } else {    // 判断数据是基本数据类型的情况和函数的情况    return typeof value;  }}</code></pre><h2 id="如何判断一个对象是否为空对象？"><a href="#如何判断一个对象是否为空对象？" class="headerlink" title="如何判断一个对象是否为空对象？"></a>如何判断一个对象是否为空对象？</h2><pre><code class="JS">function checkNullObj(obj) {  return Object.keys(obj).length === 0 &amp;&amp; Object.getOwnPropertySymbols(obj).length === 0;}</code></pre><h2 id="手写一个观察者模式？"><a href="#手写一个观察者模式？" class="headerlink" title="手写一个观察者模式？"></a>手写一个观察者模式？</h2><pre><code class="JS">var events = (function() {  var topics = {};  return {    // 注册监听函数    subscribe: function(topic, handler) {      if (!topics.hasOwnProperty(topic)) {        topics[topic] = [];      }      topics[topic].push(handler);    },    // 发布事件，触发观察者回调事件    publish: function(topic, info) {      if (topics.hasOwnProperty(topic)) {        topics[topic].forEach(function(handler) {          handler(info);        });      }    },    // 移除主题的一个观察者的回调事件    remove: function(topic, handler) {      if (!topics.hasOwnProperty(topic)) return;      var handlerIndex = -1;      topics[topic].forEach(function(item, index) {        if (item === handler) {          handlerIndex = index;        }      });      if (handlerIndex &gt;= 0) {        topics[topic].splice(handlerIndex, 1);      }    },    // 移除主题的所有观察者的回调事件    removeAll: function(topic) {      if (topics.hasOwnProperty(topic)) {        topics[topic] = [];      }    }  };})();</code></pre><h2 id="EventEmitter-实现"><a href="#EventEmitter-实现" class="headerlink" title="EventEmitter 实现"></a>EventEmitter 实现</h2><pre><code class="JS">class EventEmitter {  constructor() {    this.events = {};  }  on(event, callback) {    let callbacks = this.events[event] || [];    callbacks.push(callback);    this.events[event] = callbacks;    return this;  }  off(event, callback) {    let callbacks = this.events[event];    this.events[event] = callbacks &amp;&amp; callbacks.filter(fn =&gt; fn !== callback);    return this;  }  emit(event, ...args) {    let callbacks = this.events[event];    callbacks.forEach(fn =&gt; {      fn(...args);    });    return this;  }  once(event, callback) {    let wrapFun = (...args) =&gt; {      callback(...args);      this.off(event, wrapFun);    };    this.on(event, wrapFun);    return this;  }}</code></pre><h2 id="如何确定页面的可用性时间，什么是-Performance-API？"><a href="#如何确定页面的可用性时间，什么是-Performance-API？" class="headerlink" title="如何确定页面的可用性时间，什么是 Performance API？"></a>如何确定页面的可用性时间，什么是 Performance API？</h2><pre><code>Performance API 用于精确度量、控制、增强浏览器的性能表现。这个 API 为测量网站性能，提供以前没有办法做到的精度。使用 getTime 来计算脚本耗时的缺点，首先，getTime方法（以及 Date 对象的其他方法）都只能精确到毫秒级别（一秒的千分之一），想要得到更小的时间差别就无能为力了。其次，这种写法只能获取代码运行过程中的时间进度，无法知道一些后台事件的时间进度，比如浏览器用了多少时间从服务器加载网页。为了解决这两个不足之处，ECMAScript 5引入“高精度时间戳”这个 API，部署在 performance 对象上。它的精度可以达到1毫秒的千分之一（1秒的百万分之一）。navigationStart：当前浏览器窗口的前一个网页关闭，发生 unload 事件时的 Unix 毫秒时间戳。如果没有前一个网页，则等于 fetchStart 属性。loadEventEnd：返回当前网页 load 事件的回调函数运行结束时的 Unix 毫秒时间戳。如果该事件还没有发生，返回 0。</code></pre><p>根据上面这些属性，可以计算出网页加载各个阶段的耗时。比如，网页加载整个过程的耗时的计算方法如下：</p><pre><code class="JS">var t = performance.timing;var pageLoadTime = t.loadEventEnd - t.navigationStart;</code></pre><p>详细资料可以参考： <a href="http://javascript.ruanyifeng.com/bom/performance.html">《Performance API》</a></p><h2 id="Math-ceil-和-Math-floor"><a href="#Math-ceil-和-Math-floor" class="headerlink" title="Math.ceil 和 Math.floor"></a>Math.ceil 和 Math.floor</h2><pre><code class="JS">Math.ceil() === 向上取整，函数返回一个大于或等于给定数字的最小整数。Math.floor() === 向下取整，函数返回一个小于或等于给定数字的最大整数。</code></pre><h2 id="js-for-循环注意点"><a href="#js-for-循环注意点" class="headerlink" title="js for 循环注意点"></a>js for 循环注意点</h2><pre><code class="JS">for (var i = 0, j = 0; i &lt; 5, j &lt; 9; i++, j++) {  console.log(i, j);}// 当判断语句含有多个语句时，以最后一个判断语句的值为准，因此上面的代码会执行 10 次。// 当判断语句为空时，循环会一直进行。</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;本章节是&lt;a href=&quot;https://github.com/h5bp/Front-end-Developer-Interview-Questions/blob/master/src/questions/javascript-questions.md&quot;&gt;前端开发者面试问题 - JS 部分&lt;/a&gt;的参考答案。 欢迎提出 PR 进行建议和指正！&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>面试总结-CSS篇</title>
    <link href="http://example.com/2021/12/06/css/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/12/06/css/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</id>
    <published>2021-12-06T11:43:58.000Z</published>
    <updated>2021-12-22T06:03:57.117Z</updated>
    
    <content type="html"><![CDATA[<p>本章节是<a href="https://github.com/h5bp/Front-end-Developer-Interview-Questions/blob/master/src/questions/css-questions.md">前端开发者面试问题 - CSS 部分</a>的参考答案。 欢迎提出 PR 进行建议和指正！</p><a id="more"></a><h2 id="有哪些清除浮动的技术，都适用哪些情况？​"><a href="#有哪些清除浮动的技术，都适用哪些情况？​" class="headerlink" title="有哪些清除浮动的技术，都适用哪些情况？​"></a>有哪些清除浮动的技术，都适用哪些情况？​</h2><ul><li>空div方法：<code>&lt;div style="clear:both;"&gt;&lt;/div&gt;</code>。</li><li>Clearfix 方法：上文使用<code>.clearfix</code>类已经提到。</li><li><code>overflow: auto</code>或<code>overflow: hidden</code>方法：上文已经提到。</li><li>在大型项目中，我会使用 Clearfix 方法，在需要的地方使用<code>.clearfix</code>。<br>设置<code>overflow: hidden</code>的方法可能使其子元素显示不完整，当子元素的高度大于父元素时。</li></ul><h2 id="如何解决不同浏览器的样式兼容性问题？​"><a href="#如何解决不同浏览器的样式兼容性问题？​" class="headerlink" title="如何解决不同浏览器的样式兼容性问题？​"></a>如何解决不同浏览器的样式兼容性问题？​</h2><ul><li>在确定问题原因和有问题的浏览器后，使用单独的样式表，仅供出现问题的浏览器加载。这种方法需要使用服务器端渲染。</li><li>使用已经处理好此类问题的库，比如 Bootstrap。</li><li>使用 <code>autoprefixer</code> 自动生成 CSS 属性前缀。<br>使用 <a href="http://meyerweb.com/eric/tools/css/reset/">Reset CSS</a> 或 <a href="https://necolas.github.io/normalize.css/">Normalize.css</a>。</li></ul><h2 id="有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？​"><a href="#有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？​" class="headerlink" title="有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？​"></a>有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？​</h2><ul><li><code>width: 0; height: 0</code>：使元素不占用屏幕上的任何空间，导致不显示它。</li><li><code>position: absolute; left: -99999px</code>： 将它置于屏幕之外。</li><li><code>text-indent: -9999px</code>：这只适用于<code>block</code>元素中的文本。</li><li>Metadata： 例如通过使用 Schema.org，RDF 和 JSON-LD。</li><li>WAI-ARIA：如何增加网页可访问性的 W3C 技术规范。<br>即使 WAI-ARIA 是理想的解决方案，我也会采用<code>绝对定位</code>方法，因为它具有最少的注意事项，适用于大多数元素，而且使用起来非常简单。</li></ul><h2 id="什么情况下，用translate-而不用绝对定位？什么时候，情况相反。​"><a href="#什么情况下，用translate-而不用绝对定位？什么时候，情况相反。​" class="headerlink" title="什么情况下，用translate()而不用绝对定位？什么时候，情况相反。​"></a>什么情况下，用translate()而不用绝对定位？什么时候，情况相反。​</h2><ul><li><code>translate()</code>是<code>transform</code>的一个值。改变<code>transform</code>或<code>opacity</code>不会触发浏览器重新布局（<code>reflow</code>）或重绘（<code>repaint</code>），只会触发复合（<code>compositions</code>）。而改变绝对定位会触发重新布局，进而触发重绘和复合。</li><li><code>transform</code>使浏览器为元素创建一个 GPU 图层，但改变绝对定位会使用到 CPU。 因此<code>translate()</code>更高效，可以缩短平滑动画的绘制时间。</li></ul><p>当使用<code>translate()</code>时，元素仍然占据其原始空间（有点像<code>position：relative</code>），这与改变绝对定位不同。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本章节是&lt;a href=&quot;https://github.com/h5bp/Front-end-Developer-Interview-Questions/blob/master/src/questions/css-questions.md&quot;&gt;前端开发者面试问题 - CSS 部分&lt;/a&gt;的参考答案。 欢迎提出 PR 进行建议和指正！&lt;/p&gt;</summary>
    
    
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>面试总结-HTML篇</title>
    <link href="http://example.com/2021/12/06/HTML/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/12/06/HTML/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</id>
    <published>2021-12-06T09:47:29.000Z</published>
    <updated>2021-12-22T06:03:57.109Z</updated>
    
    <content type="html"><![CDATA[<p>本章节是<a href="https://frontendinterviewhandbook.com/zh/html-questions/">前端开发者面试问题 - HTML</a> 部分的参考答案。 欢迎提出 PR 进行建议和指正！</p><a id="more"></a><h2 id="DOCTYPE有什么用？"><a href="#DOCTYPE有什么用？" class="headerlink" title="DOCTYPE有什么用？"></a>DOCTYPE有什么用？</h2><p>在页面开始处添加<code>&lt;!DOCTYPE html&gt;</code>即可。</p><h2 id="如何提供包含多种语言内容的页面？"><a href="#如何提供包含多种语言内容的页面？" class="headerlink" title="如何提供包含多种语言内容的页面？"></a>如何提供包含多种语言内容的页面？</h2><ol><li> HTML 文档还应在<code>&lt;html&gt;</code>标签中声明<code>lang</code>属性，比如<code>&lt;html lang="en"&gt;...&lt;/html&gt;</code></li><li> 客户端向服务器发送 <code>HTTP</code> 请求时，通常会发送有关语言首选项的信息，比如使用<code>Accept-Language</code>请求头</li></ol><h2 id="在设计开发多语言网站时，需要留心哪些事情？"><a href="#在设计开发多语言网站时，需要留心哪些事情？" class="headerlink" title="在设计开发多语言网站时，需要留心哪些事情？"></a>在设计开发多语言网站时，需要留心哪些事情？</h2><ol><li> 引导用户切换到自己的母语，在 HTML 中使用<code>lang</code>属性</li><li> 限制词语或句子的长度</li><li> 不要使用连接的翻译字符串，这样做可能会打乱其他语言的语序，应该为每种语言编写带变量替换的模版字符串。<code>I will travel on {% date %}</code>和<code>{% date %}</code> 我会出发。</li></ol><h2 id="请描述-lt-script-gt-、-lt-script-async-gt-和-lt-script-defer-gt-的区别。"><a href="#请描述-lt-script-gt-、-lt-script-async-gt-和-lt-script-defer-gt-的区别。" class="headerlink" title="请描述<script>、<script async>和<script defer>的区别。"></a>请描述<code>&lt;script&gt;</code>、<code>&lt;script async&gt;</code>和<code>&lt;script defer&gt;</code>的区别。</h2><ol><li> <code>&lt;script&gt;</code> - HTML 解析中断，脚本被提取并立即执行。执行结束后，HTML 解析继续。</li><li> <code>&lt;script async&gt;</code> - 脚本的提取、执行的过程与 HTML 解析过程并行，脚本执行完毕可能在 HTML 解析完毕之前。当脚本与页面上其他脚本独立时，可以使用async，比如用作页面统计分析。</li><li> <code>&lt;script defer&gt;</code> - 脚本仅提取过程与 HTML 解析过程并行，脚本的执行将在 HTML 解析完毕后进行。如果有多个含defer的脚本，脚本的执行顺序将按照在 document 中出现的位置，从上到下顺序执行。</li></ol><p>注意：没有<code>src</code>属性的脚本，<code>async</code>和<code>defer</code>属性会被忽略。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本章节是&lt;a href=&quot;https://frontendinterviewhandbook.com/zh/html-questions/&quot;&gt;前端开发者面试问题 - HTML&lt;/a&gt; 部分的参考答案。 欢迎提出 PR 进行建议和指正！&lt;/p&gt;</summary>
    
    
    
    <category term="HTML" scheme="http://example.com/categories/HTML/"/>
    
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>使用 CURL 上传文件</title>
    <link href="http://example.com/2021/06/23/Linux/shell/%E8%AF%B7%E6%B1%82/%E4%BD%BF%E7%94%A8%20CURL%20%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2021/06/23/Linux/shell/%E8%AF%B7%E6%B1%82/%E4%BD%BF%E7%94%A8%20CURL%20%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/</id>
    <published>2021-06-23T16:30:40.000Z</published>
    <updated>2021-12-22T06:03:57.115Z</updated>
    
    <content type="html"><![CDATA[<p>CURL 是一个强大的向服务器发送请求的工具， 尤其是在测试 API 的时候。</p><a id="more"></a><p>很多人像寻常表单一样使用了 <code>-X POST</code> 方式来使用 CURL 去上传文件，但实际上这是错误的。<br>正确的方式是使用 <strong>-F (–form)</strong> 来上传文件，这样才会给请求添加 enctype=<code>"multipart/form-data"</code> 参数。</p><pre><code class="BASH">curl -F 'data=@path/to/local/file’ UPLOAD_ADDRES</code></pre><p>例如， 如果我想向服务器 <code>http://localhost/upload</code> 上传位于<code>/home/petehouston/hello.txt</code>的文件，并将上传的文件的参数命名为 <code>img_avatar</code>, 我可以这样发送请求,</p><pre><code class="BASH">curl -F 'img_avatar=@/home/petehouston/hello.txt' http://localhost/upload</code></pre><h2 id="上传多个文件"><a href="#上传多个文件" class="headerlink" title="上传多个文件"></a>上传多个文件</h2><p>想要同时上传多个文件的话，只需要添加多个 -F 选项就可以了。</p><pre><code class="BASH">curl -F 'fileX=@/path/to/fileX' -F 'fileY=@/path/to/fileY' ... http://localhost/upload</code></pre><h2 id="上传文件数组"><a href="#上传文件数组" class="headerlink" title="上传文件数组"></a>上传文件数组</h2><pre><code class="BASH">curl -F 'files[]=@/path/to/fileX' -F 'files[]=@/path/to/fileY' ... http://localhost/upload</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;CURL 是一个强大的向服务器发送请求的工具， 尤其是在测试 API 的时候。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="shell" scheme="http://example.com/tags/shell/"/>
    
    <category term="curl" scheme="http://example.com/tags/curl/"/>
    
    <category term="上传文件" scheme="http://example.com/tags/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>电商-商品设计</title>
    <link href="http://example.com/2021/04/26/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%94%B5%E5%95%86-%E5%95%86%E5%93%81%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2021/04/26/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%94%B5%E5%95%86-%E5%95%86%E5%93%81%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-04-26T16:27:08.000Z</published>
    <updated>2021-12-22T06:03:57.125Z</updated>
    
    <content type="html"><![CDATA[<p>电商数据库设计之商品设计。</p><a id="more"></a><p><img src="/My-Blogs/images/%E7%94%B5%E5%95%86-%E5%95%86%E5%93%81%E8%AE%BE%E8%AE%A1.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;电商数据库设计之商品设计。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="电商" scheme="http://example.com/tags/%E7%94%B5%E5%95%86/"/>
    
  </entry>
  
  <entry>
    <title>screen 常用命令</title>
    <link href="http://example.com/2021/04/25/Linux/shell/%E7%AA%97%E5%8F%A3/screen%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2021/04/25/Linux/shell/%E7%AA%97%E5%8F%A3/screen%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2021-04-25T21:49:24.000Z</published>
    <updated>2021-12-22T06:03:57.115Z</updated>
    
    <content type="html"><![CDATA[<p>screen 常用命令介绍</p><a id="more"></a><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><pre><code class="BASH">screen -ls              # 查看所有screenscreen -S &lt;screen-name&gt; # 创建screen，并命名ctr + A, D              # 快捷键，退出当前screenscreen -r &lt;screen-name&gt; # 进入screenscreen -X quit          # 删除screen，但没有指定会话screen -X -S [session you want to kill] quit #删除screen，指定会话screen -wipe            # 清除dead screens</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;screen 常用命令介绍&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="shell" scheme="http://example.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>在nest中使用typeorm-model-generator自动生成实体</title>
    <link href="http://example.com/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93/TypeOrm/%E5%9C%A8nest%E4%B8%AD%E4%BD%BF%E7%94%A8typeorm-model-generator%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%AE%9E%E4%BD%93/"/>
    <id>http://example.com/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93/TypeOrm/%E5%9C%A8nest%E4%B8%AD%E4%BD%BF%E7%94%A8typeorm-model-generator%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%AE%9E%E4%BD%93/</id>
    <published>2021-04-21T12:35:23.000Z</published>
    <updated>2021-12-22T06:03:57.125Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下nestjs框架使用typeorm自动生成实体类的方法。可以节省一些开发时间</p><a id="more"></a><ol><li><p><code>npm i -g typeorm-model-generator</code> 或者 <code>yarn global add typeorm-model-generator</code></p></li><li><p>修改项目中的 <code>package.json</code> 文件  </p><pre><code class="json">"scripts": {"db": "rimraf ./src/modules/entities &amp; npx typeorm-model-generator -h 121.36.70.68 -d chat -p 3306 -u root -x 123456 -e mysql -o ./src/modules/entities --noConfig true --ce pascal --cp camel"}</code></pre><ul><li><code>rm -rf entities</code>表示先删除文件夹<code>entities（window下使用 rimraf entities ）</code></li><li><code>npx typeorm-model-generator</code>如果全局安装了就不需要加npx没有全局安装就加上去</li><li><code>-h localhost -d 数据库名字 -p 端口 -u 用户名 -x 密码 -e 数据库类型</code></li><li><code>-o entities</code>表示输出到指定的文件夹</li><li><code>--noConfig true</code>表示不生成<code>ormconfig.json</code>和<code>tsconfig.json</code>文件</li><li><code>--ce pascal</code>表示将类名转换首字母是大写的驼峰命名</li><li><code>--cp camel</code>表示将数据库中的字段比如create_at转换为createAt</li><li><code>-a</code>表示会继承一个<code>BaseEntity</code>的类,根据自己需求加</li></ul></li><li><p> 运行代码 <code>npm run db</code> 或 <code>yarn db</code></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结一下nestjs框架使用typeorm自动生成实体类的方法。可以节省一些开发时间&lt;/p&gt;</summary>
    
    
    
    <category term="MYSQL" scheme="http://example.com/categories/MYSQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="nestjs" scheme="http://example.com/tags/nestjs/"/>
    
  </entry>
  
  <entry>
    <title>zip命令的基本使用</title>
    <link href="http://example.com/2021/02/22/Linux/shell/%E6%96%87%E4%BB%B6/zip%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2021/02/22/Linux/shell/%E6%96%87%E4%BB%B6/zip%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2021-02-22T10:24:04.000Z</published>
    <updated>2021-12-22T06:03:57.114Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇关于zip命令的简单使用</p><a id="more"></a><h2 id="命令简介"><a href="#命令简介" class="headerlink" title="命令简介"></a>命令简介</h2><p>zip 命令可以用来压缩、打包文件。</p><pre><code class="BASH">#Debian/Ubuntu安装apt-get&nbsp;install&nbsp;zip#CentOS安装[root@centos7&nbsp;testdir]#&nbsp;zip-bash:&nbsp;zip:&nbsp;command&nbsp;not&nbsp;found[root@centos7&nbsp;testdir]#&nbsp;yum&nbsp;install&nbsp;zip&nbsp;-y</code></pre><p>zip 命令也可以用来解压缩文件，zip也是一个常用的压缩、解压应用程序，文件经它压缩后会产生一个新以.zip为扩展名的压缩包文件。</p><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><pre><code class="BASH">zip&nbsp;[&nbsp;OPTIONS&nbsp;]&nbsp;[&nbsp;NAME&nbsp;..]</code></pre><h2 id="选项说明"><a href="#选项说明" class="headerlink" title="选项说明"></a>选项说明</h2><pre><code class="BASH">-A  #调整可执行的自动解压缩文件-b&lt;工作目录&gt;  #指定压缩文件的存放目录-c  #给每个被压缩的文件加上注释信息-d  #从压缩文件内删除指定的文件，也可以使用--delete参数-D  #压缩文件内不建立目录名称-f  #更新既有文件，将其它文件一并加入到压缩文件中-F  #修复已损坏的压缩文件-g  #将指定文件压缩至已存在的压缩文件中，不建立新文件-h  #打印帮助信息-i&lt;范本样式&gt;  #只压缩匹配指定条件的文件-m  #将指定文件压缩打包后直接删除原始文件-o  #将压缩文件的属性信息更改成与压缩文件中的最新文件的属性一致-q  #安静模式-r  #递归处理-t&lt;日期时间&gt;  #把压缩文件的日期设成指定的日期-T  #检查备份文件内的每个文件是否正确无误-u  #更新较新的文件到压缩文件内-v  #打印命令执行过程信息或版本信息-x&lt;范本样式&gt;  #压缩时排除符合条件的文件-z  #给压缩文件加上注释信息-&lt;压缩效率&gt;  #指定压缩效率（1~9数字）</code></pre><h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><p>在当前目录下创建压缩文件（自动创建以.zip的文件）</p><pre><code class="BASH">[root@centos7 testdir]# zip mingongge *  adding: cest.txt.gz (stored 0%)  adding: cuttest.txt.gz (stored 0%)  adding: dir/ (stored 0%)  adding: file (stored 0%)  adding: mingongge1.txt.gz (stored 0%)  adding: mingongge2.txt.gz (stored 0%)  adding: mingongge.txt.md5.gz (stored 0%)  adding: sort.cut.txt.gz (stored 0%)</code></pre><p>分割一个大文件</p><pre><code class="BASH">[root@centos7&nbsp;~]#&nbsp;ls&nbsp;-lhtotal&nbsp;22M-rw-------.&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;1.3K&nbsp;Aug&nbsp;20&nbsp;10:39&nbsp;anaconda-ks.cfg-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;140&nbsp;Jan&nbsp;16&nbsp;11:36&nbsp;dos_test.txtdrwxr-xr-x&nbsp;&nbsp;&nbsp;3&nbsp;root&nbsp;root&nbsp;&nbsp;&nbsp;39&nbsp;Aug&nbsp;30&nbsp;03:48&nbsp;goinception-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;13M&nbsp;Aug&nbsp;30&nbsp;03:42&nbsp;goInception-linux-amd64-v1.2.3.tar.gzdrwxr-sr-x&nbsp;&nbsp;11&nbsp;root&nbsp;&nbsp;&nbsp;40&nbsp;4.0K&nbsp;Dec&nbsp;24&nbsp;22:35&nbsp;httpd-2.4.46-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;9.0M&nbsp;Aug&nbsp;&nbsp;5&nbsp;07:32&nbsp;httpd-2.4.46.tar.gz-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;Jan&nbsp;16&nbsp;11:32&nbsp;mingongge.filedrwxr-xr-x&nbsp;&nbsp;&nbsp;3&nbsp;root&nbsp;root&nbsp;&nbsp;192&nbsp;Jan&nbsp;16&nbsp;16:19&nbsp;testdir-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;140&nbsp;Jan&nbsp;16&nbsp;11:32&nbsp;test.txt[root@centos7&nbsp;~]#&nbsp;zip&nbsp;-s&nbsp;4M&nbsp;-r&nbsp;mingongge.zip&nbsp;httpd-2.4.46.tar.gz&nbsp;&nbsp;adding:&nbsp;httpd-2.4.46.tar.gz&nbsp;(deflated&nbsp;0%)[root@centos7&nbsp;~]#&nbsp;ls&nbsp;-lhtotal&nbsp;31M-rw-------.&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;1.3K&nbsp;Aug&nbsp;20&nbsp;10:39&nbsp;anaconda-ks.cfg-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;140&nbsp;Jan&nbsp;16&nbsp;11:36&nbsp;dos_test.txtdrwxr-xr-x&nbsp;&nbsp;&nbsp;3&nbsp;root&nbsp;root&nbsp;&nbsp;&nbsp;39&nbsp;Aug&nbsp;30&nbsp;03:48&nbsp;goinception-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;13M&nbsp;Aug&nbsp;30&nbsp;03:42&nbsp;goInception-linux-amd64-v1.2.3.tar.gzdrwxr-sr-x&nbsp;&nbsp;11&nbsp;root&nbsp;&nbsp;&nbsp;40&nbsp;4.0K&nbsp;Dec&nbsp;24&nbsp;22:35&nbsp;httpd-2.4.46-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;9.0M&nbsp;Aug&nbsp;&nbsp;5&nbsp;07:32&nbsp;httpd-2.4.46.tar.gz-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;Jan&nbsp;16&nbsp;11:32&nbsp;mingongge.file-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;4.0M&nbsp;Jan&nbsp;16&nbsp;16:24&nbsp;mingongge.z01-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;4.0M&nbsp;Jan&nbsp;16&nbsp;16:24&nbsp;mingongge.z02-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;943K&nbsp;Jan&nbsp;16&nbsp;16:24&nbsp;mingongge.zipdrwxr-xr-x&nbsp;&nbsp;&nbsp;3&nbsp;root&nbsp;root&nbsp;&nbsp;192&nbsp;Jan&nbsp;16&nbsp;16:19&nbsp;testdir#从结果可以看出会拆分成三个文件即：4M大小的mingongge.z01、4M大小的mingongge.z02和一个943k的mingongge.zip文件。</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一篇关于zip命令的简单使用&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="shell" scheme="http://example.com/tags/shell/"/>
    
    <category term="文件处理" scheme="http://example.com/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>tar命令的基本使用</title>
    <link href="http://example.com/2021/02/20/Linux/shell/%E6%96%87%E4%BB%B6/tar%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2021/02/20/Linux/shell/%E6%96%87%E4%BB%B6/tar%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2021-02-20T10:24:04.000Z</published>
    <updated>2021-12-22T06:03:57.114Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇关于tar命令的简单使用</p><a id="more"></a><h2 id="命令简介"><a href="#命令简介" class="headerlink" title="命令简介"></a>命令简介</h2><p>tar 命令用于打包、压缩与解压压缩包文件。</p><p>tar 命令常常用于打包、压缩某些文件或目录，也可以添加新文件到归档文件中。Tar 代表的是磁带存档，是一种归档的文件格式，早期用于将文件归档到磁带备份存储。现可以用于收集、分发、归档文件，还可以保留文件原有的属性，如：用户和组权限，访问和修改日期以及目录结构。</p><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><pre><code class="BASH">tar&nbsp;[OPTIONS]&nbsp;[FILE]</code></pre><h2 id="选项说明"><a href="#选项说明" class="headerlink" title="选项说明"></a>选项说明</h2><pre><code class="BASH">-A&nbsp;&nbsp;#新增文件到已经存在的归档文件-B&nbsp;&nbsp;#设置区块大小-c&nbsp;&nbsp;#建立新的归档文件-C&nbsp;&nbsp;#将压缩的文件解压到指定的目录下-d&nbsp;&nbsp;#记录文件的差异-x&nbsp;&nbsp;#解压或提取归档文件内容 -t&nbsp;&nbsp;#列出备份文件的内容-z&nbsp;&nbsp;#通过gzip命令来压缩/解压缩文件，文件名一般为&nbsp;xx.tar.gz-Z&nbsp;&nbsp;#通过compress命令处理备份文件-f&nbsp;&nbsp;#指定备份文件-v&nbsp;&nbsp;#显示命令执行过程-r&nbsp;&nbsp;#添加新文件到已经压缩的文件中-u&nbsp;&nbsp;#添加改变了和现有的文件到已经存在的压缩文件-j&nbsp;&nbsp;#通过bzip2命令来压缩/解压缩文件，文件名一般为xx.tar.bz2-v&nbsp;&nbsp;#显示操作过程；-k&nbsp;&nbsp;#保留原有文件不覆盖-m&nbsp;&nbsp;#保留文件不被覆盖-w&nbsp;&nbsp;#确认压缩文件的正确性-p&nbsp;&nbsp;#保留原来的文件权限与属性-P&nbsp;&nbsp;#使用文件名的绝对路径，不删除文件名称前的“/”号-N&nbsp;&nbsp;#只将较指定日期更新的文件保存到备份文件中--exclude=[范本样式]&nbsp;&nbsp;#排除符合范本样式的文件--remove-files&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#归档/压缩之后删除源文件</code></pre><h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><p>常见应用例子</p><pre><code class="BASH">tar&nbsp;-cf&nbsp;mingongge.tar&nbsp;*.jpg#将所有.jpg的文件打包成一个名为mingongge.tar的文件&nbsp;tar&nbsp;-rf&nbsp;mingongge.tar&nbsp;*.gif#将所有.gif的文件增加到mingongge.tar的包里&nbsp;tar&nbsp;-uf&nbsp;mingonggel.tar&nbsp;mingongge.gif#更新mingongge.tar文件中的mingongge.gif文件&nbsp;tar&nbsp;-tf&nbsp;mingongge.tar#列出&nbsp;all.tar&nbsp;包中所有文件tar&nbsp;-cfv&nbsp;mingongge.tar&nbsp;foo&nbsp;bar&nbsp;&nbsp;#将文件foo和bar打包成mingongge.tar文件包，也可以理解成：从这两个文件中去创建这个mingongge.tar文件tar&nbsp;-tvf&nbsp;mingongge.tar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#详细列出mingongge.tar中的所有文件tar&nbsp;-xf&nbsp;mingongge.tar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#从mingongge.tar提取所有文件</code></pre><p>将文件全部打包成tar包</p><pre><code class="BASH">tar&nbsp;-cvf&nbsp;mingongg.tar&nbsp;mingongg.log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#仅打包，不压缩！tar&nbsp;-zcvf&nbsp;mingongg.tar.gz&nbsp;mingongg.log&nbsp;&nbsp;&nbsp;#打包后，以gzip方式压缩tar&nbsp;-jcvf&nbsp;mingongg.tar.bz2&nbsp;mingongg.log&nbsp;&nbsp;#打包后，以bzip2方式压缩</code></pre><p>解压目录</p><pre><code class="BASH">tar&nbsp;-xvf&nbsp;portal-web-v2.0.0.tar&nbsp;--strip-components&nbsp;1&nbsp;&nbsp;-C&nbsp;指定目录#排除目录--strip-components</code></pre><p>将 tar包解压缩</p><pre><code class="BASH">tar&nbsp;-zxvf&nbsp;/opt/soft/test/log.tar.gz</code></pre><p>打包或压缩文件时，排队指定的文件类型</p><pre><code class="BASH">tar&nbsp;-zcf&nbsp;mingongge.tar.gz&nbsp;/etc/&nbsp;/var/&nbsp;--exclude=*.txt</code></pre><p>注意：如果在使用过程中遇到这类错误提示</p><pre><code class="BASH">tar:&nbsp;Removing&nbsp;leading&nbsp;`/`&nbsp;from&nbsp;member&nbsp;names </code></pre><p>原因是tar默认为相对路径，使用绝对路径的话就会报这个错，可以使用-P（大写）参数解决这个问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一篇关于tar命令的简单使用&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="shell" scheme="http://example.com/tags/shell/"/>
    
    <category term="文件处理" scheme="http://example.com/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>ES6笔记</title>
    <link href="http://example.com/2021/02/07/JavaScript/ES6%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/02/07/JavaScript/ES6%E7%AC%94%E8%AE%B0/</id>
    <published>2021-02-07T11:15:02.000Z</published>
    <updated>2021-12-22T06:03:57.109Z</updated>
    
    <content type="html"><![CDATA[<p>总结一些比较需要注意的ES6语法。</p><a id="more"></a><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="TDZ-暂时性死区"><a href="#TDZ-暂时性死区" class="headerlink" title="TDZ(暂时性死区)"></a>TDZ(暂时性死区)</h3><ul><li>当使用let，const声明语句时，还未执行的时候，变量会存入TDZ(暂时性死区)，引用语句时，会抛出错误。</li><li>类声明与let声明类似，不能被提升；真正执行声明语句之前，它们会一直存在于临时死区中。</li></ul><pre><code class="JS">console.log(typeof value); // throw ReferenceError: Cannot access 'value' before initializationlet value = 'string';</code></pre><h3 id="更好的Unicode支持"><a href="#更好的Unicode支持" class="headerlink" title="更好的Unicode支持"></a>更好的Unicode支持</h3><p>以后做字符处理时，优先选择codePoint相关方法， <code>String.fromCodePoint</code> 可以同时处理BMP和非BMP字符，即支持0xFFFF以上的字符解析</p><pre><code class="JS">String.fromCodePoint(97); // aString.fromCharCode(97); // a</code></pre><h3 id="函数形参的默认值"><a href="#函数形参的默认值" class="headerlink" title="函数形参的默认值"></a>函数形参的默认值</h3><p>可以利用以下特性，对入参做些预处理</p><pre><code class="JS">function add(first, second = first) {  return first + second;}</code></pre><h3 id="新增方法"><a href="#新增方法" class="headerlink" title="新增方法"></a>新增方法</h3><p>比起 <code>===</code> 判断两个变量是否一致，Object.is()会更完善，优先使用它</p><pre><code class="JS">console.log(+0 === -0); // trueconsole.log(Object.is(+0, -0)); // falseconsole.log(NaN === NaN); // falseconsole.log(Object.is(NaN, NaN)); // true</code></pre><h3 id="自由属性枚举顺序"><a href="#自由属性枚举顺序" class="headerlink" title="自由属性枚举顺序"></a>自由属性枚举顺序</h3><p><code>Object.getOwnPropertyNames</code> 返回一个数组，它包含了指定对象所有的可枚举或不可枚举的属性名，而 <code>Object.keys</code> 返回一个包含所有给定对象自身可枚举属性名称的数组。</p><pre><code class="JS">var a = {};Object.defineProperties(a, {  one: {    enumerable: true,    value: 1  },  two: {    enumerable: false,    value: 2  },});Object.keys(a); // ["one"]Object.getOwnPropertyNames(a); // ["one", "two"]</code></pre><h3 id="Symbol共享"><a href="#Symbol共享" class="headerlink" title="Symbol共享"></a>Symbol共享</h3><p>如果想创建一个可共享的Symbol，要使用Symbol.for()方法。它只接受一个参数。</p><pre><code class="JS">let uid = Symbo.for('uid');let object = {};object[uid] = '12345';console.log(object[uid]); // "12345"console.log(uid); // "Symbol(uid)"</code></pre><blockquote><p><code>Symbol.for()</code> 方法首先在全局Symbol注册表中搜索键为”uid”的Symbol是否存在，如果存在，直接返回已有的Symbol；否则，创建一个新的Symbol，并使用这个键在Symbol全局注册表中注册，随即返回新创建的Symbol。</p></blockquote><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul><li>Set不允许相同的值存在两个，所以可以使用Set去重，比如<code>[...new Set([1, 3, 1])]</code>; </li><li>在Set集合中，不会对所存值进行强制的类型转换，数字5和字符串“5”可以作为两个独立元素存在。</li><li>add, delete, has类似数组的push、splice、includes。</li><li>在Set存放对象，当对象的引用清除了，也不会释放，调用delete或者clear，还可以使用WeakSet，存放弱引用。</li></ul><h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><ul><li>WeakSet没有Set诸如add, has, delete, forEach, size等方法和属性，也不可迭代</li><li>只适合用来跟踪对象引用。</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li>与Object相比，键值支持对象作为属性，”5”、5将作为不同的key，而Object会调用toString将5转化为字符串，两个键值将冲突。</li><li>set, get, delete, has, clear方法，size属性。</li><li>forEach。</li></ul><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><ul><li>类似WeakSet，Key存放对象的弱引用，当该对象的所有强引用都被清除时，WeakMap中对应的弱引用键及其对应的值也会自动被GC。</li></ul><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul><li>本质就是调用对象的next方法 每次调用next，返回{ value: xxx, done: false }对象，当done为true表示迭代结束。</li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li>类数组对象（具有数值型索引和length属性的对象）。</li><li>定型数组，节省内存，JS数字是以64位浮点格式存储。</li><li>数组缓冲区 ArrayBuffer，类似C语言的<code>malloc</code>分配内存。<code>DataView</code>数据视图，用来操作数组缓存区的数据。</li><li>特定类型视图，Int8Array等。<br><img src="/My-Blogs/images/ES6%E7%AC%94%E8%AE%B0/ES6%E7%AC%94%E8%AE%B0-01.png" alt="img">。</li></ul><h3 id="Promise与异步编程"><a href="#Promise与异步编程" class="headerlink" title="Promise与异步编程"></a>Promise与异步编程</h3><h3 id="代理-Proxy-和反射Reflection"><a href="#代理-Proxy-和反射Reflection" class="headerlink" title="代理(Proxy)和反射Reflection"></a>代理(Proxy)和反射Reflection</h3><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ul><li>不管在import语句中把一个模块写了多少次，该模块将只执行一次。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结一些比较需要注意的ES6语法。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="ES6" scheme="http://example.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>deno的初体验</title>
    <link href="http://example.com/2021/01/19/Deno/deno%E7%9A%84%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://example.com/2021/01/19/Deno/deno%E7%9A%84%E5%88%9D%E4%BD%93%E9%AA%8C/</id>
    <published>2021-01-19T18:40:52.000Z</published>
    <updated>2021-12-22T06:03:57.106Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇关于deno初体验文章</p><a id="more"></a><h2 id="Deno-–-小而美的脚本运行时"><a href="#Deno-–-小而美的脚本运行时" class="headerlink" title="Deno – 小而美的脚本运行时"></a><a href="https://deno.land/">Deno</a> – 小而美的脚本运行时</h2><blockquote><p>a simple, modern and secure runtime for JavaScript and TypeScript that uses V8 and is built in Rust。</p></blockquote><p>Dahl（Node.js 的创始人之一）在2017年创建，Rust 语言开发。 <code>deno</code> 音译帝诺，恐龙(dinosaur)的简称，<code>deno</code> 这个名字就是来自 Node 的字母重新组合（Node = no + de），表示”拆除 Node.js”（de = destroy, no = Node.js）。</p><h2 id="创建原由"><a href="#创建原由" class="headerlink" title="创建原由"></a>创建原由</h2><ul><li>Node.js Callback hell。</li><li>原生支持CommonJs，对ES模块不兼容。</li><li>npm(你怕吗)模块管理工具，npm_modules 极其庞杂，还有Dependency Hell，版本重复问题等问题，极难管理。详情可查看<a href="https://juejin.cn/post/6914508615969669127">node_modules 困境</a><br><img src="/My-Blogs/images/deno%E5%88%9D%E4%BD%93%E9%AA%8C-01.jpg" alt="img"></li><li>功能不完整，要学习很多外部工具，诸如webpack，babel，typescript、eslint、prettier……</li></ul><blockquote><p><em>“由于上面这些原因，Ryan Dahl 决定放弃 Node.js，从头写一个替代品，彻底解决这些问题。deno 这个名字就是来自 Node 的字母重新组合（Node = no + de），表示”拆除 Node.js”（de = destroy, no = Node.js）。<br>跟 Node.js 一样，Deno 也是一个服务器运行时，但是支持多种语言，可以直接运行 JavaScript、TypeScript 和 WebAssembly 程序。<br>它内置了 V8 引擎，用来解释 JavaScript。同时，也内置了 tsc 引擎，解释 TypeScript。它使用 Rust 语言开发，由于 Rust 原生支持 WebAssembly，所以它也能直接运行 WebAssembly。它的异步操作不使用 libuv 这个库，而是使用 Rust 语言的 Tokio 库，来实现事件循环（event loop）。”</em>— 出自阮一峰大神《<a href="https://www.ruanyifeng.com/blog/2020/01/deno-intro.html">Deno 运行时入门教程：Node.js 的替代品</a>》</p></blockquote><p><strong>闲言少叙，书归正文，让我们一起来看看Deno的特性吧。</strong></p><h2 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h2><ul><li>服务器运行时，支持多种语言，可直接运行 <code>JavaScript</code>、<code>TypeScript</code> 和 <code>WebAssembly</code> 程序。</li><li>具有安全控制，默认情况下脚本不具有读写权限。如果脚本未授权，就读写文件系统或网络，会报错。</li><li>只有一个可执行文件，所有操作都通过这个文件完成。它支持跨平台（Mac、Linux、Windows）。</li><li>异步操作 一律返回 Promise。</li><li>Deno 支持 Web API，尽量跟浏览器保持一致。<code>window</code>、<code>fetch</code>、<code>webCrypto</code>、<code>worker</code>, 也支持 <code>onload</code>、<code>onunload</code>、<code>addEventListener</code> 等事件操作函数。</li><li>所有模块通过 URL 加载，比如<code>import { bar } from "https://foo.com/bar.ts"</code>（绝对 URL）或<code>import { bar } from './foo/bar.ts'</code>（相对 URL）。本地缓存，有个Cache总目录</li><li>原生支持TypeScript, 内置<a href="https://github.com/microsoft/TypeScript">TypeScript编译器</a>和<a href="https://swc.rs/">swc</a>的Rust库组合实现。</li><li>打包、格式清理、测试、安装、文档生成、linting、脚本编译成可执行文件等一条龙服务。</li></ul><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li>高效且安全</li><li>单文件，兼容浏览器标准，体积小。</li><li>替代脚本</li><li>内存占用少，运行速度比node快。<a href="https://juejin.cn/post/6854573218419474439">从Deno跟Node的性能对比说起</a></li></ul><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><ul><li>缺少集大成框架，满足不了企业级应用开发。</li><li>社区还不完善，第三方库不够丰富。</li><li>缺乏包管理工具，管理起来混乱。</li><li><a href="https://juejin.cn/post/6917830384956899341">网络上一些怀疑的声音</a></li></ul><h3 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a><a href="https://deno.land/manual@v1.7.0/getting_started/command_line_interface">CLI</a></h3><h3 id="permission"><a href="#permission" class="headerlink" title="permission"></a><a href="https://deno.land/manual@v1.7.0/getting_started/permissions">permission</a></h3><h3 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a><a href="https://deno.land/manual@v1.7.0/getting_started/webassembly#webassembly-support">WebAssembly</a></h3><pre><code class="JS">const wasmCode = new Uint8Array([  0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127,  3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0,  5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145,  128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97,  105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0,  65, 42, 11]);const wasmModule = new WebAssembly.Module(wasmCode);const wasmInstance = new WebAssembly.Instance(wasmModule);const main = wasmInstance.exports.main as CallableFunctionconsole.log(main().toString());</code></pre><h3 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h3><ul><li><a href="https://deno.land/x">已支持开源项目</a></li><li><a href="https://deno.land/x/denon@2.4.6">denon</a></li><li><a href="https://deno.land/x/oak@v6.4.2">oak</a> – 类似koa的web框架</li><li><a href="https://deno.land/x/aleph@v0.2.28">Aleph.js</a> – 类似Next.js(React ssr框架)<h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a><a href="https://deno.land/std/">标准库</a></h3><h3 id="兼容node-js"><a href="#兼容node-js" class="headerlink" title="兼容node.js"></a><a href="https://deno.land/std/node">兼容node.js</a></h3></li></ul><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>Shell (Mac, Linux):</p><pre><code class="BASH">curl -fsSL https://deno.land/x/install/install.sh | sh</code></pre><p>PowerShell (Windows):</p><pre><code class="BASH">iwr https://deno.land/x/install/install.ps1 -useb | iex</code></pre><p>Using Homebrew (macOS):</p><pre><code class="BASH">brew install deno</code></pre><h3 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h3><p>Try running a simple program:</p><pre><code class="BASH">deno run https://deno.land/std/examples/welcome.ts</code></pre><p>Or a more complex one:</p><pre><code class="JS">import {  serve} from "https://deno.land/std@0.83.0/http/server.ts";const s = serve({  port: 8000});console.log("http://localhost:8000/");for await (const req of s) {  req.respond({    body: "Hello World\n"  });}</code></pre><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a><a href="https://deno.land/std/">例子</a></h3><h2 id="缓存目录"><a href="#缓存目录" class="headerlink" title="缓存目录"></a>缓存目录</h2><p>以Mac为例，举个🌰 </p><pre><code class="BASH"> $HOME/Library/Caches/Deno#  远程库下载地址deno run https://deno.land/std@0.83.0/examples/welcome.ts# DIRECTORIESgen/: 缓存编译为JavaScript的文件deps/: 缓存导入的远程url的文件  |__ http/: http方式导入的文件  |__ https/: https方式导入的文件# FILESdeno_history.txt: Deno REPL历史记录缓存deno info                                                                               DENO_DIR location: "/Users/lulu/Library/Caches/deno"Remote modules cache: "/Users/lulu/Library/Caches/deno/deps"TypeScript compiler cache: "/Users/lulu/Library/Caches/deno/gen"</code></pre><h3 id="gen"><a href="#gen" class="headerlink" title="gen/"></a>gen/</h3><p><code>$DENO_DIR/gen/</code> 被用来存放 JavaScript 文件，这些文件是从 TypeScript 源码编译来的。这样的编译是必要的，因为 V8 不识别 JS 子集之外的 TypeScript 语法。</p><p>gen/目录下的每一个 JS 文件的文件名是他的 TypeScript 源码的 hash 值。同时 JS 文件也对应一个 .map 为后缀的 source map 文件。</p><p>缓存存在的原因是为了避免在用户没有修改代码的情况下，每次运行时不断的重新编译文件。比如我们有一个 hello-world.ts 文件，他只是包含了代码 console.log(“Hello world”)。在第一次运行时，我们会看到编译信息：</p><pre><code class="BASH">$ deno hello-world.tsCompiling /Users/kevinqian/my-folder/hello-world.tsHello world</code></pre><p>但是在没有修改文件内容的情况下，当你重新运行代码：</p><pre><code class="BASH">$ deno hello-world.tsHello world</code></pre><p>不会再有编译信息的提示。这是因为在这一次运行中，Deno 直接使用了 gen/ 中缓存的版本，而不用再次编译。</p><p>缓存加载和保存的代码，可以从文件 src/deno_dir.rs 中的 DenoDir::load_cache 和 DenoDir::code_cache 中找到。</p><p>如果想要强制 Deno 重新编译你的代码而不是使用缓存的版本，你需要使用 <code>--recompile</code> 标志。</p><h3 id="deps"><a href="#deps" class="headerlink" title="deps/"></a>deps/</h3><p><code>$DENO_DIR/deps</code> 被用来保存远端 url import 获得的文件。根据 url 的模式，他包含了子目录（现在只有http和https），并且保存文件的位置由 URL path 决定。比如，对于下面的的 import（请注意，Deno 要求用户显式地指定扩展名）。</p><pre><code class="JS">import {  serve} from "https://deno.land/x/std/net/http.ts";</code></pre><p>下载的http.ts文件将会被存储在：</p><pre><code class="BASH">$DENO_DIR/deps/https/deno.land/x/std/net/http.ts</code></pre><p>需要注意，除非用户用 <code>--reload</code> 标志运行代码，否则我们的http.ts文件在接下来的运行中不会被重新下载。</p><p>当前（警告：将来可能改变），Deno 会关注从远端下载的文件的内容的 MIME 类型。在文件缺少扩展名或扩展名与内容类型不匹配的情况下，Deno 将创建一个以 .mime 结尾的额外文件，来存储 HTTP 响应头提供的 mime 类型。如果我们下载的文件名是 a.ts，然而响应头里面是 Content-Type: text/javascript，一个包含text/javascript内容的a.ts.mime文件将会在他旁边被创建。由于.mime文件的存在，a.ts 后面将会被当做一个 JavaScript 文件被 import。</p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><pre><code class="BASH">cd /Users/lulu/my-projects/deno-demo &amp;&amp; code .</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Deno的目标不是替代Node，而是Node的一个补充完善方案。<br>目前Deno还处于初步阶段，标准库，兼容性还有待改进，适合脚本，小型应用开发。想要完成一个成熟的大型项目，还需要时间的沉淀。让我们好好期待下，未来的Deno会如何发展？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一篇关于deno初体验文章&lt;/p&gt;</summary>
    
    
    
    <category term="deno" scheme="http://example.com/categories/deno/"/>
    
    
    <category term="deno" scheme="http://example.com/tags/deno/"/>
    
  </entry>
  
  <entry>
    <title>tree命令的基本使用</title>
    <link href="http://example.com/2021/01/18/Linux/shell/%E6%96%87%E4%BB%B6/tree%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2021/01/18/Linux/shell/%E6%96%87%E4%BB%B6/tree%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2021-01-18T10:15:44.000Z</published>
    <updated>2021-12-22T06:03:57.114Z</updated>
    
    <content type="html"><![CDATA[<p>每天学一个 Linux 命令之tree的基本使用</p><a id="more"></a><h2 id="命令简介"><a href="#命令简介" class="headerlink" title="命令简介"></a>命令简介</h2><p>tree 命令的作用是以树形结构显示目录下的内容。</p><p>常用的Linux发行版系统中默认没有这个命令，你需要通过安装才可以使用：</p><pre><code class="BASH">#Centosyum install tree -y#Ubuntusudo apt-get install tree</code></pre><p>安装完成之后就可以正常使用这个tree命令了。</p><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><pre><code class="BASH">tree [选项] [目录]</code></pre><h2 id="选项说明"><a href="#选项说明" class="headerlink" title="选项说明"></a>选项说明</h2><pre><code class="BASH">-a   #显示所有文件-d   #只显示目录（名称）-l   #显示链接文件的原始文件-f   #显示所列出的文件或目录的完整目录路径-i   #不以阶梯的形式显示文件或目录名称-q   #将控制字符以?字符代替，显示文件和目录名称-N   #直接显示文件或目录的名称-p   #显示每个文件的权限信息-u   #显示文件所有者或者uid-g   #显示文件所属组或者gid-s   #显示每个文件的大小信息-h   #以可读的方式显示文件的大小信息-D   #显示最后修改日期-v   #按字母数字正序显示文件-r   #按字母数字倒序显示文件-t   #按最后时间排序显示文件-C   #在文件和目录列表上加上色彩，便于区分文件类型-P pattern    #只显示匹配正则表式的文件或目录名称-I pattern    #与上结果相反</code></pre><h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><pre><code class="BASH">#树形显示当前目录及其子目录下的文件及目录名称[root@centos7&nbsp;testdir]#&nbsp;tree.├──&nbsp;dir│&nbsp;&nbsp;&nbsp;├──&nbsp;test2.txt~│&nbsp;&nbsp;&nbsp;├──&nbsp;test3.txt│&nbsp;&nbsp;&nbsp;└──&nbsp;test3.txt.bak├──&nbsp;test2.txt└──&nbsp;test2.txt~1&nbsp;directory,&nbsp;5&nbsp;files#只显示目录名称[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-d.└──&nbsp;dir1&nbsp;directory#显示目录及文件的权限信息[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-p.├──&nbsp;[drwxr-xr-x]&nbsp;&nbsp;dir│&nbsp;&nbsp;&nbsp;├──&nbsp;[-rw-r--r--]&nbsp;&nbsp;test2.txt~│&nbsp;&nbsp;&nbsp;├──&nbsp;[-rw-r--r--]&nbsp;&nbsp;test3.txt│&nbsp;&nbsp;&nbsp;└──&nbsp;[-rw-r--r--]&nbsp;&nbsp;test3.txt.bak├──&nbsp;[-rw-r--r--]&nbsp;&nbsp;test2.txt└──&nbsp;[-rw-r--r--]&nbsp;&nbsp;test2.txt~1&nbsp;directory,&nbsp;5&nbsp;files#显示几层信息2代表2层（向下）[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-L&nbsp;2.├──&nbsp;dir│&nbsp;&nbsp;&nbsp;├──&nbsp;test2.txt~│&nbsp;&nbsp;&nbsp;├──&nbsp;test3.txt│&nbsp;&nbsp;&nbsp;└──&nbsp;test3.txt.bak├──&nbsp;test2.txt└──&nbsp;test2.txt~1&nbsp;directory,&nbsp;5&nbsp;files[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-L&nbsp;1.├──&nbsp;dir├──&nbsp;test2.txt└──&nbsp;test2.txt~1&nbsp;directory,&nbsp;2&nbsp;files</code></pre><p>-C 显示各种文件类型，以颜色区分</p><p><img src="/My-Blogs/images/tree%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-01.png" alt="img"></p><pre><code class="BASH">#显示文件和目录的所有者[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-u.├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;cp&nbsp;-&gt;&nbsp;/usr/bin/cp├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;dir│??&nbsp;├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test2.txt~│??&nbsp;├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test3.txt│??&nbsp;└──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test3.txt.bak├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test2.txt└──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test2.txt~1&nbsp;directory,&nbsp;6&nbsp;files#显示文件和目录的所属组[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-g.├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;cp&nbsp;-&gt;&nbsp;/usr/bin/cp├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;dir│??&nbsp;├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test2.txt~│??&nbsp;├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test3.txt│??&nbsp;└──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test3.txt.bak├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test2.txt└──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test2.txt~1&nbsp;directory,&nbsp;6&nbsp;files#不按树形形式显示文件和目录[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-i.cp&nbsp;-&gt;&nbsp;/usr/bin/cpdirtest2.txt~test3.txttest3.txt.baktest2.txttest2.txt~1&nbsp;directory,&nbsp;6&nbsp;files[root@centos7&nbsp;testdir]#&nbsp;tree.├──&nbsp;cp&nbsp;-&gt;&nbsp;/usr/bin/cp├──&nbsp;dir│&nbsp;&nbsp;&nbsp;├──&nbsp;test2.txt~│&nbsp;&nbsp;&nbsp;├──&nbsp;test3.txt│&nbsp;&nbsp;&nbsp;└──&nbsp;test3.txt.bak├──&nbsp;test2.txt└──&nbsp;test2.txt~1&nbsp;directory,&nbsp;6&nbsp;files#显示文件和目录的完整路径[root@centos7&nbsp;testdir]#&nbsp;pwd/root/testdir[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-f.├──&nbsp;./cp&nbsp;-&gt;&nbsp;/usr/bin/cp├──&nbsp;./dir│&nbsp;&nbsp;&nbsp;├──&nbsp;./dir/test2.txt~│&nbsp;&nbsp;&nbsp;├──&nbsp;./dir/test3.txt│&nbsp;&nbsp;&nbsp;└──&nbsp;./dir/test3.txt.bak├──&nbsp;./test2.txt└──&nbsp;./test2.txt~1&nbsp;directory,&nbsp;6&nbsp;files[root@centos7&nbsp;~]#&nbsp;tree&nbsp;-f&nbsp;./testdir/./testdir├──&nbsp;./testdir/cp&nbsp;-&gt;&nbsp;/usr/bin/cp├──&nbsp;./testdir/dir│&nbsp;&nbsp;&nbsp;├──&nbsp;./testdir/dir/test2.txt~│&nbsp;&nbsp;&nbsp;├──&nbsp;./testdir/dir/test3.txt│&nbsp;&nbsp;&nbsp;└──&nbsp;./testdir/dir/test3.txt.bak├──&nbsp;./testdir/test2.txt└──&nbsp;./testdir/test2.txt~1&nbsp;directory,&nbsp;6&nbsp;files</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;每天学一个 Linux 命令之tree的基本使用&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="shell" scheme="http://example.com/tags/shell/"/>
    
    <category term="文件处理" scheme="http://example.com/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Explain使用分析</title>
    <link href="http://example.com/2021/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/Explain%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2021/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/Explain%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/</id>
    <published>2021-01-08T18:06:09.000Z</published>
    <updated>2021-12-22T06:03:57.125Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.<br>EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:</p><a id="more"></a><pre><code class="SQL">EXPLAIN SELECT * from user_info WHERE  id &lt; 300;</code></pre><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:</p><pre><code class="SQL">CREATE TABLE `user_info` (  `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,  `name` VARCHAR(50) NOT NULL DEFAULT '',  `age`  INT(11)              DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `name_index` (`name`))  ENGINE = InnoDB  DEFAULT CHARSET = utf8</code></pre><pre><code class="SQL">CREATE TABLE `order_info` (  `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,  `user_id`      BIGINT(20)           DEFAULT NULL,  `product_name` VARCHAR(50) NOT NULL DEFAULT '',  `productor`    VARCHAR(30)          DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`))  ENGINE = InnoDB  DEFAULT CHARSET = utf8</code></pre><h2 id="EXPLAIN-输出格式"><a href="#EXPLAIN-输出格式" class="headerlink" title="EXPLAIN 输出格式"></a>EXPLAIN 输出格式</h2><p>EXPLAIN 命令的输出内容大致如下:</p><pre><code class="SQL">mysql&gt; explain select * from user_info where id = 2\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)</code></pre><p>各列的含义如下:</p><ul><li><p><code>id</code>: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</p></li><li><p><code>select_type</code>: SELECT 查询的类型.</p></li><li><p><code>table</code>: 查询的是哪个表</p></li><li><p><code>partitions</code>: 匹配的分区</p></li><li><p><code>type</code>: join 类型</p></li><li><p><code>possible_keys</code>: 此次查询中可能选用的索引</p></li><li><p><code>key</code>: 此次查询中确切使用到的索引.</p></li><li><p><code>ref</code>: 哪个字段或常数与 key 一起被使用</p></li><li><p><code>rows</code>: 显示此查询一共扫描了多少行. 这个是一个估计值.</p></li><li><p><code>filtered</code>: 表示此查询条件所过滤的数据的百分比</p></li><li><p><code>extra</code>: 额外的信息</p></li></ul><p>接下来我们来重点看一下比较重要的几个字段.</p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p><code>select_type</code> 表示了查询的类型, 它的常用取值有:</p><ul><li><p>SIMPLE, 表示此查询不包含 UNION 查询或子查询</p></li><li><p>PRIMARY, 表示此查询是最外层的查询</p></li><li><p>UNION, 表示此查询是 UNION 的第二或随后的查询</p></li><li><p>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询</p></li><li><p>UNION RESULT, UNION 的结果</p></li><li><p>SUBQUERY, 子查询中的第一个 SELECT</p></li><li><p>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</p></li></ul><p>最常见的查询类别应该是 <code>SIMPLE</code> 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 <code>SIMPLE</code> 类型, 例如:</p><pre><code class="SQL">mysql&gt; explain select * from user_info where id = 2\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)</code></pre><p>如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:</p><pre><code class="SQL">mysql&gt; EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3))    -&gt; UNION    -&gt; (SELECT * FROM user_info WHERE id IN (3, 4, 5));+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+| id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+|  1 | PRIMARY      | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     ||  2 | UNION        | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     || NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+3 rows in set, 1 warning (0.00 sec)</code></pre><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>表示查询涉及的表或衍生表</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p><code>type</code> 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 <code>type</code> 字段, 我们判断此次查询是 <code>全表扫描</code> 还是 <code>索引扫描</code> 等.</p><p><strong>type 常用类型</strong><br>type 常用的取值有:</p><p><code>system</code> : 表中只有一条数据. 这个类型是特殊的 <code>const</code> 类型.</p><p><code>const</code> : 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. <code>const</code> 查询速度非常快, 因为它仅仅读取一次即可.<br>例如下面的这个查询, 它使用了主键索引, 因此 <code>type</code> 就是 <code>const</code> 类型的.</p><pre><code class="SQL">mysql&gt; explain select * from user_info where id = 2\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)</code></pre><ul><li><code>eq_ref</code>: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:</li></ul><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: indexpossible_keys: user_product_detail_index          key: user_product_detail_index      key_len: 314          ref: NULL         rows: 9     filtered: 100.00        Extra: Using where; Using index*************************** 2. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: eq_refpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: test.order_info.user_id         rows: 1     filtered: 100.00        Extra: NULL2 rows in set, 1 warning (0.00 sec)</code></pre><ul><li><code>ref</code>: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 <code>最左前缀</code> 规则索引的查询.</li></ul><p>例如下面这个例子中, 就使用到了 <code>ref</code> 类型的查询:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: const         rows: 1     filtered: 100.00        Extra: NULL*************************** 2. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: refpossible_keys: user_product_detail_index          key: user_product_detail_index      key_len: 9          ref: const         rows: 1     filtered: 100.00        Extra: Using index2 rows in set, 1 warning (0.01 sec)</code></pre><ul><li><code>range</code>: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.</li></ul><p>当 <code>type</code> 是 <code>range</code> 时, 那么 EXPLAIN 输出的 <code>ref</code> 字段为 NULL, 并且 <code>key_len</code> 字段是此次查询中使用到的索引的最长的那个.</p><p>例如下面的例子就是一个范围查询:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT *    -&gt;         FROM user_info    -&gt;         WHERE id BETWEEN 2 AND 8 \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: rangepossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: NULL         rows: 7     filtered: 100.00        Extra: Using where1 row in set, 1 warning (0.00 sec)</code></pre><ul><li><code>index</code>: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.</li></ul><p><code>index</code> 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 <code>Using index</code> .</p><p>例如:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT name FROM  user_info \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: indexpossible_keys: NULL          key: name_index      key_len: 152          ref: NULL         rows: 10     filtered: 100.00        Extra: Using index1 row in set, 1 warning (0.00 sec)</code></pre><p>上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 <code>index</code> , 并且 Extra 的值是 <code>Using index</code> .</p><ul><li><code>ALL</code>: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.</li></ul><p>下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT age FROM  user_info WHERE age = 20 \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 10     filtered: 10.00        Extra: Using where1 row in set, 1 warning (0.00 sec)</code></pre><p><strong>type 类型的性能比较</strong></p><p>通常来说, 不同的 type 类型的性能关系如下:</p><p> <code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code></p><p><code>ALL</code> 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.</p><p>而 <code>index</code> 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.</p><p>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</p><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p><code>possible_keys</code> 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 <code>possible_keys</code> 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 <code>key</code> 字段决定.</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>此字段是 MySQL 在当前查询时所真正使用到的索引.</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.<br>key_len 的计算规则如下:</p><ul><li><p>字符串</p><ul><li><p>char(n): n 字节长度</p></li><li><p>varchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.</p></li></ul></li><li><p>数值类型:</p><ul><li><p>TINYINT: 1字节</p></li><li><p>SMALLINT: 2字节</p></li><li><p>MEDIUMINT: 3字节</p></li><li><p>INT: 4字节</p></li><li><p>BIGINT: 8字节</p></li><li><p>时间类型</p></li><li><p>DATE: 3字节</p></li><li><p>TIMESTAMP: 4字节</p></li><li><p>DATETIME: 8字节</p></li><li><p>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.</p></li></ul></li></ul><p>我们来举两个简单的栗子:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id &lt; 3 AND product_name = 'p1' AND productor = 'WHH' \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: rangepossible_keys: user_product_detail_index          key: user_product_detail_index      key_len: 9          ref: NULL         rows: 5     filtered: 11.11        Extra: Using where; Using index1 row in set, 1 warning (0.00 sec)</code></pre><p>上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 <code>order_info</code> 有一个联合索引:</p><pre><code class="SQL">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</code></pre><p>不过此查询语句 <code>WHERE user_id &lt; 3 AND product_name = 'p1' AND productor = 'WHH'</code> 中, 因为先进行 user_id 的范围查询, 而根据 <code>最左前缀匹配</code> 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 <code>user_id</code> , 因此在 <code>EXPLAIN</code> 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 <code>BIGINT(20) NOT NULL DEFAULT '0'</code> , 则 key_length 应该是8.</p><p>上面因为 <code>最左前缀匹配</code> 原则, 我们的查询仅仅使用到了联合索引的 <code>user_id</code> 字段, 因此效率不算高.</p><p>接下来我们来看下一个例子:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = 'p1' \G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: refpossible_keys: user_product_detail_index          key: user_product_detail_index      key_len: 161          ref: const,const         rows: 2     filtered: 100.00        Extra: Using index1 row in set, 1 warning (0.00 sec)</code></pre><p>这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 <code>WHERE user_id = 1 AND product_name = 'p1'</code> 中, 仅仅使用到了联合索引中的前两个字段, 因此 <code>keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</code></p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p><code>rows</code> 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br>这个值非常直观显示 SQL 的效率好坏, 原则上 <code>rows</code> 越少越好.</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p><code>EXplain</code> 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p><ul><li><code>Using filesort</code></li></ul><p>当 Extra 中有 <code>Using filesort</code> 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 <code>Using filesort</code> , 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</p><p>例如下面的例子:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY product_name \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: indexpossible_keys: NULL          key: user_product_detail_index      key_len: 253          ref: NULL         rows: 9     filtered: 100.00        Extra: Using index; Using filesort1 row in set, 1 warning (0.00 sec)</code></pre><p>我们的索引是</p><pre><code class="SQL">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</code></pre><p>但是上面的查询中根据 <code>product_name</code> 来排序, 因此不能使用索引进行优化, 进而会产生 <code>Using filesort</code> .<br>如果我们将排序依据改为 <code>ORDER BY user_id, product_name</code> , 那么就不会出现 <code>Using filesort</code> 了. 例如:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: indexpossible_keys: NULL          key: user_product_detail_index      key_len: 253          ref: NULL         rows: 9     filtered: 100.00        Extra: Using index1 row in set, 1 warning (0.00 sec)</code></pre><ul><li><p><code>Using index</code> “覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</p></li><li><p><code>Using temporary</code> 查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;MySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.&lt;br&gt;EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>db操作常见问题</title>
    <link href="http://example.com/2021/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2021-01-08T18:05:18.000Z</published>
    <updated>2021-12-22T06:03:57.125Z</updated>
    
    <content type="html"><![CDATA[<p>总结了一些db操作的常见问题，让我们一起来看看吧</p><a id="more"></a><h2 id="联合索引问题"><a href="#联合索引问题" class="headerlink" title="联合索引问题"></a>联合索引问题</h2><ol><li> 在imo后台群唤醒活动中，用户数据表多达几千万，大数据这边，并未针对业务场景建立有效覆盖索引，导致后台SQL慢查询告警上千次，针对业务场景，提出以下优化，新增key1，key2索引覆盖，后台where条件严格按照stats_day，activelevel，categeory_id，cc顺序查询。</li><li> 按照MySQL联合索引最左匹配原则，比如A-B-C联合索引，则针对A，A-B，A-B-C查询有效，而A-C，B-C，B，C则无效，where条件最好根据索引顺序进行</li><li> 如果搜索条件过于复杂混乱，建议先与产品沟通清楚，确定好如何建立索引，严格把控搜索条件（从界面上）</li><li> 以下为用户数据表（千万级别）</li></ol><pre><code class="SQL">CREATE TABLE `xx_push_activelevel_categeory_day` (  `stats_day` date NOT NULL DEFAULT '2019-01-01',  `cc` varchar(10) NOT NULL DEFAULT '',  `activelevel` varchar(30) NOT NULL DEFAULT 'unknown',  `categeory_id` varchar(50) NOT NULL DEFAULT 'unknown',  `groupid` char(30) NOT NULL DEFAULT 'unknown',  `role` varchar(15) NOT NULL DEFAULT 'unknown',  `uid` varchar(25) NOT NULL DEFAULT '',  PRIMARY KEY (`role`,`activelevel`,`categeory_id`,`cc`,`uid`,`groupid`,`stats_day`),  KEY `role` (`role`,`activelevel`,`categeory_id`),  KEY `key1` (`stats_day`,`activelevel`,`categeory_id`,`cc`,`role`),  KEY `key2` (`stats_day`,`activelevel`,`categeory_id`,`cc`),  KEY `actl` (`activelevel`),  KEY `agid` (`categeory_id`),  KEY `cc` (`cc`)) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4/*!50100 PARTITION BY RANGE (TO_DAYS(stats_day))(PARTITION pd20200609 VALUES LESS THAN (737951) ENGINE = MyISAM, PARTITION pd20200610 VALUES LESS THAN (737952) ENGINE = MyISAM, PARTITION pd20200611 VALUES LESS THAN (737953) ENGINE = MyISAM) */;</code></pre><h2 id="主键偏移问题"><a href="#主键偏移问题" class="headerlink" title="主键偏移问题"></a>主键偏移问题</h2><ol><li> 在单表大数据量的情况下，使用索引并不是唯一选择，当SQL分页查询，offset达到一定量(大概20w以上？)以后，就会出现慢查询现象，是由于MySQL根据索引查出一定量数据之后，会根据offset抛弃之前的数据</li><li> 这意味着前20w数据的查询都是无用的，费力不讨好</li><li> 可以采用主键id(INT, BIGINT类型)偏移，INT类型查询天生就有优势，又是主键索引，可以做到一部到位</li><li> where条件最后，加上id排序，记录上一次的查询数据最后一条id，下一次查询作为偏移量，从而跳过前面无用的数据，再开始进行索引查询</li><li> 以下是某个项目的例子（仅供参考）</li></ol><pre><code class="SQL">SELECT id, stats_day, cc, activelevel, categeory_id, groupid, role, uid FROM xx_push_activelevel_categeory_day AS biggroupPushCategeoryWHERE biggroupPushCategeory.id &gt; 200000 AND biggroupPushCategeory.stats_day = '2020-07-01 00:00:00' AND biggroupPushCategeory.activelevel = 'gtype_unactive_2' AND biggroupPushCategeory.categeory_id = 'categeory_mems_less_300' AND biggroupPushCategeory.cc = 'PK'ORDER BY biggroupPushCategeory.id ASC LIMIT 500;</code></pre><h2 id="结果集过滤问题"><a href="#结果集过滤问题" class="headerlink" title="结果集过滤问题"></a>结果集过滤问题</h2><ol><li> 接上一个问题，当我们结合主键偏移+索引【KEY <code>sacc</code> (<code>stats_day</code>,<code>activelevel</code>,<code>categeory_id</code>,<code>cc</code>)】搜索的时候，SQL这边优先根据索引过滤结果集，根据上面那条sql，我们可能会过滤出一个大结果集，而且结果集并不保证id有序</li><li> 这时候我们需要重新修改索引键，加上主键id，例如KEY <code>sacci</code> (<code>stats_day</code>,<code>activelevel</code>,<code>categeory_id</code>,<code>cc</code>,<code>id</code>)，当我们进行索引查询取500行时，可以根据id&gt;20000，直接命中500行并返回，不需要重新排序，也不会返回之前sacc索引的所有结果集</li><li> 以下是优化前和优化后的对比图，性能提高了几十倍</li></ol><h3 id="优化前"><a href="#优化前" class="headerlink" title="优化前"></a>优化前</h3><p><img src="/My-Blogs/images/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-01.png" alt="优化前"></p><h3 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h3><p><img src="/My-Blogs/images/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-02.png" alt="优化后"></p><h2 id="where条件顺序问题"><a href="#where条件顺序问题" class="headerlink" title="where条件顺序问题"></a>where条件顺序问题</h2><ol><li> 接上一个问题，我们已经创建索引KEY <code>sacci</code> (<code>stats_day</code>,<code>activelevel</code>,<code>categeory_id</code>,<code>cc</code>,<code>id</code>)，如果我们把id放在最前，或者最后，会对查询的效率有影响吗？答案是没有。</li><li> SQL执行是会被进行一系列预处理，让查询优化器选择最优的查询计划，所以where条件的先后关系不是优化器选择规则的一条，当然前提是你的where条件数量与索引一致，如果where条件少于索引数量，会根据最左原则优先查询。</li><li> 总的来说，唯一会影响的就是where条件和索引的比对，以及跟order by等，跟先后顺序无关。</li><li> 引申开来说，如果对ABC三个字段建立联合索引，一般来说，在创建索引时，根据区分度原则，尽量让A能够排除更多记录而不是B或C，在查询时，根据索引前缀匹配原则，尽可能让A条件精确，B其次，C看着办。</li><li> 以下是id前后对比图</li></ol><p><img src="/My-Blogs/images/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-03.png" alt="alt"></p><p><img src="/My-Blogs/images/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-04.png" alt="alt"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结了一些db操作的常见问题，让我们一起来看看吧&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>PRPL模式加快Web应用加载</title>
    <link href="http://example.com/2021/01/08/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/"/>
    <id>http://example.com/2021/01/08/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/</id>
    <published>2021-01-08T18:01:13.000Z</published>
    <updated>2021-12-22T06:03:57.124Z</updated>
    
    <content type="html"><![CDATA[<p>PRPL 是一种用于结构化和交付 Web 应用程序和渐进式 Web 应用（PWA）的模式，重点在于改进应用的交付和启动性能。这个模式包含一组步骤，以实现快速、可靠、高效的加载：</p><a id="more"></a><ul><li><p><code>Push</code>, 推送初始路由所需的所有资源，并且只推送这些资源，以确保它们尽早可用。</p></li><li><p><code>Render</code>, 在加载其他资源之前，渲染初始路由并使其具备交互能力。</p></li><li><p><code>Pre-cache</code>, 预缓存用户可能访问的其他路由的资源，从而在恶劣的网络条件下尽可能提高对后续请求的响应能力和弹性。</p></li><li><p><code>Lazy-load</code>, 当用户请求时，按需延迟加载路由；关键路由的资源应立即从缓存中加载，而相对不常用的资源可以根据请求从网络获取。</p></li></ul><blockquote><p>注意：PRPL模式是由Polymer团队于2016年首次引入的，但已被证明适用于其他许多技术栈。</p></blockquote><p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-01.png" alt="img"></p><center>PRPL 模式加载顺序</center><p>服务器和服务 Worker 一起为非活动路由预缓存资源。当用户切换路由时，应用会延迟加载尚未缓存的所有必需资源，并创建所需的视图。</p><p>Twitter.com 自 2017 年以来就在生产中使用 PRPL 模式了。下面我们可以看到，他们对关键脚本使用了粒度代码拆分，并使用 <code>&lt;linkrel=preload&gt;</code> 推送脚本以尽快让脚本可用：</p><p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-02.png" alt="img"></p><br><center style="margin-top: 20px">PRPL 模式：预加载关键脚本</center><br><p>其他路由会按需延迟加载。Twitter 在整个用户体验部分中会按需提供 40 多个块。Twitter 还使用服务 Workers 对其他路由进行（离线）资产预缓存，以提高对后续导航操作的响应能力：</p><br><p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-03.png" alt="img"></p><br><center style="margin-top: 20px">PRPL 模式：离线缓存资源</center><br><p>他们的应用程序外壳程序（骨架 UI）也是离线缓存的，就算用户通过缓慢或不稳定的网络连接加载站点，也会立即加载它们：</p><p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-04.png" alt="img"></p><center>PRPL 模式：应用程序外壳</center><h2 id="为什么选择-PRPL？"><a href="#为什么选择-PRPL？" class="headerlink" title="为什么选择 PRPL？"></a>为什么选择 PRPL？</h2><p>应用使用 PRPL 构建是为了达到可靠、快速和引人入胜的目的。除了这些基本目标，PRPL 还旨在：</p><ul><li><p><strong>改善应用的交互就绪水平</strong>。为了做到这一点，在第一个视图渲染并具备交互能力之前，不会向浏览器发送多余的资源。</p></li><li><p><strong>提高应用的缓存效率，尤其是长期缓存效率</strong>。为了做到这一点，资源会以很细的粒度向浏览器发送。当资源被解绑或松散地打包时，对代码的每次更改给缓存的负面影响也会减少。</p></li><li><p><strong>降低开发和部署的复杂性</strong>。为了做到这一点，这种模式使用应用的隐式依赖图将每个入口点精确映射到所需的资源集，从而减少或消除了手动管理打包和交付的需求。</p></li></ul><h2 id="PRPL-应包含哪些技术？"><a href="#PRPL-应包含哪些技术？" class="headerlink" title="PRPL 应包含哪些技术？"></a>PRPL 应包含哪些技术？</h2><p>PRPL 是一种能以各种方式实现的概念模式，但是通过以下现代 Web 特性的某种组合，可以最轻松有效地实现 PRPL：</p><ul><li><p>像JavaScript Modules这样的现代模块系统，使工具可以轻松构造完整的依赖图；</p></li><li><p>服务Workers，为后续的应用视图预缓存（“安装”）资源（进而支持离线优先架构）</p></li><li><p>预加载，用于尽快交付所需资源。你还可以使用预加载链接头，这些头可以被协作服务器拦截并升级为HTTP/2 Server Push（详情可见<a href="https://www.smashingmagazine.com/2017/04/guide-http2-server-push/">原文</a>）。一定要记住，尽管Push功能强大，但它也面临着许多已知的挑战；不过PRPL使用服务Worker可以避免过度推送的问题（仅针对初始负载使用push）。</p></li></ul><h2 id="如何实现-PRPL-模式？"><a href="#如何实现-PRPL-模式？" class="headerlink" title="如何实现 PRPL 模式？"></a>如何实现 PRPL 模式？</h2><p>PRPL 的很大一部分理念是对 JS 打包思维的颠覆，并在提供资源时拆分成尽可能接近编写资源时的粒度（至少拆分成独立的功能模块）。那么如何实现细粒度呢？</p><h3 id="基于路由或基于组件的代码拆分和延迟加载"><a href="#基于路由或基于组件的代码拆分和延迟加载" class="headerlink" title="基于路由或基于组件的代码拆分和延迟加载"></a>基于路由或基于组件的代码拆分和延迟加载</h3><p>你正在将事物编写为组件。也许你正在使用 ES 模块。对于 Webpack，我们使用动态导入和代码拆分，将你的代码库拆分为按需加载的块。</p><br><p>Next.js 和 Nuxt.js 之类的元框架会默认实现基于路由的代码拆分。如果你使用的是 create-react-app 之类的工具链样板，则需要借助 React Router 之类的路由器进行动态导入，才能将基于路由或基于组件的代码拆分添加到你的应用程序中。</p><br><p>对于 PRPL 的 push/preload 部分，Webpack 还支持将 preload 作为魔术注释来预加载关键脚本。</p><br><h3 id="预缓存"><a href="#预缓存" class="headerlink" title="预缓存"></a>预缓存</h3><p>可以使用服务 worker 预缓存剩余的路由。另一种常见的做法是，利用 Workbox 之类的服务 worker 库来简化为应用程序预缓存路由和块的过程。</p><br><h2 id="PRPL-使用何种应用程序结构？"><a href="#PRPL-使用何种应用程序结构？" class="headerlink" title="PRPL 使用何种应用程序结构？"></a>PRPL 使用何种应用程序结构？</h2><p>PRPL 鼓励采用以下结构的单页应用（SPA）架构：</p><br><ul><li><p>从每个有效路由提供的应用程序的主入口点。</p></li><li><p>这个文件应该很小，因为它将通过不同的URL提供，因此会被多次缓存。入口点中的所有资源URL都必须是绝对的，因为它可以从非顶级URL提供。</p></li><li><p>外壳（app-shell），其中包括顶级应用逻辑、router等。</p></li><li><p>延迟加载的应用片段。</p></li><li><p>可以代表特定视图代码的片段，或其他可以延迟加载的代码（例如，主应用的一些部分在第一次绘制时并不需要，比如说菜单，直到用户与应用交互时才显示）。外壳负责根据需要动态导入这些片段。</p></li></ul><p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-05.png" alt="img"></p><center style="margin: 20px 0 20px 0; ">应用外壳骨架模式</center><p>应用应根据需要调用动态导入以延迟加载片段。例如，当用户更改为新路由时，它将导入与该路由关联的片段。这可能会向服务器发起新请求，或者只是从缓存中加载资源。</p><br><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>除了针对 PWA 的基本目标和标准之外，PRPL 还尽量针对以下方面做了优化：</p><br><ul><li><p>尽量减少交互的准备工作——特别是在首次使用时（无论入口点如何）。</p></li><li><p>尽量提升缓存效率，尤其是更新不断发布后的长期缓存效率。</p></li><li><p>简化开发和部署。</p></li></ul><p>自 2016 年诞生以来，PRPL 模式已获得了大规模使用，值得你在优化应用加载时考虑。</p><p>原文链接：<a href="https://addyosmani.com/blog/the-prpl-pattern/">https://addyosmani.com/blog/the-prpl-pattern/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;PRPL 是一种用于结构化和交付 Web 应用程序和渐进式 Web 应用（PWA）的模式，重点在于改进应用的交付和启动性能。这个模式包含一组步骤，以实现快速、可靠、高效的加载：&lt;/p&gt;</summary>
    
    
    
    <category term="性能优化" scheme="http://example.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="性能优化" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>谈谈登录</title>
    <link href="http://example.com/2021/01/08/%E5%AE%89%E5%85%A8/%E8%B0%88%E8%B0%88%E7%99%BB%E5%BD%95/"/>
    <id>http://example.com/2021/01/08/%E5%AE%89%E5%85%A8/%E8%B0%88%E8%B0%88%E7%99%BB%E5%BD%95/</id>
    <published>2021-01-08T17:57:43.000Z</published>
    <updated>2021-12-22T06:03:57.124Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Cookie与Session"><a href="#一、Cookie与Session" class="headerlink" title="一、Cookie与Session"></a>一、Cookie与Session</h3><p>HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行保存。因为无法管理用户状态，对于要登录的页面，每次跳转新页面时都需要再次登录。</p><a id="more"></a><p>于是引入了Cookie来管理用户状态：</p><p>① 首先客户端发起不带Cookie信息的登录请求</p><p>② 服务端接收到请求，验证用户数据正确后，添加响应头Set-Cookie</p><p>③ 客户端收到响应报文后，检查到响应头Set-Cookie，在本地保存Cookie</p><p>④ 之后每次向该域发起请求时，自动添加请求头Cookie，发送给服务端</p><p>⑤ 服务端获取请求头Cookie，根据Cookie的值，就可以判断出用户是否登录</p><p>但是Cookie极容易被篡改和伪造，于是产生了Session，Session将用户信息保存在服务端，那么Session是如何管理用户状态的呢？</p><p>① 首先客户端发起不带Cookie信息的登录请求</p><p>② 服务端接收到请求，检查到没有携带口令，验证用户密码正确后生成Session，将用户信息保存在Session，设置响应头Set-Cookie，通常是将Session ID作为口令值</p><p>③ 客户端检查到Set-Cookie响应头，在本地保存Cookie信息</p><p>④ 之后每次发起请求时，自动在请求头Cookie中携带口令，发送给服务端</p><p>⑤ 服务端获取Cookie携带的口令值，找到对应的Session，就可以判断用户状态</p><h3 id="二、如何让Session口令值更安全"><a href="#二、如何让Session口令值更安全" class="headerlink" title="二、如何让Session口令值更安全"></a>二、如何让Session口令值更安全</h3><p>虽然口令值由服务端生成，用户不容易伪造，But nothing is impossible；而且口令值存在客户端，就有可能被盗用。一旦口令值被伪造或盗用，攻击者就可以伪装成用户访问服务端的数据。</p><p>那么如何让Session口令值更安全呢？</p><p>① 将客户端的某些独有信息+口令值作为原值，对其进行签名</p><p>② 将口令值拼接签名返回给客户端，将Cookie设置为HttpOnly（禁止用户通过脚本来获取和更改Cookie）</p><p>③ 服务端再次收到请求，取客户端信息与口令值签名，与客户端携带的签名对比，不相等，说明请求不合法</p><p>这样的话：</p><p>① 即使攻击者知道了口令值，由于不知道密钥，无法伪造签名</p><p>② 即使攻击者通过某种方式得到了真实的口令值和签名，但是由于攻击者的客户端信息不一样，发送到服务端后，会得到不一样的签名，签名校验不能通过</p><h3 id="三、多系统的复杂性"><a href="#三、多系统的复杂性" class="headerlink" title="三、多系统的复杂性"></a>三、多系统的复杂性</h3><p>web系统由早期的单系统发展成多系统组成的应用群，面对如此众多的系统，用户难道要一个个登录、再一个个注销吗？</p><p>系统复杂性应该由系统内部承担，而不是用户。无论web系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问web系统的整个应用群与访问单个系统一样，只要登录/注销一次就够了。</p><p><img src="/My-Blogs/images/%E8%B0%88%E8%B0%88%E7%99%BB%E5%BD%95-01.png"></p><p>因为Cookie不允许跨域，早期多系统登录采用将Cookie种在顶级域名下的方式，来实现Cookie共享。这种方式的局限在于：</p><p>① 应用群各系统的域名得统一</p><p>② 应用群各系统的web服务端使用的技术要相同，比如Session口令值以及它的签名</p><p>方式要相同，要不Session口令值不同，无法维持会话</p><p>因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录。</p><h3 id="四、单点登录"><a href="#四、单点登录" class="headerlink" title="四、单点登录"></a>四、单点登录</h3><p>单点登录全称Single Sign On（简称SSO），是指在多系统应用群中登录一个系统，便可在其它所有系统中得到授权而无需再次登录。包括单点登录与单点注销两部分：</p><h4 id="1、单点登录"><a href="#1、单点登录" class="headerlink" title="1、单点登录"></a>1、单点登录</h4><p>　    相比于单系统登录，SSO需要一个独立的认证中心，只有认证中心能接受用户的用    户名密码等安全信息，其它系统不提供登录入口，只接受认证中心的间接授权。</p><p>通常SSO认证中心验证用户数据没问题后，会创建授权Token，分发给各个子系统。子系统拿到Token，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。这个过程，也就是单点登录的原理。</p><p><img src="/My-Blogs/images/%E8%B0%88%E8%B0%88%E7%99%BB%E5%BD%95-02.png"></p><p>例如：</p><p>    用户访问系统1，系统1发现用户未登录，跳转至SSO认证中心，并将自己的地址作为参数</p><p>    SSO认证中心发现用户未登录，将用户引导至登录页面</p><p>    用户输入用户名密码提交登录申请</p><p>    SSO认证中心校验用户信息，创建用户与SSO认证中心之间的会话，称为全局会话，同时创建授权Token</p><p>    SSO认证中心带着Token跳转回最初的请求地址（系统1）</p><p>    系统1拿到Token，去SSO认证中心校验Token是否有效</p><p>    SSO认证中心校验Token，返回有效，注册系统1</p><p>    系统1使用该Token创建与用户的会话，称为局部会话，返回受保护资源</p><p>    用户访问系统2的受保护资源</p><p>    系统2发现用户未登录，跳转至SSO认证中心，并将自己的地址作为参数</p><p>    SSO认证中心发现用户已登录，跳转回系统2的地址，并附上令牌</p><p>    系统2拿到令牌，去SSO认证中心校验令牌是否有效</p><p>    SSO认证中心校验令牌，返回有效，注册系统2</p><p>    系统2使用该令牌创建与用户的局部会话，返回受保护资源</p><p>用户登录成功之后，会与SSO认证中心及各个子系统建立会话，用户与SSO认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过SSO认证中心，全局会话与局部会话有如下约束关系：</p><p>① 局部会话存在，全局会话一定存在</p><p>② 全局会话存在，局部会话不一定存在</p><p>③ 全局会话销毁，局部会话必须销毁</p><p>2、单点注销</p><p>单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁。</p><p><img src="/My-Blogs/images/%E8%B0%88%E8%B0%88%E7%99%BB%E5%BD%95-03.png"></p><p>    用户向系统1发起注销请求</p><p>    系统1根据用户与系统1建立的会话拿到Token，向SSO认证中心发起注销请求</p><p>    SSO认证中心校验Token有效，销毁全局会话，同时取出所有用此Token注册的系统地址</p><p>    SSO认证中心向所有注册系统发起注销请求</p><p>    各注册系统接收SSO认证中心的注销请求，销毁局部会话</p><p>    SSO认证中心引导用户至登录页面</p><h3 id="五、登录安全防范"><a href="#五、登录安全防范" class="headerlink" title="五、登录安全防范"></a>五、登录安全防范</h3><p>1、CSRF攻击</p><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的登录凭证，绕过后台的用户验证，达到冒充用户对被攻击网站执行某项操作的目的。</p><p>一个典型的CSRF攻击有着如下的流程：</p><p>① 受害者登录网站a，并保留了登录凭证Cookie</p><p>② 攻击者引诱受害者访问网站b，它向网站a的服务器发送了一个跨站请求，该请求会默认携带网站a的Cookie</p><p>③ 网站a的服务器接收到请求后，对请求进行验证，确认是受害者的凭证，误以为是受害者自己发送的请求，以受害者的名义执行某个操作</p><p>④ 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让网站a执行了攻击者自己定义的操作</p><p>CSRF通常发生在第三方域名，由于浏览器同源策略的限制，攻击者不能获取到受害者的Cookie信息，只是冒用。针对这2点，我们可以制定相应的防护策略：</p><p>1）同源检测</p><p>服务器通过解析Origin 或Referer这两个请求头，确定请求的来源域，如果请求来自外域，直接阻止。</p><p>缺点：在部分情况下，攻击者可以隐藏甚至修改自己请求的Referer；会误伤一些正常请求，比如通过搜索结果跳转的页面请求。</p><p>2）Samesite Cookie</p><p>为了从源头上解决CSRF攻击，Google起草了一份草案来改进HTTP协议，即为响应头Set-Cookie新增Samesite属性：</p><p>Strict：任何情况下都不可能作为第三方Cookie，其它网站发起的任意请求都不会携带上该Cookie，包括搜索页面。</p><p>Lax：用户在不同网站之间通过链接跳转不受影响；但假如这个请求是从其它网站发起的请求，或者页面跳转是通过表单POST提交触发的，则Cookie也不会携带发送。</p><p>缺点：目前还并不成熟，其应用场景有待观望。</p><p>3）双重Cookie</p><p>①     在用户访问网站页面时，向请求域名注入两个Cookie，一个是原本要注入的Cookie，一个比如随机字符串</p><p>② 前端向后端发起请求时，取出随机字符串，添加到URL参数或请求头中</p><p>③ 后端验证携带的随机数与Cookie中的随机数是否一致，不一致则拒绝请求</p><p>缺点：难以做到子域名隔离，认证Cookie必须被种在顶级域名下，每个子域才可以访问；如果某个子域存在XSS漏洞，攻击者将这个认证Cookie修改为自己配置的Cookie；攻击者直接使用自己配置的Cookie发起CSRF攻击。</p><p>4）CSRF Token</p><p>CSRF攻击者无法直接窃取到用户的Cookie，仅仅是冒用；而CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户的请求。</p><p>① 服务器生成登录Cookie时，同时生成Token和Token签名的2个Cookie</p><p>② 前端向后端发起请求时，将Token添加到URL参数或请求头中</p><p>③ 后端收到请求，首先验证参数与Token相不相同，不相同则中止请求；然后校验签名，不相同则中止请求。因为攻击者不知道密钥，使用Token签名可以防止Cookie被篡改和伪造。</p><p>缺点：每个请求都需要携带Token，且需要服务端对每个请求进行校验。所以一般只对包含敏感数据的请求做此处理。</p><p>2、短信防刷</p><p>短信轰炸是指攻击者利用从各个网站上找到的发送动态短信的URL和前端输入的被攻击者的手机号码，发送HTTP请求，每次请求给用户发送一个动态短信。</p><p>危害：增加公司的运营成本，因为短信是需要计费的；被攻击者大量被动接收非自身请求的短信，造成无法正常使用移动运营商业务；给公司形象造成极大影响，因为一般短信会带公司签名。</p><p>常见防范手段：</p><p>    短信发送间隔设置</p><p>    发送量限制</p><p>    图文验证码</p><p>    触发流程限制</p><h3 id="六、全球部署问题"><a href="#六、全球部署问题" class="headerlink" title="六、全球部署问题"></a>六、全球部署问题</h3><p>Session存在内存里随着用户的增多会导致内存溢出，且不能跨进程、跨机器共享，且重启进程后会导致Session丢失，所以Session通常会存在第三方缓存，比如Redis里。</p><p>Redis全球部署带来的问题在于，已登录的用户再次请求时，如果请求定位到不同集群的Redis，会导致登录状态失效。</p><p>解决方案：</p><p>    不同集群Redis数据同步</p><p>    保证相同集群的Web服务请求同一集群的Redis</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一、Cookie与Session&quot;&gt;&lt;a href=&quot;#一、Cookie与Session&quot; class=&quot;headerlink&quot; title=&quot;一、Cookie与Session&quot;&gt;&lt;/a&gt;一、Cookie与Session&lt;/h3&gt;&lt;p&gt;HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行保存。因为无法管理用户状态，对于要登录的页面，每次跳转新页面时都需要再次登录。&lt;/p&gt;</summary>
    
    
    
    <category term="安全" scheme="http://example.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="安全" scheme="http://example.com/tags/%E5%AE%89%E5%85%A8/"/>
    
    <category term="登录" scheme="http://example.com/tags/%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
</feed>
