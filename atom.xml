<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>John Doe&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-12-20T10:01:53.241Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>https证书自动续签</title>
    <link href="http://example.com/2021/12/20/%E5%AE%89%E5%85%A8/https%E8%AF%81%E4%B9%A6%E8%87%AA%E5%8A%A8%E7%BB%AD%E7%AD%BE/"/>
    <id>http://example.com/2021/12/20/%E5%AE%89%E5%85%A8/https%E8%AF%81%E4%B9%A6%E8%87%AA%E5%8A%A8%E7%BB%AD%E7%AD%BE/</id>
    <published>2021-12-20T17:58:58.000Z</published>
    <updated>2021-12-20T10:01:53.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装说明"><a href="#安装说明" class="headerlink" title="安装说明"></a><a href="https://github.com/acmesh-official/acme.sh/wiki/%E8%AF%B4%E6%98%8E">安装说明</a></h2><h2 id="续签代码"><a href="#续签代码" class="headerlink" title="续签代码"></a>续签代码</h2><pre><code class="BASH">acme.sh --install-cert -d eth2app.com -d test.eth2app.com -d api.eth2app.com -d h5.eth2app.com  -d h5admin.eth2app.com -d rpc.eth2app.com  --key-file       /etc/nginx/ssl/eth2app.com/key.pem  --fullchain-file /etc/nginx/ssl/eth2app.com/cert.pemacme.sh --issue --dns dns_gd -d eth2app.com -d test.eth2app.com -d api.eth2app.com -d h5.eth2app.com -d h5admin.eth2app.com -d rpc.eth2app.com</code></pre><h2 id="DNS-API"><a href="#DNS-API" class="headerlink" title="DNS API"></a><a href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi">DNS API</a></h2><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;安装说明&quot;&gt;&lt;a href=&quot;#安装说明&quot; class=&quot;headerlink&quot; title=&quot;安装说明&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/acmesh-official/acme.sh/wiki/%E8%AF%B4%E6%98%8E&quot;&gt;安装说明&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;续签代码&quot;&gt;&lt;a href=&quot;#续签代码&quot; class=&quot;headerlink&quot; title=&quot;续签代码&quot;&gt;&lt;/a&gt;续签代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;BASH&quot;&gt;acme.sh --install-cert -d eth2app.com -d test.eth2app.com -d api.eth2app.com -d h5.eth2app.com  -d h5admin.eth2app.com -d rpc.eth2app.com  --key-file       /etc/nginx/ssl/eth2app.com/key.pem  --fullchain-file /etc/nginx/ssl/eth2app.com/cert.pem

acme.sh --issue --dns dns_gd -d eth2app.com -d test.eth2app.com -d api.eth2app.com -d h5.eth2app.com -d h5admin.eth2app.com -d rpc.eth2app.com&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;DNS-API&quot;&gt;&lt;a href=&quot;#DNS-API&quot; class=&quot;headerlink&quot; title=&quot;DNS API&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/acmesh-official/acme.sh/wiki/dnsapi&quot;&gt;DNS API&lt;/a&gt;&lt;/h2&gt;</summary>
    
    
    
    <category term="安全" scheme="http://example.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="安全" scheme="http://example.com/tags/%E5%AE%89%E5%85%A8/"/>
    
    <category term="证书" scheme="http://example.com/tags/%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Git常见问题</title>
    <link href="http://example.com/2021/12/18/Git/Git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/12/18/Git/Git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2021-12-18T10:04:28.000Z</published>
    <updated>2021-12-20T10:01:53.222Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="git-pull-和-git-fetch-的区别"><a href="#git-pull-和-git-fetch-的区别" class="headerlink" title="git pull 和 git fetch 的区别"></a>git pull 和 git fetch 的区别</h2><pre><code class="BASH">git fetch 只是将远程仓库的变化下载下来，并没有和本地分支合并。git pull 会将远程仓库的变化下载下来，并和当前分支合并。</code></pre><h2 id="git-rebase-和-git-merge-的区别"><a href="#git-rebase-和-git-merge-的区别" class="headerlink" title="git rebase 和 git merge 的区别"></a>git rebase 和 git merge 的区别</h2><pre><code class="BASH">git merge 和 git rebase 都是用于分支合并，关键在 commit 记录的处理上不同。git merge 会新建一个新的 commit 对象，然后两个分支以前的 commit 记录都指向这个新 commit 记录。这种方法会保留之前每个分支的 commit 历史。git rebase 会先找到两个分支的第一个共同的 commit 祖先记录，然后将提取当前分支这之后的所有 commit 记录，然后将这个 commit 记录添加到目标分支的最新提交后面。经过这个合并后，两个分支合并后的 commit 记录就变为了线性的记录了。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;git-pull-和-git-fetch-的区别&quot;&gt;&lt;a href=&quot;#git-pull-和-git-fetch-的区别&quot; class=&quot;headerlink&quot; title=&quot;git pull 和 git fetch 的区别&quot;</summary>
      
    
    
    
    <category term="git" scheme="http://example.com/categories/git/"/>
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>面试总结-JavaScript篇</title>
    <link href="http://example.com/2021/12/07/JavaScript/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/12/07/JavaScript/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</id>
    <published>2021-12-07T17:22:55.000Z</published>
    <updated>2021-12-20T10:01:53.226Z</updated>
    
    <content type="html"><![CDATA[<p>本章节是<a href="https://github.com/h5bp/Front-end-Developer-Interview-Questions/blob/master/src/questions/javascript-questions.md">前端开发者面试问题 - JS 部分</a>的参考答案。 欢迎提出 PR 进行建议和指正！</p><a id="more"></a><h2 id="请简述JavaScript中的this。​"><a href="#请简述JavaScript中的this。​" class="headerlink" title="请简述JavaScript中的this。​"></a>请简述JavaScript中的this。​</h2><p>JS 中的<code>this</code>是一个相对复杂的概念，不是简单几句能解释清楚的。粗略地讲，函数的调用方式决定了<code>this</code>的值。我阅读了网上很多关于<code>this</code>的文章，<a href="https://medium.com/@arnav_aggarwal">Arnav Aggrawal</a> 写的比较清楚。this取值符合以下规则：</p><ol><li> 在调用函数时使用new关键字，函数内的this是一个全新的对象。</li><li> 如果<code>apply</code>、<code>call</code>或<code>bind</code>方法用于调用、创建一个函数，函数内的 <code>this</code> 就是作为参数传入这些方法的对象。</li><li> 当函数作为对象里的方法被调用时，函数内的this是调用该函数的对象。比如当<code>obj.method()</code>被调用时，函数内的 <code>this</code> 将绑定到obj对象。</li><li> 如果调用函数不符合上述规则，那么this的值指向全局对象（<code>global object</code>）。浏览器环境下this的值指向window对象，但是在严格模式下(<code>'use strict'</code>)，<code>this</code>的值为<code>undefined</code>。</li><li> 如果符合上述多个规则，则较高的规则（1 号最高，4 号最低）将决定<code>this</code>的值。</li><li> 如果该函数是 ES2015 中的箭头函数，将忽略上面的所有规则，<code>this</code>被设置为它被创建时的上下文。</li></ol><h2 id="Object-is-与原来的比较操作符-“-”、“-”-的区别？"><a href="#Object-is-与原来的比较操作符-“-”、“-”-的区别？" class="headerlink" title="Object.is() 与原来的比较操作符 “===”、“==” 的区别？"></a>Object.is() 与原来的比较操作符 “===”、“==” 的区别？</h2><pre><code class="JS">两等号判等，会在比较时进行类型转换。三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回false）。Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true.Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。</code></pre><h2 id="介绍一下-js-的节流与防抖？"><a href="#介绍一下-js-的节流与防抖？" class="headerlink" title="介绍一下 js 的节流与防抖？"></a>介绍一下 js 的节流与防抖？</h2><pre><code class="JS">// 函数防抖： 在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。// 函数节流： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。// 函数防抖的实现function debounce(fn, wait) {  var timer = null;  return function() {    var context = this,      args = arguments;    // 如果此时存在定时器的话，则取消之前的定时器重新记时    if (timer) {      clearTimeout(timer);      timer = null;    }    // 设置定时器，使事件间隔指定事件后执行    timer = setTimeout(() =&gt; {      fn.apply(context, args);    }, wait);  };}// 函数节流的实现;function throttle(fn, delay) {  var preTime = Date.now();  return function() {    var context = this,      args = arguments,      nowTime = Date.now();    // 如果两次时间间隔超过了指定时间，则执行函数。    if (nowTime - preTime &gt;= delay) {      preTime = Date.now();      return fn.apply(context, args);    }  };}</code></pre><h2 id="escape-encodeURI-encodeURIComponent-有什么区别？"><a href="#escape-encodeURI-encodeURIComponent-有什么区别？" class="headerlink" title="escape,encodeURI,encodeURIComponent 有什么区别？"></a>escape,encodeURI,encodeURIComponent 有什么区别？</h2><pre><code class="JS">encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。</code></pre><h2 id="js-的事件循环是什么？"><a href="#js-的事件循环是什么？" class="headerlink" title="js 的事件循环是什么？"></a>js 的事件循环是什么？</h2><h3 id="相关知识点："><a href="#相关知识点：" class="headerlink" title="相关知识点："></a>相关知识点：</h3><pre><code>  事件队列是一个存储着待执行任务的队列，其中的任务严格按照时间先后顺序执行，排在队头的任务将会率先执行，而排在队尾的任务会最后执行。事件队列每次仅执行一个任务，在该任务执行完毕之后，再执行下一个任务。执行栈则是一个类似于函数调用栈的运行容器，当执行栈为空时，JS 引擎便检查事件队列，如果不为空的话，事件队列便将第一个任务压入执行栈中运行。</code></pre><h3 id="回答："><a href="#回答：" class="headerlink" title="回答："></a>回答：</h3><blockquote><p>因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</p></blockquote><blockquote><p>微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。</p></blockquote><blockquote><p>宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。</p></blockquote><h2 id="js-中的深浅拷贝实现？"><a href="#js-中的深浅拷贝实现？" class="headerlink" title="js 中的深浅拷贝实现？"></a>js 中的深浅拷贝实现？</h2><pre><code class="JS">// 浅拷贝的实现;function shallowCopy(object) {  // 只拷贝对象  if (!object || typeof object !== "object") return;  // 根据 object 的类型判断是新建一个数组还是对象  let newObject = Array.isArray(object) ? [] : {};  // 遍历 object，并且判断是 object 的属性才拷贝  for (let key in object) {    if (object.hasOwnProperty(key)) {      newObject[key] = object[key];    }  }  return newObject;}// 深拷贝的实现;function deepCopy(object) {  if (!object || typeof object !== "object") return object;  let newObject = Array.isArray(object) ? [] : {};  for (let key in object) {    if (object.hasOwnProperty(key)) {      newObject[key] = deepCopy(object[key]);    }  }  return newObject;}</code></pre><h3 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h3><blockquote><p>浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用  Object.assign 和展开运算符来实现。深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。</p></blockquote><h2 id="手写-call、apply-及-bind-函数"><a href="#手写-call、apply-及-bind-函数" class="headerlink" title="手写 call、apply 及 bind 函数"></a>手写 call、apply 及 bind 函数</h2><pre><code class="JS">// call函数实现Function.prototype.myCall = function(context) {  // 判断调用对象  if (typeof this !== "function") {    console.error("type error");  }  // 获取参数  let args = [...arguments].slice(1),    result = null;  // 判断 context 是否传入，如果未传入则设置为 window  context = context || window;  // 将调用函数设为对象的方法  context.fn = this;  // 调用函数  result = context.fn(...args);  // 将属性删除  delete context.fn;  return result;};// apply 函数实现Function.prototype.myApply = function(context) {  // 判断调用对象是否为函数  if (typeof this !== "function") {    throw new TypeError("Error");  }  let result = null;  // 判断 context 是否存在，如果未传入则为 window  context = context || window;  // 将函数设为对象的方法  context.fn = this;  // 调用方法  if (arguments[1]) {    result = context.fn(...arguments[1]);  } else {    result = context.fn();  }  // 将属性删除  delete context.fn;  return result;};// bind 函数实现Function.prototype.myBind = function(context) {  // 判断调用对象是否为函数  if (typeof this !== "function") {    throw new TypeError("Error");  }  // 获取参数  var args = [...arguments].slice(1),    fn = this;  return function Fn() {    // 根据调用方式，传入不同绑定值    return fn.apply(      this instanceof Fn ? this : context,      args.concat(...arguments)    );  };};</code></pre><h2 id="函数柯里化的实现"><a href="#函数柯里化的实现" class="headerlink" title="函数柯里化的实现"></a>函数柯里化的实现</h2><pre><code class="JS">// 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。function curry(fn, args) {  // 获取函数需要的参数长度  let length = fn.length;  args = args || [];  return function() {    let subArgs = args.slice(0);    // 拼接得到现有的所有参数    for (let i = 0; i &lt; arguments.length; i++) {      subArgs.push(arguments[i]);    }    // 判断参数的长度是否已经满足函数所需参数的长度    if (subArgs.length &gt;= length) {      // 如果满足，执行函数      return fn.apply(this, subArgs);    } else {      // 如果不满足，递归返回科里化的函数，等待参数的传入      return curry.call(this, fn, subArgs);    }  };}// es6 实现function curry(fn, ...args) {  return fn.length &lt;= args.length ? fn(...args) : curry.bind(null, fn, ...args);}</code></pre><h2 id="什么是-XSS-攻击？如何防范-XSS-攻击？"><a href="#什么是-XSS-攻击？如何防范-XSS-攻击？" class="headerlink" title="什么是 XSS 攻击？如何防范 XSS 攻击？"></a>什么是 XSS 攻击？如何防范 XSS 攻击？</h2><pre><code>XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。XSS 一般分为存储型、反射型和 DOM 型。存储型指的是恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为 HTML 后返回给了用户，从而导致了恶意代码的执行。反射型指的是攻击者构建了特殊的 URL，当服务器接收到请求后，从 URL 中获取数据，拼接到 HTML 后返回，从而导致了恶意代码的执行。DOM 型指的是攻击者构建了特殊的 URL，用户打开网站后，js 脚本从 URL 中获取数据，从而导致了恶意代码的执行。XSS 攻击的预防可以从两个方面入手，一个是恶意代码提交的时候，一个是浏览器执行恶意代码的时候。对于第一个方面，如果我们对存入数据库的数据都进行的转义处理，但是一个数据可能在多个地方使用，有的地方可能不需要转义，由于我们没有办法判断数据最后的使用场景，所以直接在输入端进行恶意代码的处理，其实是不太可靠的。因此我们可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，我们对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。还有一些方式，比如使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。还可以对一些敏感信息进行保护，比如 cookie 使用 http-only ，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。</code></pre><h2 id="什么是-CSP？"><a href="#什么是-CSP？" class="headerlink" title="什么是 CSP？"></a>什么是 CSP？</h2><pre><code class="HTML">CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 &lt;meta http-equiv="Content-Security-Policy"&gt; &lt;/meta&gt;</code></pre><h2 id="什么是-CSRF-攻击？如何防范-CSRF-攻击？"><a href="#什么是-CSRF-攻击？如何防范-CSRF-攻击？" class="headerlink" title="什么是 CSRF 攻击？如何防范 CSRF 攻击？"></a>什么是 CSRF 攻击？如何防范 CSRF 攻击？</h2><pre><code>CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。CSRF 攻击的本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。一般的 CSRF 攻击类型有三种：第一种是 GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。第二种是 POST 类型的 CSRF 攻击，比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。第三种是链接类型的 CSRF 攻击，比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。CSRF 可以用下面几种方法来防护：第一种是同源检测的方法，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。第二种方法是使用 CSRF Token 来进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。第三种方式使用双重 Cookie 验证的办法，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。第四种方式是使用在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</code></pre><h2 id="什么是-Samesite-Cookie-属性？"><a href="#什么是-Samesite-Cookie-属性？" class="headerlink" title="什么是 Samesite Cookie 属性？"></a>什么是 Samesite Cookie 属性？</h2><pre><code>Samesite Cookie 表示同站 cookie，避免 cookie 被第三方所利用。将 Samesite 设为 strict ，这种称为严格模式，表示这个 cookie 在任何情况下都不可能作为第三方 cookie。将 Samesite 设为 Lax ，这种模式称为宽松模式，如果这个请求是个 GET 请求，并且这个请求改变了当前页面或者打开了新的页面，那么这个 cookie 可以作为第三方 cookie，其余情况下都不能作为第三方 cookie。使用这种方法的缺点是，因为它不支持子域，所以子域没有办法与主域共享登录信息，每次转入子域的网站，都回重新登录。还有一个问题就是它的兼容性不够好。</code></pre><h2 id="什么是点击劫持？如何防范点击劫持？"><a href="#什么是点击劫持？如何防范点击劫持？" class="headerlink" title="什么是点击劫持？如何防范点击劫持？"></a>什么是点击劫持？如何防范点击劫持？</h2><pre><code>点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。我们可以在 http 相应头中设置 X-FRAME-OPTIONS 来防御用 iframe 嵌套的点击劫持攻击。通过不同的值，可以规定页面在特定的一些情况才能作为 iframe 来使用。</code></pre><h2 id="什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？"><a href="#什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？" class="headerlink" title="什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？"></a>什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</h2><pre><code>我对 Virtual DOM 的理解是，首先对我们将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后我们将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。当页面的状态发生改变，我们需要对页面的 DOM 的结构进行调整的时候，我们首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。我认为 Virtual DOM 这种方法对于我们需要有大量的 DOM 操作的时候，能够很好的提高我们的操作效率，通过在操作前确定需要做的最小修改，尽可能的减少 DOM 操作带来的重流和重绘的影响。其实 Virtual DOM 并不一定比我们真实的操作 DOM 要快，这种方法的目的是为了提高我们开发时的可维护性，在任意的情况下，都能保证一个尽量小的性能消耗去进行操作。</code></pre><h2 id="如何比较两个-DOM-树的差异？"><a href="#如何比较两个-DOM-树的差异？" class="headerlink" title="如何比较两个 DOM 树的差异？"></a>如何比较两个 DOM 树的差异？</h2><pre><code>两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)。算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样我们才能够复用老的 DOM 树上的节点。</code></pre><h2 id="URL-和-URI-的区别？"><a href="#URL-和-URI-的区别？" class="headerlink" title="URL 和 URI 的区别？"></a>URL 和 URI 的区别？</h2><pre><code>URI: Uniform Resource Identifier      指的是统一资源标识符URL: Uniform Resource Location        指的是统一资源定位符URN: Universal Resource Name          指的是统一资源名称URI 指的是统一资源标识符，用唯一的标识来确定一个资源，它是一种抽象的定义，也就是说，不管使用什么方法来定义，只要能唯一的标识一个资源，就可以称为 URI。URL 指的是统一资源定位符，URN 指的是统一资源名称。URL 和 URN 是 URI 的子集，URL 可以理解为使用地址来标识资源，URN 可以理解为使用名称来标识资源。</code></pre><h2 id="let-和-const-的注意点？"><a href="#let-和-const-的注意点？" class="headerlink" title="let 和 const 的注意点？"></a>let 和 const 的注意点？</h2><ol><li> 声明的变量只在声明时的代码块内有效</li><li> 不存在声明提升</li><li> 存在暂时性死区，如果在变量声明前使用，会报错</li><li> 不允许重复声明，重复声明会报错</li></ol><h2 id="require-模块引入的查找方式？"><a href="#require-模块引入的查找方式？" class="headerlink" title="require 模块引入的查找方式？"></a>require 模块引入的查找方式？</h2><pre><code>当 Node 遇到 require(X) 时，按下面的顺序处理。（1）如果 X 是内置模块（比如 require('http')）　　a. 返回该模块。　　b. 不再继续执行。（2）如果 X 以 "./" 或者 "/" 或者 "../" 开头　　a. 根据 X 所在的父模块，确定 X 的绝对路径。　　b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。    X    X.js    X.json    X.node　　c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。    X/package.json（main字段）    X/index.js    X/index.json    X/index.node（3）如果 X 不带路径　　a. 根据 X 所在的父模块，确定 X 可能的安装目录。　　b. 依次在每个目录中，将 X 当成文件名或目录名加载。（4）抛出 "not found"</code></pre><h2 id="手写一个-Promise"><a href="#手写一个-Promise" class="headerlink" title="手写一个 Promise"></a>手写一个 Promise</h2><pre><code class="JS">const PENDING = "pending";const RESOLVED = "resolved";const REJECTED = "rejected";function MyPromise(fn) {  // 保存初始化状态  var self = this;  // 初始化状态  this.state = PENDING;  // 用于保存 resolve 或者 rejected 传入的值  this.value = null;  // 用于保存 resolve 的回调函数  this.resolvedCallbacks = [];  // 用于保存 reject 的回调函数  this.rejectedCallbacks = [];  // 状态转变为 resolved 方法  function resolve(value) {    // 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变    if (value instanceof MyPromise) {      return value.then(resolve, reject);    }    // 保证代码的执行顺序为本轮事件循环的末尾    setTimeout(() =&gt; {      // 只有状态为 pending 时才能转变，      if (self.state === PENDING) {        // 修改状态        self.state = RESOLVED;        // 设置传入的值        self.value = value;        // 执行回调函数        self.resolvedCallbacks.forEach(callback =&gt; {          callback(value);        });      }    }, 0);  }  // 状态转变为 rejected 方法  function reject(value) {    // 保证代码的执行顺序为本轮事件循环的末尾    setTimeout(() =&gt; {      // 只有状态为 pending 时才能转变      if (self.state === PENDING) {        // 修改状态        self.state = REJECTED;        // 设置传入的值        self.value = value;        // 执行回调函数        self.rejectedCallbacks.forEach(callback =&gt; {          callback(value);        });      }    }, 0);  }  // 将两个方法传入函数执行  try {    fn(resolve, reject);  } catch (e) {    // 遇到错误时，捕获错误，执行 reject 函数    reject(e);  }}MyPromise.prototype.then = function(onResolved, onRejected) {  // 首先判断两个参数是否为函数类型，因为这两个参数是可选参数  onResolved =    typeof onResolved === "function"      ? onResolved      : function(value) {          return value;        };  onRejected =    typeof onRejected === "function"      ? onRejected      : function(error) {          throw error;        };  // 如果是等待状态，则将函数加入对应列表中  if (this.state === PENDING) {    this.resolvedCallbacks.push(onResolved);    this.rejectedCallbacks.push(onRejected);  }  // 如果状态已经凝固，则直接执行对应状态的函数  if (this.state === RESOLVED) {    onResolved(this.value);  }  if (this.state === REJECTED) {    onRejected(this.value);  }};</code></pre><h2 id="开发中常用的几种-Content-Type-？"><a href="#开发中常用的几种-Content-Type-？" class="headerlink" title="开发中常用的几种 Content-Type ？"></a>开发中常用的几种 Content-Type ？</h2><pre><code>（1）application/x-www-form-urlencoded浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。（2）multipart/form-data该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。（3）application/json告诉服务器消息主体是序列化后的 JSON 字符串。（4）text/xml该种方式主要用来提交 XML 格式的数据。</code></pre><h2 id="如何封装一个-javascript-的类型判断函数？"><a href="#如何封装一个-javascript-的类型判断函数？" class="headerlink" title="如何封装一个 javascript 的类型判断函数？"></a>如何封装一个 javascript 的类型判断函数？</h2><pre><code class="JS">function getType(value) {  // 判断数据是 null 的情况  if (value === null) {    return value + "";  }  // 判断数据是引用类型的情况  if (typeof value === "object") {    let valueClass = Object.prototype.toString.call(value),      type = valueClass.split(" ")[1].split("");    type.pop();    return type.join("").toLowerCase();  } else {    // 判断数据是基本数据类型的情况和函数的情况    return typeof value;  }}</code></pre><h2 id="如何判断一个对象是否为空对象？"><a href="#如何判断一个对象是否为空对象？" class="headerlink" title="如何判断一个对象是否为空对象？"></a>如何判断一个对象是否为空对象？</h2><pre><code class="JS">function checkNullObj(obj) {  return Object.keys(obj).length === 0 &amp;&amp; Object.getOwnPropertySymbols(obj).length === 0;}</code></pre><h2 id="手写一个观察者模式？"><a href="#手写一个观察者模式？" class="headerlink" title="手写一个观察者模式？"></a>手写一个观察者模式？</h2><pre><code class="JS">var events = (function() {  var topics = {};  return {    // 注册监听函数    subscribe: function(topic, handler) {      if (!topics.hasOwnProperty(topic)) {        topics[topic] = [];      }      topics[topic].push(handler);    },    // 发布事件，触发观察者回调事件    publish: function(topic, info) {      if (topics.hasOwnProperty(topic)) {        topics[topic].forEach(function(handler) {          handler(info);        });      }    },    // 移除主题的一个观察者的回调事件    remove: function(topic, handler) {      if (!topics.hasOwnProperty(topic)) return;      var handlerIndex = -1;      topics[topic].forEach(function(item, index) {        if (item === handler) {          handlerIndex = index;        }      });      if (handlerIndex &gt;= 0) {        topics[topic].splice(handlerIndex, 1);      }    },    // 移除主题的所有观察者的回调事件    removeAll: function(topic) {      if (topics.hasOwnProperty(topic)) {        topics[topic] = [];      }    }  };})();</code></pre><h2 id="EventEmitter-实现"><a href="#EventEmitter-实现" class="headerlink" title="EventEmitter 实现"></a>EventEmitter 实现</h2><pre><code class="JS">class EventEmitter {  constructor() {    this.events = {};  }  on(event, callback) {    let callbacks = this.events[event] || [];    callbacks.push(callback);    this.events[event] = callbacks;    return this;  }  off(event, callback) {    let callbacks = this.events[event];    this.events[event] = callbacks &amp;&amp; callbacks.filter(fn =&gt; fn !== callback);    return this;  }  emit(event, ...args) {    let callbacks = this.events[event];    callbacks.forEach(fn =&gt; {      fn(...args);    });    return this;  }  once(event, callback) {    let wrapFun = (...args) =&gt; {      callback(...args);      this.off(event, wrapFun);    };    this.on(event, wrapFun);    return this;  }}</code></pre><h2 id="如何确定页面的可用性时间，什么是-Performance-API？"><a href="#如何确定页面的可用性时间，什么是-Performance-API？" class="headerlink" title="如何确定页面的可用性时间，什么是 Performance API？"></a>如何确定页面的可用性时间，什么是 Performance API？</h2><pre><code>Performance API 用于精确度量、控制、增强浏览器的性能表现。这个 API 为测量网站性能，提供以前没有办法做到的精度。使用 getTime 来计算脚本耗时的缺点，首先，getTime方法（以及 Date 对象的其他方法）都只能精确到毫秒级别（一秒的千分之一），想要得到更小的时间差别就无能为力了。其次，这种写法只能获取代码运行过程中的时间进度，无法知道一些后台事件的时间进度，比如浏览器用了多少时间从服务器加载网页。为了解决这两个不足之处，ECMAScript 5引入“高精度时间戳”这个 API，部署在 performance 对象上。它的精度可以达到1毫秒的千分之一（1秒的百万分之一）。navigationStart：当前浏览器窗口的前一个网页关闭，发生 unload 事件时的 Unix 毫秒时间戳。如果没有前一个网页，则等于 fetchStart 属性。loadEventEnd：返回当前网页 load 事件的回调函数运行结束时的 Unix 毫秒时间戳。如果该事件还没有发生，返回 0。</code></pre><p>根据上面这些属性，可以计算出网页加载各个阶段的耗时。比如，网页加载整个过程的耗时的计算方法如下：</p><pre><code class="JS">var t = performance.timing;var pageLoadTime = t.loadEventEnd - t.navigationStart;</code></pre><p>详细资料可以参考： <a href="http://javascript.ruanyifeng.com/bom/performance.html">《Performance API》</a></p><h2 id="Math-ceil-和-Math-floor"><a href="#Math-ceil-和-Math-floor" class="headerlink" title="Math.ceil 和 Math.floor"></a>Math.ceil 和 Math.floor</h2><pre><code class="JS">Math.ceil() === 向上取整，函数返回一个大于或等于给定数字的最小整数。Math.floor() === 向下取整，函数返回一个小于或等于给定数字的最大整数。</code></pre><h2 id="js-for-循环注意点"><a href="#js-for-循环注意点" class="headerlink" title="js for 循环注意点"></a>js for 循环注意点</h2><pre><code class="JS">for (var i = 0, j = 0; i &lt; 5, j &lt; 9; i++, j++) {  console.log(i, j);}// 当判断语句含有多个语句时，以最后一个判断语句的值为准，因此上面的代码会执行 10 次。// 当判断语句为空时，循环会一直进行。</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;本章节是&lt;a href=&quot;https://github.com/h5bp/Front-end-Developer-Interview-Questions/blob/master/src/questions/javascript-questions.md&quot;&gt;前端开发者面试问题 - JS 部分&lt;/a&gt;的参考答案。 欢迎提出 PR 进行建议和指正！&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>面试总结-CSS篇</title>
    <link href="http://example.com/2021/12/06/css/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/12/06/css/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</id>
    <published>2021-12-06T11:43:58.000Z</published>
    <updated>2021-12-20T10:01:53.232Z</updated>
    
    <content type="html"><![CDATA[<p>本章节是<a href="https://github.com/h5bp/Front-end-Developer-Interview-Questions/blob/master/src/questions/css-questions.md">前端开发者面试问题 - CSS 部分</a>的参考答案。 欢迎提出 PR 进行建议和指正！</p><a id="more"></a><h2 id="有哪些清除浮动的技术，都适用哪些情况？​"><a href="#有哪些清除浮动的技术，都适用哪些情况？​" class="headerlink" title="有哪些清除浮动的技术，都适用哪些情况？​"></a>有哪些清除浮动的技术，都适用哪些情况？​</h2><ul><li>空div方法：<code>&lt;div style="clear:both;"&gt;&lt;/div&gt;</code>。</li><li>Clearfix 方法：上文使用<code>.clearfix</code>类已经提到。</li><li><code>overflow: auto</code>或<code>overflow: hidden</code>方法：上文已经提到。</li><li>在大型项目中，我会使用 Clearfix 方法，在需要的地方使用<code>.clearfix</code>。<br>设置<code>overflow: hidden</code>的方法可能使其子元素显示不完整，当子元素的高度大于父元素时。</li></ul><h2 id="如何解决不同浏览器的样式兼容性问题？​"><a href="#如何解决不同浏览器的样式兼容性问题？​" class="headerlink" title="如何解决不同浏览器的样式兼容性问题？​"></a>如何解决不同浏览器的样式兼容性问题？​</h2><ul><li>在确定问题原因和有问题的浏览器后，使用单独的样式表，仅供出现问题的浏览器加载。这种方法需要使用服务器端渲染。</li><li>使用已经处理好此类问题的库，比如 Bootstrap。</li><li>使用 <code>autoprefixer</code> 自动生成 CSS 属性前缀。<br>使用 <a href="http://meyerweb.com/eric/tools/css/reset/">Reset CSS</a> 或 <a href="https://necolas.github.io/normalize.css/">Normalize.css</a>。</li></ul><h2 id="有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？​"><a href="#有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？​" class="headerlink" title="有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？​"></a>有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？​</h2><ul><li><code>width: 0; height: 0</code>：使元素不占用屏幕上的任何空间，导致不显示它。</li><li><code>position: absolute; left: -99999px</code>： 将它置于屏幕之外。</li><li><code>text-indent: -9999px</code>：这只适用于<code>block</code>元素中的文本。</li><li>Metadata： 例如通过使用 Schema.org，RDF 和 JSON-LD。</li><li>WAI-ARIA：如何增加网页可访问性的 W3C 技术规范。<br>即使 WAI-ARIA 是理想的解决方案，我也会采用<code>绝对定位</code>方法，因为它具有最少的注意事项，适用于大多数元素，而且使用起来非常简单。</li></ul><h2 id="什么情况下，用translate-而不用绝对定位？什么时候，情况相反。​"><a href="#什么情况下，用translate-而不用绝对定位？什么时候，情况相反。​" class="headerlink" title="什么情况下，用translate()而不用绝对定位？什么时候，情况相反。​"></a>什么情况下，用translate()而不用绝对定位？什么时候，情况相反。​</h2><ul><li><code>translate()</code>是<code>transform</code>的一个值。改变<code>transform</code>或<code>opacity</code>不会触发浏览器重新布局（<code>reflow</code>）或重绘（<code>repaint</code>），只会触发复合（<code>compositions</code>）。而改变绝对定位会触发重新布局，进而触发重绘和复合。</li><li><code>transform</code>使浏览器为元素创建一个 GPU 图层，但改变绝对定位会使用到 CPU。 因此<code>translate()</code>更高效，可以缩短平滑动画的绘制时间。</li></ul><p>当使用<code>translate()</code>时，元素仍然占据其原始空间（有点像<code>position：relative</code>），这与改变绝对定位不同。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本章节是&lt;a href=&quot;https://github.com/h5bp/Front-end-Developer-Interview-Questions/blob/master/src/questions/css-questions.md&quot;&gt;前端开发者面试问题 - CSS 部分&lt;/a&gt;的参考答案。 欢迎提出 PR 进行建议和指正！&lt;/p&gt;</summary>
    
    
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>面试总结-HTML篇</title>
    <link href="http://example.com/2021/12/06/HTML/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/12/06/HTML/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</id>
    <published>2021-12-06T09:47:29.000Z</published>
    <updated>2021-12-20T10:01:53.223Z</updated>
    
    <content type="html"><![CDATA[<p>本章节是<a href="https://frontendinterviewhandbook.com/zh/html-questions/">前端开发者面试问题 - HTML</a> 部分的参考答案。 欢迎提出 PR 进行建议和指正！</p><a id="more"></a><h2 id="DOCTYPE有什么用？"><a href="#DOCTYPE有什么用？" class="headerlink" title="DOCTYPE有什么用？"></a>DOCTYPE有什么用？</h2><p>在页面开始处添加<code>&lt;!DOCTYPE html&gt;</code>即可。</p><h2 id="如何提供包含多种语言内容的页面？"><a href="#如何提供包含多种语言内容的页面？" class="headerlink" title="如何提供包含多种语言内容的页面？"></a>如何提供包含多种语言内容的页面？</h2><ol><li> HTML 文档还应在<code>&lt;html&gt;</code>标签中声明<code>lang</code>属性，比如<code>&lt;html lang="en"&gt;...&lt;/html&gt;</code></li><li> 客户端向服务器发送 <code>HTTP</code> 请求时，通常会发送有关语言首选项的信息，比如使用<code>Accept-Language</code>请求头</li></ol><h2 id="在设计开发多语言网站时，需要留心哪些事情？"><a href="#在设计开发多语言网站时，需要留心哪些事情？" class="headerlink" title="在设计开发多语言网站时，需要留心哪些事情？"></a>在设计开发多语言网站时，需要留心哪些事情？</h2><ol><li> 引导用户切换到自己的母语，在 HTML 中使用<code>lang</code>属性</li><li> 限制词语或句子的长度</li><li> 不要使用连接的翻译字符串，这样做可能会打乱其他语言的语序，应该为每种语言编写带变量替换的模版字符串。<code>I will travel on {% date %}</code>和<code>{% date %}</code> 我会出发。</li></ol><h2 id="请描述-lt-script-gt-、-lt-script-async-gt-和-lt-script-defer-gt-的区别。"><a href="#请描述-lt-script-gt-、-lt-script-async-gt-和-lt-script-defer-gt-的区别。" class="headerlink" title="请描述<script>、<script async>和<script defer>的区别。"></a>请描述<code>&lt;script&gt;</code>、<code>&lt;script async&gt;</code>和<code>&lt;script defer&gt;</code>的区别。</h2><ol><li> <code>&lt;script&gt;</code> - HTML 解析中断，脚本被提取并立即执行。执行结束后，HTML 解析继续。</li><li> <code>&lt;script async&gt;</code> - 脚本的提取、执行的过程与 HTML 解析过程并行，脚本执行完毕可能在 HTML 解析完毕之前。当脚本与页面上其他脚本独立时，可以使用async，比如用作页面统计分析。</li><li> <code>&lt;script defer&gt;</code> - 脚本仅提取过程与 HTML 解析过程并行，脚本的执行将在 HTML 解析完毕后进行。如果有多个含defer的脚本，脚本的执行顺序将按照在 document 中出现的位置，从上到下顺序执行。</li></ol><p>注意：没有<code>src</code>属性的脚本，<code>async</code>和<code>defer</code>属性会被忽略。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本章节是&lt;a href=&quot;https://frontendinterviewhandbook.com/zh/html-questions/&quot;&gt;前端开发者面试问题 - HTML&lt;/a&gt; 部分的参考答案。 欢迎提出 PR 进行建议和指正！&lt;/p&gt;</summary>
    
    
    
    <category term="HTML" scheme="http://example.com/categories/HTML/"/>
    
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>使用 CURL 上传文件</title>
    <link href="http://example.com/2021/06/23/Linux/shell/%E8%AF%B7%E6%B1%82/%E4%BD%BF%E7%94%A8%20CURL%20%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2021/06/23/Linux/shell/%E8%AF%B7%E6%B1%82/%E4%BD%BF%E7%94%A8%20CURL%20%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/</id>
    <published>2021-06-23T16:30:40.000Z</published>
    <updated>2021-12-20T10:01:53.229Z</updated>
    
    <content type="html"><![CDATA[<p>CURL 是一个强大的向服务器发送请求的工具， 尤其是在测试 API 的时候。</p><a id="more"></a><p>很多人像寻常表单一样使用了 <code>-X POST</code> 方式来使用 CURL 去上传文件，但实际上这是错误的。<br>正确的方式是使用 <strong>-F (–form)</strong> 来上传文件，这样才会给请求添加 enctype=<code>"multipart/form-data"</code> 参数。</p><pre><code class="BASH">curl -F 'data=@path/to/local/file’ UPLOAD_ADDRES</code></pre><p>例如， 如果我想向服务器 <code>http://localhost/upload</code> 上传位于<code>/home/petehouston/hello.txt</code>的文件，并将上传的文件的参数命名为 <code>img_avatar</code>, 我可以这样发送请求,</p><pre><code class="BASH">curl -F 'img_avatar=@/home/petehouston/hello.txt' http://localhost/upload</code></pre><h2 id="上传多个文件"><a href="#上传多个文件" class="headerlink" title="上传多个文件"></a>上传多个文件</h2><p>想要同时上传多个文件的话，只需要添加多个 -F 选项就可以了。</p><pre><code class="BASH">curl -F 'fileX=@/path/to/fileX' -F 'fileY=@/path/to/fileY' ... http://localhost/upload</code></pre><h2 id="上传文件数组"><a href="#上传文件数组" class="headerlink" title="上传文件数组"></a>上传文件数组</h2><pre><code class="BASH">curl -F 'files[]=@/path/to/fileX' -F 'files[]=@/path/to/fileY' ... http://localhost/upload</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;CURL 是一个强大的向服务器发送请求的工具， 尤其是在测试 API 的时候。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="shell" scheme="http://example.com/tags/shell/"/>
    
    <category term="curl" scheme="http://example.com/tags/curl/"/>
    
    <category term="上传文件" scheme="http://example.com/tags/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>电商-商品设计</title>
    <link href="http://example.com/2021/04/26/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%94%B5%E5%95%86-%E5%95%86%E5%93%81%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2021/04/26/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%94%B5%E5%95%86-%E5%95%86%E5%93%81%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-04-26T16:27:08.000Z</published>
    <updated>2021-12-20T10:01:53.243Z</updated>
    
    <content type="html"><![CDATA[<p>电商数据库设计之商品设计。</p><a id="more"></a><p><img src="/My-Blogs/images/%E7%94%B5%E5%95%86-%E5%95%86%E5%93%81%E8%AE%BE%E8%AE%A1.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;电商数据库设计之商品设计。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="电商" scheme="http://example.com/tags/%E7%94%B5%E5%95%86/"/>
    
  </entry>
  
  <entry>
    <title>screen 常用命令</title>
    <link href="http://example.com/2021/04/25/Linux/shell/%E7%AA%97%E5%8F%A3/screen%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2021/04/25/Linux/shell/%E7%AA%97%E5%8F%A3/screen%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2021-04-25T21:49:24.000Z</published>
    <updated>2021-12-20T10:01:53.229Z</updated>
    
    <content type="html"><![CDATA[<p>screen 常用命令介绍</p><a id="more"></a><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><pre><code class="BASH">screen -ls              # 查看所有screenscreen -S &lt;screen-name&gt; # 创建screen，并命名ctr + A, D              # 快捷键，退出当前screenscreen -r &lt;screen-name&gt; # 进入screenscreen -X quit          # 删除screen，但没有指定会话screen -X -S [session you want to kill] quit #删除screen，指定会话screen -wipe            # 清除dead screens</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;screen 常用命令介绍&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="shell" scheme="http://example.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>在nest中使用typeorm-model-generator自动生成实体</title>
    <link href="http://example.com/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93/TypeOrm/%E5%9C%A8nest%E4%B8%AD%E4%BD%BF%E7%94%A8typeorm-model-generator%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%AE%9E%E4%BD%93/"/>
    <id>http://example.com/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93/TypeOrm/%E5%9C%A8nest%E4%B8%AD%E4%BD%BF%E7%94%A8typeorm-model-generator%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%AE%9E%E4%BD%93/</id>
    <published>2021-04-21T12:35:23.000Z</published>
    <updated>2021-12-20T10:01:53.243Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下nestjs框架使用typeorm自动生成实体类的方法。可以节省一些开发时间</p><a id="more"></a><ol><li><p><code>npm i -g typeorm-model-generator</code> 或者 <code>yarn global add typeorm-model-generator</code></p></li><li><p>修改项目中的 <code>package.json</code> 文件  </p><pre><code class="json">"scripts": {"db": "rimraf ./src/modules/entities &amp; npx typeorm-model-generator -h 121.36.70.68 -d chat -p 3306 -u root -x 123456 -e mysql -o ./src/modules/entities --noConfig true --ce pascal --cp camel"}</code></pre><ul><li><code>rm -rf entities</code>表示先删除文件夹<code>entities（window下使用 rimraf entities ）</code></li><li><code>npx typeorm-model-generator</code>如果全局安装了就不需要加npx没有全局安装就加上去</li><li><code>-h localhost -d 数据库名字 -p 端口 -u 用户名 -x 密码 -e 数据库类型</code></li><li><code>-o entities</code>表示输出到指定的文件夹</li><li><code>--noConfig true</code>表示不生成<code>ormconfig.json</code>和<code>tsconfig.json</code>文件</li><li><code>--ce pascal</code>表示将类名转换首字母是大写的驼峰命名</li><li><code>--cp camel</code>表示将数据库中的字段比如create_at转换为createAt</li><li><code>-a</code>表示会继承一个<code>BaseEntity</code>的类,根据自己需求加</li></ul></li><li><p> 运行代码 <code>npm run db</code> 或 <code>yarn db</code></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结一下nestjs框架使用typeorm自动生成实体类的方法。可以节省一些开发时间&lt;/p&gt;</summary>
    
    
    
    <category term="MYSQL" scheme="http://example.com/categories/MYSQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="nestjs" scheme="http://example.com/tags/nestjs/"/>
    
  </entry>
  
  <entry>
    <title>zip命令的基本使用</title>
    <link href="http://example.com/2021/02/22/Linux/shell/%E6%96%87%E4%BB%B6/zip%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2021/02/22/Linux/shell/%E6%96%87%E4%BB%B6/zip%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2021-02-22T10:24:04.000Z</published>
    <updated>2021-12-20T10:01:53.229Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇关于zip命令的简单使用</p><a id="more"></a><h2 id="命令简介"><a href="#命令简介" class="headerlink" title="命令简介"></a>命令简介</h2><p>zip 命令可以用来压缩、打包文件。</p><pre><code class="BASH">#Debian/Ubuntu安装apt-get&nbsp;install&nbsp;zip#CentOS安装[root@centos7&nbsp;testdir]#&nbsp;zip-bash:&nbsp;zip:&nbsp;command&nbsp;not&nbsp;found[root@centos7&nbsp;testdir]#&nbsp;yum&nbsp;install&nbsp;zip&nbsp;-y</code></pre><p>zip 命令也可以用来解压缩文件，zip也是一个常用的压缩、解压应用程序，文件经它压缩后会产生一个新以.zip为扩展名的压缩包文件。</p><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><pre><code class="BASH">zip&nbsp;[&nbsp;OPTIONS&nbsp;]&nbsp;[&nbsp;NAME&nbsp;..]</code></pre><h2 id="选项说明"><a href="#选项说明" class="headerlink" title="选项说明"></a>选项说明</h2><pre><code class="BASH">-A  #调整可执行的自动解压缩文件-b&lt;工作目录&gt;  #指定压缩文件的存放目录-c  #给每个被压缩的文件加上注释信息-d  #从压缩文件内删除指定的文件，也可以使用--delete参数-D  #压缩文件内不建立目录名称-f  #更新既有文件，将其它文件一并加入到压缩文件中-F  #修复已损坏的压缩文件-g  #将指定文件压缩至已存在的压缩文件中，不建立新文件-h  #打印帮助信息-i&lt;范本样式&gt;  #只压缩匹配指定条件的文件-m  #将指定文件压缩打包后直接删除原始文件-o  #将压缩文件的属性信息更改成与压缩文件中的最新文件的属性一致-q  #安静模式-r  #递归处理-t&lt;日期时间&gt;  #把压缩文件的日期设成指定的日期-T  #检查备份文件内的每个文件是否正确无误-u  #更新较新的文件到压缩文件内-v  #打印命令执行过程信息或版本信息-x&lt;范本样式&gt;  #压缩时排除符合条件的文件-z  #给压缩文件加上注释信息-&lt;压缩效率&gt;  #指定压缩效率（1~9数字）</code></pre><h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><p>在当前目录下创建压缩文件（自动创建以.zip的文件）</p><pre><code class="BASH">[root@centos7 testdir]# zip mingongge *  adding: cest.txt.gz (stored 0%)  adding: cuttest.txt.gz (stored 0%)  adding: dir/ (stored 0%)  adding: file (stored 0%)  adding: mingongge1.txt.gz (stored 0%)  adding: mingongge2.txt.gz (stored 0%)  adding: mingongge.txt.md5.gz (stored 0%)  adding: sort.cut.txt.gz (stored 0%)</code></pre><p>分割一个大文件</p><pre><code class="BASH">[root@centos7&nbsp;~]#&nbsp;ls&nbsp;-lhtotal&nbsp;22M-rw-------.&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;1.3K&nbsp;Aug&nbsp;20&nbsp;10:39&nbsp;anaconda-ks.cfg-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;140&nbsp;Jan&nbsp;16&nbsp;11:36&nbsp;dos_test.txtdrwxr-xr-x&nbsp;&nbsp;&nbsp;3&nbsp;root&nbsp;root&nbsp;&nbsp;&nbsp;39&nbsp;Aug&nbsp;30&nbsp;03:48&nbsp;goinception-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;13M&nbsp;Aug&nbsp;30&nbsp;03:42&nbsp;goInception-linux-amd64-v1.2.3.tar.gzdrwxr-sr-x&nbsp;&nbsp;11&nbsp;root&nbsp;&nbsp;&nbsp;40&nbsp;4.0K&nbsp;Dec&nbsp;24&nbsp;22:35&nbsp;httpd-2.4.46-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;9.0M&nbsp;Aug&nbsp;&nbsp;5&nbsp;07:32&nbsp;httpd-2.4.46.tar.gz-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;Jan&nbsp;16&nbsp;11:32&nbsp;mingongge.filedrwxr-xr-x&nbsp;&nbsp;&nbsp;3&nbsp;root&nbsp;root&nbsp;&nbsp;192&nbsp;Jan&nbsp;16&nbsp;16:19&nbsp;testdir-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;140&nbsp;Jan&nbsp;16&nbsp;11:32&nbsp;test.txt[root@centos7&nbsp;~]#&nbsp;zip&nbsp;-s&nbsp;4M&nbsp;-r&nbsp;mingongge.zip&nbsp;httpd-2.4.46.tar.gz&nbsp;&nbsp;adding:&nbsp;httpd-2.4.46.tar.gz&nbsp;(deflated&nbsp;0%)[root@centos7&nbsp;~]#&nbsp;ls&nbsp;-lhtotal&nbsp;31M-rw-------.&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;1.3K&nbsp;Aug&nbsp;20&nbsp;10:39&nbsp;anaconda-ks.cfg-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;140&nbsp;Jan&nbsp;16&nbsp;11:36&nbsp;dos_test.txtdrwxr-xr-x&nbsp;&nbsp;&nbsp;3&nbsp;root&nbsp;root&nbsp;&nbsp;&nbsp;39&nbsp;Aug&nbsp;30&nbsp;03:48&nbsp;goinception-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;13M&nbsp;Aug&nbsp;30&nbsp;03:42&nbsp;goInception-linux-amd64-v1.2.3.tar.gzdrwxr-sr-x&nbsp;&nbsp;11&nbsp;root&nbsp;&nbsp;&nbsp;40&nbsp;4.0K&nbsp;Dec&nbsp;24&nbsp;22:35&nbsp;httpd-2.4.46-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;9.0M&nbsp;Aug&nbsp;&nbsp;5&nbsp;07:32&nbsp;httpd-2.4.46.tar.gz-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;Jan&nbsp;16&nbsp;11:32&nbsp;mingongge.file-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;4.0M&nbsp;Jan&nbsp;16&nbsp;16:24&nbsp;mingongge.z01-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;4.0M&nbsp;Jan&nbsp;16&nbsp;16:24&nbsp;mingongge.z02-rw-r--r--&nbsp;&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;943K&nbsp;Jan&nbsp;16&nbsp;16:24&nbsp;mingongge.zipdrwxr-xr-x&nbsp;&nbsp;&nbsp;3&nbsp;root&nbsp;root&nbsp;&nbsp;192&nbsp;Jan&nbsp;16&nbsp;16:19&nbsp;testdir#从结果可以看出会拆分成三个文件即：4M大小的mingongge.z01、4M大小的mingongge.z02和一个943k的mingongge.zip文件。</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一篇关于zip命令的简单使用&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="shell" scheme="http://example.com/tags/shell/"/>
    
    <category term="文件处理" scheme="http://example.com/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>tar命令的基本使用</title>
    <link href="http://example.com/2021/02/20/Linux/shell/%E6%96%87%E4%BB%B6/tar%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2021/02/20/Linux/shell/%E6%96%87%E4%BB%B6/tar%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2021-02-20T10:24:04.000Z</published>
    <updated>2021-12-20T10:01:53.228Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇关于tar命令的简单使用</p><a id="more"></a><h2 id="命令简介"><a href="#命令简介" class="headerlink" title="命令简介"></a>命令简介</h2><p>tar 命令用于打包、压缩与解压压缩包文件。</p><p>tar 命令常常用于打包、压缩某些文件或目录，也可以添加新文件到归档文件中。Tar 代表的是磁带存档，是一种归档的文件格式，早期用于将文件归档到磁带备份存储。现可以用于收集、分发、归档文件，还可以保留文件原有的属性，如：用户和组权限，访问和修改日期以及目录结构。</p><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><pre><code class="BASH">tar&nbsp;[OPTIONS]&nbsp;[FILE]</code></pre><h2 id="选项说明"><a href="#选项说明" class="headerlink" title="选项说明"></a>选项说明</h2><pre><code class="BASH">-A&nbsp;&nbsp;#新增文件到已经存在的归档文件-B&nbsp;&nbsp;#设置区块大小-c&nbsp;&nbsp;#建立新的归档文件-C&nbsp;&nbsp;#将压缩的文件解压到指定的目录下-d&nbsp;&nbsp;#记录文件的差异-x&nbsp;&nbsp;#解压或提取归档文件内容 -t&nbsp;&nbsp;#列出备份文件的内容-z&nbsp;&nbsp;#通过gzip命令来压缩/解压缩文件，文件名一般为&nbsp;xx.tar.gz-Z&nbsp;&nbsp;#通过compress命令处理备份文件-f&nbsp;&nbsp;#指定备份文件-v&nbsp;&nbsp;#显示命令执行过程-r&nbsp;&nbsp;#添加新文件到已经压缩的文件中-u&nbsp;&nbsp;#添加改变了和现有的文件到已经存在的压缩文件-j&nbsp;&nbsp;#通过bzip2命令来压缩/解压缩文件，文件名一般为xx.tar.bz2-v&nbsp;&nbsp;#显示操作过程；-k&nbsp;&nbsp;#保留原有文件不覆盖-m&nbsp;&nbsp;#保留文件不被覆盖-w&nbsp;&nbsp;#确认压缩文件的正确性-p&nbsp;&nbsp;#保留原来的文件权限与属性-P&nbsp;&nbsp;#使用文件名的绝对路径，不删除文件名称前的“/”号-N&nbsp;&nbsp;#只将较指定日期更新的文件保存到备份文件中--exclude=[范本样式]&nbsp;&nbsp;#排除符合范本样式的文件--remove-files&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#归档/压缩之后删除源文件</code></pre><h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><p>常见应用例子</p><pre><code class="BASH">tar&nbsp;-cf&nbsp;mingongge.tar&nbsp;*.jpg#将所有.jpg的文件打包成一个名为mingongge.tar的文件&nbsp;tar&nbsp;-rf&nbsp;mingongge.tar&nbsp;*.gif#将所有.gif的文件增加到mingongge.tar的包里&nbsp;tar&nbsp;-uf&nbsp;mingonggel.tar&nbsp;mingongge.gif#更新mingongge.tar文件中的mingongge.gif文件&nbsp;tar&nbsp;-tf&nbsp;mingongge.tar#列出&nbsp;all.tar&nbsp;包中所有文件tar&nbsp;-cfv&nbsp;mingongge.tar&nbsp;foo&nbsp;bar&nbsp;&nbsp;#将文件foo和bar打包成mingongge.tar文件包，也可以理解成：从这两个文件中去创建这个mingongge.tar文件tar&nbsp;-tvf&nbsp;mingongge.tar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#详细列出mingongge.tar中的所有文件tar&nbsp;-xf&nbsp;mingongge.tar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#从mingongge.tar提取所有文件</code></pre><p>将文件全部打包成tar包</p><pre><code class="BASH">tar&nbsp;-cvf&nbsp;mingongg.tar&nbsp;mingongg.log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#仅打包，不压缩！tar&nbsp;-zcvf&nbsp;mingongg.tar.gz&nbsp;mingongg.log&nbsp;&nbsp;&nbsp;#打包后，以gzip方式压缩tar&nbsp;-jcvf&nbsp;mingongg.tar.bz2&nbsp;mingongg.log&nbsp;&nbsp;#打包后，以bzip2方式压缩</code></pre><p>解压目录</p><pre><code class="BASH">tar&nbsp;-xvf&nbsp;portal-web-v2.0.0.tar&nbsp;--strip-components&nbsp;1&nbsp;&nbsp;-C&nbsp;指定目录#排除目录--strip-components</code></pre><p>将 tar包解压缩</p><pre><code class="BASH">tar&nbsp;-zxvf&nbsp;/opt/soft/test/log.tar.gz</code></pre><p>打包或压缩文件时，排队指定的文件类型</p><pre><code class="BASH">tar&nbsp;-zcf&nbsp;mingongge.tar.gz&nbsp;/etc/&nbsp;/var/&nbsp;--exclude=*.txt</code></pre><p>注意：如果在使用过程中遇到这类错误提示</p><pre><code class="BASH">tar:&nbsp;Removing&nbsp;leading&nbsp;`/`&nbsp;from&nbsp;member&nbsp;names </code></pre><p>原因是tar默认为相对路径，使用绝对路径的话就会报这个错，可以使用-P（大写）参数解决这个问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一篇关于tar命令的简单使用&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="shell" scheme="http://example.com/tags/shell/"/>
    
    <category term="文件处理" scheme="http://example.com/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>ES6笔记</title>
    <link href="http://example.com/2021/02/07/JavaScript/ES6%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/02/07/JavaScript/ES6%E7%AC%94%E8%AE%B0/</id>
    <published>2021-02-07T11:15:02.000Z</published>
    <updated>2021-12-20T10:01:53.223Z</updated>
    
    <content type="html"><![CDATA[<p>总结一些比较需要注意的ES6语法。</p><a id="more"></a><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="TDZ-暂时性死区"><a href="#TDZ-暂时性死区" class="headerlink" title="TDZ(暂时性死区)"></a>TDZ(暂时性死区)</h3><ul><li>当使用let，const声明语句时，还未执行的时候，变量会存入TDZ(暂时性死区)，引用语句时，会抛出错误。</li><li>类声明与let声明类似，不能被提升；真正执行声明语句之前，它们会一直存在于临时死区中。</li></ul><pre><code class="JS">console.log(typeof value); // throw ReferenceError: Cannot access 'value' before initializationlet value = 'string';</code></pre><h3 id="更好的Unicode支持"><a href="#更好的Unicode支持" class="headerlink" title="更好的Unicode支持"></a>更好的Unicode支持</h3><p>以后做字符处理时，优先选择codePoint相关方法， <code>String.fromCodePoint</code> 可以同时处理BMP和非BMP字符，即支持0xFFFF以上的字符解析</p><pre><code class="JS">String.fromCodePoint(97); // aString.fromCharCode(97); // a</code></pre><h3 id="函数形参的默认值"><a href="#函数形参的默认值" class="headerlink" title="函数形参的默认值"></a>函数形参的默认值</h3><p>可以利用以下特性，对入参做些预处理</p><pre><code class="JS">function add(first, second = first) {  return first + second;}</code></pre><h3 id="新增方法"><a href="#新增方法" class="headerlink" title="新增方法"></a>新增方法</h3><p>比起 <code>===</code> 判断两个变量是否一致，Object.is()会更完善，优先使用它</p><pre><code class="JS">console.log(+0 === -0); // trueconsole.log(Object.is(+0, -0)); // falseconsole.log(NaN === NaN); // falseconsole.log(Object.is(NaN, NaN)); // true</code></pre><h3 id="自由属性枚举顺序"><a href="#自由属性枚举顺序" class="headerlink" title="自由属性枚举顺序"></a>自由属性枚举顺序</h3><p><code>Object.getOwnPropertyNames</code> 返回一个数组，它包含了指定对象所有的可枚举或不可枚举的属性名，而 <code>Object.keys</code> 返回一个包含所有给定对象自身可枚举属性名称的数组。</p><pre><code class="JS">var a = {};Object.defineProperties(a, {  one: {    enumerable: true,    value: 1  },  two: {    enumerable: false,    value: 2  },});Object.keys(a); // ["one"]Object.getOwnPropertyNames(a); // ["one", "two"]</code></pre><h3 id="Symbol共享"><a href="#Symbol共享" class="headerlink" title="Symbol共享"></a>Symbol共享</h3><p>如果想创建一个可共享的Symbol，要使用Symbol.for()方法。它只接受一个参数。</p><pre><code class="JS">let uid = Symbo.for('uid');let object = {};object[uid] = '12345';console.log(object[uid]); // "12345"console.log(uid); // "Symbol(uid)"</code></pre><blockquote><p><code>Symbol.for()</code> 方法首先在全局Symbol注册表中搜索键为”uid”的Symbol是否存在，如果存在，直接返回已有的Symbol；否则，创建一个新的Symbol，并使用这个键在Symbol全局注册表中注册，随即返回新创建的Symbol。</p></blockquote><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul><li>Set不允许相同的值存在两个，所以可以使用Set去重，比如<code>[...new Set([1, 3, 1])]</code>; </li><li>在Set集合中，不会对所存值进行强制的类型转换，数字5和字符串“5”可以作为两个独立元素存在。</li><li>add, delete, has类似数组的push、splice、includes。</li><li>在Set存放对象，当对象的引用清除了，也不会释放，调用delete或者clear，还可以使用WeakSet，存放弱引用。</li></ul><h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><ul><li>WeakSet没有Set诸如add, has, delete, forEach, size等方法和属性，也不可迭代</li><li>只适合用来跟踪对象引用。</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li>与Object相比，键值支持对象作为属性，”5”、5将作为不同的key，而Object会调用toString将5转化为字符串，两个键值将冲突。</li><li>set, get, delete, has, clear方法，size属性。</li><li>forEach。</li></ul><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><ul><li>类似WeakSet，Key存放对象的弱引用，当该对象的所有强引用都被清除时，WeakMap中对应的弱引用键及其对应的值也会自动被GC。</li></ul><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul><li>本质就是调用对象的next方法 每次调用next，返回{ value: xxx, done: false }对象，当done为true表示迭代结束。</li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li>类数组对象（具有数值型索引和length属性的对象）。</li><li>定型数组，节省内存，JS数字是以64位浮点格式存储。</li><li>数组缓冲区 ArrayBuffer，类似C语言的<code>malloc</code>分配内存。<code>DataView</code>数据视图，用来操作数组缓存区的数据。</li><li>特定类型视图，Int8Array等。<br><img src="/My-Blogs/images/ES6%E7%AC%94%E8%AE%B0/ES6%E7%AC%94%E8%AE%B0-01.png" alt="img">。</li></ul><h3 id="Promise与异步编程"><a href="#Promise与异步编程" class="headerlink" title="Promise与异步编程"></a>Promise与异步编程</h3><h3 id="代理-Proxy-和反射Reflection"><a href="#代理-Proxy-和反射Reflection" class="headerlink" title="代理(Proxy)和反射Reflection"></a>代理(Proxy)和反射Reflection</h3><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ul><li>不管在import语句中把一个模块写了多少次，该模块将只执行一次。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结一些比较需要注意的ES6语法。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="ES6" scheme="http://example.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>deno的初体验</title>
    <link href="http://example.com/2021/01/19/Deno/deno%E7%9A%84%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://example.com/2021/01/19/Deno/deno%E7%9A%84%E5%88%9D%E4%BD%93%E9%AA%8C/</id>
    <published>2021-01-19T18:40:52.000Z</published>
    <updated>2021-12-20T10:01:53.221Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇关于deno初体验文章</p><a id="more"></a><h2 id="Deno-–-小而美的脚本运行时"><a href="#Deno-–-小而美的脚本运行时" class="headerlink" title="Deno – 小而美的脚本运行时"></a><a href="https://deno.land/">Deno</a> – 小而美的脚本运行时</h2><blockquote><p>a simple, modern and secure runtime for JavaScript and TypeScript that uses V8 and is built in Rust。</p></blockquote><p>Dahl（Node.js 的创始人之一）在2017年创建，Rust 语言开发。 <code>deno</code> 音译帝诺，恐龙(dinosaur)的简称，<code>deno</code> 这个名字就是来自 Node 的字母重新组合（Node = no + de），表示”拆除 Node.js”（de = destroy, no = Node.js）。</p><h2 id="创建原由"><a href="#创建原由" class="headerlink" title="创建原由"></a>创建原由</h2><ul><li>Node.js Callback hell。</li><li>原生支持CommonJs，对ES模块不兼容。</li><li>npm(你怕吗)模块管理工具，npm_modules 极其庞杂，还有Dependency Hell，版本重复问题等问题，极难管理。详情可查看<a href="https://juejin.cn/post/6914508615969669127">node_modules 困境</a><br><img src="/My-Blogs/images/deno%E5%88%9D%E4%BD%93%E9%AA%8C-01.jpg" alt="img"></li><li>功能不完整，要学习很多外部工具，诸如webpack，babel，typescript、eslint、prettier……</li></ul><blockquote><p><em>“由于上面这些原因，Ryan Dahl 决定放弃 Node.js，从头写一个替代品，彻底解决这些问题。deno 这个名字就是来自 Node 的字母重新组合（Node = no + de），表示”拆除 Node.js”（de = destroy, no = Node.js）。<br>跟 Node.js 一样，Deno 也是一个服务器运行时，但是支持多种语言，可以直接运行 JavaScript、TypeScript 和 WebAssembly 程序。<br>它内置了 V8 引擎，用来解释 JavaScript。同时，也内置了 tsc 引擎，解释 TypeScript。它使用 Rust 语言开发，由于 Rust 原生支持 WebAssembly，所以它也能直接运行 WebAssembly。它的异步操作不使用 libuv 这个库，而是使用 Rust 语言的 Tokio 库，来实现事件循环（event loop）。”</em>— 出自阮一峰大神《<a href="https://www.ruanyifeng.com/blog/2020/01/deno-intro.html">Deno 运行时入门教程：Node.js 的替代品</a>》</p></blockquote><p><strong>闲言少叙，书归正文，让我们一起来看看Deno的特性吧。</strong></p><h2 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h2><ul><li>服务器运行时，支持多种语言，可直接运行 <code>JavaScript</code>、<code>TypeScript</code> 和 <code>WebAssembly</code> 程序。</li><li>具有安全控制，默认情况下脚本不具有读写权限。如果脚本未授权，就读写文件系统或网络，会报错。</li><li>只有一个可执行文件，所有操作都通过这个文件完成。它支持跨平台（Mac、Linux、Windows）。</li><li>异步操作 一律返回 Promise。</li><li>Deno 支持 Web API，尽量跟浏览器保持一致。<code>window</code>、<code>fetch</code>、<code>webCrypto</code>、<code>worker</code>, 也支持 <code>onload</code>、<code>onunload</code>、<code>addEventListener</code> 等事件操作函数。</li><li>所有模块通过 URL 加载，比如<code>import { bar } from "https://foo.com/bar.ts"</code>（绝对 URL）或<code>import { bar } from './foo/bar.ts'</code>（相对 URL）。本地缓存，有个Cache总目录</li><li>原生支持TypeScript, 内置<a href="https://github.com/microsoft/TypeScript">TypeScript编译器</a>和<a href="https://swc.rs/">swc</a>的Rust库组合实现。</li><li>打包、格式清理、测试、安装、文档生成、linting、脚本编译成可执行文件等一条龙服务。</li></ul><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li>高效且安全</li><li>单文件，兼容浏览器标准，体积小。</li><li>替代脚本</li><li>内存占用少，运行速度比node快。<a href="https://juejin.cn/post/6854573218419474439">从Deno跟Node的性能对比说起</a></li></ul><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><ul><li>缺少集大成框架，满足不了企业级应用开发。</li><li>社区还不完善，第三方库不够丰富。</li><li>缺乏包管理工具，管理起来混乱。</li><li><a href="https://juejin.cn/post/6917830384956899341">网络上一些怀疑的声音</a></li></ul><h3 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a><a href="https://deno.land/manual@v1.7.0/getting_started/command_line_interface">CLI</a></h3><h3 id="permission"><a href="#permission" class="headerlink" title="permission"></a><a href="https://deno.land/manual@v1.7.0/getting_started/permissions">permission</a></h3><h3 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a><a href="https://deno.land/manual@v1.7.0/getting_started/webassembly#webassembly-support">WebAssembly</a></h3><pre><code class="JS">const wasmCode = new Uint8Array([  0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127,  3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0,  5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145,  128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97,  105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0,  65, 42, 11]);const wasmModule = new WebAssembly.Module(wasmCode);const wasmInstance = new WebAssembly.Instance(wasmModule);const main = wasmInstance.exports.main as CallableFunctionconsole.log(main().toString());</code></pre><h3 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h3><ul><li><a href="https://deno.land/x">已支持开源项目</a></li><li><a href="https://deno.land/x/denon@2.4.6">denon</a></li><li><a href="https://deno.land/x/oak@v6.4.2">oak</a> – 类似koa的web框架</li><li><a href="https://deno.land/x/aleph@v0.2.28">Aleph.js</a> – 类似Next.js(React ssr框架)<h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a><a href="https://deno.land/std/">标准库</a></h3><h3 id="兼容node-js"><a href="#兼容node-js" class="headerlink" title="兼容node.js"></a><a href="https://deno.land/std/node">兼容node.js</a></h3></li></ul><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>Shell (Mac, Linux):</p><pre><code class="BASH">curl -fsSL https://deno.land/x/install/install.sh | sh</code></pre><p>PowerShell (Windows):</p><pre><code class="BASH">iwr https://deno.land/x/install/install.ps1 -useb | iex</code></pre><p>Using Homebrew (macOS):</p><pre><code class="BASH">brew install deno</code></pre><h3 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h3><p>Try running a simple program:</p><pre><code class="BASH">deno run https://deno.land/std/examples/welcome.ts</code></pre><p>Or a more complex one:</p><pre><code class="JS">import {  serve} from "https://deno.land/std@0.83.0/http/server.ts";const s = serve({  port: 8000});console.log("http://localhost:8000/");for await (const req of s) {  req.respond({    body: "Hello World\n"  });}</code></pre><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a><a href="https://deno.land/std/">例子</a></h3><h2 id="缓存目录"><a href="#缓存目录" class="headerlink" title="缓存目录"></a>缓存目录</h2><p>以Mac为例，举个🌰 </p><pre><code class="BASH"> $HOME/Library/Caches/Deno#  远程库下载地址deno run https://deno.land/std@0.83.0/examples/welcome.ts# DIRECTORIESgen/: 缓存编译为JavaScript的文件deps/: 缓存导入的远程url的文件  |__ http/: http方式导入的文件  |__ https/: https方式导入的文件# FILESdeno_history.txt: Deno REPL历史记录缓存deno info                                                                               DENO_DIR location: "/Users/lulu/Library/Caches/deno"Remote modules cache: "/Users/lulu/Library/Caches/deno/deps"TypeScript compiler cache: "/Users/lulu/Library/Caches/deno/gen"</code></pre><h3 id="gen"><a href="#gen" class="headerlink" title="gen/"></a>gen/</h3><p><code>$DENO_DIR/gen/</code> 被用来存放 JavaScript 文件，这些文件是从 TypeScript 源码编译来的。这样的编译是必要的，因为 V8 不识别 JS 子集之外的 TypeScript 语法。</p><p>gen/目录下的每一个 JS 文件的文件名是他的 TypeScript 源码的 hash 值。同时 JS 文件也对应一个 .map 为后缀的 source map 文件。</p><p>缓存存在的原因是为了避免在用户没有修改代码的情况下，每次运行时不断的重新编译文件。比如我们有一个 hello-world.ts 文件，他只是包含了代码 console.log(“Hello world”)。在第一次运行时，我们会看到编译信息：</p><pre><code class="BASH">$ deno hello-world.tsCompiling /Users/kevinqian/my-folder/hello-world.tsHello world</code></pre><p>但是在没有修改文件内容的情况下，当你重新运行代码：</p><pre><code class="BASH">$ deno hello-world.tsHello world</code></pre><p>不会再有编译信息的提示。这是因为在这一次运行中，Deno 直接使用了 gen/ 中缓存的版本，而不用再次编译。</p><p>缓存加载和保存的代码，可以从文件 src/deno_dir.rs 中的 DenoDir::load_cache 和 DenoDir::code_cache 中找到。</p><p>如果想要强制 Deno 重新编译你的代码而不是使用缓存的版本，你需要使用 <code>--recompile</code> 标志。</p><h3 id="deps"><a href="#deps" class="headerlink" title="deps/"></a>deps/</h3><p><code>$DENO_DIR/deps</code> 被用来保存远端 url import 获得的文件。根据 url 的模式，他包含了子目录（现在只有http和https），并且保存文件的位置由 URL path 决定。比如，对于下面的的 import（请注意，Deno 要求用户显式地指定扩展名）。</p><pre><code class="JS">import {  serve} from "https://deno.land/x/std/net/http.ts";</code></pre><p>下载的http.ts文件将会被存储在：</p><pre><code class="BASH">$DENO_DIR/deps/https/deno.land/x/std/net/http.ts</code></pre><p>需要注意，除非用户用 <code>--reload</code> 标志运行代码，否则我们的http.ts文件在接下来的运行中不会被重新下载。</p><p>当前（警告：将来可能改变），Deno 会关注从远端下载的文件的内容的 MIME 类型。在文件缺少扩展名或扩展名与内容类型不匹配的情况下，Deno 将创建一个以 .mime 结尾的额外文件，来存储 HTTP 响应头提供的 mime 类型。如果我们下载的文件名是 a.ts，然而响应头里面是 Content-Type: text/javascript，一个包含text/javascript内容的a.ts.mime文件将会在他旁边被创建。由于.mime文件的存在，a.ts 后面将会被当做一个 JavaScript 文件被 import。</p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><pre><code class="BASH">cd /Users/lulu/my-projects/deno-demo &amp;&amp; code .</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Deno的目标不是替代Node，而是Node的一个补充完善方案。<br>目前Deno还处于初步阶段，标准库，兼容性还有待改进，适合脚本，小型应用开发。想要完成一个成熟的大型项目，还需要时间的沉淀。让我们好好期待下，未来的Deno会如何发展？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一篇关于deno初体验文章&lt;/p&gt;</summary>
    
    
    
    <category term="deno" scheme="http://example.com/categories/deno/"/>
    
    
    <category term="deno" scheme="http://example.com/tags/deno/"/>
    
  </entry>
  
  <entry>
    <title>tree命令的基本使用</title>
    <link href="http://example.com/2021/01/18/Linux/shell/%E6%96%87%E4%BB%B6/tree%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2021/01/18/Linux/shell/%E6%96%87%E4%BB%B6/tree%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2021-01-18T10:15:44.000Z</published>
    <updated>2021-12-20T10:01:53.228Z</updated>
    
    <content type="html"><![CDATA[<p>每天学一个 Linux 命令之tree的基本使用</p><a id="more"></a><h2 id="命令简介"><a href="#命令简介" class="headerlink" title="命令简介"></a>命令简介</h2><p>tree 命令的作用是以树形结构显示目录下的内容。</p><p>常用的Linux发行版系统中默认没有这个命令，你需要通过安装才可以使用：</p><pre><code class="BASH">#Centosyum install tree -y#Ubuntusudo apt-get install tree</code></pre><p>安装完成之后就可以正常使用这个tree命令了。</p><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><pre><code class="BASH">tree [选项] [目录]</code></pre><h2 id="选项说明"><a href="#选项说明" class="headerlink" title="选项说明"></a>选项说明</h2><pre><code class="BASH">-a   #显示所有文件-d   #只显示目录（名称）-l   #显示链接文件的原始文件-f   #显示所列出的文件或目录的完整目录路径-i   #不以阶梯的形式显示文件或目录名称-q   #将控制字符以?字符代替，显示文件和目录名称-N   #直接显示文件或目录的名称-p   #显示每个文件的权限信息-u   #显示文件所有者或者uid-g   #显示文件所属组或者gid-s   #显示每个文件的大小信息-h   #以可读的方式显示文件的大小信息-D   #显示最后修改日期-v   #按字母数字正序显示文件-r   #按字母数字倒序显示文件-t   #按最后时间排序显示文件-C   #在文件和目录列表上加上色彩，便于区分文件类型-P pattern    #只显示匹配正则表式的文件或目录名称-I pattern    #与上结果相反</code></pre><h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><pre><code class="BASH">#树形显示当前目录及其子目录下的文件及目录名称[root@centos7&nbsp;testdir]#&nbsp;tree.├──&nbsp;dir│&nbsp;&nbsp;&nbsp;├──&nbsp;test2.txt~│&nbsp;&nbsp;&nbsp;├──&nbsp;test3.txt│&nbsp;&nbsp;&nbsp;└──&nbsp;test3.txt.bak├──&nbsp;test2.txt└──&nbsp;test2.txt~1&nbsp;directory,&nbsp;5&nbsp;files#只显示目录名称[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-d.└──&nbsp;dir1&nbsp;directory#显示目录及文件的权限信息[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-p.├──&nbsp;[drwxr-xr-x]&nbsp;&nbsp;dir│&nbsp;&nbsp;&nbsp;├──&nbsp;[-rw-r--r--]&nbsp;&nbsp;test2.txt~│&nbsp;&nbsp;&nbsp;├──&nbsp;[-rw-r--r--]&nbsp;&nbsp;test3.txt│&nbsp;&nbsp;&nbsp;└──&nbsp;[-rw-r--r--]&nbsp;&nbsp;test3.txt.bak├──&nbsp;[-rw-r--r--]&nbsp;&nbsp;test2.txt└──&nbsp;[-rw-r--r--]&nbsp;&nbsp;test2.txt~1&nbsp;directory,&nbsp;5&nbsp;files#显示几层信息2代表2层（向下）[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-L&nbsp;2.├──&nbsp;dir│&nbsp;&nbsp;&nbsp;├──&nbsp;test2.txt~│&nbsp;&nbsp;&nbsp;├──&nbsp;test3.txt│&nbsp;&nbsp;&nbsp;└──&nbsp;test3.txt.bak├──&nbsp;test2.txt└──&nbsp;test2.txt~1&nbsp;directory,&nbsp;5&nbsp;files[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-L&nbsp;1.├──&nbsp;dir├──&nbsp;test2.txt└──&nbsp;test2.txt~1&nbsp;directory,&nbsp;2&nbsp;files</code></pre><p>-C 显示各种文件类型，以颜色区分</p><p><img src="/My-Blogs/images/tree%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-01.png" alt="img"></p><pre><code class="BASH">#显示文件和目录的所有者[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-u.├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;cp&nbsp;-&gt;&nbsp;/usr/bin/cp├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;dir│??&nbsp;├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test2.txt~│??&nbsp;├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test3.txt│??&nbsp;└──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test3.txt.bak├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test2.txt└──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test2.txt~1&nbsp;directory,&nbsp;6&nbsp;files#显示文件和目录的所属组[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-g.├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;cp&nbsp;-&gt;&nbsp;/usr/bin/cp├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;dir│??&nbsp;├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test2.txt~│??&nbsp;├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test3.txt│??&nbsp;└──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test3.txt.bak├──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test2.txt└──&nbsp;[root&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;test2.txt~1&nbsp;directory,&nbsp;6&nbsp;files#不按树形形式显示文件和目录[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-i.cp&nbsp;-&gt;&nbsp;/usr/bin/cpdirtest2.txt~test3.txttest3.txt.baktest2.txttest2.txt~1&nbsp;directory,&nbsp;6&nbsp;files[root@centos7&nbsp;testdir]#&nbsp;tree.├──&nbsp;cp&nbsp;-&gt;&nbsp;/usr/bin/cp├──&nbsp;dir│&nbsp;&nbsp;&nbsp;├──&nbsp;test2.txt~│&nbsp;&nbsp;&nbsp;├──&nbsp;test3.txt│&nbsp;&nbsp;&nbsp;└──&nbsp;test3.txt.bak├──&nbsp;test2.txt└──&nbsp;test2.txt~1&nbsp;directory,&nbsp;6&nbsp;files#显示文件和目录的完整路径[root@centos7&nbsp;testdir]#&nbsp;pwd/root/testdir[root@centos7&nbsp;testdir]#&nbsp;tree&nbsp;-f.├──&nbsp;./cp&nbsp;-&gt;&nbsp;/usr/bin/cp├──&nbsp;./dir│&nbsp;&nbsp;&nbsp;├──&nbsp;./dir/test2.txt~│&nbsp;&nbsp;&nbsp;├──&nbsp;./dir/test3.txt│&nbsp;&nbsp;&nbsp;└──&nbsp;./dir/test3.txt.bak├──&nbsp;./test2.txt└──&nbsp;./test2.txt~1&nbsp;directory,&nbsp;6&nbsp;files[root@centos7&nbsp;~]#&nbsp;tree&nbsp;-f&nbsp;./testdir/./testdir├──&nbsp;./testdir/cp&nbsp;-&gt;&nbsp;/usr/bin/cp├──&nbsp;./testdir/dir│&nbsp;&nbsp;&nbsp;├──&nbsp;./testdir/dir/test2.txt~│&nbsp;&nbsp;&nbsp;├──&nbsp;./testdir/dir/test3.txt│&nbsp;&nbsp;&nbsp;└──&nbsp;./testdir/dir/test3.txt.bak├──&nbsp;./testdir/test2.txt└──&nbsp;./testdir/test2.txt~1&nbsp;directory,&nbsp;6&nbsp;files</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;每天学一个 Linux 命令之tree的基本使用&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="shell" scheme="http://example.com/tags/shell/"/>
    
    <category term="文件处理" scheme="http://example.com/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Explain使用分析</title>
    <link href="http://example.com/2021/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/Explain%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2021/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/Explain%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/</id>
    <published>2021-01-08T18:06:09.000Z</published>
    <updated>2021-12-20T10:01:53.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.<br>EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:</p><a id="more"></a><pre><code class="SQL">EXPLAIN SELECT * from user_info WHERE  id &lt; 300;</code></pre><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:</p><pre><code class="SQL">CREATE TABLE `user_info` (  `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,  `name` VARCHAR(50) NOT NULL DEFAULT '',  `age`  INT(11)              DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `name_index` (`name`))  ENGINE = InnoDB  DEFAULT CHARSET = utf8</code></pre><pre><code class="SQL">CREATE TABLE `order_info` (  `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,  `user_id`      BIGINT(20)           DEFAULT NULL,  `product_name` VARCHAR(50) NOT NULL DEFAULT '',  `productor`    VARCHAR(30)          DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`))  ENGINE = InnoDB  DEFAULT CHARSET = utf8</code></pre><h2 id="EXPLAIN-输出格式"><a href="#EXPLAIN-输出格式" class="headerlink" title="EXPLAIN 输出格式"></a>EXPLAIN 输出格式</h2><p>EXPLAIN 命令的输出内容大致如下:</p><pre><code class="SQL">mysql&gt; explain select * from user_info where id = 2\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)</code></pre><p>各列的含义如下:</p><ul><li><p><code>id</code>: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</p></li><li><p><code>select_type</code>: SELECT 查询的类型.</p></li><li><p><code>table</code>: 查询的是哪个表</p></li><li><p><code>partitions</code>: 匹配的分区</p></li><li><p><code>type</code>: join 类型</p></li><li><p><code>possible_keys</code>: 此次查询中可能选用的索引</p></li><li><p><code>key</code>: 此次查询中确切使用到的索引.</p></li><li><p><code>ref</code>: 哪个字段或常数与 key 一起被使用</p></li><li><p><code>rows</code>: 显示此查询一共扫描了多少行. 这个是一个估计值.</p></li><li><p><code>filtered</code>: 表示此查询条件所过滤的数据的百分比</p></li><li><p><code>extra</code>: 额外的信息</p></li></ul><p>接下来我们来重点看一下比较重要的几个字段.</p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p><code>select_type</code> 表示了查询的类型, 它的常用取值有:</p><ul><li><p>SIMPLE, 表示此查询不包含 UNION 查询或子查询</p></li><li><p>PRIMARY, 表示此查询是最外层的查询</p></li><li><p>UNION, 表示此查询是 UNION 的第二或随后的查询</p></li><li><p>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询</p></li><li><p>UNION RESULT, UNION 的结果</p></li><li><p>SUBQUERY, 子查询中的第一个 SELECT</p></li><li><p>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</p></li></ul><p>最常见的查询类别应该是 <code>SIMPLE</code> 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 <code>SIMPLE</code> 类型, 例如:</p><pre><code class="SQL">mysql&gt; explain select * from user_info where id = 2\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)</code></pre><p>如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:</p><pre><code class="SQL">mysql&gt; EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3))    -&gt; UNION    -&gt; (SELECT * FROM user_info WHERE id IN (3, 4, 5));+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+| id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+|  1 | PRIMARY      | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     ||  2 | UNION        | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     || NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+3 rows in set, 1 warning (0.00 sec)</code></pre><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>表示查询涉及的表或衍生表</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p><code>type</code> 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 <code>type</code> 字段, 我们判断此次查询是 <code>全表扫描</code> 还是 <code>索引扫描</code> 等.</p><p><strong>type 常用类型</strong><br>type 常用的取值有:</p><p><code>system</code> : 表中只有一条数据. 这个类型是特殊的 <code>const</code> 类型.</p><p><code>const</code> : 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. <code>const</code> 查询速度非常快, 因为它仅仅读取一次即可.<br>例如下面的这个查询, 它使用了主键索引, 因此 <code>type</code> 就是 <code>const</code> 类型的.</p><pre><code class="SQL">mysql&gt; explain select * from user_info where id = 2\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)</code></pre><ul><li><code>eq_ref</code>: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:</li></ul><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: indexpossible_keys: user_product_detail_index          key: user_product_detail_index      key_len: 314          ref: NULL         rows: 9     filtered: 100.00        Extra: Using where; Using index*************************** 2. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: eq_refpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: test.order_info.user_id         rows: 1     filtered: 100.00        Extra: NULL2 rows in set, 1 warning (0.00 sec)</code></pre><ul><li><code>ref</code>: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 <code>最左前缀</code> 规则索引的查询.</li></ul><p>例如下面这个例子中, 就使用到了 <code>ref</code> 类型的查询:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: const         rows: 1     filtered: 100.00        Extra: NULL*************************** 2. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: refpossible_keys: user_product_detail_index          key: user_product_detail_index      key_len: 9          ref: const         rows: 1     filtered: 100.00        Extra: Using index2 rows in set, 1 warning (0.01 sec)</code></pre><ul><li><code>range</code>: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.</li></ul><p>当 <code>type</code> 是 <code>range</code> 时, 那么 EXPLAIN 输出的 <code>ref</code> 字段为 NULL, 并且 <code>key_len</code> 字段是此次查询中使用到的索引的最长的那个.</p><p>例如下面的例子就是一个范围查询:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT *    -&gt;         FROM user_info    -&gt;         WHERE id BETWEEN 2 AND 8 \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: rangepossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: NULL         rows: 7     filtered: 100.00        Extra: Using where1 row in set, 1 warning (0.00 sec)</code></pre><ul><li><code>index</code>: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.</li></ul><p><code>index</code> 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 <code>Using index</code> .</p><p>例如:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT name FROM  user_info \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: indexpossible_keys: NULL          key: name_index      key_len: 152          ref: NULL         rows: 10     filtered: 100.00        Extra: Using index1 row in set, 1 warning (0.00 sec)</code></pre><p>上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 <code>index</code> , 并且 Extra 的值是 <code>Using index</code> .</p><ul><li><code>ALL</code>: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.</li></ul><p>下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT age FROM  user_info WHERE age = 20 \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 10     filtered: 10.00        Extra: Using where1 row in set, 1 warning (0.00 sec)</code></pre><p><strong>type 类型的性能比较</strong></p><p>通常来说, 不同的 type 类型的性能关系如下:</p><p> <code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code></p><p><code>ALL</code> 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.</p><p>而 <code>index</code> 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.</p><p>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</p><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p><code>possible_keys</code> 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 <code>possible_keys</code> 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 <code>key</code> 字段决定.</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>此字段是 MySQL 在当前查询时所真正使用到的索引.</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.<br>key_len 的计算规则如下:</p><ul><li><p>字符串</p><ul><li><p>char(n): n 字节长度</p></li><li><p>varchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.</p></li></ul></li><li><p>数值类型:</p><ul><li><p>TINYINT: 1字节</p></li><li><p>SMALLINT: 2字节</p></li><li><p>MEDIUMINT: 3字节</p></li><li><p>INT: 4字节</p></li><li><p>BIGINT: 8字节</p></li><li><p>时间类型</p></li><li><p>DATE: 3字节</p></li><li><p>TIMESTAMP: 4字节</p></li><li><p>DATETIME: 8字节</p></li><li><p>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.</p></li></ul></li></ul><p>我们来举两个简单的栗子:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id &lt; 3 AND product_name = 'p1' AND productor = 'WHH' \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: rangepossible_keys: user_product_detail_index          key: user_product_detail_index      key_len: 9          ref: NULL         rows: 5     filtered: 11.11        Extra: Using where; Using index1 row in set, 1 warning (0.00 sec)</code></pre><p>上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 <code>order_info</code> 有一个联合索引:</p><pre><code class="SQL">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</code></pre><p>不过此查询语句 <code>WHERE user_id &lt; 3 AND product_name = 'p1' AND productor = 'WHH'</code> 中, 因为先进行 user_id 的范围查询, 而根据 <code>最左前缀匹配</code> 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 <code>user_id</code> , 因此在 <code>EXPLAIN</code> 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 <code>BIGINT(20) NOT NULL DEFAULT '0'</code> , 则 key_length 应该是8.</p><p>上面因为 <code>最左前缀匹配</code> 原则, 我们的查询仅仅使用到了联合索引的 <code>user_id</code> 字段, 因此效率不算高.</p><p>接下来我们来看下一个例子:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = 'p1' \G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: refpossible_keys: user_product_detail_index          key: user_product_detail_index      key_len: 161          ref: const,const         rows: 2     filtered: 100.00        Extra: Using index1 row in set, 1 warning (0.00 sec)</code></pre><p>这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 <code>WHERE user_id = 1 AND product_name = 'p1'</code> 中, 仅仅使用到了联合索引中的前两个字段, 因此 <code>keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</code></p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p><code>rows</code> 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br>这个值非常直观显示 SQL 的效率好坏, 原则上 <code>rows</code> 越少越好.</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p><code>EXplain</code> 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p><ul><li><code>Using filesort</code></li></ul><p>当 Extra 中有 <code>Using filesort</code> 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 <code>Using filesort</code> , 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</p><p>例如下面的例子:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY product_name \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: indexpossible_keys: NULL          key: user_product_detail_index      key_len: 253          ref: NULL         rows: 9     filtered: 100.00        Extra: Using index; Using filesort1 row in set, 1 warning (0.00 sec)</code></pre><p>我们的索引是</p><pre><code class="SQL">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</code></pre><p>但是上面的查询中根据 <code>product_name</code> 来排序, 因此不能使用索引进行优化, 进而会产生 <code>Using filesort</code> .<br>如果我们将排序依据改为 <code>ORDER BY user_id, product_name</code> , 那么就不会出现 <code>Using filesort</code> 了. 例如:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: indexpossible_keys: NULL          key: user_product_detail_index      key_len: 253          ref: NULL         rows: 9     filtered: 100.00        Extra: Using index1 row in set, 1 warning (0.00 sec)</code></pre><ul><li><p><code>Using index</code> “覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</p></li><li><p><code>Using temporary</code> 查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;MySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.&lt;br&gt;EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>db操作常见问题</title>
    <link href="http://example.com/2021/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2021-01-08T18:05:18.000Z</published>
    <updated>2021-12-20T10:01:53.243Z</updated>
    
    <content type="html"><![CDATA[<p>总结了一些db操作的常见问题，让我们一起来看看吧</p><a id="more"></a><h2 id="联合索引问题"><a href="#联合索引问题" class="headerlink" title="联合索引问题"></a>联合索引问题</h2><ol><li> 在imo后台群唤醒活动中，用户数据表多达几千万，大数据这边，并未针对业务场景建立有效覆盖索引，导致后台SQL慢查询告警上千次，针对业务场景，提出以下优化，新增key1，key2索引覆盖，后台where条件严格按照stats_day，activelevel，categeory_id，cc顺序查询。</li><li> 按照MySQL联合索引最左匹配原则，比如A-B-C联合索引，则针对A，A-B，A-B-C查询有效，而A-C，B-C，B，C则无效，where条件最好根据索引顺序进行</li><li> 如果搜索条件过于复杂混乱，建议先与产品沟通清楚，确定好如何建立索引，严格把控搜索条件（从界面上）</li><li> 以下为用户数据表（千万级别）</li></ol><pre><code class="SQL">CREATE TABLE `xx_push_activelevel_categeory_day` (  `stats_day` date NOT NULL DEFAULT '2019-01-01',  `cc` varchar(10) NOT NULL DEFAULT '',  `activelevel` varchar(30) NOT NULL DEFAULT 'unknown',  `categeory_id` varchar(50) NOT NULL DEFAULT 'unknown',  `groupid` char(30) NOT NULL DEFAULT 'unknown',  `role` varchar(15) NOT NULL DEFAULT 'unknown',  `uid` varchar(25) NOT NULL DEFAULT '',  PRIMARY KEY (`role`,`activelevel`,`categeory_id`,`cc`,`uid`,`groupid`,`stats_day`),  KEY `role` (`role`,`activelevel`,`categeory_id`),  KEY `key1` (`stats_day`,`activelevel`,`categeory_id`,`cc`,`role`),  KEY `key2` (`stats_day`,`activelevel`,`categeory_id`,`cc`),  KEY `actl` (`activelevel`),  KEY `agid` (`categeory_id`),  KEY `cc` (`cc`)) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4/*!50100 PARTITION BY RANGE (TO_DAYS(stats_day))(PARTITION pd20200609 VALUES LESS THAN (737951) ENGINE = MyISAM, PARTITION pd20200610 VALUES LESS THAN (737952) ENGINE = MyISAM, PARTITION pd20200611 VALUES LESS THAN (737953) ENGINE = MyISAM) */;</code></pre><h2 id="主键偏移问题"><a href="#主键偏移问题" class="headerlink" title="主键偏移问题"></a>主键偏移问题</h2><ol><li> 在单表大数据量的情况下，使用索引并不是唯一选择，当SQL分页查询，offset达到一定量(大概20w以上？)以后，就会出现慢查询现象，是由于MySQL根据索引查出一定量数据之后，会根据offset抛弃之前的数据</li><li> 这意味着前20w数据的查询都是无用的，费力不讨好</li><li> 可以采用主键id(INT, BIGINT类型)偏移，INT类型查询天生就有优势，又是主键索引，可以做到一部到位</li><li> where条件最后，加上id排序，记录上一次的查询数据最后一条id，下一次查询作为偏移量，从而跳过前面无用的数据，再开始进行索引查询</li><li> 以下是某个项目的例子（仅供参考）</li></ol><pre><code class="SQL">SELECT id, stats_day, cc, activelevel, categeory_id, groupid, role, uid FROM xx_push_activelevel_categeory_day AS biggroupPushCategeoryWHERE biggroupPushCategeory.id &gt; 200000 AND biggroupPushCategeory.stats_day = '2020-07-01 00:00:00' AND biggroupPushCategeory.activelevel = 'gtype_unactive_2' AND biggroupPushCategeory.categeory_id = 'categeory_mems_less_300' AND biggroupPushCategeory.cc = 'PK'ORDER BY biggroupPushCategeory.id ASC LIMIT 500;</code></pre><h2 id="结果集过滤问题"><a href="#结果集过滤问题" class="headerlink" title="结果集过滤问题"></a>结果集过滤问题</h2><ol><li> 接上一个问题，当我们结合主键偏移+索引【KEY <code>sacc</code> (<code>stats_day</code>,<code>activelevel</code>,<code>categeory_id</code>,<code>cc</code>)】搜索的时候，SQL这边优先根据索引过滤结果集，根据上面那条sql，我们可能会过滤出一个大结果集，而且结果集并不保证id有序</li><li> 这时候我们需要重新修改索引键，加上主键id，例如KEY <code>sacci</code> (<code>stats_day</code>,<code>activelevel</code>,<code>categeory_id</code>,<code>cc</code>,<code>id</code>)，当我们进行索引查询取500行时，可以根据id&gt;20000，直接命中500行并返回，不需要重新排序，也不会返回之前sacc索引的所有结果集</li><li> 以下是优化前和优化后的对比图，性能提高了几十倍</li></ol><h3 id="优化前"><a href="#优化前" class="headerlink" title="优化前"></a>优化前</h3><p><img src="/My-Blogs/images/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-01.png" alt="优化前"></p><h3 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h3><p><img src="/My-Blogs/images/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-02.png" alt="优化后"></p><h2 id="where条件顺序问题"><a href="#where条件顺序问题" class="headerlink" title="where条件顺序问题"></a>where条件顺序问题</h2><ol><li> 接上一个问题，我们已经创建索引KEY <code>sacci</code> (<code>stats_day</code>,<code>activelevel</code>,<code>categeory_id</code>,<code>cc</code>,<code>id</code>)，如果我们把id放在最前，或者最后，会对查询的效率有影响吗？答案是没有。</li><li> SQL执行是会被进行一系列预处理，让查询优化器选择最优的查询计划，所以where条件的先后关系不是优化器选择规则的一条，当然前提是你的where条件数量与索引一致，如果where条件少于索引数量，会根据最左原则优先查询。</li><li> 总的来说，唯一会影响的就是where条件和索引的比对，以及跟order by等，跟先后顺序无关。</li><li> 引申开来说，如果对ABC三个字段建立联合索引，一般来说，在创建索引时，根据区分度原则，尽量让A能够排除更多记录而不是B或C，在查询时，根据索引前缀匹配原则，尽可能让A条件精确，B其次，C看着办。</li><li> 以下是id前后对比图</li></ol><p><img src="/My-Blogs/images/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-03.png" alt="alt"></p><p><img src="/My-Blogs/images/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-04.png" alt="alt"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结了一些db操作的常见问题，让我们一起来看看吧&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>PRPL模式加快Web应用加载</title>
    <link href="http://example.com/2021/01/08/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/"/>
    <id>http://example.com/2021/01/08/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/</id>
    <published>2021-01-08T18:01:13.000Z</published>
    <updated>2021-12-20T10:01:53.242Z</updated>
    
    <content type="html"><![CDATA[<p>PRPL 是一种用于结构化和交付 Web 应用程序和渐进式 Web 应用（PWA）的模式，重点在于改进应用的交付和启动性能。这个模式包含一组步骤，以实现快速、可靠、高效的加载：</p><a id="more"></a><ul><li><p><code>Push</code>, 推送初始路由所需的所有资源，并且只推送这些资源，以确保它们尽早可用。</p></li><li><p><code>Render</code>, 在加载其他资源之前，渲染初始路由并使其具备交互能力。</p></li><li><p><code>Pre-cache</code>, 预缓存用户可能访问的其他路由的资源，从而在恶劣的网络条件下尽可能提高对后续请求的响应能力和弹性。</p></li><li><p><code>Lazy-load</code>, 当用户请求时，按需延迟加载路由；关键路由的资源应立即从缓存中加载，而相对不常用的资源可以根据请求从网络获取。</p></li></ul><blockquote><p>注意：PRPL模式是由Polymer团队于2016年首次引入的，但已被证明适用于其他许多技术栈。</p></blockquote><p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-01.png" alt="img"></p><center>PRPL 模式加载顺序</center><p>服务器和服务 Worker 一起为非活动路由预缓存资源。当用户切换路由时，应用会延迟加载尚未缓存的所有必需资源，并创建所需的视图。</p><p>Twitter.com 自 2017 年以来就在生产中使用 PRPL 模式了。下面我们可以看到，他们对关键脚本使用了粒度代码拆分，并使用 <code>&lt;linkrel=preload&gt;</code> 推送脚本以尽快让脚本可用：</p><p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-02.png" alt="img"></p><br><center style="margin-top: 20px">PRPL 模式：预加载关键脚本</center><br><p>其他路由会按需延迟加载。Twitter 在整个用户体验部分中会按需提供 40 多个块。Twitter 还使用服务 Workers 对其他路由进行（离线）资产预缓存，以提高对后续导航操作的响应能力：</p><br><p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-03.png" alt="img"></p><br><center style="margin-top: 20px">PRPL 模式：离线缓存资源</center><br><p>他们的应用程序外壳程序（骨架 UI）也是离线缓存的，就算用户通过缓慢或不稳定的网络连接加载站点，也会立即加载它们：</p><p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-04.png" alt="img"></p><center>PRPL 模式：应用程序外壳</center><h2 id="为什么选择-PRPL？"><a href="#为什么选择-PRPL？" class="headerlink" title="为什么选择 PRPL？"></a>为什么选择 PRPL？</h2><p>应用使用 PRPL 构建是为了达到可靠、快速和引人入胜的目的。除了这些基本目标，PRPL 还旨在：</p><ul><li><p><strong>改善应用的交互就绪水平</strong>。为了做到这一点，在第一个视图渲染并具备交互能力之前，不会向浏览器发送多余的资源。</p></li><li><p><strong>提高应用的缓存效率，尤其是长期缓存效率</strong>。为了做到这一点，资源会以很细的粒度向浏览器发送。当资源被解绑或松散地打包时，对代码的每次更改给缓存的负面影响也会减少。</p></li><li><p><strong>降低开发和部署的复杂性</strong>。为了做到这一点，这种模式使用应用的隐式依赖图将每个入口点精确映射到所需的资源集，从而减少或消除了手动管理打包和交付的需求。</p></li></ul><h2 id="PRPL-应包含哪些技术？"><a href="#PRPL-应包含哪些技术？" class="headerlink" title="PRPL 应包含哪些技术？"></a>PRPL 应包含哪些技术？</h2><p>PRPL 是一种能以各种方式实现的概念模式，但是通过以下现代 Web 特性的某种组合，可以最轻松有效地实现 PRPL：</p><ul><li><p>像JavaScript Modules这样的现代模块系统，使工具可以轻松构造完整的依赖图；</p></li><li><p>服务Workers，为后续的应用视图预缓存（“安装”）资源（进而支持离线优先架构）</p></li><li><p>预加载，用于尽快交付所需资源。你还可以使用预加载链接头，这些头可以被协作服务器拦截并升级为HTTP/2 Server Push（详情可见<a href="https://www.smashingmagazine.com/2017/04/guide-http2-server-push/">原文</a>）。一定要记住，尽管Push功能强大，但它也面临着许多已知的挑战；不过PRPL使用服务Worker可以避免过度推送的问题（仅针对初始负载使用push）。</p></li></ul><h2 id="如何实现-PRPL-模式？"><a href="#如何实现-PRPL-模式？" class="headerlink" title="如何实现 PRPL 模式？"></a>如何实现 PRPL 模式？</h2><p>PRPL 的很大一部分理念是对 JS 打包思维的颠覆，并在提供资源时拆分成尽可能接近编写资源时的粒度（至少拆分成独立的功能模块）。那么如何实现细粒度呢？</p><h3 id="基于路由或基于组件的代码拆分和延迟加载"><a href="#基于路由或基于组件的代码拆分和延迟加载" class="headerlink" title="基于路由或基于组件的代码拆分和延迟加载"></a>基于路由或基于组件的代码拆分和延迟加载</h3><p>你正在将事物编写为组件。也许你正在使用 ES 模块。对于 Webpack，我们使用动态导入和代码拆分，将你的代码库拆分为按需加载的块。</p><br><p>Next.js 和 Nuxt.js 之类的元框架会默认实现基于路由的代码拆分。如果你使用的是 create-react-app 之类的工具链样板，则需要借助 React Router 之类的路由器进行动态导入，才能将基于路由或基于组件的代码拆分添加到你的应用程序中。</p><br><p>对于 PRPL 的 push/preload 部分，Webpack 还支持将 preload 作为魔术注释来预加载关键脚本。</p><br><h3 id="预缓存"><a href="#预缓存" class="headerlink" title="预缓存"></a>预缓存</h3><p>可以使用服务 worker 预缓存剩余的路由。另一种常见的做法是，利用 Workbox 之类的服务 worker 库来简化为应用程序预缓存路由和块的过程。</p><br><h2 id="PRPL-使用何种应用程序结构？"><a href="#PRPL-使用何种应用程序结构？" class="headerlink" title="PRPL 使用何种应用程序结构？"></a>PRPL 使用何种应用程序结构？</h2><p>PRPL 鼓励采用以下结构的单页应用（SPA）架构：</p><br><ul><li><p>从每个有效路由提供的应用程序的主入口点。</p></li><li><p>这个文件应该很小，因为它将通过不同的URL提供，因此会被多次缓存。入口点中的所有资源URL都必须是绝对的，因为它可以从非顶级URL提供。</p></li><li><p>外壳（app-shell），其中包括顶级应用逻辑、router等。</p></li><li><p>延迟加载的应用片段。</p></li><li><p>可以代表特定视图代码的片段，或其他可以延迟加载的代码（例如，主应用的一些部分在第一次绘制时并不需要，比如说菜单，直到用户与应用交互时才显示）。外壳负责根据需要动态导入这些片段。</p></li></ul><p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-05.png" alt="img"></p><center style="margin: 20px 0 20px 0; ">应用外壳骨架模式</center><p>应用应根据需要调用动态导入以延迟加载片段。例如，当用户更改为新路由时，它将导入与该路由关联的片段。这可能会向服务器发起新请求，或者只是从缓存中加载资源。</p><br><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>除了针对 PWA 的基本目标和标准之外，PRPL 还尽量针对以下方面做了优化：</p><br><ul><li><p>尽量减少交互的准备工作——特别是在首次使用时（无论入口点如何）。</p></li><li><p>尽量提升缓存效率，尤其是更新不断发布后的长期缓存效率。</p></li><li><p>简化开发和部署。</p></li></ul><p>自 2016 年诞生以来，PRPL 模式已获得了大规模使用，值得你在优化应用加载时考虑。</p><p>原文链接：<a href="https://addyosmani.com/blog/the-prpl-pattern/">https://addyosmani.com/blog/the-prpl-pattern/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;PRPL 是一种用于结构化和交付 Web 应用程序和渐进式 Web 应用（PWA）的模式，重点在于改进应用的交付和启动性能。这个模式包含一组步骤，以实现快速、可靠、高效的加载：&lt;/p&gt;</summary>
    
    
    
    <category term="性能优化" scheme="http://example.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="性能优化" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>谈谈登录</title>
    <link href="http://example.com/2021/01/08/%E5%AE%89%E5%85%A8/%E8%B0%88%E8%B0%88%E7%99%BB%E5%BD%95/"/>
    <id>http://example.com/2021/01/08/%E5%AE%89%E5%85%A8/%E8%B0%88%E8%B0%88%E7%99%BB%E5%BD%95/</id>
    <published>2021-01-08T17:57:43.000Z</published>
    <updated>2021-12-20T10:01:53.241Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Cookie与Session"><a href="#一、Cookie与Session" class="headerlink" title="一、Cookie与Session"></a>一、Cookie与Session</h3><p>HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行保存。因为无法管理用户状态，对于要登录的页面，每次跳转新页面时都需要再次登录。</p><a id="more"></a><p>于是引入了Cookie来管理用户状态：</p><p>① 首先客户端发起不带Cookie信息的登录请求</p><p>② 服务端接收到请求，验证用户数据正确后，添加响应头Set-Cookie</p><p>③ 客户端收到响应报文后，检查到响应头Set-Cookie，在本地保存Cookie</p><p>④ 之后每次向该域发起请求时，自动添加请求头Cookie，发送给服务端</p><p>⑤ 服务端获取请求头Cookie，根据Cookie的值，就可以判断出用户是否登录</p><p>但是Cookie极容易被篡改和伪造，于是产生了Session，Session将用户信息保存在服务端，那么Session是如何管理用户状态的呢？</p><p>① 首先客户端发起不带Cookie信息的登录请求</p><p>② 服务端接收到请求，检查到没有携带口令，验证用户密码正确后生成Session，将用户信息保存在Session，设置响应头Set-Cookie，通常是将Session ID作为口令值</p><p>③ 客户端检查到Set-Cookie响应头，在本地保存Cookie信息</p><p>④ 之后每次发起请求时，自动在请求头Cookie中携带口令，发送给服务端</p><p>⑤ 服务端获取Cookie携带的口令值，找到对应的Session，就可以判断用户状态</p><h3 id="二、如何让Session口令值更安全"><a href="#二、如何让Session口令值更安全" class="headerlink" title="二、如何让Session口令值更安全"></a>二、如何让Session口令值更安全</h3><p>虽然口令值由服务端生成，用户不容易伪造，But nothing is impossible；而且口令值存在客户端，就有可能被盗用。一旦口令值被伪造或盗用，攻击者就可以伪装成用户访问服务端的数据。</p><p>那么如何让Session口令值更安全呢？</p><p>① 将客户端的某些独有信息+口令值作为原值，对其进行签名</p><p>② 将口令值拼接签名返回给客户端，将Cookie设置为HttpOnly（禁止用户通过脚本来获取和更改Cookie）</p><p>③ 服务端再次收到请求，取客户端信息与口令值签名，与客户端携带的签名对比，不相等，说明请求不合法</p><p>这样的话：</p><p>① 即使攻击者知道了口令值，由于不知道密钥，无法伪造签名</p><p>② 即使攻击者通过某种方式得到了真实的口令值和签名，但是由于攻击者的客户端信息不一样，发送到服务端后，会得到不一样的签名，签名校验不能通过</p><h3 id="三、多系统的复杂性"><a href="#三、多系统的复杂性" class="headerlink" title="三、多系统的复杂性"></a>三、多系统的复杂性</h3><p>web系统由早期的单系统发展成多系统组成的应用群，面对如此众多的系统，用户难道要一个个登录、再一个个注销吗？</p><p>系统复杂性应该由系统内部承担，而不是用户。无论web系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问web系统的整个应用群与访问单个系统一样，只要登录/注销一次就够了。</p><p><img src="/My-Blogs/images/%E8%B0%88%E8%B0%88%E7%99%BB%E5%BD%95-01.png"></p><p>因为Cookie不允许跨域，早期多系统登录采用将Cookie种在顶级域名下的方式，来实现Cookie共享。这种方式的局限在于：</p><p>① 应用群各系统的域名得统一</p><p>② 应用群各系统的web服务端使用的技术要相同，比如Session口令值以及它的签名</p><p>方式要相同，要不Session口令值不同，无法维持会话</p><p>因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录。</p><h3 id="四、单点登录"><a href="#四、单点登录" class="headerlink" title="四、单点登录"></a>四、单点登录</h3><p>单点登录全称Single Sign On（简称SSO），是指在多系统应用群中登录一个系统，便可在其它所有系统中得到授权而无需再次登录。包括单点登录与单点注销两部分：</p><h4 id="1、单点登录"><a href="#1、单点登录" class="headerlink" title="1、单点登录"></a>1、单点登录</h4><p>　    相比于单系统登录，SSO需要一个独立的认证中心，只有认证中心能接受用户的用    户名密码等安全信息，其它系统不提供登录入口，只接受认证中心的间接授权。</p><p>通常SSO认证中心验证用户数据没问题后，会创建授权Token，分发给各个子系统。子系统拿到Token，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。这个过程，也就是单点登录的原理。</p><p><img src="/My-Blogs/images/%E8%B0%88%E8%B0%88%E7%99%BB%E5%BD%95-02.png"></p><p>例如：</p><p>    用户访问系统1，系统1发现用户未登录，跳转至SSO认证中心，并将自己的地址作为参数</p><p>    SSO认证中心发现用户未登录，将用户引导至登录页面</p><p>    用户输入用户名密码提交登录申请</p><p>    SSO认证中心校验用户信息，创建用户与SSO认证中心之间的会话，称为全局会话，同时创建授权Token</p><p>    SSO认证中心带着Token跳转回最初的请求地址（系统1）</p><p>    系统1拿到Token，去SSO认证中心校验Token是否有效</p><p>    SSO认证中心校验Token，返回有效，注册系统1</p><p>    系统1使用该Token创建与用户的会话，称为局部会话，返回受保护资源</p><p>    用户访问系统2的受保护资源</p><p>    系统2发现用户未登录，跳转至SSO认证中心，并将自己的地址作为参数</p><p>    SSO认证中心发现用户已登录，跳转回系统2的地址，并附上令牌</p><p>    系统2拿到令牌，去SSO认证中心校验令牌是否有效</p><p>    SSO认证中心校验令牌，返回有效，注册系统2</p><p>    系统2使用该令牌创建与用户的局部会话，返回受保护资源</p><p>用户登录成功之后，会与SSO认证中心及各个子系统建立会话，用户与SSO认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过SSO认证中心，全局会话与局部会话有如下约束关系：</p><p>① 局部会话存在，全局会话一定存在</p><p>② 全局会话存在，局部会话不一定存在</p><p>③ 全局会话销毁，局部会话必须销毁</p><p>2、单点注销</p><p>单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁。</p><p><img src="/My-Blogs/images/%E8%B0%88%E8%B0%88%E7%99%BB%E5%BD%95-03.png"></p><p>    用户向系统1发起注销请求</p><p>    系统1根据用户与系统1建立的会话拿到Token，向SSO认证中心发起注销请求</p><p>    SSO认证中心校验Token有效，销毁全局会话，同时取出所有用此Token注册的系统地址</p><p>    SSO认证中心向所有注册系统发起注销请求</p><p>    各注册系统接收SSO认证中心的注销请求，销毁局部会话</p><p>    SSO认证中心引导用户至登录页面</p><h3 id="五、登录安全防范"><a href="#五、登录安全防范" class="headerlink" title="五、登录安全防范"></a>五、登录安全防范</h3><p>1、CSRF攻击</p><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的登录凭证，绕过后台的用户验证，达到冒充用户对被攻击网站执行某项操作的目的。</p><p>一个典型的CSRF攻击有着如下的流程：</p><p>① 受害者登录网站a，并保留了登录凭证Cookie</p><p>② 攻击者引诱受害者访问网站b，它向网站a的服务器发送了一个跨站请求，该请求会默认携带网站a的Cookie</p><p>③ 网站a的服务器接收到请求后，对请求进行验证，确认是受害者的凭证，误以为是受害者自己发送的请求，以受害者的名义执行某个操作</p><p>④ 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让网站a执行了攻击者自己定义的操作</p><p>CSRF通常发生在第三方域名，由于浏览器同源策略的限制，攻击者不能获取到受害者的Cookie信息，只是冒用。针对这2点，我们可以制定相应的防护策略：</p><p>1）同源检测</p><p>服务器通过解析Origin 或Referer这两个请求头，确定请求的来源域，如果请求来自外域，直接阻止。</p><p>缺点：在部分情况下，攻击者可以隐藏甚至修改自己请求的Referer；会误伤一些正常请求，比如通过搜索结果跳转的页面请求。</p><p>2）Samesite Cookie</p><p>为了从源头上解决CSRF攻击，Google起草了一份草案来改进HTTP协议，即为响应头Set-Cookie新增Samesite属性：</p><p>Strict：任何情况下都不可能作为第三方Cookie，其它网站发起的任意请求都不会携带上该Cookie，包括搜索页面。</p><p>Lax：用户在不同网站之间通过链接跳转不受影响；但假如这个请求是从其它网站发起的请求，或者页面跳转是通过表单POST提交触发的，则Cookie也不会携带发送。</p><p>缺点：目前还并不成熟，其应用场景有待观望。</p><p>3）双重Cookie</p><p>①     在用户访问网站页面时，向请求域名注入两个Cookie，一个是原本要注入的Cookie，一个比如随机字符串</p><p>② 前端向后端发起请求时，取出随机字符串，添加到URL参数或请求头中</p><p>③ 后端验证携带的随机数与Cookie中的随机数是否一致，不一致则拒绝请求</p><p>缺点：难以做到子域名隔离，认证Cookie必须被种在顶级域名下，每个子域才可以访问；如果某个子域存在XSS漏洞，攻击者将这个认证Cookie修改为自己配置的Cookie；攻击者直接使用自己配置的Cookie发起CSRF攻击。</p><p>4）CSRF Token</p><p>CSRF攻击者无法直接窃取到用户的Cookie，仅仅是冒用；而CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户的请求。</p><p>① 服务器生成登录Cookie时，同时生成Token和Token签名的2个Cookie</p><p>② 前端向后端发起请求时，将Token添加到URL参数或请求头中</p><p>③ 后端收到请求，首先验证参数与Token相不相同，不相同则中止请求；然后校验签名，不相同则中止请求。因为攻击者不知道密钥，使用Token签名可以防止Cookie被篡改和伪造。</p><p>缺点：每个请求都需要携带Token，且需要服务端对每个请求进行校验。所以一般只对包含敏感数据的请求做此处理。</p><p>2、短信防刷</p><p>短信轰炸是指攻击者利用从各个网站上找到的发送动态短信的URL和前端输入的被攻击者的手机号码，发送HTTP请求，每次请求给用户发送一个动态短信。</p><p>危害：增加公司的运营成本，因为短信是需要计费的；被攻击者大量被动接收非自身请求的短信，造成无法正常使用移动运营商业务；给公司形象造成极大影响，因为一般短信会带公司签名。</p><p>常见防范手段：</p><p>    短信发送间隔设置</p><p>    发送量限制</p><p>    图文验证码</p><p>    触发流程限制</p><h3 id="六、全球部署问题"><a href="#六、全球部署问题" class="headerlink" title="六、全球部署问题"></a>六、全球部署问题</h3><p>Session存在内存里随着用户的增多会导致内存溢出，且不能跨进程、跨机器共享，且重启进程后会导致Session丢失，所以Session通常会存在第三方缓存，比如Redis里。</p><p>Redis全球部署带来的问题在于，已登录的用户再次请求时，如果请求定位到不同集群的Redis，会导致登录状态失效。</p><p>解决方案：</p><p>    不同集群Redis数据同步</p><p>    保证相同集群的Web服务请求同一集群的Redis</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一、Cookie与Session&quot;&gt;&lt;a href=&quot;#一、Cookie与Session&quot; class=&quot;headerlink&quot; title=&quot;一、Cookie与Session&quot;&gt;&lt;/a&gt;一、Cookie与Session&lt;/h3&gt;&lt;p&gt;HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行保存。因为无法管理用户状态，对于要登录的页面，每次跳转新页面时都需要再次登录。&lt;/p&gt;</summary>
    
    
    
    <category term="安全" scheme="http://example.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="安全" scheme="http://example.com/tags/%E5%AE%89%E5%85%A8/"/>
    
    <category term="登录" scheme="http://example.com/tags/%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>ssh的基本用法</title>
    <link href="http://example.com/2021/01/08/%E5%8D%8F%E8%AE%AE/ssh/ssh%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <id>http://example.com/2021/01/08/%E5%8D%8F%E8%AE%AE/ssh/ssh%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</id>
    <published>2021-01-08T17:54:30.000Z</published>
    <updated>2021-12-20T10:01:53.241Z</updated>
    
    <content type="html"><![CDATA[<p><code>SSH</code>，我们经常操作远程服务器的时候，都会用到这个命令，但是他除了登录服务器还有很多作用，下面我们一起来了解下吧</p><a id="more"></a><h2 id="ssh登录服务器命令"><a href="#ssh登录服务器命令" class="headerlink" title="ssh登录服务器命令"></a>ssh登录服务器命令</h2><pre><code class="BASH">ssh hostname</code></pre><p>上面命令中， <code>hostname</code> 是主机名，它可以是域名，也可能是 IP 地址或局域网内部的主机名。不指定用户名的情况下，将使用客户端的当前用户名，作为远程服务器的登录用户名。</p><p>如果要指定用户名，可以采用下面的语法。</p><pre><code class="BASH">ssh user@hostname</code></pre><p>上面的命令中，用户名和主机名写在一起了，之间使用 <code>@</code> 分隔。</p><p>指定用户名，可以使用 <code>ssh</code> 和 <code>-l</code> 参数</p><pre><code class="BASH">ssh -l username host</code></pre><p>ssh 默认连接服务器的 <code>22</code> 端口， <code>-p</code> 参数可以指定其他端口</p><pre><code class="BASH">ssh -p 8821 hostname</code></pre><h2 id="ssh执行远程命令"><a href="#ssh执行远程命令" class="headerlink" title="ssh执行远程命令"></a>ssh执行远程命令</h2><p>将命令直接写在 <code>ssh</code> 命令的后面</p><pre><code class="BASH">ssh username@hostname command</code></pre><p>上面的命令会使得 SSH 在登录成功后，立刻在远程主机上执行命令 <code>command</code> 。</p><p>例子</p><pre><code class="BASH">ssh foo@server.example.com cat /etc/hosts</code></pre><p>上面的命令会在登录成功后，立即远程执行命令 <code>cat /etc/hosts</code> 。</p><h2 id="ssh命令行配置项"><a href="#ssh命令行配置项" class="headerlink" title="ssh命令行配置项"></a>ssh命令行配置项</h2><h3 id="c-参数指定加密算法。"><a href="#c-参数指定加密算法。" class="headerlink" title="-c 参数指定加密算法。"></a><code>-c</code> 参数指定加密算法。</h3><pre><code class="BASH">$ ssh -c blowfish,3des server.example.com# 或者$ ssh -c blowfish -c 3des server.example.com</code></pre><p>上面命令指定使用加密算法 <code>blowfish</code> 或 <code>3des</code></p><h3 id="C-参数表示压缩数据传输"><a href="#C-参数表示压缩数据传输" class="headerlink" title="-C 参数表示压缩数据传输"></a><code>-C</code> 参数表示压缩数据传输</h3><pre><code class="BASH">ssh -C server.example.com</code></pre><h3 id="d-参数设置打印的-debug-信息级别，数值越高，输出的内容越详细。"><a href="#d-参数设置打印的-debug-信息级别，数值越高，输出的内容越详细。" class="headerlink" title="-d 参数设置打印的 debug 信息级别，数值越高，输出的内容越详细。"></a><code>-d</code> 参数设置打印的 debug 信息级别，数值越高，输出的内容越详细。</h3><pre><code class="BASH">ssh –d 1 foo.com</code></pre><h3 id="D-参数指定本机的-Socks-监听端口"><a href="#D-参数指定本机的-Socks-监听端口" class="headerlink" title="-D 参数指定本机的 Socks 监听端口"></a><code>-D</code> 参数指定本机的 Socks 监听端口</h3><blockquote><p>该端口收到的请求，都将转发到远程的 SSH 主机，又称动态端口转发</p></blockquote><pre><code class="BASH"> ssh -D 1080 server</code></pre><p>上面命令将本机 1080 端口收到的请求，都转发到服务器 <code>server</code></p><h3 id="f-参数表示-SSH-连接在后台运行"><a href="#f-参数表示-SSH-连接在后台运行" class="headerlink" title="-f 参数表示 SSH 连接在后台运行"></a><code>-f</code> 参数表示 SSH 连接在后台运行</h3><h3 id="F-参数指定配置文件"><a href="#F-参数指定配置文件" class="headerlink" title="-F 参数指定配置文件"></a><code>-F</code> 参数指定配置文件</h3><pre><code class="BASH">ssh -F /usr/local/ssh/other_config</code></pre><p>上面命令指定使用配置文件 <code>other_config</code></p><h3 id="i-参数用于指定私钥"><a href="#i-参数用于指定私钥" class="headerlink" title="-i 参数用于指定私钥"></a><code>-i</code> 参数用于指定私钥</h3><blockquote><p>意为“identity_file”，默认值为~/.ssh/id_dsa。注意，对应的公钥必须存放到服务器</p></blockquote><pre><code class="BASH">ssh -i my-key server.example.com</code></pre><h3 id="l-参数指定远程登录的账户名"><a href="#l-参数指定远程登录的账户名" class="headerlink" title="-l 参数指定远程登录的账户名"></a><code>-l</code> 参数指定远程登录的账户名</h3><pre><code class="BASH">$ ssh -l sally server.example.com# 等同于$ ssh sally@server.example.com</code></pre><h3 id="L-参数设置本地端口转发"><a href="#L-参数设置本地端口转发" class="headerlink" title="-L 参数设置本地端口转发"></a><code>-L</code> 参数设置本地端口转发</h3><pre><code class="BASH">ssh  -L 9999:targetServer:80 user@remoteserver</code></pre><p>上面命令中，所有发向本地 <code>9999</code> 端口的请求，都会经过 <code>remoteserver</code> 发往 <code>targetServer</code> 的 <code>80</code> 端口，这就相当于直接连上了 <code>targetServer</code> 的 <code>80</code> 端口</p><h3 id="m-参数指定校验数据完整性的算法"><a href="#m-参数指定校验数据完整性的算法" class="headerlink" title="-m 参数指定校验数据完整性的算法"></a><code>-m</code> 参数指定校验数据完整性的算法</h3><pre><code class="BASH">ssh -m hmac-sha1,hmac-md5 server.example.com</code></pre><p>上面命令指定数据校验算法为 <code>hmac-sha1</code> 或 <code>hmac-md5</code></p><h3 id="o-参数用来指定一个配置命令"><a href="#o-参数用来指定一个配置命令" class="headerlink" title="-o 参数用来指定一个配置命令"></a><code>-o</code> 参数用来指定一个配置命令</h3><pre><code class="BASH">ssh -o "Keyword Value"</code></pre><p>举例来说，配置文件里面有如下内容。</p><pre><code class="BASH">User sallyPort 220</code></pre><p>通过 <code>-o</code> 参数，可以把上面两个配置命令从命令行传入。</p><pre><code class="BASH">ssh -o "User sally" -o "Port 220" server.example.com</code></pre><p>使用等号时，配置命令可以不用写在引号里面，但是等号前后不能有空格</p><pre><code class="BASH">ssh -o User=sally -o Port=220 server.example.com</code></pre><h3 id="p-参数指定-SSH-客户端连接的服务器端口"><a href="#p-参数指定-SSH-客户端连接的服务器端口" class="headerlink" title="-p 参数指定 SSH 客户端连接的服务器端口"></a><code>-p</code> 参数指定 SSH 客户端连接的服务器端口</h3><pre><code class="BASH">ssh -p 2035 server.example.com</code></pre><p>上面命令连接服务器的2035端口</p><h3 id="q-参数表示安静模式（quiet），不向用户输出任何警告信息"><a href="#q-参数表示安静模式（quiet），不向用户输出任何警告信息" class="headerlink" title="-q 参数表示安静模式（quiet），不向用户输出任何警告信息"></a><code>-q</code> 参数表示安静模式（quiet），不向用户输出任何警告信息</h3><pre><code class="BASH">ssh –q foo.comroot’s password:</code></pre><p>上面命令使用 <code>-q</code> 参数，只输出要求用户输入密码的提示</p><h3 id="R-参数指定远程端口转发"><a href="#R-参数指定远程端口转发" class="headerlink" title="-R 参数指定远程端口转发"></a><code>-R</code> 参数指定远程端口转发</h3><pre><code class="BASH">ssh -R 9999:targetServer:902 local</code></pre><p>上面命令需在跳板服务器执行，指定本地计算机 <code>local</code> 监听自己的 9999 端口，所有发向这个端口的请求，都会转向 targetServer 的 902 端口</p><h3 id="t-参数在-ssh-直接运行远端命令时，提供一个互动式-Shell"><a href="#t-参数在-ssh-直接运行远端命令时，提供一个互动式-Shell" class="headerlink" title="-t 参数在 ssh 直接运行远端命令时，提供一个互动式 Shell"></a><code>-t</code> 参数在 ssh 直接运行远端命令时，提供一个互动式 Shell</h3><pre><code class="BASH">ssh -t server.example.com emacs</code></pre><h3 id="v-参数显示详细信息"><a href="#v-参数显示详细信息" class="headerlink" title="-v 参数显示详细信息"></a><code>-v</code> 参数显示详细信息</h3><pre><code class="BASH">ssh -v server.example.com</code></pre><p><code>-v</code> 可以重复多次，表示信息的详细程度，比如 <code>-vv</code> 和 <code>-vvv</code></p><pre><code class="BASH">$ ssh -vvv server.example.com# 或者$ ssh -v -v -v server.example.com</code></pre><p>上面命令会输出最详细的连接信息</p><h3 id="V-参数输出-ssh-客户端的版本"><a href="#V-参数输出-ssh-客户端的版本" class="headerlink" title="-V 参数输出 ssh 客户端的版本"></a><code>-V</code> 参数输出 ssh 客户端的版本</h3><pre><code class="BASH">$ ssh –Vssh: SSH Secure Shell 3.2.3 (non-commercial version) on i686-pc-linux-gnu</code></pre><p>上面命令输出本机 ssh 客户端版本是 <code>SSH Secure Shell 3.2.3</code></p><h3 id="X-参数表示打开-X-窗口转发"><a href="#X-参数表示打开-X-窗口转发" class="headerlink" title="-X 参数表示打开 X 窗口转发"></a><code>-X</code> 参数表示打开 X 窗口转发</h3><pre><code class="BASH">ssh -X server.example.com</code></pre><h3 id="1-2参数指定使用-SSH1-SSH2-协议。"><a href="#1-2参数指定使用-SSH1-SSH2-协议。" class="headerlink" title="-1, -2参数指定使用 SSH1, SSH2 协议。"></a>-1, -2参数指定使用 SSH1, SSH2 协议。</h3><pre><code class="BASH">ssh -2 server.example.com</code></pre><h3 id="4-指定使用-IPv4-协议，这是默认值"><a href="#4-指定使用-IPv4-协议，这是默认值" class="headerlink" title="-4 指定使用 IPv4 协议，这是默认值"></a><code>-4</code> 指定使用 IPv4 协议，这是默认值</h3><pre><code class="BASH">ssh -4 server.example.com</code></pre><h3 id="6-指定使用-IPv6-协议"><a href="#6-指定使用-IPv6-协议" class="headerlink" title="-6 指定使用 IPv6 协议"></a><code>-6</code> 指定使用 IPv6 协议</h3><pre><code class="BASH">ssh -6 server.example.com</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;SSH&lt;/code&gt;，我们经常操作远程服务器的时候，都会用到这个命令，但是他除了登录服务器还有很多作用，下面我们一起来了解下吧&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="SSH" scheme="http://example.com/tags/SSH/"/>
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="shell" scheme="http://example.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>微服务缓存原理与最佳实践</title>
    <link href="http://example.com/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E7%BC%93%E5%AD%98/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://example.com/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E7%BC%93%E5%AD%98/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2021-01-08T17:52:53.000Z</published>
    <updated>2021-12-20T10:01:53.240Z</updated>
    
    <content type="html"><![CDATA[<p>文章主要介绍了分布式架构里的微服务缓存原理与最佳实践，下面让我们来一起看看吧</p><a id="more"></a><h2 id="为什么需要缓存？"><a href="#为什么需要缓存？" class="headerlink" title="为什么需要缓存？"></a>为什么需要缓存？</h2><ol><li><p> 程序存储在 <code>disk</code> 中</p></li><li><p> 程序是运行在 <code>RAM</code> 之中，也就是我们所说的 <code>main memory</code></p></li><li><p> 程序的计算逻辑在 <code>CPU</code> 中执行</p></li></ol><p>来看一个最简单的例子： <code>a = a + 1</code></p><ol><li><p> <code>load x:</code></p></li><li><p> <code>x0 = x0 + 1</code></p></li><li><p> <code>load x0 -&gt; RAM</code></p></li></ol><p><img src="/My-Blogs/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-01.png" alt="img"></p><p>上面提到了3种存储介质。我们都知道，三类的读写速度和成本成反比，所以我们在克服速度问题上需要引入一个 中间层。这个中间层，需要高速存取的速度，但是成本可接受。于是乎, <code>Cache</code> 被引入</p><p><img src="/My-Blogs/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-02.png" alt="img"></p><p>而在计算机系统中，有两种默认缓存：</p><p>CPU 里面的末级缓存，即 <code>LLC</code> 。缓存内存中的数据</p><p>内存中的高速页缓存，即 <code>page cache</code> 。缓存磁盘中的数据</p><h2 id="缓存读写策略"><a href="#缓存读写策略" class="headerlink" title="缓存读写策略"></a>缓存读写策略</h2><p>引入 <code>Cache</code> 之后，我们继续来看看操作缓存会发生什么。因为存在存取速度的差异「而且差异很大」，从而在操作数据时，延迟或程序失败等都会导致缓存和实际存储层数据不一致。</p><p>我们就以标准的 <code>Cache+DB</code> 来看看经典读写策略和应用场景。</p><h3 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache Aside"></a>Cache Aside</h3><p>先来考虑一种最简单的业务场景，比如用户表: <code>userId</code> : 用户id, <code>phone</code> : 用户电话token, <code>avtoar</code> : 用户头像url，缓存中我们用 <code>phone</code> 作为key存储用户头像。当用户修改头像url该如何做？</p><p>更新DB数据，再更新 <code>Cache</code> 数据</p><p>更新 DB 数据，再删除 <code>Cache</code> 数据</p><p>首先 变更数据库 和 变更缓存 是两个独立的操作，而我们并没有对操作做任何的并发控制。那么当两个线程并发更新它们的时候，就会因为写入顺序的不同造成数据不一致。</p><p>所以更好的方案是 <code>2</code> :</p><p>更新数据时不更新缓存，而是直接删除缓存</p><p>后续的请求发现缓存缺失，回去查询 <code>DB</code> ，并将结果 <code>load cache</code></p><p><img src="/My-Blogs/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-03.png" alt="img"></p><p>这个策略就是我们使用缓存最常见的策略: <code>Cache Aside</code> 。这个策略数据以数据库中的数据为准，缓存中的数据是按需加载的，分为读策略和写策略。</p><p>但是可见的问题也就出现了：频繁的读写操作会导致 <code>Cache</code> 反复地替换，缓存命中率降低。当然如果在业务中对命中率有监控报警时，可以考虑以下方案：</p><ol><li><p> 更新数据时同时更新缓存，但是在更新缓存前加一个 分布式锁。这样同一时间只有一个线程操作缓存，解决了并发问题。同时在后续读请求中时读到最新的缓存，解决了不一致的问题。</p></li><li><p> 更新数据时同时更新缓存，但是给缓存一个较短的 <code>TTL</code>。</p></li></ol><p>当然除了这个策略，在计算机体系还有其他几种经典的缓存策略，它们也有各自适用的使用场景。</p><h3 id="Write-Through"><a href="#Write-Through" class="headerlink" title="Write Through"></a>Write Through</h3><p>先查询写入数据key是否击中缓存，如果在 -&gt; 更新缓存，同时缓存组件同步数据至DB；不存在，则触发 ·。</p><p>而一般 · 有两种方式：</p><p><code>Write Allocate</code> ：写时直接分配 <code>Cache line</code></p><p><code>No-write allocate</code> ：写时不写入缓存，直接写入DB，return</p><p>在 <code>Write Through</code> 中，一般采取 <code>No-write allocate</code> 。因为其实无论哪种，最终数据都会持久化到DB中，省去一步缓存的写入，提升写性能。而缓存由 <code>Read Through</code> 写入缓存。</p><p><img src="/My-Blogs/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-04.png" alt="img"></p><p>这个策略的核心原则：<strong>用户只与缓存打交道，由缓存组件和DB通信，写入或者读取数据</strong>。在一些本地进程缓存组件可以考虑这种策略。</p><h3 id="Write-Back"><a href="#Write-Back" class="headerlink" title="Write Back"></a>Write Back</h3><p>相信你也看出上述方案的缺陷：写数据时缓存和数据库同步，但是我们知道这两块存储介质的速度差几个数量级，对写入性能是有很大影响。那我们是否异步更新数据库？</p><p><code>Write back</code> 就是在写数据时只更新该 Cache Line 对应的数据，并把该行标记为 Dirty。在读数据时或是在缓存满时换出「缓存替换策略」时，将 Dirty 写入存储。</p><p>需要注意的是：在 <code>Write Miss</code> 情况下，采取的是 <code>Write Allocate</code> ，即写入存储同时写入缓存，这样我们在之后的写请求只需要更新缓存。</p><p><img src="/My-Blogs/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-05.png" alt="img"></p><blockquote><p><code>async purge</code> 此类概念其实存在计算机体系中。 <code>Mysql</code> 中刷脏页，本质都是尽可能防止随机写，统一写磁盘时机。</p></blockquote><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><code>Redis</code> 是一个独立的系统软件，和我们写的业务程序是两个软件。当我们部署了Redis 实例后，它只会被动地等待客户端发送请求，然后再进行处理。所以，如果应用程序想要使用 Redis 缓存，我们就要在程序中增加相应的缓存操作代码。所以我们也把 <code>Redis</code> 称为 <strong>旁路缓存</strong>，也就是说：读取缓存、读取数据库和更新缓存的操作都需要在应用程序中来完成。</p><p>而作为缓存的 <code>Redis</code> ，同样需要面临常见的问题：</p><ul><li><p>缓存的容量终究有限</p></li><li><p>上游并发请求冲击</p></li><li><p>缓存与后端存储数据一致性</p></li></ul><h3 id="替换策略"><a href="#替换策略" class="headerlink" title="替换策略"></a>替换策略</h3><p>一般来说，缓存对于选定的被淘汰数据，会根据其是干净数据还是脏数据，选择直接删除还是写回数据库。但是，在 Redis 中，被淘汰数据无论干净与否都会被删除，所以，这是我们在使用 Redis 缓存时要特别注意的：当数据修改成为脏数据时，需要在数据库中也把数据修改过来。</p><p>所以不管替换策略是什么，脏数据有可能在换入换出中丢失。那我们在产生脏数据就应该删除缓存，而不是更新缓存，一切数据应该以数据库为准。这也很好理解，缓存写入应该交给读请求来完成；写请求尽可能保证数据一致性。</p><p>至于替换策略有哪些，网上已经有很多文章归纳之间的优劣，这里就不再赘述。</p><h2 id="缓存和存储更新顺序"><a href="#缓存和存储更新顺序" class="headerlink" title="缓存和存储更新顺序"></a>缓存和存储更新顺序</h2><p>这是开发中常见纠结问题：<strong>到底是先删除缓存还是先更新存储</strong>？</p><blockquote><p>情况一：先删除缓存，再更新存储；</p><ul><li>A 删除缓存，更新存储时网络延迟</li><li>B 读请求，发现缓存缺失，读存储 -&gt; 此时读到旧数据</li></ul></blockquote><p>这样会产生两个问题：</p><ul><li>B 读取旧值</li><li>B 同时读请求会把旧值写入缓存，导致后续读请求读到旧值</li></ul><p>既然是缓存可能是旧值，那就不管删除。有一个并不优雅的解决方案：<strong>在写请求更新完存储值以后</strong>， <code>sleep()</code> <strong>一小段时间，再进行一次缓存删除操作</strong>。</p><p><code>sleep</code> 是为了确保读请求结束，写请求可以删除读请求造成的缓存脏数据，当然也要考虑到 redis 主从同步的耗时。不过还是要根据实际业务而定。</p><p>这个方案会在第一次删除缓存值后，延迟一段时间再次进行删除，被称为： <code>延迟双删</code> 。</p><blockquote><p>情况二：先更新数据库值，再删除缓存值：</p><ul><li>A 删除存储值，但是删除缓存网络延迟</li><li>B 读请求时，缓存击中，就直接返回旧值</li></ul></blockquote><p>这种情况对业务的影响较小，而绝大多数缓存组件都是采取此种更新顺序，满足最终一致性要求。</p><blockquote><p>情况三：新用户注册，直接写入数据库，同时缓存中肯定没有。如果程序此时读从库，由于主从延迟，导致读取不到用户数据。</p></blockquote><p>这种情况就需要针对 Insert 这种操作：插入新数据入数据库同时写缓存。使得后续读请求可以直接读缓存，同时因为是刚插入的新数据，在一段时间修改的可能性不大。</p><p><strong>以上方案在复杂的情况或多或少都有潜在问题，需要贴合业务做具体的修改。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;文章主要介绍了分布式架构里的微服务缓存原理与最佳实践，下面让我们来一起看看吧&lt;/p&gt;</summary>
    
    
    
    <category term="分布式架构" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="分布式架构" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/"/>
    
    <category term="缓存" scheme="http://example.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
</feed>
