<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>John Doe&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-01-15T01:30:52.182Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/01/15/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/%E4%B8%AA%E4%BA%BA%E6%8A%A4%E5%9F%8E%E6%B2%B3/"/>
    <id>http://example.com/2021/01/15/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/%E4%B8%AA%E4%BA%BA%E6%8A%A4%E5%9F%8E%E6%B2%B3/</id>
    <published>2021-01-15T01:30:52.182Z</published>
    <updated>2021-01-15T01:30:52.182Z</updated>
    
    <content type="html"><![CDATA[<h3 id="我最喜欢的职业建议是发展”个人护城河“。"><a href="#我最喜欢的职业建议是发展”个人护城河“。" class="headerlink" title="我最喜欢的职业建议是发展”个人护城河“。"></a>我最喜欢的职业建议是发展”<a href="https://eriktorenberg.substack.com/p/build-personal-moats">个人护城河</a>“。</h3><br><p><img src="https://www.wangbase.com/blogimg/asset/202009/bg2020092807.jpg" alt="image"></p><br><p>你的个人护城河是一组独特的且不断累积的竞争优势，别人很难学习，或者很难做到。如果你有了它，你会让自己变得无法取代。</p><br><p>你必须找到属于你的特殊东西，而且这些东西会随着时间的流逝而增加价值。</p><br><h3 id="如何找到自己的护城河？"><a href="#如何找到自己的护城河？" class="headerlink" title="如何找到自己的护城河？"></a>如何找到自己的护城河？</h3><br><p>你可以问自己：对我来说，什么事情容易做，而对别人却很难？我所拥有的技能中，哪些是其他人模仿会非常困难的？或者，你所爱的、擅长的事物，跟社会需要的事物有什么交汇点？</p><br><p>护城河会随着条件的变化而变化。比如，录音技术诞生之前，稀缺的是音乐本身，你想听音乐，就需要有一个艺术家给你现场表演。现在，音乐录音到处都是，稀缺的是策划、发行和个性的展示。</p><br><p>同样地，在社会中，以前的稀缺资源是金钱和特殊关系。而在互联网时代，稀缺的是特定知识和某些稀有技能。</p><br><p>漫画家斯科特·亚当斯（Scott Adams）曾经提过一种建立个人护城河的方法，就是找到自己最擅长的2个～3个事物的交集。比如，他既不是最好的漫画家，也不是最好的作家，也不是最好的企业家，但他可以是最好的商业类漫画短文作者，这就是他的护城河。</p><br><p>总之，你要发现对你来说容易而对他人却很难的事物，并在这些事物上变得出色，然后利用它来积累社会和金融资本。</p><br><h3 id="找出最擅长的2-3个事物的交集。"><a href="#找出最擅长的2-3个事物的交集。" class="headerlink" title="找出最擅长的2~3个事物的交集。"></a><strong>找出最擅长的2~3个事物的交集</strong>。</h3><br><p><img src="https://cdn.substack.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F3e1e36d1-f32a-4aff-bd08-10e131454905_1124x1063.png" alt="交集图"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;我最喜欢的职业建议是发展”个人护城河“。&quot;&gt;&lt;a href=&quot;#我最喜欢的职业建议是发展”个人护城河“。&quot; class=&quot;headerlink&quot; title=&quot;我最喜欢的职业建议是发展”个人护城河“。&quot;&gt;&lt;/a&gt;我最喜欢的职业建议是发展”&lt;a href=&quot;http</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Explain使用分析</title>
    <link href="http://example.com/2021/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/Explain%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2021/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/Explain%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/</id>
    <published>2021-01-08T18:06:09.000Z</published>
    <updated>2021-01-15T01:30:52.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.<br>EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:</p><a id="more"></a><pre><code class="SQL">EXPLAIN SELECT * from user_info WHERE  id &lt; 300;</code></pre><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:</p><pre><code class="SQL">CREATE TABLE `user_info` (  `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,  `name` VARCHAR(50) NOT NULL DEFAULT '',  `age`  INT(11)              DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `name_index` (`name`))  ENGINE = InnoDB  DEFAULT CHARSET = utf8</code></pre><pre><code class="SQL">CREATE TABLE `order_info` (  `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,  `user_id`      BIGINT(20)           DEFAULT NULL,  `product_name` VARCHAR(50) NOT NULL DEFAULT '',  `productor`    VARCHAR(30)          DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`))  ENGINE = InnoDB  DEFAULT CHARSET = utf8</code></pre><h2 id="EXPLAIN-输出格式"><a href="#EXPLAIN-输出格式" class="headerlink" title="EXPLAIN 输出格式"></a>EXPLAIN 输出格式</h2><p>EXPLAIN 命令的输出内容大致如下:</p><pre><code class="SQL">mysql&gt; explain select * from user_info where id = 2\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)</code></pre><p>各列的含义如下:</p><ul><li><p><code>id</code>: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</p></li><li><p><code>select_type</code>: SELECT 查询的类型.</p></li><li><p><code>table</code>: 查询的是哪个表</p></li><li><p><code>partitions</code>: 匹配的分区</p></li><li><p><code>type</code>: join 类型</p></li><li><p><code>possible_keys</code>: 此次查询中可能选用的索引</p></li><li><p><code>key</code>: 此次查询中确切使用到的索引.</p></li><li><p><code>ref</code>: 哪个字段或常数与 key 一起被使用</p></li><li><p><code>rows</code>: 显示此查询一共扫描了多少行. 这个是一个估计值.</p></li><li><p><code>filtered</code>: 表示此查询条件所过滤的数据的百分比</p></li><li><p><code>extra</code>: 额外的信息</p></li></ul><p>接下来我们来重点看一下比较重要的几个字段.</p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p><code>select_type</code> 表示了查询的类型, 它的常用取值有:</p><ul><li><p>SIMPLE, 表示此查询不包含 UNION 查询或子查询</p></li><li><p>PRIMARY, 表示此查询是最外层的查询</p></li><li><p>UNION, 表示此查询是 UNION 的第二或随后的查询</p></li><li><p>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询</p></li><li><p>UNION RESULT, UNION 的结果</p></li><li><p>SUBQUERY, 子查询中的第一个 SELECT</p></li><li><p>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</p></li></ul><p>最常见的查询类别应该是 <code>SIMPLE</code> 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 <code>SIMPLE</code> 类型, 例如:</p><pre><code class="SQL">mysql&gt; explain select * from user_info where id = 2\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)</code></pre><p>如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:</p><pre><code class="SQL">mysql&gt; EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3))    -&gt; UNION    -&gt; (SELECT * FROM user_info WHERE id IN (3, 4, 5));+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+| id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+|  1 | PRIMARY      | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     ||  2 | UNION        | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     || NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+3 rows in set, 1 warning (0.00 sec)</code></pre><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>表示查询涉及的表或衍生表</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p><code>type</code> 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 <code>type</code> 字段, 我们判断此次查询是 <code>全表扫描</code> 还是 <code>索引扫描</code> 等.</p><p><strong>type 常用类型</strong><br>type 常用的取值有:</p><p><code>system</code> : 表中只有一条数据. 这个类型是特殊的 <code>const</code> 类型.</p><p><code>const</code> : 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. <code>const</code> 查询速度非常快, 因为它仅仅读取一次即可.<br>例如下面的这个查询, 它使用了主键索引, 因此 <code>type</code> 就是 <code>const</code> 类型的.</p><pre><code class="SQL">mysql&gt; explain select * from user_info where id = 2\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)</code></pre><ul><li><code>eq_ref</code>: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:</li></ul><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: indexpossible_keys: user_product_detail_index          key: user_product_detail_index      key_len: 314          ref: NULL         rows: 9     filtered: 100.00        Extra: Using where; Using index*************************** 2. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: eq_refpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: test.order_info.user_id         rows: 1     filtered: 100.00        Extra: NULL2 rows in set, 1 warning (0.00 sec)</code></pre><ul><li><code>ref</code>: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 <code>最左前缀</code> 规则索引的查询.</li></ul><p>例如下面这个例子中, 就使用到了 <code>ref</code> 类型的查询:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: const         rows: 1     filtered: 100.00        Extra: NULL*************************** 2. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: refpossible_keys: user_product_detail_index          key: user_product_detail_index      key_len: 9          ref: const         rows: 1     filtered: 100.00        Extra: Using index2 rows in set, 1 warning (0.01 sec)</code></pre><ul><li><code>range</code>: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.</li></ul><p>当 <code>type</code> 是 <code>range</code> 时, 那么 EXPLAIN 输出的 <code>ref</code> 字段为 NULL, 并且 <code>key_len</code> 字段是此次查询中使用到的索引的最长的那个.</p><p>例如下面的例子就是一个范围查询:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT *    -&gt;         FROM user_info    -&gt;         WHERE id BETWEEN 2 AND 8 \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: rangepossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: NULL         rows: 7     filtered: 100.00        Extra: Using where1 row in set, 1 warning (0.00 sec)</code></pre><ul><li><code>index</code>: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.</li></ul><p><code>index</code> 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 <code>Using index</code> .</p><p>例如:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT name FROM  user_info \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: indexpossible_keys: NULL          key: name_index      key_len: 152          ref: NULL         rows: 10     filtered: 100.00        Extra: Using index1 row in set, 1 warning (0.00 sec)</code></pre><p>上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 <code>index</code> , 并且 Extra 的值是 <code>Using index</code> .</p><ul><li><code>ALL</code>: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.</li></ul><p>下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT age FROM  user_info WHERE age = 20 \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 10     filtered: 10.00        Extra: Using where1 row in set, 1 warning (0.00 sec)</code></pre><p><strong>type 类型的性能比较</strong></p><p>通常来说, 不同的 type 类型的性能关系如下:</p><p> <code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code></p><p><code>ALL</code> 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.</p><p>而 <code>index</code> 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.</p><p>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</p><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p><code>possible_keys</code> 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 <code>possible_keys</code> 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 <code>key</code> 字段决定.</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>此字段是 MySQL 在当前查询时所真正使用到的索引.</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.<br>key_len 的计算规则如下:</p><ul><li><p>字符串</p><ul><li><p>char(n): n 字节长度</p></li><li><p>varchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.</p></li></ul></li><li><p>数值类型:</p><ul><li><p>TINYINT: 1字节</p></li><li><p>SMALLINT: 2字节</p></li><li><p>MEDIUMINT: 3字节</p></li><li><p>INT: 4字节</p></li><li><p>BIGINT: 8字节</p></li><li><p>时间类型</p></li><li><p>DATE: 3字节</p></li><li><p>TIMESTAMP: 4字节</p></li><li><p>DATETIME: 8字节</p></li><li><p>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.</p></li></ul></li></ul><p>我们来举两个简单的栗子:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id &lt; 3 AND product_name = 'p1' AND productor = 'WHH' \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: rangepossible_keys: user_product_detail_index          key: user_product_detail_index      key_len: 9          ref: NULL         rows: 5     filtered: 11.11        Extra: Using where; Using index1 row in set, 1 warning (0.00 sec)</code></pre><p>上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 <code>order_info</code> 有一个联合索引:</p><pre><code class="SQL">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</code></pre><p>不过此查询语句 <code>WHERE user_id &lt; 3 AND product_name = 'p1' AND productor = 'WHH'</code> 中, 因为先进行 user_id 的范围查询, 而根据 <code>最左前缀匹配</code> 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 <code>user_id</code> , 因此在 <code>EXPLAIN</code> 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 <code>BIGINT(20) NOT NULL DEFAULT '0'</code> , 则 key_length 应该是8.</p><p>上面因为 <code>最左前缀匹配</code> 原则, 我们的查询仅仅使用到了联合索引的 <code>user_id</code> 字段, 因此效率不算高.</p><p>接下来我们来看下一个例子:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = 'p1' \G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: refpossible_keys: user_product_detail_index          key: user_product_detail_index      key_len: 161          ref: const,const         rows: 2     filtered: 100.00        Extra: Using index1 row in set, 1 warning (0.00 sec)</code></pre><p>这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 <code>WHERE user_id = 1 AND product_name = 'p1'</code> 中, 仅仅使用到了联合索引中的前两个字段, 因此 <code>keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</code></p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p><code>rows</code> 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br>这个值非常直观显示 SQL 的效率好坏, 原则上 <code>rows</code> 越少越好.</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p><code>EXplain</code> 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p><ul><li><code>Using filesort</code></li></ul><p>当 Extra 中有 <code>Using filesort</code> 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 <code>Using filesort</code> , 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</p><p>例如下面的例子:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY product_name \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: indexpossible_keys: NULL          key: user_product_detail_index      key_len: 253          ref: NULL         rows: 9     filtered: 100.00        Extra: Using index; Using filesort1 row in set, 1 warning (0.00 sec)</code></pre><p>我们的索引是</p><pre><code class="SQL">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</code></pre><p>但是上面的查询中根据 <code>product_name</code> 来排序, 因此不能使用索引进行优化, 进而会产生 <code>Using filesort</code> .<br>如果我们将排序依据改为 <code>ORDER BY user_id, product_name</code> , 那么就不会出现 <code>Using filesort</code> 了. 例如:</p><pre><code class="SQL">mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: order_info   partitions: NULL         type: indexpossible_keys: NULL          key: user_product_detail_index      key_len: 253          ref: NULL         rows: 9     filtered: 100.00        Extra: Using index1 row in set, 1 warning (0.00 sec)</code></pre><ul><li><p><code>Using index</code> “覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</p></li><li><p><code>Using temporary</code> 查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;MySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.&lt;br&gt;EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>db操作常见问题</title>
    <link href="http://example.com/2021/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2021-01-08T18:05:18.000Z</published>
    <updated>2021-01-15T01:30:52.182Z</updated>
    
    <content type="html"><![CDATA[<p>总结了一些db操作的常见问题，让我们一起来看看吧</p><a id="more"></a><h2 id="联合索引问题"><a href="#联合索引问题" class="headerlink" title="联合索引问题"></a>联合索引问题</h2><ol><li> 在imo后台群唤醒活动中，用户数据表多达几千万，大数据这边，并未针对业务场景建立有效覆盖索引，导致后台SQL慢查询告警上千次，针对业务场景，提出以下优化，新增key1，key2索引覆盖，后台where条件严格按照stats_day，activelevel，categeory_id，cc顺序查询。</li><li> 按照MySQL联合索引最左匹配原则，比如A-B-C联合索引，则针对A，A-B，A-B-C查询有效，而A-C，B-C，B，C则无效，where条件最好根据索引顺序进行</li><li> 如果搜索条件过于复杂混乱，建议先与产品沟通清楚，确定好如何建立索引，严格把控搜索条件（从界面上）</li><li> 以下为用户数据表（千万级别）</li></ol><pre><code class="SQL">CREATE TABLE `xx_push_activelevel_categeory_day` (  `stats_day` date NOT NULL DEFAULT '2019-01-01',  `cc` varchar(10) NOT NULL DEFAULT '',  `activelevel` varchar(30) NOT NULL DEFAULT 'unknown',  `categeory_id` varchar(50) NOT NULL DEFAULT 'unknown',  `groupid` char(30) NOT NULL DEFAULT 'unknown',  `role` varchar(15) NOT NULL DEFAULT 'unknown',  `uid` varchar(25) NOT NULL DEFAULT '',  PRIMARY KEY (`role`,`activelevel`,`categeory_id`,`cc`,`uid`,`groupid`,`stats_day`),  KEY `role` (`role`,`activelevel`,`categeory_id`),  KEY `key1` (`stats_day`,`activelevel`,`categeory_id`,`cc`,`role`),  KEY `key2` (`stats_day`,`activelevel`,`categeory_id`,`cc`),  KEY `actl` (`activelevel`),  KEY `agid` (`categeory_id`),  KEY `cc` (`cc`)) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4/*!50100 PARTITION BY RANGE (TO_DAYS(stats_day))(PARTITION pd20200609 VALUES LESS THAN (737951) ENGINE = MyISAM, PARTITION pd20200610 VALUES LESS THAN (737952) ENGINE = MyISAM, PARTITION pd20200611 VALUES LESS THAN (737953) ENGINE = MyISAM) */;</code></pre><h2 id="主键偏移问题"><a href="#主键偏移问题" class="headerlink" title="主键偏移问题"></a>主键偏移问题</h2><ol><li> 在单表大数据量的情况下，使用索引并不是唯一选择，当SQL分页查询，offset达到一定量(大概20w以上？)以后，就会出现慢查询现象，是由于MySQL根据索引查出一定量数据之后，会根据offset抛弃之前的数据</li><li> 这意味着前20w数据的查询都是无用的，费力不讨好</li><li> 可以采用主键id(INT, BIGINT类型)偏移，INT类型查询天生就有优势，又是主键索引，可以做到一部到位</li><li> where条件最后，加上id排序，记录上一次的查询数据最后一条id，下一次查询作为偏移量，从而跳过前面无用的数据，再开始进行索引查询</li><li> 以下是某个项目的例子（仅供参考）</li></ol><pre><code class="SQL">SELECT id, stats_day, cc, activelevel, categeory_id, groupid, role, uid FROM xx_push_activelevel_categeory_day AS biggroupPushCategeoryWHERE biggroupPushCategeory.id &gt; 200000 AND biggroupPushCategeory.stats_day = '2020-07-01 00:00:00' AND biggroupPushCategeory.activelevel = 'gtype_unactive_2' AND biggroupPushCategeory.categeory_id = 'categeory_mems_less_300' AND biggroupPushCategeory.cc = 'PK'ORDER BY biggroupPushCategeory.id ASC LIMIT 500;</code></pre><h2 id="结果集过滤问题"><a href="#结果集过滤问题" class="headerlink" title="结果集过滤问题"></a>结果集过滤问题</h2><ol><li> 接上一个问题，当我们结合主键偏移+索引【KEY <code>sacc</code> (<code>stats_day</code>,<code>activelevel</code>,<code>categeory_id</code>,<code>cc</code>)】搜索的时候，SQL这边优先根据索引过滤结果集，根据上面那条sql，我们可能会过滤出一个大结果集，而且结果集并不保证id有序</li><li> 这时候我们需要重新修改索引键，加上主键id，例如KEY <code>sacci</code> (<code>stats_day</code>,<code>activelevel</code>,<code>categeory_id</code>,<code>cc</code>,<code>id</code>)，当我们进行索引查询取500行时，可以根据id&gt;20000，直接命中500行并返回，不需要重新排序，也不会返回之前sacc索引的所有结果集</li><li> 以下是优化前和优化后的对比图，性能提高了几十倍</li></ol><h3 id="优化前"><a href="#优化前" class="headerlink" title="优化前"></a>优化前</h3><p><img src="/My-Blogs/images/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-01.png" alt="优化前"></p><h3 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h3><p><img src="/My-Blogs/images/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-02.png" alt="优化后"></p><h2 id="where条件顺序问题"><a href="#where条件顺序问题" class="headerlink" title="where条件顺序问题"></a>where条件顺序问题</h2><ol><li> 接上一个问题，我们已经创建索引KEY <code>sacci</code> (<code>stats_day</code>,<code>activelevel</code>,<code>categeory_id</code>,<code>cc</code>,<code>id</code>)，如果我们把id放在最前，或者最后，会对查询的效率有影响吗？答案是没有。</li><li> SQL执行是会被进行一系列预处理，让查询优化器选择最优的查询计划，所以where条件的先后关系不是优化器选择规则的一条，当然前提是你的where条件数量与索引一致，如果where条件少于索引数量，会根据最左原则优先查询。</li><li> 总的来说，唯一会影响的就是where条件和索引的比对，以及跟order by等，跟先后顺序无关。</li><li> 引申开来说，如果对ABC三个字段建立联合索引，一般来说，在创建索引时，根据区分度原则，尽量让A能够排除更多记录而不是B或C，在查询时，根据索引前缀匹配原则，尽可能让A条件精确，B其次，C看着办。</li><li> 以下是id前后对比图</li></ol><p><img src="/My-Blogs/images/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-03.png" alt="alt"></p><p><img src="/My-Blogs/images/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-04.png" alt="alt"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结了一些db操作的常见问题，让我们一起来看看吧&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>PRPL模式加快Web应用加载</title>
    <link href="http://example.com/2021/01/08/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/"/>
    <id>http://example.com/2021/01/08/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/</id>
    <published>2021-01-08T18:01:13.000Z</published>
    <updated>2021-01-15T01:30:52.181Z</updated>
    
    <content type="html"><![CDATA[<p>PRPL 是一种用于结构化和交付 Web 应用程序和渐进式 Web 应用（PWA）的模式，重点在于改进应用的交付和启动性能。这个模式包含一组步骤，以实现快速、可靠、高效的加载：</p><a id="more"></a><ul><li><p><code>Push</code>, 推送初始路由所需的所有资源，并且只推送这些资源，以确保它们尽早可用。</p></li><li><p><code>Render</code>, 在加载其他资源之前，渲染初始路由并使其具备交互能力。</p></li><li><p><code>Pre-cache</code>, 预缓存用户可能访问的其他路由的资源，从而在恶劣的网络条件下尽可能提高对后续请求的响应能力和弹性。</p></li><li><p><code>Lazy-load</code>, 当用户请求时，按需延迟加载路由；关键路由的资源应立即从缓存中加载，而相对不常用的资源可以根据请求从网络获取。</p></li></ul><blockquote><p>注意：PRPL模式是由Polymer团队于2016年首次引入的，但已被证明适用于其他许多技术栈。</p></blockquote><p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-01.png" alt="img"></p><center>PRPL 模式加载顺序</center><p>服务器和服务 Worker 一起为非活动路由预缓存资源。当用户切换路由时，应用会延迟加载尚未缓存的所有必需资源，并创建所需的视图。</p><p>Twitter.com 自 2017 年以来就在生产中使用 PRPL 模式了。下面我们可以看到，他们对关键脚本使用了粒度代码拆分，并使用 <code>&lt;linkrel=preload&gt;</code> 推送脚本以尽快让脚本可用：</p><p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-02.png" alt="img"></p><br><center style="margin-top: 20px">PRPL 模式：预加载关键脚本</center><br><p>其他路由会按需延迟加载。Twitter 在整个用户体验部分中会按需提供 40 多个块。Twitter 还使用服务 Workers 对其他路由进行（离线）资产预缓存，以提高对后续导航操作的响应能力：</p><br><p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-03.png" alt="img"></p><br><center style="margin-top: 20px">PRPL 模式：离线缓存资源</center><br><p>他们的应用程序外壳程序（骨架 UI）也是离线缓存的，就算用户通过缓慢或不稳定的网络连接加载站点，也会立即加载它们：</p><p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-04.png" alt="img"></p><center>PRPL 模式：应用程序外壳</center><h2 id="为什么选择-PRPL？"><a href="#为什么选择-PRPL？" class="headerlink" title="为什么选择 PRPL？"></a>为什么选择 PRPL？</h2><p>应用使用 PRPL 构建是为了达到可靠、快速和引人入胜的目的。除了这些基本目标，PRPL 还旨在：</p><ul><li><p><strong>改善应用的交互就绪水平</strong>。为了做到这一点，在第一个视图渲染并具备交互能力之前，不会向浏览器发送多余的资源。</p></li><li><p><strong>提高应用的缓存效率，尤其是长期缓存效率</strong>。为了做到这一点，资源会以很细的粒度向浏览器发送。当资源被解绑或松散地打包时，对代码的每次更改给缓存的负面影响也会减少。</p></li><li><p><strong>降低开发和部署的复杂性</strong>。为了做到这一点，这种模式使用应用的隐式依赖图将每个入口点精确映射到所需的资源集，从而减少或消除了手动管理打包和交付的需求。</p></li></ul><h2 id="PRPL-应包含哪些技术？"><a href="#PRPL-应包含哪些技术？" class="headerlink" title="PRPL 应包含哪些技术？"></a>PRPL 应包含哪些技术？</h2><p>PRPL 是一种能以各种方式实现的概念模式，但是通过以下现代 Web 特性的某种组合，可以最轻松有效地实现 PRPL：</p><ul><li><p>像JavaScript Modules这样的现代模块系统，使工具可以轻松构造完整的依赖图；</p></li><li><p>服务Workers，为后续的应用视图预缓存（“安装”）资源（进而支持离线优先架构）</p></li><li><p>预加载，用于尽快交付所需资源。你还可以使用预加载链接头，这些头可以被协作服务器拦截并升级为HTTP/2 Server Push（详情可见<a href="https://www.smashingmagazine.com/2017/04/guide-http2-server-push/">原文</a>）。一定要记住，尽管Push功能强大，但它也面临着许多已知的挑战；不过PRPL使用服务Worker可以避免过度推送的问题（仅针对初始负载使用push）。</p></li></ul><h2 id="如何实现-PRPL-模式？"><a href="#如何实现-PRPL-模式？" class="headerlink" title="如何实现 PRPL 模式？"></a>如何实现 PRPL 模式？</h2><p>PRPL 的很大一部分理念是对 JS 打包思维的颠覆，并在提供资源时拆分成尽可能接近编写资源时的粒度（至少拆分成独立的功能模块）。那么如何实现细粒度呢？</p><h3 id="基于路由或基于组件的代码拆分和延迟加载"><a href="#基于路由或基于组件的代码拆分和延迟加载" class="headerlink" title="基于路由或基于组件的代码拆分和延迟加载"></a>基于路由或基于组件的代码拆分和延迟加载</h3><p>你正在将事物编写为组件。也许你正在使用 ES 模块。对于 Webpack，我们使用动态导入和代码拆分，将你的代码库拆分为按需加载的块。</p><br><p>Next.js 和 Nuxt.js 之类的元框架会默认实现基于路由的代码拆分。如果你使用的是 create-react-app 之类的工具链样板，则需要借助 React Router 之类的路由器进行动态导入，才能将基于路由或基于组件的代码拆分添加到你的应用程序中。</p><br><p>对于 PRPL 的 push/preload 部分，Webpack 还支持将 preload 作为魔术注释来预加载关键脚本。</p><br><h3 id="预缓存"><a href="#预缓存" class="headerlink" title="预缓存"></a>预缓存</h3><p>可以使用服务 worker 预缓存剩余的路由。另一种常见的做法是，利用 Workbox 之类的服务 worker 库来简化为应用程序预缓存路由和块的过程。</p><br><h2 id="PRPL-使用何种应用程序结构？"><a href="#PRPL-使用何种应用程序结构？" class="headerlink" title="PRPL 使用何种应用程序结构？"></a>PRPL 使用何种应用程序结构？</h2><p>PRPL 鼓励采用以下结构的单页应用（SPA）架构：</p><br><ul><li><p>从每个有效路由提供的应用程序的主入口点。</p></li><li><p>这个文件应该很小，因为它将通过不同的URL提供，因此会被多次缓存。入口点中的所有资源URL都必须是绝对的，因为它可以从非顶级URL提供。</p></li><li><p>外壳（app-shell），其中包括顶级应用逻辑、router等。</p></li><li><p>延迟加载的应用片段。</p></li><li><p>可以代表特定视图代码的片段，或其他可以延迟加载的代码（例如，主应用的一些部分在第一次绘制时并不需要，比如说菜单，直到用户与应用交互时才显示）。外壳负责根据需要动态导入这些片段。</p></li></ul><p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-05.png" alt="img"></p><center style="margin: 20px 0 20px 0; ">应用外壳骨架模式</center><p>应用应根据需要调用动态导入以延迟加载片段。例如，当用户更改为新路由时，它将导入与该路由关联的片段。这可能会向服务器发起新请求，或者只是从缓存中加载资源。</p><br><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>除了针对 PWA 的基本目标和标准之外，PRPL 还尽量针对以下方面做了优化：</p><br><ul><li><p>尽量减少交互的准备工作——特别是在首次使用时（无论入口点如何）。</p></li><li><p>尽量提升缓存效率，尤其是更新不断发布后的长期缓存效率。</p></li><li><p>简化开发和部署。</p></li></ul><p>自 2016 年诞生以来，PRPL 模式已获得了大规模使用，值得你在优化应用加载时考虑。</p><p>原文链接：<a href="https://addyosmani.com/blog/the-prpl-pattern/">https://addyosmani.com/blog/the-prpl-pattern/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;PRPL 是一种用于结构化和交付 Web 应用程序和渐进式 Web 应用（PWA）的模式，重点在于改进应用的交付和启动性能。这个模式包含一组步骤，以实现快速、可靠、高效的加载：&lt;/p&gt;</summary>
    
    
    
    <category term="性能优化" scheme="http://example.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="性能优化" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>谈谈登录</title>
    <link href="http://example.com/2021/01/08/%E5%AE%89%E5%85%A8/%E8%B0%88%E8%B0%88%E7%99%BB%E5%BD%95/"/>
    <id>http://example.com/2021/01/08/%E5%AE%89%E5%85%A8/%E8%B0%88%E8%B0%88%E7%99%BB%E5%BD%95/</id>
    <published>2021-01-08T17:57:43.000Z</published>
    <updated>2021-01-15T01:30:52.181Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Cookie与Session"><a href="#一、Cookie与Session" class="headerlink" title="一、Cookie与Session"></a>一、Cookie与Session</h3><p>HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行保存。因为无法管理用户状态，对于要登录的页面，每次跳转新页面时都需要再次登录。</p><a id="more"></a><p>于是引入了Cookie来管理用户状态：</p><p>① 首先客户端发起不带Cookie信息的登录请求</p><p>② 服务端接收到请求，验证用户数据正确后，添加响应头Set-Cookie</p><p>③ 客户端收到响应报文后，检查到响应头Set-Cookie，在本地保存Cookie</p><p>④ 之后每次向该域发起请求时，自动添加请求头Cookie，发送给服务端</p><p>⑤ 服务端获取请求头Cookie，根据Cookie的值，就可以判断出用户是否登录</p><p>但是Cookie极容易被篡改和伪造，于是产生了Session，Session将用户信息保存在服务端，那么Session是如何管理用户状态的呢？</p><p>① 首先客户端发起不带Cookie信息的登录请求</p><p>② 服务端接收到请求，检查到没有携带口令，验证用户密码正确后生成Session，将用户信息保存在Session，设置响应头Set-Cookie，通常是将Session ID作为口令值</p><p>③ 客户端检查到Set-Cookie响应头，在本地保存Cookie信息</p><p>④ 之后每次发起请求时，自动在请求头Cookie中携带口令，发送给服务端</p><p>⑤ 服务端获取Cookie携带的口令值，找到对应的Session，就可以判断用户状态</p><h3 id="二、如何让Session口令值更安全"><a href="#二、如何让Session口令值更安全" class="headerlink" title="二、如何让Session口令值更安全"></a>二、如何让Session口令值更安全</h3><p>虽然口令值由服务端生成，用户不容易伪造，But nothing is impossible；而且口令值存在客户端，就有可能被盗用。一旦口令值被伪造或盗用，攻击者就可以伪装成用户访问服务端的数据。</p><p>那么如何让Session口令值更安全呢？</p><p>① 将客户端的某些独有信息+口令值作为原值，对其进行签名</p><p>② 将口令值拼接签名返回给客户端，将Cookie设置为HttpOnly（禁止用户通过脚本来获取和更改Cookie）</p><p>③ 服务端再次收到请求，取客户端信息与口令值签名，与客户端携带的签名对比，不相等，说明请求不合法</p><p>这样的话：</p><p>① 即使攻击者知道了口令值，由于不知道密钥，无法伪造签名</p><p>② 即使攻击者通过某种方式得到了真实的口令值和签名，但是由于攻击者的客户端信息不一样，发送到服务端后，会得到不一样的签名，签名校验不能通过</p><h3 id="三、多系统的复杂性"><a href="#三、多系统的复杂性" class="headerlink" title="三、多系统的复杂性"></a>三、多系统的复杂性</h3><p>web系统由早期的单系统发展成多系统组成的应用群，面对如此众多的系统，用户难道要一个个登录、再一个个注销吗？</p><p>系统复杂性应该由系统内部承担，而不是用户。无论web系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问web系统的整个应用群与访问单个系统一样，只要登录/注销一次就够了。</p><p><img src="/My-Blogs/images/%E8%B0%88%E8%B0%88%E7%99%BB%E5%BD%95-01.png"></p><p>因为Cookie不允许跨域，早期多系统登录采用将Cookie种在顶级域名下的方式，来实现Cookie共享。这种方式的局限在于：</p><p>① 应用群各系统的域名得统一</p><p>② 应用群各系统的web服务端使用的技术要相同，比如Session口令值以及它的签名</p><p>方式要相同，要不Session口令值不同，无法维持会话</p><p>因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录。</p><h3 id="四、单点登录"><a href="#四、单点登录" class="headerlink" title="四、单点登录"></a>四、单点登录</h3><p>单点登录全称Single Sign On（简称SSO），是指在多系统应用群中登录一个系统，便可在其它所有系统中得到授权而无需再次登录。包括单点登录与单点注销两部分：</p><h4 id="1、单点登录"><a href="#1、单点登录" class="headerlink" title="1、单点登录"></a>1、单点登录</h4><p>　    相比于单系统登录，SSO需要一个独立的认证中心，只有认证中心能接受用户的用    户名密码等安全信息，其它系统不提供登录入口，只接受认证中心的间接授权。</p><p>通常SSO认证中心验证用户数据没问题后，会创建授权Token，分发给各个子系统。子系统拿到Token，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。这个过程，也就是单点登录的原理。</p><p><img src="/My-Blogs/images/%E8%B0%88%E8%B0%88%E7%99%BB%E5%BD%95-02.png"></p><p>例如：</p><p>    用户访问系统1，系统1发现用户未登录，跳转至SSO认证中心，并将自己的地址作为参数</p><p>    SSO认证中心发现用户未登录，将用户引导至登录页面</p><p>    用户输入用户名密码提交登录申请</p><p>    SSO认证中心校验用户信息，创建用户与SSO认证中心之间的会话，称为全局会话，同时创建授权Token</p><p>    SSO认证中心带着Token跳转回最初的请求地址（系统1）</p><p>    系统1拿到Token，去SSO认证中心校验Token是否有效</p><p>    SSO认证中心校验Token，返回有效，注册系统1</p><p>    系统1使用该Token创建与用户的会话，称为局部会话，返回受保护资源</p><p>    用户访问系统2的受保护资源</p><p>    系统2发现用户未登录，跳转至SSO认证中心，并将自己的地址作为参数</p><p>    SSO认证中心发现用户已登录，跳转回系统2的地址，并附上令牌</p><p>    系统2拿到令牌，去SSO认证中心校验令牌是否有效</p><p>    SSO认证中心校验令牌，返回有效，注册系统2</p><p>    系统2使用该令牌创建与用户的局部会话，返回受保护资源</p><p>用户登录成功之后，会与SSO认证中心及各个子系统建立会话，用户与SSO认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过SSO认证中心，全局会话与局部会话有如下约束关系：</p><p>① 局部会话存在，全局会话一定存在</p><p>② 全局会话存在，局部会话不一定存在</p><p>③ 全局会话销毁，局部会话必须销毁</p><p>2、单点注销</p><p>单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁。</p><p><img src="/My-Blogs/images/%E8%B0%88%E8%B0%88%E7%99%BB%E5%BD%95-03.png"></p><p>    用户向系统1发起注销请求</p><p>    系统1根据用户与系统1建立的会话拿到Token，向SSO认证中心发起注销请求</p><p>    SSO认证中心校验Token有效，销毁全局会话，同时取出所有用此Token注册的系统地址</p><p>    SSO认证中心向所有注册系统发起注销请求</p><p>    各注册系统接收SSO认证中心的注销请求，销毁局部会话</p><p>    SSO认证中心引导用户至登录页面</p><h3 id="五、登录安全防范"><a href="#五、登录安全防范" class="headerlink" title="五、登录安全防范"></a>五、登录安全防范</h3><p>1、CSRF攻击</p><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的登录凭证，绕过后台的用户验证，达到冒充用户对被攻击网站执行某项操作的目的。</p><p>一个典型的CSRF攻击有着如下的流程：</p><p>① 受害者登录网站a，并保留了登录凭证Cookie</p><p>② 攻击者引诱受害者访问网站b，它向网站a的服务器发送了一个跨站请求，该请求会默认携带网站a的Cookie</p><p>③ 网站a的服务器接收到请求后，对请求进行验证，确认是受害者的凭证，误以为是受害者自己发送的请求，以受害者的名义执行某个操作</p><p>④ 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让网站a执行了攻击者自己定义的操作</p><p>CSRF通常发生在第三方域名，由于浏览器同源策略的限制，攻击者不能获取到受害者的Cookie信息，只是冒用。针对这2点，我们可以制定相应的防护策略：</p><p>1）同源检测</p><p>服务器通过解析Origin 或Referer这两个请求头，确定请求的来源域，如果请求来自外域，直接阻止。</p><p>缺点：在部分情况下，攻击者可以隐藏甚至修改自己请求的Referer；会误伤一些正常请求，比如通过搜索结果跳转的页面请求。</p><p>2）Samesite Cookie</p><p>为了从源头上解决CSRF攻击，Google起草了一份草案来改进HTTP协议，即为响应头Set-Cookie新增Samesite属性：</p><p>Strict：任何情况下都不可能作为第三方Cookie，其它网站发起的任意请求都不会携带上该Cookie，包括搜索页面。</p><p>Lax：用户在不同网站之间通过链接跳转不受影响；但假如这个请求是从其它网站发起的请求，或者页面跳转是通过表单POST提交触发的，则Cookie也不会携带发送。</p><p>缺点：目前还并不成熟，其应用场景有待观望。</p><p>3）双重Cookie</p><p>①     在用户访问网站页面时，向请求域名注入两个Cookie，一个是原本要注入的Cookie，一个比如随机字符串</p><p>② 前端向后端发起请求时，取出随机字符串，添加到URL参数或请求头中</p><p>③ 后端验证携带的随机数与Cookie中的随机数是否一致，不一致则拒绝请求</p><p>缺点：难以做到子域名隔离，认证Cookie必须被种在顶级域名下，每个子域才可以访问；如果某个子域存在XSS漏洞，攻击者将这个认证Cookie修改为自己配置的Cookie；攻击者直接使用自己配置的Cookie发起CSRF攻击。</p><p>4）CSRF Token</p><p>CSRF攻击者无法直接窃取到用户的Cookie，仅仅是冒用；而CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户的请求。</p><p>① 服务器生成登录Cookie时，同时生成Token和Token签名的2个Cookie</p><p>② 前端向后端发起请求时，将Token添加到URL参数或请求头中</p><p>③ 后端收到请求，首先验证参数与Token相不相同，不相同则中止请求；然后校验签名，不相同则中止请求。因为攻击者不知道密钥，使用Token签名可以防止Cookie被篡改和伪造。</p><p>缺点：每个请求都需要携带Token，且需要服务端对每个请求进行校验。所以一般只对包含敏感数据的请求做此处理。</p><p>2、短信防刷</p><p>短信轰炸是指攻击者利用从各个网站上找到的发送动态短信的URL和前端输入的被攻击者的手机号码，发送HTTP请求，每次请求给用户发送一个动态短信。</p><p>危害：增加公司的运营成本，因为短信是需要计费的；被攻击者大量被动接收非自身请求的短信，造成无法正常使用移动运营商业务；给公司形象造成极大影响，因为一般短信会带公司签名。</p><p>常见防范手段：</p><p>    短信发送间隔设置</p><p>    发送量限制</p><p>    图文验证码</p><p>    触发流程限制</p><h3 id="六、全球部署问题"><a href="#六、全球部署问题" class="headerlink" title="六、全球部署问题"></a>六、全球部署问题</h3><p>Session存在内存里随着用户的增多会导致内存溢出，且不能跨进程、跨机器共享，且重启进程后会导致Session丢失，所以Session通常会存在第三方缓存，比如Redis里。</p><p>Redis全球部署带来的问题在于，已登录的用户再次请求时，如果请求定位到不同集群的Redis，会导致登录状态失效。</p><p>解决方案：</p><p>    不同集群Redis数据同步</p><p>    保证相同集群的Web服务请求同一集群的Redis</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一、Cookie与Session&quot;&gt;&lt;a href=&quot;#一、Cookie与Session&quot; class=&quot;headerlink&quot; title=&quot;一、Cookie与Session&quot;&gt;&lt;/a&gt;一、Cookie与Session&lt;/h3&gt;&lt;p&gt;HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行保存。因为无法管理用户状态，对于要登录的页面，每次跳转新页面时都需要再次登录。&lt;/p&gt;</summary>
    
    
    
    <category term="安全" scheme="http://example.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="安全" scheme="http://example.com/tags/%E5%AE%89%E5%85%A8/"/>
    
    <category term="登录" scheme="http://example.com/tags/%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>ssh的基本用法</title>
    <link href="http://example.com/2021/01/08/%E5%8D%8F%E8%AE%AE/ssh/ssh%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <id>http://example.com/2021/01/08/%E5%8D%8F%E8%AE%AE/ssh/ssh%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</id>
    <published>2021-01-08T17:54:30.000Z</published>
    <updated>2021-01-15T01:30:52.180Z</updated>
    
    <content type="html"><![CDATA[<p><code>SSH</code>，我们经常操作远程服务器的时候，都会用到这个命令，但是他除了登录服务器还有很多作用，下面我们一起来了解下吧</p><a id="more"></a><h2 id="ssh登录服务器命令"><a href="#ssh登录服务器命令" class="headerlink" title="ssh登录服务器命令"></a>ssh登录服务器命令</h2><pre><code class="BASH">ssh hostname</code></pre><p>上面命令中， <code>hostname</code> 是主机名，它可以是域名，也可能是 IP 地址或局域网内部的主机名。不指定用户名的情况下，将使用客户端的当前用户名，作为远程服务器的登录用户名。</p><p>如果要指定用户名，可以采用下面的语法。</p><pre><code class="BASH">ssh user@hostname</code></pre><p>上面的命令中，用户名和主机名写在一起了，之间使用 <code>@</code> 分隔。</p><p>指定用户名，可以使用 <code>ssh</code> 和 <code>-l</code> 参数</p><pre><code class="BASH">ssh -l username host</code></pre><p>ssh 默认连接服务器的 <code>22</code> 端口， <code>-p</code> 参数可以指定其他端口</p><pre><code class="BASH">ssh -p 8821 hostname</code></pre><h2 id="ssh执行远程命令"><a href="#ssh执行远程命令" class="headerlink" title="ssh执行远程命令"></a>ssh执行远程命令</h2><p>将命令直接写在 <code>ssh</code> 命令的后面</p><pre><code class="BASH">ssh username@hostname command</code></pre><p>上面的命令会使得 SSH 在登录成功后，立刻在远程主机上执行命令 <code>command</code> 。</p><p>例子</p><pre><code class="BASH">ssh foo@server.example.com cat /etc/hosts</code></pre><p>上面的命令会在登录成功后，立即远程执行命令 <code>cat /etc/hosts</code> 。</p><h2 id="ssh命令行配置项"><a href="#ssh命令行配置项" class="headerlink" title="ssh命令行配置项"></a>ssh命令行配置项</h2><h3 id="c-参数指定加密算法。"><a href="#c-参数指定加密算法。" class="headerlink" title="-c 参数指定加密算法。"></a><code>-c</code> 参数指定加密算法。</h3><pre><code class="BASH">$ ssh -c blowfish,3des server.example.com# 或者$ ssh -c blowfish -c 3des server.example.com</code></pre><p>上面命令指定使用加密算法 <code>blowfish</code> 或 <code>3des</code></p><h3 id="C-参数表示压缩数据传输"><a href="#C-参数表示压缩数据传输" class="headerlink" title="-C 参数表示压缩数据传输"></a><code>-C</code> 参数表示压缩数据传输</h3><pre><code class="BASH">ssh -C server.example.com</code></pre><h3 id="d-参数设置打印的-debug-信息级别，数值越高，输出的内容越详细。"><a href="#d-参数设置打印的-debug-信息级别，数值越高，输出的内容越详细。" class="headerlink" title="-d 参数设置打印的 debug 信息级别，数值越高，输出的内容越详细。"></a><code>-d</code> 参数设置打印的 debug 信息级别，数值越高，输出的内容越详细。</h3><pre><code class="BASH">ssh –d 1 foo.com</code></pre><h3 id="D-参数指定本机的-Socks-监听端口"><a href="#D-参数指定本机的-Socks-监听端口" class="headerlink" title="-D 参数指定本机的 Socks 监听端口"></a><code>-D</code> 参数指定本机的 Socks 监听端口</h3><blockquote><p>该端口收到的请求，都将转发到远程的 SSH 主机，又称动态端口转发</p></blockquote><pre><code class="BASH"> ssh -D 1080 server</code></pre><p>上面命令将本机 1080 端口收到的请求，都转发到服务器 <code>server</code></p><h3 id="f-参数表示-SSH-连接在后台运行"><a href="#f-参数表示-SSH-连接在后台运行" class="headerlink" title="-f 参数表示 SSH 连接在后台运行"></a><code>-f</code> 参数表示 SSH 连接在后台运行</h3><h3 id="F-参数指定配置文件"><a href="#F-参数指定配置文件" class="headerlink" title="-F 参数指定配置文件"></a><code>-F</code> 参数指定配置文件</h3><pre><code class="BASH">ssh -F /usr/local/ssh/other_config</code></pre><p>上面命令指定使用配置文件 <code>other_config</code></p><h3 id="i-参数用于指定私钥"><a href="#i-参数用于指定私钥" class="headerlink" title="-i 参数用于指定私钥"></a><code>-i</code> 参数用于指定私钥</h3><blockquote><p>意为“identity_file”，默认值为~/.ssh/id_dsa。注意，对应的公钥必须存放到服务器</p></blockquote><pre><code class="BASH">ssh -i my-key server.example.com</code></pre><h3 id="l-参数指定远程登录的账户名"><a href="#l-参数指定远程登录的账户名" class="headerlink" title="-l 参数指定远程登录的账户名"></a><code>-l</code> 参数指定远程登录的账户名</h3><pre><code class="BASH">$ ssh -l sally server.example.com# 等同于$ ssh sally@server.example.com</code></pre><h3 id="L-参数设置本地端口转发"><a href="#L-参数设置本地端口转发" class="headerlink" title="-L 参数设置本地端口转发"></a><code>-L</code> 参数设置本地端口转发</h3><pre><code class="BASH">ssh  -L 9999:targetServer:80 user@remoteserver</code></pre><p>上面命令中，所有发向本地 <code>9999</code> 端口的请求，都会经过 <code>remoteserver</code> 发往 <code>targetServer</code> 的 <code>80</code> 端口，这就相当于直接连上了 <code>targetServer</code> 的 <code>80</code> 端口</p><h3 id="m-参数指定校验数据完整性的算法"><a href="#m-参数指定校验数据完整性的算法" class="headerlink" title="-m 参数指定校验数据完整性的算法"></a><code>-m</code> 参数指定校验数据完整性的算法</h3><pre><code class="BASH">ssh -m hmac-sha1,hmac-md5 server.example.com</code></pre><p>上面命令指定数据校验算法为 <code>hmac-sha1</code> 或 <code>hmac-md5</code></p><h3 id="o-参数用来指定一个配置命令"><a href="#o-参数用来指定一个配置命令" class="headerlink" title="-o 参数用来指定一个配置命令"></a><code>-o</code> 参数用来指定一个配置命令</h3><pre><code class="BASH">ssh -o "Keyword Value"</code></pre><p>举例来说，配置文件里面有如下内容。</p><pre><code class="BASH">User sallyPort 220</code></pre><p>通过 <code>-o</code> 参数，可以把上面两个配置命令从命令行传入。</p><pre><code class="BASH">ssh -o "User sally" -o "Port 220" server.example.com</code></pre><p>使用等号时，配置命令可以不用写在引号里面，但是等号前后不能有空格</p><pre><code class="BASH">ssh -o User=sally -o Port=220 server.example.com</code></pre><h3 id="p-参数指定-SSH-客户端连接的服务器端口"><a href="#p-参数指定-SSH-客户端连接的服务器端口" class="headerlink" title="-p 参数指定 SSH 客户端连接的服务器端口"></a><code>-p</code> 参数指定 SSH 客户端连接的服务器端口</h3><pre><code class="BASH">ssh -p 2035 server.example.com</code></pre><p>上面命令连接服务器的2035端口</p><h3 id="q-参数表示安静模式（quiet），不向用户输出任何警告信息"><a href="#q-参数表示安静模式（quiet），不向用户输出任何警告信息" class="headerlink" title="-q 参数表示安静模式（quiet），不向用户输出任何警告信息"></a><code>-q</code> 参数表示安静模式（quiet），不向用户输出任何警告信息</h3><pre><code class="BASH">ssh –q foo.comroot’s password:</code></pre><p>上面命令使用 <code>-q</code> 参数，只输出要求用户输入密码的提示</p><h3 id="R-参数指定远程端口转发"><a href="#R-参数指定远程端口转发" class="headerlink" title="-R 参数指定远程端口转发"></a><code>-R</code> 参数指定远程端口转发</h3><pre><code class="BASH">ssh -R 9999:targetServer:902 local</code></pre><p>上面命令需在跳板服务器执行，指定本地计算机 <code>local</code> 监听自己的 9999 端口，所有发向这个端口的请求，都会转向 targetServer 的 902 端口</p><h3 id="t-参数在-ssh-直接运行远端命令时，提供一个互动式-Shell"><a href="#t-参数在-ssh-直接运行远端命令时，提供一个互动式-Shell" class="headerlink" title="-t 参数在 ssh 直接运行远端命令时，提供一个互动式 Shell"></a><code>-t</code> 参数在 ssh 直接运行远端命令时，提供一个互动式 Shell</h3><pre><code class="BASH">ssh -t server.example.com emacs</code></pre><h3 id="v-参数显示详细信息"><a href="#v-参数显示详细信息" class="headerlink" title="-v 参数显示详细信息"></a><code>-v</code> 参数显示详细信息</h3><pre><code class="BASH">ssh -v server.example.com</code></pre><p><code>-v</code> 可以重复多次，表示信息的详细程度，比如 <code>-vv</code> 和 <code>-vvv</code></p><pre><code class="BASH">$ ssh -vvv server.example.com# 或者$ ssh -v -v -v server.example.com</code></pre><p>上面命令会输出最详细的连接信息</p><h3 id="V-参数输出-ssh-客户端的版本"><a href="#V-参数输出-ssh-客户端的版本" class="headerlink" title="-V 参数输出 ssh 客户端的版本"></a><code>-V</code> 参数输出 ssh 客户端的版本</h3><pre><code class="BASH">$ ssh –Vssh: SSH Secure Shell 3.2.3 (non-commercial version) on i686-pc-linux-gnu</code></pre><p>上面命令输出本机 ssh 客户端版本是 <code>SSH Secure Shell 3.2.3</code></p><h3 id="X-参数表示打开-X-窗口转发"><a href="#X-参数表示打开-X-窗口转发" class="headerlink" title="-X 参数表示打开 X 窗口转发"></a><code>-X</code> 参数表示打开 X 窗口转发</h3><pre><code class="BASH">ssh -X server.example.com</code></pre><h3 id="1-2参数指定使用-SSH1-SSH2-协议。"><a href="#1-2参数指定使用-SSH1-SSH2-协议。" class="headerlink" title="-1, -2参数指定使用 SSH1, SSH2 协议。"></a>-1, -2参数指定使用 SSH1, SSH2 协议。</h3><pre><code class="BASH">ssh -2 server.example.com</code></pre><h3 id="4-指定使用-IPv4-协议，这是默认值"><a href="#4-指定使用-IPv4-协议，这是默认值" class="headerlink" title="-4 指定使用 IPv4 协议，这是默认值"></a><code>-4</code> 指定使用 IPv4 协议，这是默认值</h3><pre><code class="BASH">ssh -4 server.example.com</code></pre><h3 id="6-指定使用-IPv6-协议"><a href="#6-指定使用-IPv6-协议" class="headerlink" title="-6 指定使用 IPv6 协议"></a><code>-6</code> 指定使用 IPv6 协议</h3><pre><code class="BASH">ssh -6 server.example.com</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;SSH&lt;/code&gt;，我们经常操作远程服务器的时候，都会用到这个命令，但是他除了登录服务器还有很多作用，下面我们一起来了解下吧&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="SSH" scheme="http://example.com/tags/SSH/"/>
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="shell" scheme="http://example.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>微服务缓存原理与最佳实践</title>
    <link href="http://example.com/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E7%BC%93%E5%AD%98/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://example.com/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E7%BC%93%E5%AD%98/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2021-01-08T17:52:53.000Z</published>
    <updated>2021-01-15T01:30:52.180Z</updated>
    
    <content type="html"><![CDATA[<p>文章主要介绍了分布式架构里的微服务缓存原理与最佳实践，下面让我们来一起看看吧</p><a id="more"></a><h2 id="为什么需要缓存？"><a href="#为什么需要缓存？" class="headerlink" title="为什么需要缓存？"></a>为什么需要缓存？</h2><ol><li><p> 程序存储在 <code>disk</code> 中</p></li><li><p> 程序是运行在 <code>RAM</code> 之中，也就是我们所说的 <code>main memory</code></p></li><li><p> 程序的计算逻辑在 <code>CPU</code> 中执行</p></li></ol><p>来看一个最简单的例子： <code>a = a + 1</code></p><ol><li><p> <code>load x:</code></p></li><li><p> <code>x0 = x0 + 1</code></p></li><li><p> <code>load x0 -&gt; RAM</code></p></li></ol><p><img src="/My-Blogs/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-01.png" alt="img"></p><p>上面提到了3种存储介质。我们都知道，三类的读写速度和成本成反比，所以我们在克服速度问题上需要引入一个 中间层。这个中间层，需要高速存取的速度，但是成本可接受。于是乎, <code>Cache</code> 被引入</p><p><img src="/My-Blogs/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-02.png" alt="img"></p><p>而在计算机系统中，有两种默认缓存：</p><p>CPU 里面的末级缓存，即 <code>LLC</code> 。缓存内存中的数据</p><p>内存中的高速页缓存，即 <code>page cache</code> 。缓存磁盘中的数据</p><h2 id="缓存读写策略"><a href="#缓存读写策略" class="headerlink" title="缓存读写策略"></a>缓存读写策略</h2><p>引入 <code>Cache</code> 之后，我们继续来看看操作缓存会发生什么。因为存在存取速度的差异「而且差异很大」，从而在操作数据时，延迟或程序失败等都会导致缓存和实际存储层数据不一致。</p><p>我们就以标准的 <code>Cache+DB</code> 来看看经典读写策略和应用场景。</p><h3 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache Aside"></a>Cache Aside</h3><p>先来考虑一种最简单的业务场景，比如用户表: <code>userId</code> : 用户id, <code>phone</code> : 用户电话token, <code>avtoar</code> : 用户头像url，缓存中我们用 <code>phone</code> 作为key存储用户头像。当用户修改头像url该如何做？</p><p>更新DB数据，再更新 <code>Cache</code> 数据</p><p>更新 DB 数据，再删除 <code>Cache</code> 数据</p><p>首先 变更数据库 和 变更缓存 是两个独立的操作，而我们并没有对操作做任何的并发控制。那么当两个线程并发更新它们的时候，就会因为写入顺序的不同造成数据不一致。</p><p>所以更好的方案是 <code>2</code> :</p><p>更新数据时不更新缓存，而是直接删除缓存</p><p>后续的请求发现缓存缺失，回去查询 <code>DB</code> ，并将结果 <code>load cache</code></p><p><img src="/My-Blogs/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-03.png" alt="img"></p><p>这个策略就是我们使用缓存最常见的策略: <code>Cache Aside</code> 。这个策略数据以数据库中的数据为准，缓存中的数据是按需加载的，分为读策略和写策略。</p><p>但是可见的问题也就出现了：频繁的读写操作会导致 <code>Cache</code> 反复地替换，缓存命中率降低。当然如果在业务中对命中率有监控报警时，可以考虑以下方案：</p><ol><li><p> 更新数据时同时更新缓存，但是在更新缓存前加一个 分布式锁。这样同一时间只有一个线程操作缓存，解决了并发问题。同时在后续读请求中时读到最新的缓存，解决了不一致的问题。</p></li><li><p> 更新数据时同时更新缓存，但是给缓存一个较短的 <code>TTL</code>。</p></li></ol><p>当然除了这个策略，在计算机体系还有其他几种经典的缓存策略，它们也有各自适用的使用场景。</p><h3 id="Write-Through"><a href="#Write-Through" class="headerlink" title="Write Through"></a>Write Through</h3><p>先查询写入数据key是否击中缓存，如果在 -&gt; 更新缓存，同时缓存组件同步数据至DB；不存在，则触发 ·。</p><p>而一般 · 有两种方式：</p><p><code>Write Allocate</code> ：写时直接分配 <code>Cache line</code></p><p><code>No-write allocate</code> ：写时不写入缓存，直接写入DB，return</p><p>在 <code>Write Through</code> 中，一般采取 <code>No-write allocate</code> 。因为其实无论哪种，最终数据都会持久化到DB中，省去一步缓存的写入，提升写性能。而缓存由 <code>Read Through</code> 写入缓存。</p><p><img src="/My-Blogs/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-04.png" alt="img"></p><p>这个策略的核心原则：<strong>用户只与缓存打交道，由缓存组件和DB通信，写入或者读取数据</strong>。在一些本地进程缓存组件可以考虑这种策略。</p><h3 id="Write-Back"><a href="#Write-Back" class="headerlink" title="Write Back"></a>Write Back</h3><p>相信你也看出上述方案的缺陷：写数据时缓存和数据库同步，但是我们知道这两块存储介质的速度差几个数量级，对写入性能是有很大影响。那我们是否异步更新数据库？</p><p><code>Write back</code> 就是在写数据时只更新该 Cache Line 对应的数据，并把该行标记为 Dirty。在读数据时或是在缓存满时换出「缓存替换策略」时，将 Dirty 写入存储。</p><p>需要注意的是：在 <code>Write Miss</code> 情况下，采取的是 <code>Write Allocate</code> ，即写入存储同时写入缓存，这样我们在之后的写请求只需要更新缓存。</p><p><img src="/My-Blogs/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-05.png" alt="img"></p><blockquote><p><code>async purge</code> 此类概念其实存在计算机体系中。 <code>Mysql</code> 中刷脏页，本质都是尽可能防止随机写，统一写磁盘时机。</p></blockquote><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><code>Redis</code> 是一个独立的系统软件，和我们写的业务程序是两个软件。当我们部署了Redis 实例后，它只会被动地等待客户端发送请求，然后再进行处理。所以，如果应用程序想要使用 Redis 缓存，我们就要在程序中增加相应的缓存操作代码。所以我们也把 <code>Redis</code> 称为 <strong>旁路缓存</strong>，也就是说：读取缓存、读取数据库和更新缓存的操作都需要在应用程序中来完成。</p><p>而作为缓存的 <code>Redis</code> ，同样需要面临常见的问题：</p><ul><li><p>缓存的容量终究有限</p></li><li><p>上游并发请求冲击</p></li><li><p>缓存与后端存储数据一致性</p></li></ul><h3 id="替换策略"><a href="#替换策略" class="headerlink" title="替换策略"></a>替换策略</h3><p>一般来说，缓存对于选定的被淘汰数据，会根据其是干净数据还是脏数据，选择直接删除还是写回数据库。但是，在 Redis 中，被淘汰数据无论干净与否都会被删除，所以，这是我们在使用 Redis 缓存时要特别注意的：当数据修改成为脏数据时，需要在数据库中也把数据修改过来。</p><p>所以不管替换策略是什么，脏数据有可能在换入换出中丢失。那我们在产生脏数据就应该删除缓存，而不是更新缓存，一切数据应该以数据库为准。这也很好理解，缓存写入应该交给读请求来完成；写请求尽可能保证数据一致性。</p><p>至于替换策略有哪些，网上已经有很多文章归纳之间的优劣，这里就不再赘述。</p><h2 id="缓存和存储更新顺序"><a href="#缓存和存储更新顺序" class="headerlink" title="缓存和存储更新顺序"></a>缓存和存储更新顺序</h2><p>这是开发中常见纠结问题：<strong>到底是先删除缓存还是先更新存储</strong>？</p><blockquote><p>情况一：先删除缓存，再更新存储；</p><ul><li>A 删除缓存，更新存储时网络延迟</li><li>B 读请求，发现缓存缺失，读存储 -&gt; 此时读到旧数据</li></ul></blockquote><p>这样会产生两个问题：</p><ul><li>B 读取旧值</li><li>B 同时读请求会把旧值写入缓存，导致后续读请求读到旧值</li></ul><p>既然是缓存可能是旧值，那就不管删除。有一个并不优雅的解决方案：<strong>在写请求更新完存储值以后</strong>， <code>sleep()</code> <strong>一小段时间，再进行一次缓存删除操作</strong>。</p><p><code>sleep</code> 是为了确保读请求结束，写请求可以删除读请求造成的缓存脏数据，当然也要考虑到 redis 主从同步的耗时。不过还是要根据实际业务而定。</p><p>这个方案会在第一次删除缓存值后，延迟一段时间再次进行删除，被称为： <code>延迟双删</code> 。</p><blockquote><p>情况二：先更新数据库值，再删除缓存值：</p><ul><li>A 删除存储值，但是删除缓存网络延迟</li><li>B 读请求时，缓存击中，就直接返回旧值</li></ul></blockquote><p>这种情况对业务的影响较小，而绝大多数缓存组件都是采取此种更新顺序，满足最终一致性要求。</p><blockquote><p>情况三：新用户注册，直接写入数据库，同时缓存中肯定没有。如果程序此时读从库，由于主从延迟，导致读取不到用户数据。</p></blockquote><p>这种情况就需要针对 Insert 这种操作：插入新数据入数据库同时写缓存。使得后续读请求可以直接读缓存，同时因为是刚插入的新数据，在一段时间修改的可能性不大。</p><p><strong>以上方案在复杂的情况或多或少都有潜在问题，需要贴合业务做具体的修改。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;文章主要介绍了分布式架构里的微服务缓存原理与最佳实践，下面让我们来一起看看吧&lt;/p&gt;</summary>
    
    
    
    <category term="分布式架构" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="分布式架构" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/"/>
    
    <category term="缓存" scheme="http://example.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>架构三高总结</title>
    <link href="http://example.com/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E6%A6%82%E5%BF%B5/%E6%9E%B6%E6%9E%84%E4%B8%89%E9%AB%98%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E6%A6%82%E5%BF%B5/%E6%9E%B6%E6%9E%84%E4%B8%89%E9%AB%98%E6%80%BB%E7%BB%93/</id>
    <published>2021-01-08T17:51:03.000Z</published>
    <updated>2021-01-15T01:30:52.180Z</updated>
    
    <content type="html"><![CDATA[<p>针对高性能、高可用、高扩展3个方面，罗列出需要注意的点。</p><a id="more"></a><h3 id="一、高性能的实践方案"><a href="#一、高性能的实践方案" class="headerlink" title="一、高性能的实践方案"></a>一、高性能的实践方案</h3><p>1、集群部署，通过负载均衡减轻单机压力。</p><p>2、多级缓存，包括静态数据使用CDN、本地缓存、分布式缓存等，以及对缓存场景中的热点key、缓存穿透、缓存并发、数据一致性等问题的处理。</p><p>3、分库分表和索引优化，以及借助搜索引擎解决复杂查询问题。</p><p>4、考虑数据库的使用，比如<code>HBase</code>、<code>TiDB</code>等，但是团队必须熟悉这些组件，且有较强的运维能力。</p><p>5、异步化，将次要流程通过多线程、<code>MQ</code>、甚至延时任务进行异步处理。</p><p>6、限流，需要先考虑业务是否允许限流（比如秒杀场景是允许的），包括前端限流、<code>Nginx</code>接入层的限流、服务端的限流。</p><p>7、对流量进行削峰填谷，通过<code>MQ</code>承接流量。</p><p>8、并发处理，通过多线程将串行逻辑并行化。</p><p>9、预计算，比如抢红包场景，可以提前计算好红包金额缓存起来，发红包时直接使用即可。</p><p>10、缓存预热，通过异步任务提前预热数据到本地缓存或者分布式缓存中。</p><p>11、减少IO次数，比如数据库和缓存的批量读写、<code>RPC</code>的批量接口支持、或者通过冗余数据的方式干掉<code>RPC</code>调用。</p><p>12、减少IO时的数据包大小，包括采用轻量级的通信协议、合适的数据结构、去掉接口中的多余字段、减少缓存key的大小、压缩缓存value等。</p><p>13、程序逻辑优化，比如将大概率阻断执行流程的判断逻辑前置、For循环的计算逻辑优化，或者采用更高效的算法。</p><p>14、各种池化技术的使用和池大小的设置，包括<code>HTTP</code>请求池、线程池（考虑<code>CPU密集型</code>还是<code>IO密集型</code>设置核心参数）、数据库和<code>Redis</code>连接池等。</p><p>15、<code>JVM</code>优化，包括新生代和老年代的大小、GC算法的选择等，尽可能减少GC频率和耗时。</p><p>16、锁选择，读多写少的场景用乐观锁，或者考虑通过分段锁的方式减少锁冲突。</p><p>上述方案无外乎从计算和 IO 两个维度考虑所有可能的优化点，需要有配套的监控系统实时了解当前的性能表现，并支撑你进行性能瓶颈分析，然后再遵循二八原则，抓主要矛盾进行优化。</p><h3 id="二、高可用的实践方案"><a href="#二、高可用的实践方案" class="headerlink" title="二、高可用的实践方案"></a>二、高可用的实践方案</h3><p>1、对等节点的故障转移，Nginx和服务治理框架均支持一个节点失败后访问另一个节点。</p><p>2、非对等节点的故障转移，通过心跳检测并实施主备切换（比如<code>redis</code>的哨兵模式或者集群模式、MySQL的主从切换等）。</p><p>3、接口层面的超时设置、重试策略和幂等设计。</p><p>4、降级处理：保证核心服务，牺牲非核心服务，必要时进行熔断；或者核心链路出问题时，有备选链路。</p><p>5、限流处理：对超过系统处理能力的请求直接拒绝或者返回错误码。</p><p>6、MQ场景的消息可靠性保证，包括<code>producer</code>端的重试机制、<code>broker</code>侧的持久化、<code>consumer</code>端的ack机制等。</p><p>7、灰度发布，能支持按机器维度进行小流量部署，观察系统日志和业务指标，等运行平稳后再推全量。</p><p>8、监控报警：全方位的监控体系，包括最基础的CPU、内存、磁盘、网络的监控，以及Web服务器、JVM、数据库、各类中间件的监控和业务指标的监控。</p><p>9、灾备演练：类似当前的“混沌工程”，对系统进行一些破坏性手段，观察局部故障是否会引起可用性问题。</p><p>高可用的方案主要从冗余、取舍、系统运维3个方向考虑，同时需要有配套的值班机制和故障处理流程，当出现线上问题时，可及时跟进处理。</p><h3 id="三、高扩展的实践方案"><a href="#三、高扩展的实践方案" class="headerlink" title="三、高扩展的实践方案"></a>三、高扩展的实践方案</h3><p>1、合理的分层架构：比如上面谈到的互联网最常见的分层架构，另外还能进一步按照数据访问层、业务逻辑层对微服务做更细粒度的分层（但是需要评估性能，会存在网络多一跳的情况）。</p><p>2、存储层的拆分：按照业务维度做垂直拆分、按照数据特征维度进一步做水平拆分（分库分表）。</p><p>3、业务层的拆分：最常见的是按照业务维度拆（比如电商场景的商品服务、订单服务等），也可以按照核心接口和非核心接口拆，还可以按照请求源拆（比如To C和To B，APP和H5）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;针对高性能、高可用、高扩展3个方面，罗列出需要注意的点。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式架构" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="分布式架构" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>幂等性与分布式锁</title>
    <link href="http://example.com/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E6%A6%82%E5%BF%B5/%E5%B9%82%E7%AD%89%E6%80%A7%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://example.com/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E6%A6%82%E5%BF%B5/%E5%B9%82%E7%AD%89%E6%80%A7%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2021-01-08T17:50:14.000Z</published>
    <updated>2021-01-15T01:30:52.179Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是幂等性"><a href="#1-什么是幂等性" class="headerlink" title="1. 什么是幂等性"></a>1. 什么是幂等性</h3><p><code>幂等性</code> 就是指：一个幂等操作任其执行多次所产生的影响均与一次执行的影响相同。用数学的概念表达是这样的: <code>f(f(x)) = f(x)</code> . 就像 <code>nx1 = n</code> 一样， x1 就是一个幂等操作。无论是乘以多少次结果都一样。</p><a id="more"></a><h3 id="2-常见的幂等性问题"><a href="#2-常见的幂等性问题" class="headerlink" title="2. 常见的幂等性问题"></a>2. 常见的幂等性问题</h3><blockquote><p>幂等性问题经常会是由网络问题引起的，还有重复操作引起的。</p></blockquote><p><strong>场景一：比如点赞功能，一个用户只能对同一片文章点赞一次，重复点赞提示已经点过赞了。</strong></p><p>示例代码：</p><pre><code class="JAVA">public void like(Article article,User user) {    //检查是否点过赞    if (checkIsLike(article,user)) {        //点过赞了        throw new ApiException(CodeEnums.SYSTEM_ERR);    } else {        //保存点赞        saveLike(article,user);    }}</code></pre><p>看上去好像没有什么问题，保存点赞之前已经检查过是否点赞了，理论上同一个人不会对同一篇文章重复点赞。但实际不是这样的。因为网络请求不是排队进来的，而是一窝蜂涌进来的。</p><p>某些时候，用户网络不好，可能很短的时间内点击了多次，由于网络传输问题，这些请求可能会同时来到我们的服务器。</p><ul><li><strong>第一个请求 checkIsLike（） 返回 false ， 正在执行 saveLike() 操作，还没来的及提交事务</strong> </li><li><strong>第二个请求过来了 ，checkIsLike（） 返回 也是 false , 并去 执行了 saveLike() 操作</strong></li></ul><p>这样子，就造成了一个用户同时对一篇文章进行了多次点赞操作。</p><p>这就是典型的幂等性问题， 操作了一次和操作了两次结果不一样，因为你多点了一次赞，按照幂等性原则 不管你点击了多少次结果都一样，只点了一次赞。</p><p>很多场景都是这样造成的，比如用户重复下单，重复评论，重复提交表单等。</p><p>那怎么解决呢？假设网络的请求是排队进来的就不会出现这个问题了。</p><p>于是我们可以改成这样：</p><pre><code class="JAVA">public synchronized void like(Article article,User user) {    //检查是否点过赞    if (checkIsLike(article,user)) {        //点过赞了        throw new ApiException(CodeEnums.SYSTEM_ERR);    } else {        //保存点赞        saveLike(article,user);    }}</code></pre><p><code>synchronized</code> 同步锁 这样我们的请求就会乖乖的排队进来了。</p><p>PS: 这样做是效率比较低的做法，不建议这么做，只是举例子，<code>synchronized</code> 也不适合分布式集群场景。</p><p><strong>场景二 ： 第三方回调</strong></p><p>我们系统经常需要和第三方系统打交道，比如微信充值，支付宝充值什么的，微信和支付宝常常会以回调你的接口通知你支付结果。为了保证你能收到回调，往往可能会回调多次。</p><p>有时候我们也为了保证数据的准确性会有个定时器去查询支付结果未知的流水，并执行响应的处理。<br>如果定时器的轮询和回调刚好是在同时进行，这可能又出BUG了, 又进行了两次重复操作。</p><p>那么问题来了：假设我是一个充值操作， 回调回来的时候 ，会做业务处理，成功了给用户账户加钱。这是后就要保证幂等性了， 假设微信同一笔交易给你回调了两次，如果你给用户充值了两次，这显然不合理(我是老板肯定扣你工资)，所以要保证 不管微信回调你多少次 ，同一笔交易你只能给用户充一次钱。这就幂等性</p><h3 id="解决幂等性问题方案"><a href="#解决幂等性问题方案" class="headerlink" title="解决幂等性问题方案"></a>解决幂等性问题方案</h3><ul><li>synchronized 适合单机应用，不追求性能 ，不追求并发。</li><li>分布式锁 但是往往我们的应用是分布式的集群，并且很讲究性能，并发，所以我们需要用到 分布式锁 来解决这个问题。</li></ul><p>Redis 分布式锁：</p><pre><code class="JAVA">/*** setNx**  @param key*  @param value*  @return*/public Boolean setNx(String key,Object value) {    return redisTemplate.opsForValue().setIfAbsent(key,value);}/***  @param key 锁*  @param waitTime 等待时间  毫秒*  @param expireTime 超时时间  毫秒*  @return*/public Boolean lock(String key,long waitTime,long expireTime) {    String vlaue =  UUIDUtil.mongoObjectId();    Boolean flag = setNx(key,vlaue);    //尝试获取锁  成功返回    if (flag) {        redisTemplate.expire(key,expireTime,TimeUnit.MILLISECONDS);        return flag;    } else {        //失败        //现在时间        long newTime =  System.currentTimeMillis();        //等待过期时间        long loseTime = newTime + waitTime;        //不断尝试获取锁成功返回        while (System.currentTimeMillis()  &lt; loseTime) {            Boolean testFlag = setNx(key,vlaue);            if (testFlag) {                redisTemplate.expire(key,expireTime,TimeUnit.MILLISECONDS);                return testFlag;            }            //休眠100毫秒            try {                Thread.sleep(100);            }            catch (InterruptedException e) {                e.printStackTrace();            }        }    }    return false;}/***  @param key*  @return*/public Boolean lock(String key) {    return lock(key,1000L,60  *  1000L);}/***  @param key*/public void unLock(String key) {    remove(key);}</code></pre><p>利用Redis 分布式锁 我们的代码可以改成这样：</p><pre><code class="JAVA">public void like(Article article,User user) {    String key =  "key:like"  + article.getId()  +  ":"  + user.getUserId();    //  等待锁的时间  0  ，  过期时间  一分钟防止死锁    Boolean flag = redisService.lock(key,0,60  *  1000L);    if(!flag) {        //获取锁失败  说明前面的请求已经获取了锁        throw new ApiException(CodeEnums.SYSTEM_ERR);    }    //检查是否点过赞    if (checkIsLike(article,user)) {        //点过赞了        throw new ApiException(CodeEnums.SYSTEM_ERR);    } else {        //保存点赞        saveLike(article,user);    }    //删除锁    redisService.unLock(key);}</code></pre><p>key 的设计也很讲究：</p><p>数据不冲突的两个业务场景，key不能冲突，不同人的key也不一样，不同的文章Key也不一样。</p><p>根据场景业务设定。</p><p><strong>一个原则： 尽可能的缩小key的范围。</strong> 这样才能增强我们的并发。</p><p>首先我们先获取锁，获取锁成功 执行完操作，保存数据 ，删除锁。获取不到锁返回失败。设置过期时间是为了防止‘死锁’，比如机器获取到了 锁，没有设置过期时间，但是他死机了，没有删除释放锁。</p><ul><li>版本号控制CAS 算法： CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。这个比较繁杂，有兴趣的大家可以去看看。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-什么是幂等性&quot;&gt;&lt;a href=&quot;#1-什么是幂等性&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是幂等性&quot;&gt;&lt;/a&gt;1. 什么是幂等性&lt;/h3&gt;&lt;p&gt;&lt;code&gt;幂等性&lt;/code&gt; 就是指：一个幂等操作任其执行多次所产生的影响均与一次执行的影响相同。用数学的概念表达是这样的: &lt;code&gt;f(f(x)) = f(x)&lt;/code&gt; . 就像 &lt;code&gt;nx1 = n&lt;/code&gt; 一样， x1 就是一个幂等操作。无论是乘以多少次结果都一样。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式架构" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="分布式架构" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>如何学习分布式系统(转载)</title>
    <link href="http://example.com/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E6%96%87%E7%AB%A0/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F(%E8%BD%AC%E8%BD%BD)/"/>
    <id>http://example.com/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E6%96%87%E7%AB%A0/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F(%E8%BD%AC%E8%BD%BD)/</id>
    <published>2021-01-08T17:47:31.000Z</published>
    <updated>2021-01-15T01:30:52.179Z</updated>
    
    <content type="html"><![CDATA[<p>学习一个知识之前，我觉得比较好的方式是先理解它的来龙去脉：即这个知识产生的过程，它解决了什么问题，它是怎么样解决的并且它带来了哪些问题，这样我们才能比较好的抓到它的脉络和关键点，不会一开始就迷失在细节中。</p><p>所以，我们要解决的第一个问题是：<strong>分布式系统解决了什么问题？</strong></p><a id="more"></a><p><strong>第一个</strong>是单机性能瓶颈导致的成本问题，由于摩尔定律失效，廉价 PC 机性能的瓶颈无法继续突破，小型机和大型机能提高更高的单机性能，但是成本太大高，一般的公司很难承受；</p><p><strong>第二个</strong>是用户量和数据量爆炸性的增大导致的成本问题，进入互联网时代，用户量爆炸性的增大，用户产生的数据量也在爆炸性的增大，但是单个用户或者单条数据的价值其实比软件时代（比如银行用户）的价值是只低不高，所以必须寻找更经济的方案；</p><p><strong>第三个</strong>是业务高可用的要求，对于互联网的产品来说，都要求 7 * 24 小时提供服务，无法容忍停止服务等故障，而要提供高可用的服务，唯一的方式就是增加冗余来完成，这样就算单机系统可以支撑的服务，因为高可用的要求，也会变成一个分布式系统。</p><p>基于上面的三个原因可以看出，在互联网时代，单机系统是无法解决成本和高可用问题的，但是这两个问题对几乎对所有的公司来说都是非常关键的问题，所以，从单机系统到分布式系统是无法避免的技术大潮流。</p><p>那么，分布式系统是怎么来解决单机系统面临的成本和高可用问题呢？其实想法很简单，就是将一些廉价的 PC 机通过网络连接起来，共同完成工作，并且在系统中提供冗余来解决高可用的问题。我们来看分布式系统的定义：<strong>分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统</strong>。在定义中，我们可用看出，分布式系统它通过多工作节点来解决单机系统面临的成本和可用性问题，但是它引入了对分布式系统内部工作节点的协调问题。</p><p>掌握一个知识需要理解它的前因后果，对于分布式系统来说，前因是「分布式系统解决了什么问题」，后果是「它是怎么做内部工作节点的协调」，所以我们要解决的第二个问题是：分布式系统是怎么做内部工作节点协调的？</p><p>先从简单的情况入手，对于分布式计算（无状态）的情况，系统内部的协调需要做哪些工作：</p><h3 id="1、怎么样找到服务？"><a href="#1、怎么样找到服务？" class="headerlink" title="1、怎么样找到服务？"></a>1、怎么样找到服务？</h3><p>在分布式系统内部，会有不同的服务（角色），服务 A 怎么找到服务 B 是需要解决的问题，一般来说服务注册与发现机制是常用的思路，所以可以了解一下服务注册发现机制实现原理，并且可以思考服务注册发现是选择做成 AP 还是 CP 系统更合理；</p><h3 id="2、怎么样找到实例？"><a href="#2、怎么样找到实例？" class="headerlink" title="2、怎么样找到实例？"></a>2、怎么样找到实例？</h3><p>找到服务后，当前的请求应该选择发往服务的哪一个实例呢？一般来说，如果同一个服务的实例都是完全对等的（无状态），那么按负载均衡策略来处理就足够（轮询、权重、hash、一致性hash，fair等各种策略的适用场景）；如果同一个服务的实例不是对等的（有状态），那么需要通过路由服务（元数据服务等）先确定当前要访问的请求数据做哪一个实例上，然后再进行访问。</p><h3 id="3、怎么样避免雪崩？"><a href="#3、怎么样避免雪崩？" class="headerlink" title="3、怎么样避免雪崩？"></a>3、怎么样避免雪崩？</h3><p>系统雪崩是指故障的由于正反馈循序导致不断扩大规则的故障。一次雪崩通常是由于整个系统中一个很小的部分出现故障于引发，进而导致系统其它部分也出现故障。比如系统中某一个服务的一个实例出现故障，导致负载均衡将该实例摘除而引起其它实例负载升高，最终导致该服务的所有实例像多米诺骨牌一样一个一个全部出现故障。</p><p>避免雪崩总体的策略比较简单，只要是两个思路，一个是快速失败和降级机制（熔断、降级、限流等），通过快速减少系统负载来避免雪崩的发生；另一个为弹性扩容机制，通过快速增加系统的服务能力来避免雪崩的发生。这个根据不同的场景可以做不同的选择，或者两个策略都使用。</p><p>一般来说，快速失败会导致部分的请求失败，如果分布式系统内部对一致性要求很高的话，快速失败会带来系统数据不一致的问题，弹性扩容会是一个比较好的选择，但是弹性扩容的实现成本和响应时间比快速失败要大得多。</p><h3 id="4、怎么样监控告警？"><a href="#4、怎么样监控告警？" class="headerlink" title="4、怎么样监控告警？"></a>4、怎么样监控告警？</h3><p>对于一个分布式系统，如果我们不能很清楚地了解内部的状态，那么高可用是没有办法完全保障的，所以对分布式系统的监控（比如接口的时延和可用性等信息），分布式追踪 Trace，模拟故障的混沌工程，以及相关的告警等机制是一定要完善的；</p><p>接下来我们再来看分布式存储（有状态）的内部的协调是怎么做的，同时，前面介绍的分布式计算的协调方式在分布式存储中同样适用，就不再重复了：</p><h3 id="5、CAP-及其相关理论与衡权："><a href="#5、CAP-及其相关理论与衡权：" class="headerlink" title="5、CAP 及其相关理论与衡权："></a>5、CAP 及其相关理论与衡权：</h3><p>ACID、BASE 和 CAP 理论，了解这三个主题，推荐这一篇文章以及文章后面相关的参考文献：<a href="https://link.zhihu.com/?target=https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed/">英文版本</a>，<a href="https://link.zhihu.com/?target=https://www.infoq.cn/article/cap-twelve-years-later-how-the-rules-have-changed/">中文版本</a></p><h3 id="6、怎么样做数据分片："><a href="#6、怎么样做数据分片：" class="headerlink" title="6、怎么样做数据分片："></a>6、怎么样做数据分片：</h3><p>单机的存储能力是不可能存储所有的数据的，所以需要解决怎么将数据按一定的规则分别存储到不同的机器上，目前使用比较多的方案为: <code>Hash</code> 和 <code>Region</code> 分片策略，可以了解一下它们的优缺点和各自的应用场景；</p><h3 id="7、怎么样做数据复制："><a href="#7、怎么样做数据复制：" class="headerlink" title="7、怎么样做数据复制："></a>7、怎么样做数据复制：</h3><p>为了满足系统的高可用要求，需要对数据做冗余处理，目前的方案主要为：中心化方案（主从复制、一致性协议比如 <code>Raft</code> 和 <code>Paxos</code> 等）和 去中心化的方案（<code>Quorum</code> 和 <code>Vector Clock</code>）了解一下它们的优缺点和各自的应用场景，以及对系统外部表现出来的数据一致性级别（线性一致性、顺序一致性、最终一致性等）；</p><h3 id="8、怎么样做分布式事务："><a href="#8、怎么样做分布式事务：" class="headerlink" title="8、怎么样做分布式事务："></a>8、怎么样做分布式事务：</h3><p>对于分布式系统来说，要实现事务，首先需要一个对并发事务进行排序的能力，这样在事务冲突的时候，确认哪个事务提供成功，哪个事务提交失败。</p><p>对于单机系统来说这个完全不说问题，简单的通过时间戳加序号的方式就可以实现，但是对于分布式系统来说，系统中机器的时间不能完全同步，并且单台机器序号也没用全局意义，按上面的方式说不行的。</p><p>不过整个系统选一台机器按单机的模式生产事务ID是可以的，同城多中心和短距离的异地多中心都没有问题，不过想做成全球分布式系统的话，那么每一次事务都要去一个节点去获取事务ID的成本太高（比如中国杭州到美国东部的RTT为200+ms），Google 的 Spanner 是通过 GPS 和 原子钟实现 <code>TrueTime</code> API 来解决这个问题从而实现全球分布式数据库的。</p><p>有了事务ID后，通过 <code>2PC</code> 或者 <code>3PC</code> 协议来实现分布式事务的原子性，其他部分和单机事务差别不大，就不再细说来。</p><p>到这里，对分布式系统脉络上有了基本的概念，接下来开始进入细节学习阶段，这也是非常幸苦的阶段，对于分布式系统的理解深入与否，对细节的深入度是很重要的评价指标，毕竟魔鬼在细节。这里可以往两个方面进行系统的学习：</p><ol><li><p> 从实践出发，研究目前比较常用的分布式系统的设计，HDFS 或者 GFS（分布式文件系统）、Kafka 和 Pulsar（分布式消息队列），Redis Cluster 和 Codis（分布式缓存），MySQL 的分库分表（传统关系型数据库的分布式方案），MongoDB 的 Replica Set 和 Sharing机制集（NoSQL数据库），TiDB（NewSQL），以及一些微服务框架 等；</p></li><li><p> 从理论出发，研究分布式相关的论文，这里推荐一本书「 Designing Data-Intensive Applications」（中文版本：数据密集型应用系统设计），先整体看书，对比较感兴趣的章节，再读一读该章节中涉及到的相关参考文献。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习一个知识之前，我觉得比较好的方式是先理解它的来龙去脉：即这个知识产生的过程，它解决了什么问题，它是怎么样解决的并且它带来了哪些问题，这样我们才能比较好的抓到它的脉络和关键点，不会一开始就迷失在细节中。&lt;/p&gt;
&lt;p&gt;所以，我们要解决的第一个问题是：&lt;strong&gt;分布式系统解决了什么问题？&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="分布式架构" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="分布式架构" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/"/>
    
    <category term="分布式系统" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>如何构建一个完善的活动平台</title>
    <link href="http://example.com/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E6%96%87%E7%AB%A0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/"/>
    <id>http://example.com/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E6%96%87%E7%AB%A0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/</id>
    <published>2021-01-08T17:46:41.000Z</published>
    <updated>2021-01-15T01:30:52.179Z</updated>
    
    <content type="html"><![CDATA[<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><blockquote><p>即是将页面的某一部分独立出来，将这一部分的用黑盒的形式全部封装到一个组件内，暴露出一些属性供外部组件传入值</p></blockquote><a id="more"></a><h3 id="白话解释"><a href="#白话解释" class="headerlink" title="白话解释"></a>白话解释</h3><blockquote><p>执行一段‘组件脚本’后，可以写“非法”HTML标签（指代组件实例），并在标签内绑定数据，该标签（组件）会根据自身逻辑，渲染出相关视图。</p></blockquote><h3 id="如下图"><a href="#如下图" class="headerlink" title="如下图"></a>如下图</h3><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-01.png"></p><br><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h3 id="一段不堪回首的经历😭"><a href="#一段不堪回首的经历😭" class="headerlink" title="一段不堪回首的经历😭"></a>一段不堪回首的经历😭</h3><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-02.png" alt="不堪回首"></p><br><h3 id="需求上线流程图"><a href="#需求上线流程图" class="headerlink" title="需求上线流程图"></a>需求上线流程图</h3><p><strong>特征：</strong></p><ol><li> 参与人员多。</li><li> 上线周期长。</li></ol><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-03.png" alt="img"></p><br><h3 id="可视化平台设想"><a href="#可视化平台设想" class="headerlink" title="可视化平台设想"></a>可视化平台设想</h3><p><strong>特征：</strong></p><ol><li> 设计、开发协作，提供通用、规范UI组件。</li><li> 用户创建活动，选择需要的组件，编辑组件数据。</li><li> 保存，预览，发布，访问。</li></ol><br><p><strong>如下图👇</strong><br><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-04.png" alt="img"></p><br><h3 id="上线流程图设想"><a href="#上线流程图设想" class="headerlink" title="上线流程图设想"></a>上线流程图设想</h3><p><strong>特征：</strong></p><ol><li> 人员少：仅运营1人。</li><li> 上线快：小时级周期。</li></ol><br><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-05.png" alt="img"></p><br><h3 id="平台启动前思考🤔"><a href="#平台启动前思考🤔" class="headerlink" title="平台启动前思考🤔"></a>平台启动前思考🤔</h3><p><code>组件开发</code>：<br>平台的组件数量应该无限制，组件之间独立，组件与平台解耦，做到动态加载、编辑组件。</p><p><code>配置平台</code>：<br>对外的核心交互，配置平台负责可视化创建页面，选择组件，编辑数据。</p><p><code>页面渲染</code>：<br>平台的最终产物，保存活动配置后，渲染页应该仅加载本活动涉及的组件。</p><p><code>总结</code>：<br>组件开发模块：负责产出页面的基本单元——组件。<br>配置平台模块：负责可视化创建，编辑活动页。<br>页面渲染模块：负责呈现活动视图。</p><br><h1 id="平台实现"><a href="#平台实现" class="headerlink" title="平台实现"></a>平台实现</h1><h3 id="组件开发架构图"><a href="#组件开发架构图" class="headerlink" title="组件开发架构图"></a>组件开发架构图</h3><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-06.png" alt="img"></p><br><h3 id="组件开发环境"><a href="#组件开发环境" class="headerlink" title="组件开发环境"></a>组件开发环境</h3><p><strong>组件开发：</strong></p><ol><li> 提供集中式开发、管理组件的项目环境。</li><li> 支持命令式创建、调试、编译、校验、发布组件。</li></ol><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-07.png" alt="img"></p><br><h3 id="再来说下组件形态"><a href="#再来说下组件形态" class="headerlink" title="再来说下组件形态"></a>再来说下组件形态</h3><ol><li> 一段可执行JS脚本——组件本身。</li><li> 一份XLSX文件——多地区语言配置。</li><li> 一份JSON文件——可编辑属性申明。</li></ol><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-08.png" alt="img"></p><br><h3 id="组件发布"><a href="#组件发布" class="headerlink" title="组件发布"></a>组件发布</h3><blockquote><p>命令式发布，相关字段被完善，注册入库。</p></blockquote><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-09.png" alt="img"></p><br><h1 id="平台实现-1"><a href="#平台实现-1" class="headerlink" title="平台实现"></a>平台实现</h1><h3 id="页面配置一览"><a href="#页面配置一览" class="headerlink" title="页面配置一览"></a>页面配置一览</h3><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-10.png" alt="img"></p><br><h3 id="页面配置-编辑"><a href="#页面配置-编辑" class="headerlink" title="页面配置-编辑"></a>页面配置-编辑</h3><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-11.png" alt="img"></p><br><h3 id="页面配置-发布"><a href="#页面配置-发布" class="headerlink" title="页面配置-发布"></a>页面配置-发布</h3><p><strong>发布流程</strong></p><ol><li> 将组件、配置打包。</li><li> 打包文件推至CDN。</li></ol><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-12.png" alt="img"></p><br><h3 id="页面渲染-解析"><a href="#页面渲染-解析" class="headerlink" title="页面渲染-解析"></a>页面渲染-解析</h3><ol><li> 加载CDN配置文件。</li><li> 遍历Render组件并传入该组件配置</li></ol><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-13.png" alt="img"></p><br><h3 id="页面渲染-监控"><a href="#页面渲染-监控" class="headerlink" title="页面渲染-监控"></a>页面渲染-监控</h3><ol><li> 异常监控+告警。</li><li> 页面性能监控+告警。</li><li> 用户行为监控。</li></ol><p><img src="/My-Blogs/images/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-14.png" alt="img"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>组件开发</code>：关键数据有JS, JSON, XLSX。</li><li><code>页面配置</code>：选择组件，编辑组件，保存配置。</li><li><code>页面渲染</code>：逐个渲染组件并传入配置，页面监控。</li></ul><br><h1 id="实现细节总结"><a href="#实现细节总结" class="headerlink" title="实现细节总结"></a>实现细节总结</h1><ul><li><code>组件编辑面板</code>: 根据组件JSON配置，展开编辑面板。</li><li><code>组件通信</code>: 将发射、接收的事件、方法名申明，添加事件监听并调用暴露方法。</li><li><code>组件嵌套</code>: 配置中父子关系链。</li><li><code>多语言</code>: 汇总各组件多语言文件，集中处理成包，再以Hash ID分发。</li><li><code>主题色</code>: 规范视觉UI的色值占位，一套主题即一套词典。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;组件&quot;&gt;&lt;a href=&quot;#组件&quot; class=&quot;headerlink&quot; title=&quot;组件&quot;&gt;&lt;/a&gt;组件&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;即是将页面的某一部分独立出来，将这一部分的用黑盒的形式全部封装到一个组件内，暴露出一些属性供外部组件传入值&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="分布式架构" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="分布式架构" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/"/>
    
    <category term="活动平台" scheme="http://example.com/tags/%E6%B4%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>easywebpack项目添加svg处理</title>
    <link href="http://example.com/2021/01/08/webpack/easywebpack/easywebpack%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0svg%E5%A4%84%E7%90%86/"/>
    <id>http://example.com/2021/01/08/webpack/easywebpack/easywebpack%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0svg%E5%A4%84%E7%90%86/</id>
    <published>2021-01-08T17:43:20.000Z</published>
    <updated>2021-01-15T01:30:52.179Z</updated>
    
    <content type="html"><![CDATA[<p>比如查看webpack最终的loader： <code>easywebpack print test -n module.rules</code></p><a id="more"></a><p>easywebpack配置svg-sprite-loader的配置：</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><blockquote><p>去除默认svg处理，并添加svg-sprite-loader配置</p></blockquote><pre><code class="JS">loaders: {  urlimage: {    test: /\.(png|jpe?g|gif)(\?.*)?$/, // 默认的url-loader在将svg也处理了，需要去掉  },  svg: {    test: /\.svg$/,    loader: 'svg-sprite-loader',    options: {      symbolId: 'icon-[name]',    },    include: resolve('app/web/asset/svg'),  },}</code></pre><p>网上关于<a href="https://juejin.cn/post/6854573215646875655">svg-sprite-loader</a>的介绍</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;比如查看webpack最终的loader： &lt;code&gt;easywebpack print test -n module.rules&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="easywebpack" scheme="http://example.com/categories/easywebpack/"/>
    
    
    <category term="svg" scheme="http://example.com/tags/svg/"/>
    
    <category term="webpack" scheme="http://example.com/tags/webpack/"/>
    
    <category term="基础构建" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80%E6%9E%84%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Vue3新特性</title>
    <link href="http://example.com/2021/01/08/vue/vue3/%E6%B5%85%E8%B0%88Vue3%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2021/01/08/vue/vue3/%E6%B5%85%E8%B0%88Vue3%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2021-01-08T17:42:31.000Z</published>
    <updated>2021-01-15T01:30:52.178Z</updated>
    
    <content type="html"><![CDATA[<p>Vue3的<a href="https://github.com/vuejs/vue-next">release版本</a>终于发布了，新的Vue3在语法以及底层都进行了全新的重构，带来了更快的运行速度，更小的构建包，更友好的编程规范。</p><a id="more"></a><h2 id="更快"><a href="#更快" class="headerlink" title="更快"></a>更快</h2><p>传统的虚拟dom算法：</p><p>组件patch的时候，需要重新创建整个vdom树，然后遍历整棵树进行diff，update…</p><p>更快的虚拟dom算法，源自编译模板时给予更多的运行时提示：</p><ol><li> 编译模板时对动态内容进行patch标记，告诉patch算法只关注被标记的动态部分</li></ol><p><img src="/My-Blogs/images/%E6%B5%85%E8%B0%88Vue3%E6%96%B0%E7%89%B9%E6%80%A7-01.png"></p><ol><li> 对静态内容进行静态提升（变量提升），只在页面初始化时创建并渲染一次，其余时候不再渲染</li></ol><p><img src="/My-Blogs/images/%E6%B5%85%E8%B0%88Vue3%E6%96%B0%E7%89%B9%E6%80%A7-02.png"></p><ol><li> 对事件监听函数进行缓存，防止内联监听函数带来的副作用</li></ol><p>开启缓存前：</p><p><img src="/My-Blogs/images/%E6%B5%85%E8%B0%88Vue3%E6%96%B0%E7%89%B9%E6%80%A7-03.png"></p><p>开启缓存后：</p><p><img src="/My-Blogs/images/%E6%B5%85%E8%B0%88Vue3%E6%96%B0%E7%89%B9%E6%80%A7-04.png"></p><p>……</p><p>从在线模板编译器中编辑并查看新变化 =&gt;<a href="https://vue-next-template-explorer.netlify.app/">模板编译器</a></p><h2 id="更小"><a href="#更小" class="headerlink" title="更小"></a>更小</h2><h3 id="全局API的使用"><a href="#全局API的使用" class="headerlink" title="全局API的使用"></a>全局API的使用</h3><p>全局 API 现在只能作为 ES 模块构建的命名导出进行访问。</p><h4 id="Vue2的使用方式"><a href="#Vue2的使用方式" class="headerlink" title="Vue2的使用方式"></a>Vue2的使用方式</h4><p>Vue.nextTick（this.$nextTick）、Vue.set、Vue.delete …</p><h4 id="Vue3的使用方式"><a href="#Vue3的使用方式" class="headerlink" title="Vue3的使用方式"></a>Vue3的使用方式</h4><p>import { nextTick, set, delete, … } from ‘vue’; </p><p>nextTick(() =&gt; {// dosomething});<br>……</p><h3 id="内部组件与helper的使用"><a href="#内部组件与helper的使用" class="headerlink" title="内部组件与helper的使用"></a>内部组件与helper的使用</h3><p>当在模板中使用到transtion组件、keepAlive组件、 …</p><p>经complier编译后，生成</p><p>import { transtion, keepAlive, … } from ‘vue’</p><p>当在模板中使用到v-show、v-model…</p><p>complier编译后，生成</p><p>import { vShow, vModel … } from ‘vue’</p><p>意味着只有在应用程序实际使用了某个API或者组件的时候才会导入它。没有使用到的功能代码将不会出现在最终的构建包中。框架体积进一步缩小。</p><h2 id="更友好？"><a href="#更友好？" class="headerlink" title="更友好？"></a>更友好？</h2><h4 id="VUE2组件现存的缺陷"><a href="#VUE2组件现存的缺陷" class="headerlink" title="VUE2组件现存的缺陷"></a>VUE2组件现存的缺陷</h4><ol><li><p> 组件越来越大，可读性和可维护性越来越差。根本原因在于Vue使用的option API：必须按配置(options)来组织代码，你需要把一个功能的实现分布在各个配置里：data，computed，watcher，methods，但是在某些情况下按功能来组织代码更合理。如果要在一个很大的组件中修改一个功能，就要跳到各个属性找，如果组件里面还用了mixins，还得跳文件看</p></li><li><p>mixins无法特别好的在多个组件中复用同一段代码  </p><p> mixins有什么问题？<br> 可读性太差，得跳到mixins所在的文件中才能知道它到底有什么<br> 不同的mixins容易冲突<br> 复用其他同伴的mixins的时候，有些代码不合自己的预期，但是不能随意更改</p></li><li><p> 对typeScript的支持有限</p></li></ol><h4 id="使用componsition-API"><a href="#使用componsition-API" class="headerlink" title="使用componsition API"></a>使用componsition API</h4><p>什么时候使用componsition API？</p><p><img src="/My-Blogs/images/%E6%B5%85%E8%B0%88Vue3%E6%96%B0%E7%89%B9%E6%80%A7-05.png"></p><ol><li> 如果你有一个很大的组件，想要按功能来聚合代码。</li><li> 如果你想要复用组件的一部分代码。</li><li> 如果你想要更好地支持typeScript</li></ol><pre><code class="JS">import useFeature1 from '../use/useFeature1';import useFeature2 from '../use/useFeature2';export default {  setup() {    const {      data1,      data2,      method1,      computed1,      ...    } = useFeature1();    const {      data3,      data4,      method2,      computed2,      ...    } = useFeature2();    // do something    return {      data1,      data2,      method1,      ...    };  }}</code></pre><p>上面这段代码是compsition API的一种示例，它做到了：按功能组织代码，想要修改某个业务逻辑时，不需要满大街找散布各地的数据和方法了，响应式属性与组件解耦，自由控制需要成为响应式的以及需要暴露给模板的属性。</p><p>setup内的代码只依赖于传入的参数和全局引入的Vue API，而不是特殊修改过的 <code>this</code> 。所以只需要导出你想要复用的功能函数。甚至可以导出整个 <code>setup</code> 函数去实现“类似”继承的效果。</p><h4 id="两种创建响应式属性的API"><a href="#两种创建响应式属性的API" class="headerlink" title="两种创建响应式属性的API"></a>两种创建响应式属性的API</h4><h5 id="ref-为传入的值封装一个响应式对象，通过value属性访问与设置对象的值"><a href="#ref-为传入的值封装一个响应式对象，通过value属性访问与设置对象的值" class="headerlink" title="ref: 为传入的值封装一个响应式对象，通过value属性访问与设置对象的值"></a>ref: 为传入的值封装一个响应式对象，通过value属性访问与设置对象的值</h5><pre><code class="JS">setup() {  const capacity = ref(3);  const attending = ref(['tim', 'Bob', 'Joe']);  watch(capacity, () =&gt; {    console.log('capacity changed!');  });  watch(attending, () =&gt; {    console.log('attending changed!');  });  onMounted(() =&gt; {    capacity.value += 1; // capacity changed!    attending.value[0] = 'Jack'; // ?    // 通过ref封装的响应式对象无法进行深层监听  });  return {    capacity  };}</code></pre><h5 id="reactive-让传入的对象成为响应式对象"><a href="#reactive-让传入的对象成为响应式对象" class="headerlink" title="reactive: 让传入的对象成为响应式对象"></a>reactive: 让传入的对象成为响应式对象</h5><pre><code class="JS">setup() {  const event = reactive({    capacity: 3,    attending: ['tim', 'Bob', 'Joe'],  });  watch(event, () =&gt; {    console.log('something changed!');  });  onMounted(() =&gt; {    event.attending[0] = 'Jack'; // something changed!  });  return {    event  };}</code></pre><p>Vue3的响应式监听的实现方式与Vue2有很大不同，并挣脱了Vue2中无法监听动态增加对象属性与数组元素直接赋值的束缚。</p><p>点这里查看<a href="https://github.com/LaiTaoGDUT/learnVue3/blob/master/public/reactive.html">简略版本的新响应式监听实现</a></p><h4 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h4><h5 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h5><pre><code class="JS">setup() {  const capacity = ref(3);  const attending = ref(['tim', 'Bob', 'Joe']);  const stop = watchEffect(() =&gt; {    console.log(capacity.value + attending.value.length);  })  onMounted(() =&gt; {    capacity.value += 1; // 7  });  return {    capacity,    attending,    stop  };}stop(); // 停止监听</code></pre><p><a href="https://vue3js.cn/docs/zh/api/">更多API请参考官方文档</a></p><h4 id="compisition-API的下一步"><a href="#compisition-API的下一步" class="headerlink" title="compisition API的下一步"></a>compisition API的下一步</h4><h5 id="现存的缺点"><a href="#现存的缺点" class="headerlink" title="现存的缺点"></a>现存的缺点</h5><ol><li> ref和reactive太像了，初上手时很难决定到底用哪个。</li><li> 没有了options的限制，一不小心就可能会写出比使用option API更加臃肿难读的代码</li><li> 使用Composition API时，需要区分哪些值或者对象是响应式的，哪些不是。</li><li> 阅读或者修改ref会有点麻烦，因为必须通过<code>.value</code>才能实现。</li><li> 一旦组件需要使用的数据多起来，import和return语句就会很冗长。</li></ol><h5 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h5><p><a href="https://github.com/vuejs/rfcs/pull/222">New script setup and ref sugar</a></p><p>前阵子，Vue3.0提出了两个新提案，分别为script-setup提案与ref-suger提案</p><p>对于以下源代码：</p><pre><code class="HTML">&lt;script&gt;  import {    ref  } from 'vue'  export default {    setup() {      const count = ref(1)      const inc = () =&gt; {        count.value++      }      return {        count,        inc      }    }  }&lt;/script&gt;</code></pre><p><strong>使用script-setup 提案，将 options.setup 提取到代码顶层，所有顶层声明默认导出为模板使用</strong></p><pre><code class="HTML">&lt;script setup&gt;  import {    ref  } from 'vue'  const count = ref(0)  const inc = () =&gt; {    count.value++  }&lt;/script&gt;</code></pre><p><strong>使用ref-sugar 提案，将 ref.value 的写法，做进一步简化，放弃<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/label">标记语句</a>的普通语法，将其作为ref声明的语法糖。</strong></p><pre><code class="HTML">&lt;script setup&gt;  ref: count = 1  const inc = () =&gt; {    count++  }  // 通过添加$前缀来访问响应式对象  console.log($count.value)&lt;/script&gt;</code></pre><p>这是Vue3带来的小改进还是大挑战 ？</p><h2 id="其他变化"><a href="#其他变化" class="headerlink" title="其他变化"></a>其他变化</h2><h4 id="不再支持keyCode修饰"><a href="#不再支持keyCode修饰" class="headerlink" title="不再支持keyCode修饰"></a>不再支持keyCode修饰</h4><pre><code class="HTML">&lt;input v-on:keyup.13="handleEnter"&gt;&lt;/input&gt;</code></pre><p>替换为</p><pre><code class="HTML">&lt;input v-on:keyup:enter="handleEnter"&gt;&lt;/input&gt;</code></pre><h4 id="过渡类名变更"><a href="#过渡类名变更" class="headerlink" title="过渡类名变更"></a>过渡类名变更</h4><p>.v-enter =&gt; .v-enter-from</p><p>.v-leave =&gt; .v-leave-from</p><h4 id="v-model变更"><a href="#v-model变更" class="headerlink" title="v-model变更"></a>v-model变更</h4><p>可使用多个v-model, 不再需要.sync修饰符来进行双向绑定了</p><pre><code class="HTML">&lt;ChildComponent v-model:title="pageTitle" /&gt;</code></pre><p>相当于</p><pre><code class="HTML">&lt;ChildComponent :title="pageTitle" @update:title="pageTitle = $event" /&gt;</code></pre><h4 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h4><p>Vue认为$ on，$ off 和 $once 实例方法不应该由它来提供，因此Vue3将它们移除了</p><p>过滤器filters被移除了，需要使用计算属性或方法来代替</p><p>新增Suspence组件 =&gt; 组件loading完成前显示后备内容</p><p>新增teleport组件（portal） =&gt; 允许传送组件内容到根节点以外的任何地方<br>…</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Vue3的&lt;a href=&quot;https://github.com/vuejs/vue-next&quot;&gt;release版本&lt;/a&gt;终于发布了，新的Vue3在语法以及底层都进行了全新的重构，带来了更快的运行速度，更小的构建包，更友好的编程规范。&lt;/p&gt;</summary>
    
    
    
    <category term="vue3" scheme="http://example.com/categories/vue3/"/>
    
    
    <category term="vue3" scheme="http://example.com/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>Redis缓存的三大问题及其解决方案</title>
    <link href="http://example.com/2021/01/08/Redis/%E3%80%90Redis%E3%80%91%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://example.com/2021/01/08/Redis/%E3%80%90Redis%E3%80%91%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2021-01-08T17:40:53.000Z</published>
    <updated>2021-01-15T01:30:52.175Z</updated>
    
    <content type="html"><![CDATA[<p>Redis经常用于系统中的缓存，这样可以解决目前IO设备无法满足互联网应用海量的读写请求的问题。</p><a id="more"></a><h2 id="一、缓存穿透"><a href="#一、缓存穿透" class="headerlink" title="一、缓存穿透"></a>一、缓存穿透</h2><p>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起id为-1的数据或者特别大的不存在的数据。有可能是黑客利用漏洞攻击从而去压垮应用的数据库。</p><h3 id="1-常见解决方案"><a href="#1-常见解决方案" class="headerlink" title="1. 常见解决方案"></a>1. 常见解决方案</h3><p>对于缓存穿透问题，常见的解决方案有以下三种：</p><ul><li>验证拦截：接口层进行校验，如鉴定用户权限，对ID之类的字段做基础的校验，如id&lt;=0的字段直接拦截；</li><li>缓存空数据：当数据库查询到的数据为空时，也将这条数据进行缓存，但缓存的有效性设置得要较短，以免影响正常数据的缓存；</li></ul><pre><code class="JAVA">public Student getStudentsByID(Long id) {    // 从Redis中获取学生信息    Student student = redisTemplate.opsForValue()        .get(String.valueOf(id));    if (student != null) {        return student;    }    // 从数据库查询学生信息，并存入Redis    student = studentDao.selectByStudentId(id);    if (student != null) {        redisTemplate.opsForValue()            .set(String.valueOf(id), student, 60, TimeUnit.MINUTES);    } else {        // 即使不存在，也将其存入缓存中        redisTemplate.opsForValue()            .set(String.valueOf(id), null, 60, TimeUnit.SECONDS);    }    return student;}</code></pre><ul><li>使用布隆过滤器：布隆过滤器是一种比较独特数据结构，有一定的误差。当它指定一个数据存在时，它不一定存在，但是当它指定一个数据不存在时，那么它一定是不存在的。</li></ul><h3 id="2-布隆过滤器"><a href="#2-布隆过滤器" class="headerlink" title="2. 布隆过滤器"></a>2. 布隆过滤器</h3><p>布隆过滤器是一种比较特殊的数据结构，有点类似与HashMap，在业务中我们可能会通过使用HashMap来判断一个值是否存在，它可以在<code>O(1)</code>时间复杂度内返回结果，效率极高，但是受限于存储容量，如果可能需要去判断的值超过亿级别，那么HashMap所占的内存就很可观了。<br>而<code>BloomFilter</code>解决这个问题的方案很简单。首先用多个bit位去代替HashMap中的数组，这样的话储存空间就下来了，之后就是对 Key 进行多次哈希，将 Key 哈希后的值所对应的 bit 位置为1。<br>当判断一个元素是否存在时，就去判断这个值哈希出来的比特位是否都为1，如果都为1，那么可能存在，也可能不存在（如下图F）。但是如果有一个bit位不为1，那么这个Key就肯定不存在。</p><p><img src="/My-Blogs/images/%E3%80%90Redis%E3%80%91%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-01.png" alt="img"></p><br><p>注意：<code>BloomFilter</code>并不支持删除操作，只支持添加操作。这一点很容易理解，因为你如果要删除数据，就得将对应的bit位置为0，但是你这个Key对应的bit位可能其他的Key也对应着。</p><h3 id="3-缓存空数据与布隆过滤器的比较"><a href="#3-缓存空数据与布隆过滤器的比较" class="headerlink" title="3. 缓存空数据与布隆过滤器的比较"></a>3. 缓存空数据与布隆过滤器的比较</h3><p>上面对这两种方案都进行了简单的介绍，缓存空数据与布隆过滤器都能有效解决缓存穿透问题，但使用场景有着些许不同；</p><ul><li>当一些恶意攻击查询查询的key各不相同，而且数量巨多，此时缓存空数据不是一个好的解决方案。因为它需要存储所有的Key，内存空间占用高。并且在这种情况下，很多key可能只用一次，所以存储下来没有意义。所以对于这种情况而言，使用布隆过滤器是个不错的选择；</li><li>而对与空数据的Key数量有限、Key重复请求效率较高的场景而言，可以选择缓存空数据的方案。</li></ul><h2 id="二、缓存击穿"><a href="#二、缓存击穿" class="headerlink" title="二、缓存击穿"></a>二、缓存击穿</h2><p>缓存击穿是指当前热点数据存储到期时，多个线程同时并发访问热点数据。因为缓存刚过期，所有并发请求都会到数据库中查询数据。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>将热点数据设置为永不过期；</li><li>加互斥锁：互斥锁可以控制查询数据库的线程访问，但这种方案会导致系统的吞吐量下降，需要根据实际情况使用。</li></ul><pre><code class="JAVA">public String get(key) {    String value = redis.get(key);    if (value == null) { // 代表缓存值过期        // 设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db        if (redis.setnx(key_mutex, 1, 3 * 60) == 1) {  // 代表设置成功            value = db.get(key);            redis.set(key, value, expire_secs);            redis.del(key_mutex);        } else {  // 这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可            sleep(50);            get(key);  // 重试        }    } else {        return value;          }}</code></pre><h2 id="三、缓存雪崩"><a href="#三、缓存雪崩" class="headerlink" title="三、缓存雪崩"></a>三、缓存雪崩</h2><p>缓存雪崩发生有几种情况，比如大量缓存集中在或者缓存同时在大范围中失效，出现了大量请求去访问数据库，从而导致CPU和内存过载，甚至停机。</p><p>一个简单的雪崩过程：</p><ol><li> Redis 集群产生了大面积故障；</li><li> 缓存失败，此时仍有大量请求去访问 Redis 缓存服务器；</li><li> 在大量 Redis 请求失败后，这些请求将会去访问数据库；</li><li> 由于应用的设计依赖于数据库和 Redis 服务，很快就会造成服务器集群的雪崩，最终导致整个系统的瘫痪。</li></ol><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>【事前】高可用缓存：高可用缓存是防止出现整个缓存故障。即使个别节点，机器甚至机房都关闭，系统仍然可以提供服务，Redis 哨兵(Sentinel) 和 Redis 集群(Cluster) 都可以做到高可用；</li><li>【事中】缓存降级（临时支持）：当访问次数急剧增加导致服务出现问题时，我们如何确保服务仍然可用。在国内使用比较多的是 Hystrix，它通过熔断、降级、限流三个手段来降低雪崩发生后的损失。只要确保数据库不死，系统总可以响应请求，每年的春节 12306 我们不都是这么过来的吗？只要还可以响应起码还有抢到票的机会；</li><li>【事后】Redis备份和快速预热：Redis数据备份和恢复、快速缓存预热。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis经常用于系统中的缓存，这样可以解决目前IO设备无法满足互联网应用海量的读写请求的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>PWA在likee业务线的实践</title>
    <link href="http://example.com/2021/01/08/PWA/PWA%E5%9C%A8likee%E4%B8%9A%E5%8A%A1%E7%BA%BF%E7%9A%84%E5%AE%9E%E8%B7%B5/"/>
    <id>http://example.com/2021/01/08/PWA/PWA%E5%9C%A8likee%E4%B8%9A%E5%8A%A1%E7%BA%BF%E7%9A%84%E5%AE%9E%E8%B7%B5/</id>
    <published>2021-01-08T17:37:50.000Z</published>
    <updated>2021-01-15T01:30:52.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是PWA？"><a href="#1-什么是PWA？" class="headerlink" title="1. 什么是PWA？"></a>1. 什么是PWA？</h2><p>PWA（Progressive web apps，渐进式 Web 应用）运用现代的 Web API 以及传统的渐进式增强策略来创建跨平台 Web 应用程序。</p><a id="more"></a><p>如何理解渐进式？</p><ul><li>  渐进式构建。构成 PWA 的标准都来自 Web 技术，它们都是浏览器提供的、向下兼容的、没有额外运行时代价的技术。因此可以把任何现有的框架开发的 Web 页面改造成 PWA，不需要完全重构现有代码，可以逐步地迁移和改善。</li><li>  渐进式增强。浏览器厂商会逐步提供对 PWA 相关api的支持，现代浏览器的用户会逐步受益，但不会为使用旧版浏览器的用户破坏任何内容。</li></ul><h2 id="2-PWA能做什么？"><a href="#2-PWA能做什么？" class="headerlink" title="2. PWA能做什么？"></a>2. PWA能做什么？</h2><ul><li><p>  安装添加桌面图标</p></li><li><p>  提供前端网络代理</p></li><li><p>  利用cache api对response进行缓存</p></li><li><p>发送push通知  </p><p>  接收服务端推送</p></li></ul><h2 id="3-PWA的工作原理"><a href="#3-PWA的工作原理" class="headerlink" title="3. PWA的工作原理"></a>3. PWA的工作原理</h2><p>PWA实现上述功能，依赖于service worker提供的能力。</p><p>service worker是web worker的一种，是运行在独立线程中的js代码。一个service worker的完整生命周期如下图所示。</p><p><img src="/My-Blogs/images/PWA%E5%9C%A8likee%E4%B8%9A%E5%8A%A1%E7%BA%BF%E7%9A%84%E5%AE%9E%E8%B7%B5-01.png"></p><p>通常遵循以下基本步骤来使用 service worker：</p><ul><li><p>  service worker URL 通过 serviceWorkerContainer.register() 来获取和注册。</p></li><li><p>  如果注册成功，service worker 就在 ServiceWorkerGlobalScope 环境中运行； 这是一个特殊类型的 worker 上下文运行环境，与主运行线程（执行脚本）相独立，同时也没有访问 DOM 的能力。</p></li><li><p>service worker 现在可以处理事件了。  </p><p>  受 service worker 控制的页面打开后会尝试去安装 service worker。最先发送给 service worker 的事件是安装事件。</p></li><li><p>  当 oninstall 事件的处理程序执行完毕后，可以认为 service worker 安装完成了。</p></li><li><p>  下一步是激活。当 service worker 安装完成后，会接收到一个激活事件(activate event)。onactivate 主要用途是清理先前版本的service worker 脚本中使用的资源。</p></li><li><p>  service worker 现在可以控制页面了，但仅是在 register() 成功后的打开的页面。</p></li></ul><p>示例代码如下：</p><pre><code class="JS">navigator.serviceWorker.register(opts.url).then(function(registration) {  console.log("Service worker successfully registered.");})</code></pre><h2 id="4-处理业务需要封装的基本方法"><a href="#4-处理业务需要封装的基本方法" class="headerlink" title="4. 处理业务需要封装的基本方法"></a>4. 处理业务需要封装的基本方法</h2><p>为了处理业务，我们对service worker相关的基本方法进行了封装</p><p>主线程js封装如下：</p><pre><code class="JS">/** * service worker sdk *  * @param {string} opts.url [required] sw文件地址 * @param {function} opts.onReady [optional] sw注册成功 * @param {function} opts.onBeforeInstallPrompt [optional] 未安装pwa事件触发 * @param {function} opts.onClickInstallPrompt [optional] 点击安装确认弹窗 * @param {function} opts.onInstalled [optional] pwa安装成功时触发 * @param {function} opts.onNotificationPermission [optional] 点击通知授权确认弹窗 *  */export function SWSdk(opts) {  /**   * 初始化sw   */  /**   * sw注册成功   */  /**   * 未安装pwa事件触发   */  /**   * pwa安装成功时触发   */  /**   * 弹出安装确认弹窗   */  /**   * 监听sw事件   */  /**   * 触发sw事件   */  /**   * 弹出通知授权确认弹窗   */  /**   * 发送一条通知   */  /**   * 缓存资源   */  /**   * 删除缓存资源   */}</code></pre><p>sw线程js封装如下：</p><pre><code class="JS">/** * SW *  * @param {string} opts. CACHE_NAME [optional] 缓存命名空间，建议每个应用独立命名 * @param {number} opts.tickTime [optional] 每个tick的时间间隔，单位ms，默认1000 * @param {function} opts.onTick [optional] 每个时间间隔调用一次 * @param {function} opts.onProxy [optional] 代理网络请求 * @param {function} opts.onInstall [optional] 安装事件的回调 * @param {function} opts.onActivate [optional] 激活事件的回调 * @param {function} opts.onPush [optional] 收到服务端事件的回调 * @param {function} opts.notificationOnClick [optional] 点击push通知的回调 */var SW = function(opts) {  /**   * 初始化sw   */  /**   * 监听窗口事件   */  /**   * 触发窗口事件   */  /**   * 设置cache   */  /**   * 获取cache   */  /**   * 发送一条通知   */};</code></pre><p>对service worker api的封装，使我们可以更加集中精力处理业务。</p><p>封装的基本方法有：</p><blockquote><p>a. 线程间通讯。主线程和service worker线程之间需要频繁的通信，因此需要封装比较友好的通信方法</p></blockquote><p>主线程：</p><pre><code class="JS">/** * 监听sw事件 *  * @param {string} eventName [required] 事件名称 * @param {function} handler [required] 处理函数 */this.on = function(eventName, handler) {  this.eventListener.push({    eventName: eventName,    handler: handler  })};/** * 触发sw事件 *  * @param {string} eventName [required] 事件名称 * @param {any} payload [optional] 传递的数据 */this.emit = function(eventName, payload) {  const data = {    eventName: eventName,    payload: payload  };  try {    if (navigator.serviceWorker.controller) {      navigator.serviceWorker.controller.postMessage(data);    } else {      navigator.serviceWorker.addEventListener("controllerchange", () =&gt; {        navigator.serviceWorker.controller.postMessage(data);      });    }  } catch (err) {    console.error(err);  }}</code></pre><p>service worker线程：</p><pre><code class="JS">/** * 监听窗口事件 *  * @param {string} eventName [required] 事件名称 * @param {function} handler [required] 处理函数 */this.on = function(eventName, handler) {  this.eventListener.push({    eventName: eventName,    handler: handler  })};/** * 触发窗口事件 *  * @param {string} eventName [required] 事件名称 * @param {any} payload [optional] 传递的数据 */this.emit = function(eventName, payload) {  clients.matchAll({    type: 'window',    includeUncontrolled: true  }).then(function(matchClient) {    matchClient.forEach(function(client) {      client.postMessage({        eventName: eventName,        payload: payload      });    })  });};</code></pre><blockquote><p>b. 本地存储。在service worker 线程中，我们无法使用cookie，localStorage和sessionStorage，我们只能使用cache api或者indexDB作为存储key-value数据的载体。</p></blockquote><pre><code class="JS">/** * 设置cache *  * @param {string} key cache的key * @param {any} value cache的值 */this.setCache = function(key, value) {  try {    return caches.open(this.CACHE_NAME).then(function(cache) {      return cache.put(key, new Response(value));    })  } catch (err) {    const that = this;    return new Promise(function(resolve) {      if (!that.cacheStorage[that.CACHE_NAME]) {        that.cacheStorage[that.CACHE_NAME] = {};      }      that.cacheStorage[that.CACHE_NAME][key] = value;      resolve();    })  }};/** * 获取cache *  * @param {string} key cache的key */this.getCache = function(key) {  try {    return caches.open(this.CACHE_NAME).then(function(cache) {      return cache.match(key);    }).then(function(response) {      return response ? response.text() : '';    })  } catch (err) {    const that = this;    return new Promise(function(resolve) {      resolve(new String(that.cacheStorage[that.CACHE_NAME][key]));    })  }};</code></pre><p>cache api无法直接保存key-value键值对数据，只能保存url-response对数据，我们这里使用了一些小技巧，使它可以存储key-value型数据</p><blockquote><p>c. 通知</p></blockquote><p>主线程申请授权</p><pre><code class="JS">/** * 弹出通知授权确认弹窗 */this.requestNotificationPermission = function() {  Notification.requestPermission().then((result) =&gt; {    that.onNotificationPermission.bind(that)(result);  });};</code></pre><p>service worker线程发送通知</p><pre><code class="JS">/** * 发送一条通知 *  * @param {object} params [required] * @param {string} params.title [required] 标题 * @param {string} params.desc [optional] 描述 * @param {string} params.icon [optional] 图标 * @param {any} params.data [optional] 传递参数 * @param {string} params.url [optional] 点击跳转地址 */this.showNotification = function(params) {  try {    self.registration.showNotification(params.title, {      body: params.desc,      icon: params.icon,      image: params.image,      data: Object.assign({        url: params.url      }, params.data)    })  } catch (err) {    console.log(err);  }};</code></pre><h2 id="5-业务需求及对策"><a href="#5-业务需求及对策" class="headerlink" title="5. 业务需求及对策"></a>5. 业务需求及对策</h2><p>此小节内容太多，不详细展开，有兴趣可以私聊</p><blockquote><p>a. 安装桌面快捷方式</p></blockquote><ul><li>  未安装事件</li><li>  弹出询问安装弹窗api</li></ul><blockquote><p>b. 本地推送通知</p></blockquote><ul><li>  询问授权通知api</li><li>  发送通知</li></ul><blockquote><p>c. sw内埋点</p></blockquote><ul><li>  Fetch api</li><li>  请求数据构造</li></ul><blockquote><p>d. 拉活桌面pwa</p></blockquote><ul><li>  需要安装google play服务</li><li>  需要由不同域的页面发起重定向跳转</li><li>  与pwa同域的链接均可拉活pwa，且pwa展示跳转链接，而非start_url中配置的链接</li><li>  中转页策略</li></ul><blockquote><p>e. 视频预加载</p></blockquote><ul><li>  使用cache api</li></ul><blockquote><p>f. 识别用户访问的是web页面还是桌面pwa</p></blockquote><ul><li>  桌面入口拉活</li><li>  链接拉活</li></ul><h2 id="6-遇到的问题"><a href="#6-遇到的问题" class="headerlink" title="6. 遇到的问题"></a>6. 遇到的问题</h2><blockquote><p>a. 兼容问题</p></blockquote><p>pwa的兼容性是比较差的，几乎每个api都有兼容问题，需要对不同的设备做适配。这些兼容问题很多是查看线上统计数据后才发现的</p><blockquote><p>b. 数据统计</p></blockquote><p>为了统计pwa转化效果，我们需要识别用户访问的是web页面还是桌面的pwa，然而，我们只能统计到桌面图标打开的用户和链接拉活的pwa用户，对于push拉活，第三方app拉活的场景，我们是无法识别的。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-什么是PWA？&quot;&gt;&lt;a href=&quot;#1-什么是PWA？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是PWA？&quot;&gt;&lt;/a&gt;1. 什么是PWA？&lt;/h2&gt;&lt;p&gt;PWA（Progressive web apps，渐进式 Web 应用）运用现代的 Web API 以及传统的渐进式增强策略来创建跨平台 Web 应用程序。&lt;/p&gt;</summary>
    
    
    
    <category term="PWA" scheme="http://example.com/categories/PWA/"/>
    
    
    <category term="PWA" scheme="http://example.com/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>Libuv线程池如何提高nodejs性能</title>
    <link href="http://example.com/2021/01/08/NodeJs/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Libuv%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98NodeJs%E6%80%A7%E8%83%BD/"/>
    <id>http://example.com/2021/01/08/NodeJs/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Libuv%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98NodeJs%E6%80%A7%E8%83%BD/</id>
    <published>2021-01-08T17:35:42.000Z</published>
    <updated>2021-01-15T01:30:52.174Z</updated>
    
    <content type="html"><![CDATA[<p>如何提高NodeJS性能？下面我们来介绍一种方式，一起看看吧</p><a id="more"></a><h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><a href="https://hackernoon.com/how-libuv-thread-pool-can-boost-your-node-js-performance-bel3tyf">原文链接</a></h3><h3 id="Libuv线程池"><a href="#Libuv线程池" class="headerlink" title="Libuv线程池"></a>Libuv线程池</h3><p>Libuv启动一个包含4个线程的线程池，用于将同步操作卸载到该线程池。为此，Libuv确保同步任务不会不必要地阻止我们的应用程序。</p><p>在这里，我们将利用设置来更好地适应我们的计算机或将应用程序部署到的虚拟机的规格。这是因为我们被允许将4个线程的默认值更改为最多1024个线程。我们通过设置UV_THREADPOOL_SIZE Node变量来实现。</p><p>物理与逻辑CPU内核</p><p>为了更好地了解将UV_THREADPOOL_SIZE设置为什么，我们首先需要了解我们的计算机正在运行多少个逻辑核心。如果以我的MacBook Pro为例，它运行的是6个物理CPU内核（英特尔）。</p><p>但是，这些内核具有超线程，这意味着每个内核可以同时运行2个操作。因此，我们将具有超线程的1个物理核心视为2个逻辑核心。就我而言，我的MacBook Pro运行12个逻辑核心。</p><h3 id="如何提高Node-JS性能"><a href="#如何提高Node-JS性能" class="headerlink" title="如何提高Node JS性能"></a>如何提高Node JS性能</h3><p>建议将 <code>UV_THREADPOOL_SIZE</code> 设置为计算机正在运行的逻辑核心数。就我而言，我将线程池大小设置为12。</p><p>将大小设置为除硬件正在运行的逻辑内核之外的任何值都没有意义，实际上可能会导致性能降低。</p><h3 id="如何检查逻辑核心"><a href="#如何检查逻辑核心" class="headerlink" title="如何检查逻辑核心"></a>如何检查逻辑核心</h3><p>部署时，最后要做的是手动设置UV_THREADPOOL_SIZE，因为您的应用程序可能在具有不同机器规格的多个环境中运行。因此，我们需要一种在相关环境中启动应用程序后动态设置线程池大小的方法。</p><p>好消息是，这很简单，但必须谨慎对待。为此，请将以下代码添加到Node应用程序的根JS文件的顶部：</p><pre><code class="JavaScript">const OS = require('os')process.env.UV_THREADPOOL_SIZE = OS.cpus().length</code></pre><p>该OS模块是原产于节点JS。它具有一个函数cpus（），该函数返回计算机正在运行的逻辑内核的总数。很好的是，如果您的CPU内核没有超线程，则此函数将只返回物理cpu内核的数量，这是完美的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如何提高NodeJS性能？下面我们来介绍一种方式，一起看看吧&lt;/p&gt;</summary>
    
    
    
    <category term="nodejs" scheme="http://example.com/categories/nodejs/"/>
    
    
    <category term="nodejs" scheme="http://example.com/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Nginx配置小结</title>
    <link href="http://example.com/2021/01/08/nginx/Nginx%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93/"/>
    <id>http://example.com/2021/01/08/nginx/Nginx%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93/</id>
    <published>2021-01-08T17:33:59.000Z</published>
    <updated>2021-01-15T01:30:52.178Z</updated>
    
    <content type="html"><![CDATA[<p>nginx配置有哪些变量？匹配规则又有哪些？让我们一起看看吧</p><a id="more"></a><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><pre><code class="NGINX">$args ： 这个变量等于请求行中的参数，同$query_string$content_length ： 请求头中的Content-length字段$content_type ： 请求头中的Content-Type字段$document_root ： 当前请求在root指令中指定的值$host ： 请求主机头字段，否则为服务器名称$http_user_agent ： 客户端agent信息$http_cookie ： 客户端cookie信息$limit_rate ： 这个变量可以限制连接速率$request_method ： 客户端请求的动作，通常为GET或POST$remote_addr ： 客户端的IP地址$remote_port ： 客户端的端口$remote_user ： 已经经过Auth Basic Module验证的用户名$request_filename ： 当前请求的文件路径，由root或alias指令与URI请求生成$scheme ： HTTP方法（如http，https）$server_protocol ： 请求使用的协议，通常是HTTP/1.0或HTTP/1.1$server_addr ： 服务器地址，在完成一次系统调用后可以确定这个值$server_name ： 服务器名称$server_port ： 请求到达服务器的端口号$request_uri ： 包含请求参数的原始URI，不包含主机名，如/foo/bar.php?arg=baz$uri ： 不带请求参数的当前URI，$uri不包含主机名，如/foo/bar.html$document_uri ： 与$uri相同</code></pre><p>假设请求为<a href="http://www.qq.com:8080/a/b/c.php%EF%BC%8C%E5%88%99">http://www.qq.com:8080/a/b/c.php，则</a></p><pre><code class="NGINX">$host：www.qq.com$server_port：8080$request_uri：http://www.qq.com:8080/a/b/c.php$document_uri：/a/b/c.php$document_root：/var/www/html$request_filename：/var/www/html/a/b/c.php</code></pre><h2 id="主机名（server-name）匹配"><a href="#主机名（server-name）匹配" class="headerlink" title="主机名（server_name）匹配"></a>主机名（server_name）匹配</h2><p>从上到下的优先级为从高到低</p><ol><li> 明确的<code>server_name</code>名称，如<code>www.qq.com</code></li><li> 前缀通配符，如<code>*.qq.com</code>或<code>. qq.com</code></li><li> 后缀通配符，如<code>www.qq.*</code></li><li> 正则表达式，如<code>~[a-z]+\.qq\.com</code></li></ol><h2 id="Location查找规则"><a href="#Location查找规则" class="headerlink" title="Location查找规则"></a>Location查找规则</h2><p>从上到下的优先级为从高到低</p><ol><li> 等号类型，精确匹配，如location = / {}</li><li> ^<del>类型，前缀匹配，不支持正则，如location ^</del> /user {}</li><li> <del>和</del>*类型，正则匹配，<del>区分大小写，</del>*不区分大小写，如location ~ ^/user {}</li><li> 常规字符串匹配类型，如location / {}或location /user {}</li></ol><h2 id="Try-files规则"><a href="#Try-files规则" class="headerlink" title="Try_files规则"></a>Try_files规则</h2><p>try_files $uri $uri/ /index.php<br>假设请求为<code>http://www.qq.com/test</code>，则<code>$uri</code>为<code>test</code></p><p>查找<code>/$root/test</code>文件<br>查找<code>/$root/test/</code>目录<br>发起<code>/index.php</code>的内部“子请求”</p><h2 id="Rewrite规则"><a href="#Rewrite规则" class="headerlink" title="Rewrite规则"></a>Rewrite规则</h2><p>rewrite ^/images/(.*).(png|jpg|gif)$ /images?name=$1.$4 last;</p><p>上面的<code>rewrite</code>规则会将文件名改写到参数中</p><ul><li>last : 相当于<code>Apache</code>的[L]标记，表示完成<code>rewrite</code></li><li>break : 停止执行当前虚拟主机的后续<code>rewrite</code>指令集</li><li>redirect : 返回302临时重定向，地址栏会显示跳转后的地址</li><li>permanent : 返回301永久重定向，地址栏会显示跳转后的地址</li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>例子如下</p><pre><code class="NGINX">upstream backend1 {    server backend1.qq.com weight=5;    server 127.0.0.1:8080 max_fails=3 fail_timeout=30s;    server unix:/tmp/backend3 backup;}upstream backend2 {    ip_hash;    server backend1.qq.com;    server backend2.qq.com;    server backend3.qq.com down;    server backend4.qq.com;}server {    location / {        proxy_pass http://backend1;    }    location /api {        proxy_pass http://backend2;    }}</code></pre><h2 id="查看一个实例"><a href="#查看一个实例" class="headerlink" title="查看一个实例"></a>查看一个实例</h2><p>下面是一个 <code>laravel</code>框架<code>Nginx</code>配置的例子，听过这堂课终于了解了下面的原理。</p><pre><code class="NGINX">server {    listen 80 default_server;    listen [::]:80 default_server ipv6only=on;    # 设定网站根目录    root /var/www/laravel/public;    # 网站默认首页    index index.php index.html index.htm;    # 服务器名称，server_domain_or_IP 请替换为自己设置的名称或者 IP 地址    server_name server_domain_or_IP;    # 修改为 Laravel 转发规则，否则PHP无法获取$_GET信息，提示404错误    location / {        try_files $uri $uri/ /index.php?$query_string;    }    # PHP 支持    location ~ \.php$ {        try_files $uri /index.php =404;        fastcgi_split_path_info ^(.+\.php)(/.+)$;        fastcgi_pass unix:/var/run/php5-fpm.sock;        fastcgi_index index.php;        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;        include fastcgi_params;    }}</code></pre><p>我们主要关注两个<code>location</code>，假设地址是<code>http://www.qq.com/user/info</code>，会匹配到如下<code>location</code></p><pre><code class="NGINX">location / {    try_files $uri $uri/ /index.php?$query_string;}</code></pre><p>由于<code>$uri</code>和<code>$uri/</code>是不存在的，所以会走<code>/index.php?$query_string</code>，这时候会发起一个内部“子请求”，“子请求”会重新匹配<code>location</code>，然后匹配到如下<code>location</code></p><pre><code class="NGINX">location ~ \.php$ {    try_files $uri /index.php =404;    fastcgi_split_path_info ^(.+\.php)(/.+)$;    fastcgi_pass unix:/var/run/php5-fpm.sock;    fastcgi_index index.php;    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;    include fastcgi_params;}</code></pre><p>这样请求就会发送到<code>fastcgi</code>去做处理。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;nginx配置有哪些变量？匹配规则又有哪些？让我们一起看看吧&lt;/p&gt;</summary>
    
    
    
    <category term="nginx" scheme="http://example.com/categories/nginx/"/>
    
    
    <category term="nginx" scheme="http://example.com/tags/nginx/"/>
    
    <category term="devops" scheme="http://example.com/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>Nginx代理proxy pass配置去除前缀问题</title>
    <link href="http://example.com/2021/01/08/nginx/Nginx%E4%BB%A3%E7%90%86proxy%20pass%E9%85%8D%E7%BD%AE%E5%8E%BB%E9%99%A4%E5%89%8D%E7%BC%80%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/01/08/nginx/Nginx%E4%BB%A3%E7%90%86proxy%20pass%E9%85%8D%E7%BD%AE%E5%8E%BB%E9%99%A4%E5%89%8D%E7%BC%80%E9%97%AE%E9%A2%98/</id>
    <published>2021-01-08T17:32:38.000Z</published>
    <updated>2021-01-15T01:30:52.178Z</updated>
    
    <content type="html"><![CDATA[<p>设置反向代理的时候，有时候程序会拿不到URL后面的path部分，这是为什么呢？让我们一起来看看吧</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用Nginx做代理的时候，可以简单的直接把请求原封不动的转发给下一个服务。</p><p>比如，访问abc.com/appv2/a/b.html, 要求转发到localhost:8088/appv2/a/b.html</p><p>简单配置如下：</p><pre><code class="nginx">upstream one {  server localhost:8088 weight=5;}server {    listen              80;    server_name         abc.com;    access_log  "pipe:rollback /data/log/nginx/access.log interval=1d baknum=7 maxsize=1G"  main;    location / {        proxy_set_header Host $host;        proxy_set_header  X-Real-IP        $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;        proxy_set_header X-NginX-Proxy true;        proxy_pass http://one;    }}</code></pre><p>即，设置 <code>proxy_pass</code> 即可。请求只会替换域名。</p><p>但很多时候，我们需要根据url的前缀转发到不同的服务。</p><p>比如</p><p>abc.com/user/profile.html 转发到 用户服务localhost:8089/profile.html</p><p>abc.com/order/details.html 转发到 订单服务 localhost:8090/details.html</p><p>即，url的前缀对下游的服务是不需要的，除非下游服务添加context-path, 但很多时候我们并不喜欢加这个。如果Nginx转发的时候，把这个前缀去掉就好了。</p><h3 id="一个种方案是proxy-pass后面加根路径"><a href="#一个种方案是proxy-pass后面加根路径" class="headerlink" title="一个种方案是proxy_pass后面加根路径 / ."></a>一个种方案是proxy_pass后面加根路径 <code>/</code> .</h3><pre><code class="nginx">server {    listen              80;    server_name         abc.com;    access_log  "pipe:rollback /data/log/nginx/access.log interval=1d baknum=7 maxsize=1G"  main;    location ^~/user/ {        proxy_set_header Host $host;        proxy_set_header  X-Real-IP        $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;        proxy_set_header X-NginX-Proxy true;        proxy_pass http://user/;    }    location ^~/order/ {        proxy_set_header Host $host;        proxy_set_header  X-Real-IP        $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;        proxy_set_header X-NginX-Proxy true;        proxy_pass http://order/;    }}</code></pre><p><code>^~/user/</code> 表示匹配前缀是 <code>user</code> 的请求，proxy_pass的结尾有/， 则会把 <code>/user/*</code> 后面的路径直接拼接到后面，即移除user.</p><h3 id="另一种方案是使用-rewrite"><a href="#另一种方案是使用-rewrite" class="headerlink" title="另一种方案是使用 rewrite"></a>另一种方案是使用 <code>rewrite</code></h3><pre><code class="nginx">upstream user {  server localhost:8089 weight=5;}upstream order {  server localhost:8090 weight=5;}server {    listen              80;    server_name         abc.com;    access_log  "pipe:rollback /data/log/nginx/access.log interval=1d baknum=7 maxsize=1G"  main;    location ^~/user/ {        proxy_set_header Host $host;        proxy_set_header  X-Real-IP        $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;        proxy_set_header X-NginX-Proxy true;        rewrite ^/user/(.*)$ /$1 break;        proxy_pass http://user;    }    location ^~/order/ {        proxy_set_header Host $host;        proxy_set_header  X-Real-IP        $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;        proxy_set_header X-NginX-Proxy true;        rewrite ^/order/(.*)$ /$1 break;        proxy_pass http://order;    }}</code></pre><p>注意到proxy_pass结尾没有 <code>/</code> , <code>rewrite</code> 重写了url。</p><p>关于rewrite</p><pre><code class="nginx">syntax: rewrite regex replacement [flag]Default: —Context: server, location, if</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;设置反向代理的时候，有时候程序会拿不到URL后面的path部分，这是为什么呢？让我们一起来看看吧&lt;/p&gt;</summary>
    
    
    
    <category term="nginx" scheme="http://example.com/categories/nginx/"/>
    
    
    <category term="nginx" scheme="http://example.com/tags/nginx/"/>
    
    <category term="devops" scheme="http://example.com/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>Nginx location匹配规则</title>
    <link href="http://example.com/2021/01/08/nginx/Nginx%20location%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/"/>
    <id>http://example.com/2021/01/08/nginx/Nginx%20location%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/</id>
    <published>2021-01-08T17:31:08.000Z</published>
    <updated>2021-01-15T01:30:52.177Z</updated>
    
    <content type="html"><![CDATA[<p>location的匹配规则有哪些呢？让我们来一起看看吧</p><a id="more"></a><h3 id="url匹配规则"><a href="#url匹配规则" class="headerlink" title="url匹配规则"></a>url匹配规则</h3><pre><code class="nginx">location [=|~|~*|^~|@] /uri/ {  ...} </code></pre><ul><li><code>=</code> : 表示精确匹配后面的url</li><li><code>~</code> : 表示正则匹配，但是区分大小写</li><li><code>~*</code> : 正则匹配，不区分大小写</li><li><code>^~</code> : 表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录</li><li><code>@</code> : “@” 定义一个命名的 location，使用在内部定向时，例如 error_page</li></ul><p>上述匹配规则的优先匹配顺序：</p><ol><li> = 前缀的指令严格匹配这个查询。如果找到，停止搜索；</li><li> 所有剩下的常规字符串，最长的匹配。如果这个匹配使用 ^~ 前缀，搜索停止；</li><li> 正则表达式，在配置文件中定义的顺序；</li><li> 如果第 3 条规则产生匹配的话，结果被使用。否则，使用第 2 条规则的结果。</li></ol><h3 id="目标地址处理规则"><a href="#目标地址处理规则" class="headerlink" title="目标地址处理规则"></a>目标地址处理规则</h3><p>匹配到uri后，接下来要代理到目标服务地址。</p><pre><code class="NGINX">upstream api_server {  server 10.0.101.62:8081;  server 10.0.101.61:8082;}location / {        rewrite ^(.*)$ http://10.0.101.62:8000/my-module$1 break;}location ^~ /my-module/ {    root   /data/my-module/dist;    rewrite ^/my-module/(.*)$  /$1 break;    index  index.html index.htm;}location /my-module/api {    proxy_pass  http://api_server;    proxy_set_header Host $host;    proxy_set_header  X-Real-IP        $remote_addr;    proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;    proxy_set_header  your-custome-header    "myHeader";    proxy_set_header X-NginX-Proxy true;}</code></pre><p>上述配置，默认访问 <code>/</code> 会重定向到 <code>/my-module</code> , 然后直接返回 <code>/data/my-module/dist</code> 下的html等静态文件。</p><p>访问 <code>/my-module/api</code> 则会代理到我们api服务器地址，是一个默认的round-robin负载均衡配置。</p><p>下面是访问localhost的日志, 访问首页一共进行了2次重定向。</p><pre><code class="PHP">Request URL: http://10.0.101.62:8000/Request Method: GETStatus Code: 302 Moved TemporarilyLocation: http://10.0.101.62:8000/flash/Request URL: http://10.0.101.62:8000/flash/Request Method: GETStatus Code: 302 Moved TemporarilyLocation: http://10.0.101.62:8000/flash/index.htmlRequest URL: http://10.0.101.62:8000/flash/index.htmlRequest Method: GETStatus Code: 304 Not Modified</code></pre><h3 id="alias与root的区别"><a href="#alias与root的区别" class="headerlink" title="alias与root的区别"></a>alias与root的区别</h3><blockquote><p>root 实际访问文件路径会拼接URL中的路径</p><p>alias 实际访问文件路径不会拼接URL中的路径</p></blockquote><p>示例如下：</p><pre><code class="NGINX">location ^~ /sta/ {     alias /usr/local/nginx/html/static/;  }</code></pre><p>请求：<code>http://test.com/sta/sta1.html</code><br>实际访问：<code>/usr/local/nginx/html/static/sta1.html</code> 文件</p><pre><code class="NGINX">location ^~ /tea/ {     root /usr/local/nginx/html/;  }</code></pre><p>请求： <code>http://test.com/tea/tea1.html</code></p><p>实际访问： <code>/usr/local/nginx/html/tea/tea1.html</code> 文件</p><p>显然，第二次重定向是不需要的，本意是访问/flash/的时候，直接访问对应目录下的html静态文件。 但因为root拼接flash导致找不到对应文件，要重写url，去掉flash这个模块前缀，使用了 <code>rewrite</code> , 而 <code>rewrite</code> 会返回302重定向。</p><p>接下来，我们修改 <code>root</code> 为 <code>alias</code></p><pre><code class="NGINX">location ^~ /flash/ {    alias   /data/flash/dist/;    #rewrite ^/flash/(.*)$  /$1 break;    index  index.html index.htm;}</code></pre><p>直接重定向1次后返回html</p><pre><code class="PHP">Request URL: http://10.0.101.62:8000/Request Method: GETStatus Code: 302 Moved TemporarilyRequest URL: http://10.0.101.62:8000/flash/Request Method: GETStatus Code: 200 OK (from disk cache)</code></pre><h3 id="last-和-break关键字的区别"><a href="#last-和-break关键字的区别" class="headerlink" title="last 和 break关键字的区别"></a>last 和 break关键字的区别</h3><p>只用到了break，即匹配到此处后不会继续跳。</p><h3 id="permanent-和-redirect关键字的区别"><a href="#permanent-和-redirect关键字的区别" class="headerlink" title="permanent 和 redirect关键字的区别"></a>permanent 和 redirect关键字的区别</h3><ul><li>rewrite … permanent 永久性重定向，请求日志中的状态码为301</li><li>rewrite … redirect 临时重定向，请求日志中的状态码为302</li></ul><p>我们常用的 <code>80</code> 端口转 <code>443</code> ，即http转https的一种配置方案为</p><pre><code class="NGINX">server {    listen 80;    server_name demo.com;    rewrite ^(.*)$ https://${server_name}$1 permanent; }</code></pre><p>会返回301永久重定向到对应的https：</p><pre><code class="PHP">Request URL: http://demo.com/flash/index.htmlRequest Method: GETStatus Code: 301 Moved PermanentlyLocation: https://demo/flash/index.html</code></pre><h3 id="一些使用场景"><a href="#一些使用场景" class="headerlink" title="一些使用场景"></a>一些使用场景</h3><p>上述demo差不多就是我平时用的前后端分离的代理配置方案。下面是一些遇到过的场景。</p><p>配置一个静态文件下载服务，我们下面软件会经常看到index /的页面。</p><pre><code class="NGINX">server {        listen       8888;        #端口        server_name  _;   #服务名        charset utf-8,gbk;        root    /data/download;  #显示的根索引目录        autoindex on;             #开启索引功能        autoindex_exact_size off; # 关闭计算文件确切大小（单位bytes），只显示大概大小（单位kb、mb、gb）        autoindex_localtime on;   # 显示本机时间而非 GMT 时间}</code></pre><p>配置http重定向到https</p><pre><code class="NGINX">server {    listen 80;    server_name demo.com;    rewrite ^(.*)$ https://${server_name}$1 permanent; }server {    listen       443;    server_name  demo.com;    charset utf-8;    location / {       alias   /data/web;       index  index.html index.htm;    }}</code></pre><p>配置静态前端页面</p><pre><code class="NGINX">location / {    alias   /data/web;    index  index.html index.htm;}</code></pre><p>配置反向代理, 比如我们访问<a href="http://demo.com/api/aaa/bbb%EF%BC%8C%E6%88%91%E4%BB%AC%E6%83%B3%E8%A6%81%E4%BB%A3%E7%90%86%E5%88%B0http://api.com/api/aaa/bbb">http://demo.com/api/aaa/bbb，我们想要代理到http://api.com/api/aaa/bbb</a>, 只切换了域名，uri相同。</p><pre><code class="NGINX">upstream api_server {  server 10.0.101.62:8081;  server 10.0.101.61:8082;}location /api {    proxy_pass  http://api_server;    proxy_set_header Host $host;    proxy_set_header  X-Real-IP        $remote_addr;    proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;    proxy_set_header  your-custome-header    "myHeader";    proxy_set_header X-NginX-Proxy true;}</code></pre><p>配置反向代理时，移除前缀。比如我们的服务<a href="http://demo.com/users/aaa/bbb">http://demo.com/users/aaa/bbb</a>, 我们想要代理到<a href="http://users.com/aaa/bbb%EF%BC%8C%E5%8D%B3%E5%88%87%E6%8D%A2%E5%9F%9F%E5%90%8D%E7%9A%84%E5%90%8C%E6%97%B6%EF%BC%8C%E5%8E%BB%E6%8E%89users%E5%89%8D%E7%BC%80%E3%80%82%E5%8C%BA%E5%88%AB%E6%98%AFproxy_pass">http://users.com/aaa/bbb，即切换域名的同时，去掉users前缀。区别是proxy_pass</a> 结尾的 <code>/</code> .</p><pre><code class="NGINX">location ^~/users/ {    proxy_set_header Host $host;    proxy_set_header  X-Real-IP        $remote_addr;    proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;    proxy_set_header X-NginX-Proxy true;    proxy_pass http://users.com/;}</code></pre><p>反向代理时，想要自定义修改uri。使用rewrite正则修改。</p><pre><code class="NGINX"># 修改uri，去掉了flash的前缀，$1表示正则匹配到的字符串内容。location ^~ /flash/ {    root   /data/flash/dist/;    rewrite ^/flash/(.*)$  /$1 break;    index  index.html index.htm;}# 修改uri, 重新代理到新的地址location ^~/order/ {    proxy_set_header Host $host;    proxy_set_header  X-Real-IP        $remote_addr;    proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;    proxy_set_header X-NginX-Proxy true;    rewrite ^/order/(.*)$ /$1 break;    proxy_pass http://order;}</code></pre><p>代理跨域, 比如bing每日一图，不支持我们ajax获取图片地址，我们可以自己写一个支持的接口。</p><p><a href="http://101.200.218.760/proxy/bing/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1">http://101.200.218.760/proxy/bing/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1</a></p><p>代理对象为：</p><p><a href="https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1">https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1</a></p><pre><code class="NGINX">location ^~/proxy/bing/ {    add_header 'Access-Control-Allow-Origin' 'http://localhost:8088';    add_header 'Cache-Control' 'public, max-age=604800';    add_header 'Access-Control-Allow-Credentials' 'true';    add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';    rewrite ^/proxy/bing/(.*)$ /$1 break;    proxy_pass https://cn.bing.com/; }</code></pre><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><ul><li><a href="https://www.cnblogs.com/duhuo/p/8323812.html">https://www.cnblogs.com/duhuo/p/8323812.html</a></li><li><a href="https://www.cnblogs.com/woshimrf/p/nginx-proxy-rewrite-url.html">https://www.cnblogs.com/woshimrf/p/nginx-proxy-rewrite-url.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;location的匹配规则有哪些呢？让我们来一起看看吧&lt;/p&gt;</summary>
    
    
    
    <category term="nginx" scheme="http://example.com/categories/nginx/"/>
    
    
    <category term="nginx" scheme="http://example.com/tags/nginx/"/>
    
    <category term="devops" scheme="http://example.com/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>Nginx的负载均衡实例，均衡策略，session保持方案</title>
    <link href="http://example.com/2021/01/08/nginx/Nginx%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E4%BE%8B%EF%BC%8C%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%EF%BC%8Csession%E4%BF%9D%E6%8C%81%E6%96%B9%E6%A1%88/"/>
    <id>http://example.com/2021/01/08/nginx/Nginx%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E4%BE%8B%EF%BC%8C%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%EF%BC%8Csession%E4%BF%9D%E6%8C%81%E6%96%B9%E6%A1%88/</id>
    <published>2021-01-08T17:29:30.000Z</published>
    <updated>2021-01-15T01:30:52.178Z</updated>
    
    <content type="html"><![CDATA[<p>负载均衡定义：代理服务器将接收的请求均衡的分发到各服务器中<br>负载均衡作用：主要解决网络拥塞问题，提高服务器响应速度，服务就近提供，达到更好的访问质量，减少后台服务器并发压力。</p><a id="more"></a><h2 id="负载均衡的配置实例"><a href="#负载均衡的配置实例" class="headerlink" title="负载均衡的配置实例"></a>负载均衡的配置实例</h2><p>可访问的服务有两个：</p><ul><li><a href="http://172.16.25.44:8080/rsbi">http://172.16.25.44:8080/rsbi</a></li><li><a href="http://192.168.1.138:8080/rsbi">http://192.168.1.138:8080/rsbi</a></li></ul><p>nginx.conf完整配置如下：</p><pre><code class="NGINX">#user &nbsp;nobody;worker_processes &nbsp;1;events {&nbsp; &nbsp; worker_connections &nbsp;1024;}http {&nbsp; &nbsp; &nbsp; &nbsp; include &nbsp; &nbsp; &nbsp; mime.types;&nbsp; &nbsp; &nbsp; &nbsp; default_type &nbsp;application/octet-stream;&nbsp; &nbsp; &nbsp; &nbsp; sendfile &nbsp; &nbsp; &nbsp; &nbsp;on;&nbsp; &nbsp; &nbsp; &nbsp; keepalive_timeout &nbsp;65;&nbsp; &nbsp; &nbsp; &nbsp; #此处定义常量xd-projec&nbsp; &nbsp; &nbsp; &nbsp; upstream xd-project{&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #注意 此处的server只能是ip:port 不能有任何多余的http或者项目名称&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; server 172.16.25.44:8080;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; server &nbsp;192.168.1.138:8080;&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; server{&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; listen 8081;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; server_name &nbsp;localhost;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; location / {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #此处使用上面定义常量xd-projec&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proxy_pass http://xd-project;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; location ~ .* {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proxy_pass http://xd-project;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proxy_set_header Host $http_host;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proxy_set_header X-Real-IP $remote_addr;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error_page &nbsp; 500 502 503 504 &nbsp;/50x.html;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; location = /50x.html {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root &nbsp; html;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; include servers/*;}</code></pre><p>说明：上面的均衡方式是轮询，即nginx的默认负载均衡方式</p><h2 id="nginx的负载均衡策略及其适用场景"><a href="#nginx的负载均衡策略及其适用场景" class="headerlink" title="nginx的负载均衡策略及其适用场景"></a>nginx的负载均衡策略及其适用场景</h2><h3 id="1-轮询（默认）"><a href="#1-轮询（默认）" class="headerlink" title="1.  轮询（默认）"></a>1.  轮询（默认）</h3><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。主要用于大量请求场景中环节服务端的压力。<br>配置实例：</p><pre><code class="NGINX">upstream xd-project{        #注意 此处的server只能是ip:port 不能有任何多余的http或者项目名称        server 172.16.25.44:8080;        server  192.168.1.138:8080;} </code></pre><h3 id="2-weight"><a href="#2-weight" class="headerlink" title="2.  weight"></a>2.  weight</h3><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。<br>配置实例</p><pre><code class="NGINX">upstream xd-project{  #注意 此处的server只能是ip:port 不能有任何多余的http或者项目名称  server 172.16.25.44:8080 weight=1;  server  192.168.1.138:8080 weight=2;}</code></pre><p>说明：假设有三次访问，因为weight的值，会有一次落在172.16.25.44:8080，两次落在192.168.1.138:8080<br>应用场景：后端服务器性能不均的情况</p><h3 id="3-ip-hash"><a href="#3-ip-hash" class="headerlink" title="3.  ip_hash"></a>3.  ip_hash</h3><p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。<br>配置实例：</p><pre><code class="NGINX">upstream xd-project{        ip_hash;        server 172.16.25.44:8080;        server  192.168.1.138:8080;}</code></pre><p>应用场景：当你服务端的一个特定url路径会被同一个用户连续访问时，如果负载均衡策略还是轮询的话，那该用户的多次访问会被打到各台服务器上，这显然并不高效（会建立多次http链接等问题）。甚至考虑一种极端情况，用户需要分片上传文件到服务器下，然后再由服务器将分片合并，这时如果用户的请求到达了不同的服务器，那么分片将存储于不同的服务器目录中，导致无法将分片合并。</p><h3 id="4-url-hash（第三方）"><a href="#4-url-hash（第三方）" class="headerlink" title="4.  url_hash（第三方）"></a>4.  url_hash（第三方）</h3><p>每个请求按访问url的hash结果分配，这样每个url请求固定访问一个后端服务器。<br>配置实例：</p><pre><code class="NGINX">upstream xd-project{        hash $request_uri;        server 172.16.25.44:8080;        server  192.168.1.138:8080;}</code></pre><p>应用场景：<br>一般来讲，要用到urlhash，是要配合缓存命中来使用。举一个我遇到的实例：有一个服务器集群A，需要对外提供文件下载，由于文件上传量巨大，没法存储到服务器磁盘中，所以用到了第三方云存储来做文件存储。服务器集群A收到客户端请求之后，需要从云存储中下载文件然后返回，为了省去不必要的网络带宽和下载耗时，在服务器集群A上做了一层临时缓存（缓存一个月）。由于是服务器集群，所以同一个资源多次请求，可能会到达不同的服务器上，导致不必要的多次下载，缓存命中率不高，以及一些资源时间的浪费。在此类场景下，为了使得缓存命中率提高，很适合使用url_hash策略，同一个url（也就是同一个资源请求）会到达同一台机器，一旦缓存住了资源，再此收到请求，就可以从缓存中读取，既减少了带宽，也减少的下载时间。</p><h3 id="5-fair（第三方）"><a href="#5-fair（第三方）" class="headerlink" title="5.  fair（第三方）"></a>5.  fair（第三方）</h3><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><h2 id="负载均衡session会话保持方法"><a href="#负载均衡session会话保持方法" class="headerlink" title="负载均衡session会话保持方法"></a>负载均衡session会话保持方法</h2><p>负载均衡时，为了保证同一用户session会被分配到同一台服务器上，可以使用以下方法：</p><ol><li> 使用cookie</li></ol><p>将用户的session存入cookie里，当用户分配到不同的服务器时，先判断服务器是否存在该用户的session，如果没有就先把cookie里面的sessoin存入该服务器，实现session会话保持。缺点是存入cookie有安全隐患。</p><ol start="2"><li> 使用缓存</li></ol><p>利用memcache，redis等缓存分布式的特点，可以将所有服务器产生的session存入同一台服务器的缓存中，实现session共享。这样安全性比较高，而且从内存中读取session比从文件中读取速度快。</p><ol start="3"><li> 使用ip_hash</li></ol><p>如果是nginx服务器的负载均衡，可以在upstream里设置ip_hash，每个请求按访问ip的hash结果分配，映射到固定某一台的服务器。缺点是可能导致负载不均衡。</p><h2 id="upstream中的down和backup"><a href="#upstream中的down和backup" class="headerlink" title="upstream中的down和backup"></a>upstream中的down和backup</h2><p><img src="/My-Blogs/images/Nginx%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E4%BE%8B%EF%BC%8C%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%EF%BC%8Csession%E4%BF%9D%E6%8C%81%E6%96%B9%E6%A1%88-01.png" alt="alt"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;负载均衡定义：代理服务器将接收的请求均衡的分发到各服务器中&lt;br&gt;负载均衡作用：主要解决网络拥塞问题，提高服务器响应速度，服务就近提供，达到更好的访问质量，减少后台服务器并发压力。&lt;/p&gt;</summary>
    
    
    
    <category term="nginx" scheme="http://example.com/categories/nginx/"/>
    
    
    <category term="nginx" scheme="http://example.com/tags/nginx/"/>
    
    <category term="devops" scheme="http://example.com/tags/devops/"/>
    
  </entry>
  
</feed>
