<!DOCTYPE html><html class="appearance-auto" lang="zh-cn"><head><meta charset="UTF-8"><title>算法篇-例题</title><meta name="description" content="完善自己"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><link rel="icon"><link rel="stylesheet" href="/My-Blogs/style/bulma.css"><link rel="stylesheet" href="/My-Blogs/style/base.css"><link rel="stylesheet" href="/My-Blogs/style/helper.css"><script src="/My-Blogs/js/main.js"></script><link rel="stylesheet" href="/My-Blogs/style/post.css"><link rel="stylesheet" href="/My-Blogs/style/highlight-theme-light.css"><script src="/My-Blogs/jslib/highlight.pack.js"></script><meta name="generator" content="Hexo 5.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/My-Blogs/atom.xml" title="John Doe's blog" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-space-between is-hidden-mobile"><section class="is-hidden-mobile"><h2><a href="/My-Blogs/">Lucas's blog</a></h2></section><h3 class="is-hidden-mobile"></h3><aside><h3 class="is-inline-block"><a href="/My-Blogs/">Home</a></h3><h3 class="is-inline-block"><a href="/My-Blogs/about">About</a></h3><h3 class="is-inline-block"><a href="/My-Blogs/archives">Archives</a></h3></aside></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/My-Blogs/">Home</a></h3><h3 class="is-inline-block"><a href="/My-Blogs/about">About</a></h3><h3 class="is-inline-block"><a href="/My-Blogs/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">JavaScript 算法与数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%B8%BB%E9%A2%98"><span class="toc-text">算法主题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F"><span class="toc-text">算法范式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%9C%AC%E4%BB%93%E5%BA%93"><span class="toc-text">如何使用本仓库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E7%94%A8%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-text">有用的信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-text">引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7O%E7%AC%A6%E5%8F%B7"><span class="toc-text">大O符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7"><span class="toc-text">数据结构操作的复杂性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7"><span class="toc-text">数组排序算法的复杂性</span></a></li></ol></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/My-Blogs/tags/JavaScript"><i class="tag post-item-tag">JavaScript</i></a><a href="/My-Blogs/tags/%E7%AE%97%E6%B3%95"><i class="tag post-item-tag">算法</i></a></header><h1 class="mt-0 mb-1 is-family-serif">算法篇-例题</h1><time class="has-text-grey" datetime="2021-12-22T14:00:26.000Z">2021-12-22</time><article class="mt-2 post-content"><a id="more"></a>

<h1 id="JavaScript-算法与数据结构"><a href="#JavaScript-算法与数据结构" class="headerlink" title="JavaScript 算法与数据结构"></a>JavaScript 算法与数据结构</h1><p>本仓库包含了多种基于 JavaScript 的算法与数据结构。</p>
<p><em>注意：这个项目仅用于学习和研究，<strong>不是</strong>用于生产环境。</em></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据结构是在计算机中组织和存储数据的一种特殊方式，使得数据可以高效地被访问和修改。更确切地说，数据结构是数据值的集合，表示数据之间的关系，也包括了作用在数据上的函数或操作。</p>
<p><code>B</code> - 初学者， <code>A</code> - 进阶</p>
<ul>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/linked-list/README.zh-CN.md">链表</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/doubly-linked-list/README.zh-CN.md">双向链表</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/queue/README.zh-CN.md">队列</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/stack/README.zh-CN.md">栈</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/hash-table/README.zh-CN.md">哈希表(散列)</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/heap/README.zh-CN.md">堆</a> - 最大堆 &amp; 最小堆</li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/priority-queue/README.zh-CN.md">优先队列</a></li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/trie/README.zh-CN.md">字典树</a></li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/tree/README.zh-CN.md">树</a><ul>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/tree/binary-search-tree">二叉查找树</a></li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/tree/avl-tree">AVL 树</a></li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/tree/red-black-tree">红黑树</a></li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/tree/segment-tree">线段树</a> - 使用 <code>最小/最大/总和</code> 范围查询示例</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/tree/fenwick-tree">树状数组</a> (二叉索引树)</li>
</ul>
</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/graph/README.zh-CN.md">图</a> (有向图与无向图)</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/disjoint-set">并查集</a></li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/bloom-filter">布隆过滤器</a></li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法是如何解决一类问题的明确规范。算法是一组精确定义操作序列的规则。</p>
<p><code>B</code> - 初学者， <code>A</code> - 进阶</p>
<h3 id="算法主题"><a href="#算法主题" class="headerlink" title="算法主题"></a>算法主题</h3><ul>
<li><strong>数学</strong><ul>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/bits">位运算</a> - set/get/update/clear 位、乘以/除以二进制位 、变负等</li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/factorial/README.zh-CN.md">阶乘</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/fibonacci">斐波那契数</a> - <code>经典</code> 和 <code>闭式</code> 版本</li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/primality-test">素数检测</a> (排除法)</li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/euclidean-algorithm">欧几里得算法</a> - 计算最大公约数 (GCD)</li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/least-common-multiple">最小公倍数</a> (LCM)</li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/sieve-of-eratosthenes">素数筛</a> - 查找任意给定范围内的所有素数</li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/is-power-of-two">判断 2 次方数</a> - 检查数字是否为 2 的幂 (原生和按位算法)</li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/pascal-triangle">杨辉三角形</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/complex-number">复数</a> - 复数及其基本运算</li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/radian">弧度和角</a> - 弧度与角的相互转换</li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/fast-powering">快速算次方</a></li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/integer-partition">整数拆分</a></li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/liu-hui">割圆术</a> - 基于 N-gons 的近似 π 计算</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/fourier-transform">离散傅里叶变换</a> - 把时间信号解析成构成它的频率</li>
</ul>
</li>
<li><strong>集合</strong><ul>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/cartesian-product">笛卡尔积</a> - 多集合结果</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/fisher-yates">洗牌算法</a> - 随机置换有限序列</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/power-set">幂集</a> - 该集合的所有子集</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/permutations">排列</a> (有/无重复)</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/combinations">组合</a> (有/无重复)</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/longest-common-subsequence">最长公共子序列</a> (LCS)</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/longest-increasing-subsequence">最长递增子序列</a></li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/shortest-common-supersequence">最短公共父序列</a> (SCS)</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/knapsack-problem">背包问题</a> - <code>0/1</code> 和 <code>无边界</code> 问题</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/maximum-subarray">最大子数列问题</a> - <code>BF 算法</code> 和 <code>动态规划</code></li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/combination-sum">组合求和</a> - 查找形成特定总和的所有组合</li>
</ul>
</li>
<li><strong>字符串</strong><ul>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/hamming-distance">汉明距离</a> - 符号不同的位置数</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/levenshtein-distance">莱温斯坦距离</a> - 两个序列之间的最小编辑距离</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/knuth-morris-pratt">Knuth–Morris–Pratt 算法</a> KMP 算法 - 子串搜索 (模式匹配)</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/z-algorithm">字符串快速查找</a> - 子串搜索 (模式匹配)</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/rabin-karp">Rabin Karp 算法</a> - 子串搜索</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/longest-common-substring">最长公共子串</a></li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/regular-expression-matching">正则表达式匹配</a></li>
</ul>
</li>
<li><strong>搜索</strong><ul>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/search/linear-search">线性搜索</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/search/jump-search">跳转搜索/块搜索</a> - 搜索有序数组</li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/search/binary-search">二分查找</a> - 搜索有序数组</li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/search/interpolation-search">插值搜索</a> - 搜索均匀分布的有序数组</li>
</ul>
</li>
<li><strong>排序</strong><ul>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/bubble-sort">冒泡排序</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/selection-sort">选择排序</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/insertion-sort">插入排序</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/heap-sort">堆排序</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/merge-sort">归并排序</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/quick-sort">快速排序</a> - in-place (原地) 和 non-in-place 版本</li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/shell-sort">希尔排序</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/counting-sort">计数排序</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/radix-sort">基数排序</a></li>
</ul>
</li>
<li><strong>链表</strong><ul>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/linked-list/traversal">正向遍历</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/linked-list/reverse-traversal">反向遍历</a></li>
</ul>
</li>
<li><strong>树</strong><ul>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/tree/depth-first-search">深度优先搜索</a> (DFS)</li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/tree/breadth-first-search">广度优先搜索</a> (BFS)</li>
</ul>
</li>
<li><strong>图</strong><ul>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/depth-first-search">深度优先搜索</a> (DFS)</li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/breadth-first-search">广度优先搜索</a> (BFS)</li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/kruskal">克鲁斯克尔演算法</a> - 寻找加权无向图的最小生成树 (MST)</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/dijkstra">戴克斯特拉算法</a> - 找到图中所有顶点的最短路径</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/bellman-ford">贝尔曼-福特算法</a> - 找到图中所有顶点的最短路径</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/floyd-warshall">弗洛伊德算法</a> - 找到所有顶点对 之间的最短路径</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/detect-cycle">判圈算法</a> - 对于有向图和无向图 (基于 DFS 和不相交集的版本)</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/prim">普林演算法</a> - 寻找加权无向图的最小生成树 (MST)</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/topological-sorting">拓扑排序</a> - DFS 方法</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/articulation-points">关节点</a> - Tarjan 算法 (基于 DFS)</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/bridges">桥</a> - 基于 DFS 的算法</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/eulerian-path">欧拉回径与一笔画问题</a> - Fleury 的算法 - 一次访问每个边</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/hamiltonian-cycle">哈密顿图</a> - 恰好访问每个顶点一次</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/strongly-connected-components">强连通分量</a> - Kosaraju 算法</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/travelling-salesman">旅行推销员问题</a> - 尽可能以最短的路线访问每个城市并返回原始城市</li>
</ul>
</li>
<li><strong>加密</strong><ul>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/cryptography/polynomial-hash">多项式 hash</a> - 基于多项式的 rolling hash 函数</li>
</ul>
</li>
<li><strong>机器学习</strong><ul>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/nano-neuron">NanoNeuron</a> -7个简单的JS函数，说明机器如何实际学习（向前/向后传播）</li>
</ul>
</li>
<li><strong>未分类</strong><ul>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/hanoi-tower">汉诺塔</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/square-matrix-rotation">旋转矩阵</a> - 原地算法</li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/jump-game">跳跃游戏</a> - 回溯,、动态编程 (自上而下+自下而上) 和贪婪的例子</li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/unique-paths">独特(唯一) 路径</a> - 回溯、动态编程和基于 Pascal 三角形的例子</li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/rain-terraces">雨水收集</a> - 诱捕雨水问题 (动态编程和暴力版本)</li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/recursive-staircase">递归楼梯</a> - 计算有共有多少种方法可以到达顶层 (4 种解题方案)</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/n-queens">八皇后问题</a></li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/knight-tour">骑士巡逻</a></li>
</ul>
</li>
</ul>
<h3 id="算法范式"><a href="#算法范式" class="headerlink" title="算法范式"></a>算法范式</h3><p>算法范式是一种通用方法，基于一类算法的设计。这是比算法更高的抽象，就像算法是比计算机程序更高的抽象。</p>
<ul>
<li><strong>BF 算法</strong> - <code>查找/搜索</code> 所有可能性并选择最佳解决方案<ul>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/search/linear-search">线性搜索</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/rain-terraces">雨水收集</a> - 诱导雨水问题</li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/recursive-staircase">递归楼梯</a> - 计算有共有多少种方法可以到达顶层 (4 种解题方案)</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/maximum-subarray">最大子数列</a></li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/travelling-salesman">旅行推销员问题</a> - 尽可能以最短的路线访问每个城市并返回原始城市</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/fourier-transform">离散傅里叶变换</a> - 把时间信号解析成构成它的频率</li>
</ul>
</li>
<li><strong>贪心法</strong> - 在当前选择最佳选项，不考虑以后情况<ul>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/jump-game">跳跃游戏</a></li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/knapsack-problem">背包问题</a></li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/dijkstra">戴克斯特拉算法</a> - 找到所有图顶点的最短路径</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/prim">普里姆算法</a> - 寻找加权无向图的最小生成树 (MST)</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/kruskal">克鲁斯卡尔算法</a> - 寻找加权无向图的最小生成树 (MST)</li>
</ul>
</li>
<li><strong>分治法</strong> - 将问题分成较小的部分，然后解决这些部分<ul>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/search/binary-search">二分查找</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/hanoi-tower">汉诺塔</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/pascal-triangle">杨辉三角形</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/euclidean-algorithm">欧几里得算法</a> - 计算最大公约数 (GCD)</li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/merge-sort">归并排序</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sorting/quick-sort">快速排序</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/tree/depth-first-search">树深度优先搜索</a> (DFS)</li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/depth-first-search">图深度优先搜索</a> (DFS)</li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/jump-game">跳跃游戏</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/fast-powering">快速算次方</a></li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/permutations">排列</a> (有/无重复)</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/combinations">组合</a> (有/无重复)</li>
</ul>
</li>
<li><strong>动态编程</strong> - 使用以前找到的子解决方案构建解决方案<ul>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/fibonacci">斐波那契数</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/jump-game">跳跃游戏</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/unique-paths">独特路径</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/rain-terraces">雨水收集</a> - 疏导雨水问题</li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/recursive-staircase">递归楼梯</a> - 计算有共有多少种方法可以到达顶层 (4 种解题方案)</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/levenshtein-distance">莱温斯坦距离</a> - 两个序列之间的最小编辑距离</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/longest-common-subsequence">最长公共子序列</a> (LCS)</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/longest-common-substring">最长公共子串</a></li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/longest-increasing-subsequence">最长递增子序列</a></li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/shortest-common-supersequence">最短公共子序列</a></li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/knapsack-problem">0-1背包问题</a></li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/integer-partition">整数拆分</a></li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/maximum-subarray">最大子数列</a></li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/bellman-ford">贝尔曼-福特算法</a> - 找到所有图顶点的最短路径</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/floyd-warshall">弗洛伊德算法</a> - 找到所有顶点对之间的最短路径</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/regular-expression-matching">正则表达式匹配</a></li>
</ul>
</li>
<li><strong>回溯法</strong> - 类似于 <code>BF 算法</code> 试图产生所有可能的解决方案，但每次生成解决方案测试如果它满足所有条件，那么只有继续生成后续解决方案。否则回溯并继续寻找不同路径的解决方案。<ul>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/jump-game">跳跃游戏</a></li>
<li><code>B</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/unique-paths">独特路径</a></li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/power-set">幂集</a> - 该集合的所有子集</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/graph/hamiltonian-cycle">哈密顿图</a> - 恰好访问每个顶点一次</li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/n-queens">八皇后问题</a></li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/uncategorized/knight-tour">骑士巡逻</a></li>
<li><code>A</code> <a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/combination-sum">组合求和</a> - 从规定的总和中找出所有的组合</li>
</ul>
</li>
<li><strong>Branch &amp; Bound</strong> - 记住在回溯搜索的每个阶段找到的成本最低的解决方案，并使用到目前为止找到的成本最小值作为下限。以便丢弃成本大于最小值的解决方案。通常，使用 BFS 遍历以及状态空间树的 DFS 遍历。</li>
</ul>
<h2 id="如何使用本仓库"><a href="#如何使用本仓库" class="headerlink" title="如何使用本仓库"></a>如何使用本仓库</h2><p><strong>安装依赖</strong></p>
<pre><code>npm install</code></pre>
<p><strong>运行 ESLint</strong></p>
<p>检查代码质量</p>
<pre><code>npm run lint</code></pre>
<p><strong>执行测试</strong></p>
<pre><code>npm test</code></pre>
<p><strong>按照名称执行测试</strong></p>
<pre><code>npm test -- 'LinkedList'</code></pre>
<p><strong>Playground</strong></p>
<p>你可以在 <code>./https://github.com/trekhleb/javascript-algorithms/blob/master/src/playground/playground.js</code> 文件中操作数据结构与算法，并在 <code>./https://github.com/trekhleb/javascript-algorithms/blob/master/src/playground/__test__/playground.test.js</code> 中编写测试。</p>
<p>然后，只需运行以下命令来测试你的 Playground 是否无误:</p>
<pre><code>npm test -- 'playground'</code></pre>
<h2 id="有用的信息"><a href="#有用的信息" class="headerlink" title="有用的信息"></a>有用的信息</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a target="_blank" rel="noopener" href="https://www.youtube.com/playlist?list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8">▶ YouTube</a></p>
<h3 id="大O符号"><a href="#大O符号" class="headerlink" title="大O符号"></a>大O符号</h3><p>大O符号中指定的算法的增长顺序。</p>
<p><img src="/My-Blogs/./assets/big-o-graph.png" alt="Big O graphs"></p>
<p>源: <a target="_blank" rel="noopener" href="http://bigocheatsheet.com/">Big O Cheat Sheet</a>.</p>
<p>以下是一些最常用的 大O标记法 列表以及它们与不同大小输入数据的性能比较。</p>
<table>
<thead>
<tr>
<th>大O标记法</th>
<th>计算10个元素</th>
<th>计算100个元素</th>
<th>计算1000个元素</th>
</tr>
</thead>
<tbody><tr>
<td><strong>O(1)</strong></td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><strong>O(log N)</strong></td>
<td>3</td>
<td>6</td>
<td>9</td>
</tr>
<tr>
<td><strong>O(N)</strong></td>
<td>10</td>
<td>100</td>
<td>1000</td>
</tr>
<tr>
<td><strong>O(N log N)</strong></td>
<td>30</td>
<td>600</td>
<td>9000</td>
</tr>
<tr>
<td><strong>O(N^2)</strong></td>
<td>100</td>
<td>10000</td>
<td>1000000</td>
</tr>
<tr>
<td><strong>O(2^N)</strong></td>
<td>1024</td>
<td>1.26e+29</td>
<td>1.07e+301</td>
</tr>
<tr>
<td><strong>O(N!)</strong></td>
<td>3628800</td>
<td>9.3e+157</td>
<td>4.02e+2567</td>
</tr>
</tbody></table>
<h3 id="数据结构操作的复杂性"><a href="#数据结构操作的复杂性" class="headerlink" title="数据结构操作的复杂性"></a>数据结构操作的复杂性</h3><table>
<thead>
<tr>
<th>数据结构</th>
<th align="center">连接</th>
<th align="center">查找</th>
<th align="center">插入</th>
<th align="center">删除</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><strong>数组</strong></td>
<td align="center">1</td>
<td align="center">n</td>
<td align="center">n</td>
<td align="center">n</td>
<td></td>
</tr>
<tr>
<td><strong>栈</strong></td>
<td align="center">n</td>
<td align="center">n</td>
<td align="center">1</td>
<td align="center">1</td>
<td></td>
</tr>
<tr>
<td><strong>队列</strong></td>
<td align="center">n</td>
<td align="center">n</td>
<td align="center">1</td>
<td align="center">1</td>
<td></td>
</tr>
<tr>
<td><strong>链表</strong></td>
<td align="center">n</td>
<td align="center">n</td>
<td align="center">1</td>
<td align="center">1</td>
<td></td>
</tr>
<tr>
<td><strong>哈希表</strong></td>
<td align="center">-</td>
<td align="center">n</td>
<td align="center">n</td>
<td align="center">n</td>
<td>在完全哈希函数情况下，复杂度是 O(1）</td>
</tr>
<tr>
<td><strong>二分查找树</strong></td>
<td align="center">n</td>
<td align="center">n</td>
<td align="center">n</td>
<td align="center">n</td>
<td>在平衡树情况下，复杂度是 O(log(n))</td>
</tr>
<tr>
<td><strong>B 树</strong></td>
<td align="center">log(n)</td>
<td align="center">log(n)</td>
<td align="center">log(n)</td>
<td align="center">log(n)</td>
<td></td>
</tr>
<tr>
<td><strong>红黑树</strong></td>
<td align="center">log(n)</td>
<td align="center">log(n)</td>
<td align="center">log(n)</td>
<td align="center">log(n)</td>
<td></td>
</tr>
<tr>
<td><strong>AVL 树</strong></td>
<td align="center">log(n)</td>
<td align="center">log(n)</td>
<td align="center">log(n)</td>
<td align="center">log(n)</td>
<td></td>
</tr>
<tr>
<td><strong>布隆过滤器</strong></td>
<td align="center">-</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">-</td>
<td>存在一定概率的判断错误（误判成存在）</td>
</tr>
</tbody></table>
<h3 id="数组排序算法的复杂性"><a href="#数组排序算法的复杂性" class="headerlink" title="数组排序算法的复杂性"></a>数组排序算法的复杂性</h3><table>
<thead>
<tr>
<th>名称</th>
<th align="center">最优</th>
<th align="center">平均</th>
<th align="center">最坏</th>
<th align="center">内存</th>
<th align="center">稳定</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><strong>冒泡排序</strong></td>
<td align="center">n</td>
<td align="center">n^2</td>
<td align="center">n^2</td>
<td align="center">1</td>
<td align="center">Yes</td>
<td></td>
</tr>
<tr>
<td><strong>插入排序</strong></td>
<td align="center">n</td>
<td align="center">n^2</td>
<td align="center">n^2</td>
<td align="center">1</td>
<td align="center">Yes</td>
<td></td>
</tr>
<tr>
<td><strong>选择排序</strong></td>
<td align="center">n^2</td>
<td align="center">n^2</td>
<td align="center">n^2</td>
<td align="center">1</td>
<td align="center">No</td>
<td></td>
</tr>
<tr>
<td><strong>堆排序</strong></td>
<td align="center">n log(n)</td>
<td align="center">n log(n)</td>
<td align="center">n log(n)</td>
<td align="center">1</td>
<td align="center">No</td>
<td></td>
</tr>
<tr>
<td><strong>归并排序</strong></td>
<td align="center">n log(n)</td>
<td align="center">n log(n)</td>
<td align="center">n log(n)</td>
<td align="center">n</td>
<td align="center">Yes</td>
<td></td>
</tr>
<tr>
<td><strong>快速排序</strong></td>
<td align="center">n log(n)</td>
<td align="center">n log(n)</td>
<td align="center">n^2</td>
<td align="center">log(n)</td>
<td align="center">No</td>
<td>在 in-place 版本下，内存复杂度通常是 O(log(n))</td>
</tr>
<tr>
<td><strong>希尔排序</strong></td>
<td align="center">n log(n)</td>
<td align="center">取决于差距序列</td>
<td align="center">n (log(n))^2</td>
<td align="center">1</td>
<td align="center">No</td>
<td></td>
</tr>
<tr>
<td><strong>计数排序</strong></td>
<td align="center">n + r</td>
<td align="center">n + r</td>
<td align="center">n + r</td>
<td align="center">n + r</td>
<td align="center">Yes</td>
<td>r - 数组里最大的数</td>
</tr>
<tr>
<td><strong>基数排序</strong></td>
<td align="center">n * k</td>
<td align="center">n * k</td>
<td align="center">n * k</td>
<td align="center">n + k</td>
<td align="center">Yes</td>
<td>k - 最长 key 的升序</td>
</tr>
</tbody></table>
<blockquote>
<p>ℹ️ A few more <a target="_blank" rel="noopener" href="https://trekhleb.dev/projects/">projects</a> and <a target="_blank" rel="noopener" href="https://trekhleb.dev/blog/">articles</a> about JavaScript and algorithms on <a target="_blank" rel="noopener" href="https://trekhleb.dev/">trekhleb.dev</a></p>
</blockquote>
</article><section class="is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-small is-default" href="/My-Blogs/2021/12/21/JavaScript/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%9F%BA%E7%A1%80/" title="算法篇-基础">Next</a></section><article class="mt-6 comment-container"><script src="https://utteranc.es/client.js" repo="529303664/My-Blogs" issue-term="pathname" theme="github-light" async></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/https://twitter.com/Lucas55207840?s=05"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/529303664"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><a title="rss" target="_blank" rel="noopener nofollow" href="/My-Blogs/atom.xml"><i class="iconfont icon-rss"></i></a><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com/https://www.facebook.com/profile.php?id=100010703889793"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Lucas 2021</span></p><div class="is-flex"><p>Powered by Hexo｜</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by &nbspHaojen&nbsp</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script>hljs.initHighlighting();

var directory = document.querySelectorAll('.toc a')
if (directory.length > 0) {
    var contentTocList = []
    var activeClassName = 'is-active'

    directory.forEach(function (link) {
        if (!link.href) return
        var id = decodeURI(link.href).split('#')[1]
        contentTocList.push(document.getElementById(id))
    })

    var DELAY = 150
    var needWait = false
    window.addEventListener('scroll', function (evt) {
        if (needWait) {
            return
        }
        needWait = true
        var tocContainer = document.querySelector('.toc')
        setTimeout(function () {
            var spacing = 60
            var activeTopicEl = null
            var scrollTop = window.pageYOffset
            for (var i = 0; i < contentTocList.length; i++) {
                var currentTopic = contentTocList[i]

                if (currentTopic.offsetTop > scrollTop + spacing / 2) {
                    // jump to next loop
                    continue
                }

                if (!activeTopicEl) {
                    activeTopicEl = currentTopic
                } else if (currentTopic.offsetTop + spacing >= activeTopicEl.offsetTop - spacing) {
                    activeTopicEl = currentTopic
                }

                var beforeActiveEl = document.querySelector('.toc' + ' .' + activeClassName)
                beforeActiveEl && beforeActiveEl.classList.remove(activeClassName)

                var selectTarget = '.toc a[href="#' + encodeURI(activeTopicEl.id) + '"]'
                var direc = document.querySelector(selectTarget)
                direc.classList.add(activeClassName)

                var tocContainerHeight = tocContainer.getBoundingClientRect().height
                if (direc.offsetTop >= tocContainerHeight - spacing) {
                    tocContainer.scrollTo({
                        // top: direc.offsetTop - spacing,
                        top: direc.offsetTop + 100 - tocContainerHeight,
                    })
                }
                else {
                    tocContainer.scrollTo({ top: 0 })
                }
            }
            needWait = false
        }, DELAY)

    })

}</script></body></html>