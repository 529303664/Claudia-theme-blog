<!DOCTYPE html><html class="appearance-auto" lang="zh-cn"><head><meta charset="UTF-8"><title>你不知道的Blob</title><meta name="description" content="完善自己"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><link rel="icon"><link rel="stylesheet" href="/My-Blogs/style/bulma.css"><link rel="stylesheet" href="/My-Blogs/style/base.css"><link rel="stylesheet" href="/My-Blogs/style/helper.css"><script src="/My-Blogs/js/main.js"></script><link rel="stylesheet" href="/My-Blogs/style/post.css"><link rel="stylesheet" href="/My-Blogs/style/highlight-theme-light.css"><script src="/My-Blogs/jslib/highlight.pack.js"></script><meta name="generator" content="Hexo 5.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/My-Blogs/atom.xml" title="John Doe's blog" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-space-between is-hidden-mobile"><section class="is-hidden-mobile"><h2><a href="/My-Blogs/">Lucas's blog</a></h2></section><h3 class="is-hidden-mobile"></h3><aside><h3 class="is-inline-block"><a href="/My-Blogs/">Home</a></h3><h3 class="is-inline-block"><a href="/My-Blogs/about">About</a></h3><h3 class="is-inline-block"><a href="/My-Blogs/archives">Archives</a></h3></aside></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/My-Blogs/">Home</a></h3><h3 class="is-inline-block"><a href="/My-Blogs/about">About</a></h3><h3 class="is-inline-block"><a href="/My-Blogs/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Blob-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">一、Blob 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Blob-API-%E7%AE%80%E4%BB%8B"><span class="toc-text">二、Blob API 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">2.1 构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%B1%9E%E6%80%A7"><span class="toc-text">2.2 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E6%96%B9%E6%B3%95"><span class="toc-text">2.3 方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Blob-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">三、Blob 使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0"><span class="toc-text">3.1 分片上传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E4%BB%8E%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%8B%E8%BD%BD%E6%95%B0%E6%8D%AE"><span class="toc-text">3.2 从互联网下载数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-Blob-%E7%94%A8%E4%BD%9C-URL"><span class="toc-text">3.3 Blob 用作 URL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-Blob-%E8%BD%AC%E6%8D%A2%E4%B8%BA-Base64"><span class="toc-text">3.4 Blob 转换为 Base64</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9"><span class="toc-text">3.5 图片压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E7%94%9F%E6%88%90-PDF-%E6%96%87%E6%A1%A3"><span class="toc-text">3.6 生成 PDF 文档</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Blob-%E4%B8%8E-ArrayBuffer-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">四、Blob 与 ArrayBuffer 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-Blob-vs-ArrayBuffer"><span class="toc-text">4.1 Blob vs ArrayBuffer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90"><span class="toc-text">五、参考资源</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/My-Blogs/tags/JavaScript"><i class="tag post-item-tag">JavaScript</i></a><a href="/My-Blogs/tags/Blob"><i class="tag post-item-tag">Blob</i></a><a href="/My-Blogs/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6"><i class="tag post-item-tag">二进制</i></a></header><h1 class="mt-0 mb-1 is-family-serif">你不知道的Blob</h1><time class="has-text-grey" datetime="2021-01-08T16:27:54.000Z">2021-01-08</time><article class="mt-2 post-content"><p>如果你允许用户从你的网站上下载某些文件，那你可能会遇到 Blob 类型。为了实现上述的功能，你可以很容易从网上找到相关的示例，并根据实际需求进行适当的调整。对于部分开发者来说，在完成上述功能之后，他们并不会继续思考 Blob 是什么？</p>
<a id="more"></a>

<p>这就导致了一些开发者，还是停留在熟练使用 API 的层面，当遇到比较棘手的问题时，就束手无策。<strong>换句话说，如果当你在熟悉 API 的使用之后，还能继续多问几个为什么，继续探究下去，不仅能加深对知识的理解，还能触类旁通，拓展自己的知识面提高自己。</strong></p>
<p>好了，如果你想继续了解什么是 Blob，那么就跟上我的脚步，来一个 Blob Web API 探索之旅。还在犹豫什么，Let’s go！</p>
<p>读完本文你将了解到以下内容：</p>
<ul>
<li><p>Blob 是什么</p>
</li>
<li><p>Blob API 简介</p>
</li>
<li><p>构造函数</p>
</li>
<li><p>属性和方法</p>
</li>
<li><p>Blob 使用场景</p>
</li>
<li><p>分片上传</p>
</li>
<li><p>从互联网下载数据</p>
</li>
<li><p>Blob 用作 URL</p>
</li>
<li><p>Blob 转换为 Base64</p>
</li>
<li><p>图片压缩</p>
</li>
<li><p>生成 PDF</p>
</li>
<li><p>Blob 与 ArrayBuffer 的区别</p>
</li>
</ul>
<h3 id="一、Blob-是什么"><a href="#一、Blob-是什么" class="headerlink" title="一、Blob 是什么"></a><span style="display: none; "></span>一、Blob 是什么<span style="display: none; "></span></h3><p>Blob（Binary Large Object）表示二进制类型的大对象。在数据库管理系统中，将二进制数据存储为一个单一个体的集合。Blob 通常是影像、声音或多媒体文件。<strong>在 JavaScript 中 Blob 类型的对象表示不可变的类似文件对象的原始数据。</strong> 为了更直观的感受 Blob 对象，我们先来使用 Blob 构造函数，创建一个 myBlob 对象，具体如下图所示：</p>
<p><img src="/My-Blogs/images/blobInfo.webp"></p>
<p>如你所见，myBlob 对象含有两个属性：size 和 type。其中 <code>size</code> 属性用于表示数据的大小（以字节为单位）， <code>type</code> 是 MIME 类型的字符串。Blob 表示的不一定是 JavaScript 原生格式的数据。比如 <code>File</code> 接口基于 <code>Blob</code> ，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p>
<h3 id="二、Blob-API-简介"><a href="#二、Blob-API-简介" class="headerlink" title="二、Blob API 简介"></a><span style="display: none; "></span>二、Blob API 简介<span style="display: none; "></span></h3><p><code>Blob</code> 由一个可选的字符串 <code>type</code> （通常是 MIME 类型）和 <code>blobParts</code> 组成：</p>
<p><img src="/My-Blogs/images/blobInfo2.webp"></p>
<blockquote>
<p>MIME（Multipurpose Internet Mail Extensions）多用途互联网邮件扩展类型，是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。</p>
<p>常见的 MIME 类型有：超文本标记语言文本 .html text/html、PNG图像 .png image/png、普通文本 .txt text/plain 等。</p>
</blockquote>
<h4 id="2-1-构造函数"><a href="#2-1-构造函数" class="headerlink" title="2.1 构造函数"></a><span style="display: none; "></span>2.1 构造函数<span style="display: none; "></span></h4><p>Blob 构造函数的语法为：</p>
<pre><code class="js">var aBlob = new Blob(blobParts, options);</code></pre>
<p>相关的参数说明如下：</p>
<ul>
<li><p>blobParts：它是一个由 ArrayBuffer，ArrayBufferView，Blob，DOMString 等对象构成的数组。DOMStrings 会被编码为 UTF-8。</p>
</li>
<li><p>options：一个可选的对象，包含以下两个属性：</p>
</li>
<li><p>type —— 默认值为 <code>""</code>，它代表了将会被放入到 blob 中的数组内容的 MIME 类型。</p>
</li>
<li><p>endings —— 默认值为 <code>"transparent"</code>，用于指定包含行结束符 <code>\n</code> 的字符串如何被写入。它是以下两个值中的一个：<code>"native"</code>，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 <code>"transparent"</code>，代表会保持 blob 中保存的结束符不变。</p>
</li>
</ul>
<p><strong>示例一：从字符串创建 Blob</strong></p>
<pre><code class="js">let myBlobParts = ['&lt;html&gt;&lt;h2&gt;Hello&nbsp;Semlinker&lt;/h2&gt;&lt;/html&gt;']; //&nbsp;an&nbsp;array&nbsp;consisting&nbsp;of&nbsp;a&nbsp;single&nbsp;DOMString
let myBlob = new Blob(myBlobParts, {
    type: 'text/html',
    endings: "transparent"
}); //the&nbsp;blob
console.log(myBlob.size + "&nbsp;bytes&nbsp;size"); //&nbsp;Output:&nbsp;37&nbsp;bytes&nbsp;size
console.log(myBlob.type + "&nbsp;is&nbsp;the&nbsp;type"); //&nbsp;Output:&nbsp;text/html&nbsp;is&nbsp;the&nbsp;type</code></pre>
<p><strong>示例二：从类型化数组和字符串创建 Blob</strong></p>
<pre><code class="js">let hello = new Uint8Array([72, 101, 108, 108, 111]); //&nbsp;二进制格式的&nbsp;"hello"
let blob = new Blob([hello, '&nbsp;', 'semlinker'], {
    type: 'text/plain'
});</code></pre>
<p>介绍完 Blob 构造函数，接下来我们来分别介绍 Blob 类的属性和方法：</p>
<p><img src="/My-Blogs/images/blobInfo3.webp"></p>
<h4 id="2-2-属性"><a href="#2-2-属性" class="headerlink" title="2.2 属性"></a><span style="display: none; "></span>2.2 属性<span style="display: none; "></span></h4><p>前面我们已经知道 Blob 对象包含两个属性：</p>
<ul>
<li><p>size（只读）：表示 <code>Blob</code> 对象中所包含数据的大小（以字节为单位）。</p>
</li>
<li><p>type（只读）：一个字符串，表明该 <code>Blob</code> 对象所包含数据的 MIME 类型。如果类型未知，则该值为空字符串。</p>
</li>
</ul>
<h4 id="2-3-方法"><a href="#2-3-方法" class="headerlink" title="2.3 方法"></a><span style="display: none; "></span>2.3 方法<span style="display: none; "></span></h4><ul>
<li><p>slice([start[, end[, contentType]]])：返回一个新的 Blob 对象，包含了源 Blob 对象中指定范围内的数据。</p>
</li>
<li><p>stream()：返回一个能读取 blob 内容的 <code>ReadableStream</code>。</p>
</li>
<li><p>text()：返回一个 Promise 对象且包含 blob 所有内容的 UTF-8 格式的 <code>USVString</code>。</p>
</li>
<li><p>arrayBuffer()：返回一个 Promise 对象且包含 blob 所有内容的二进制格式的 <code>ArrayBuffer</code>。</p>
</li>
</ul>
<p>这里我们需要注意的是，** <code>Blob</code> 对象是不可改变的**。我们不能直接在一个 Blob 中更改数据，但是我们可以对一个 Blob 进行分割，从其中创建新的 Blob 对象，将它们混合到一个新的 Blob 中。这种行为类似于 JavaScript 字符串：我们无法更改字符串中的字符，但可以创建新的更正后的字符串。</p>
<h3 id="三、Blob-使用场景"><a href="#三、Blob-使用场景" class="headerlink" title="三、Blob 使用场景"></a><span style="display: none; "></span>三、Blob 使用场景<span style="display: none; "></span></h3><h4 id="3-1-分片上传"><a href="#3-1-分片上传" class="headerlink" title="3.1 分片上传"></a><span style="display: none; "></span>3.1 分片上传<span style="display: none; "></span></h4><p>File 对象是特殊类型的 Blob，且可以用在任意的 Blob 类型的上下文中。所以针对大文件传输的场景，我们可以使用 slice 方法对大文件进行切割，然后分片进行上传，具体示例如下：</p>
<pre><code class="js">const file = new File(["a".repeat(1000000)], "test.txt");
const chunkSize = 40000;
const url = "https://httpbin.org/post";
async function chunkedUpload() {
    for (let start = 0; start &lt; file.size; start += chunkSize) {
        const chunk = file.slice(start, start + chunkSize + 1);
        const fd = new FormData();
        fd.append("data", chunk);
        await fetch(url, {
            method: "post",
            body: fd
        }).then((res) =&gt; res.text());
    }
}</code></pre>
<h4 id="3-2-从互联网下载数据"><a href="#3-2-从互联网下载数据" class="headerlink" title="3.2 从互联网下载数据"></a><span style="display: none; "></span>3.2 从互联网下载数据<span style="display: none; "></span></h4><p>我们可以使用以下方法从互联网上下载数据并将数据存储到 Blob 对象中，比如：</p>
<pre><code class="js">const downloadBlob = (url, callback) =&gt; {
    const xhr = new XMLHttpRequest()
    xhr.open('GET', url)
    xhr.responseType = 'blob'
    xhr.onload = () =&gt; {
        callback(xhr.response)
    }
    xhr.send(null)
}</code></pre>
<p>当然除了使用 <code>XMLHttpRequest</code> API 之外，我们也可以使用 <code>fetch</code> API 来实现以流的方式获取二进制数据。这里我们来看一下如何使用 fetch API 获取线上图片并本地显示，具体实现如下：</p>
<pre><code class="js">const myImage = document.querySelector('img');
const myRequest = new Request('flowers.jpg');
fetch(myRequest)
    .then(function(response) {
        return response.blob();
    })
    .then(function(myBlob) {
        let objectURL = URL.createObjectURL(myBlob);
        myImage.src = objectURL;
    });</code></pre>
<p>当 fetch 请求成功的时候，我们调用 response 对象的 <code>blob()</code> 方法，从 response 对象中读取一个 Blob 对象，然后使用 <code>createObjectURL()</code> 方法创建一个 objectURL，然后把它赋值给 <code>img</code> 元素的 <code>src</code> 属性从而显示这张图片。</p>
<h4 id="3-3-Blob-用作-URL"><a href="#3-3-Blob-用作-URL" class="headerlink" title="3.3 Blob 用作 URL"></a><span style="display: none; "></span>3.3 Blob 用作 URL<span style="display: none; "></span></h4><p>Blob 可以很容易的作为 <code>&lt;a&gt;</code> 、 <code>&lt;img&gt;</code> 或其他标签的 URL，多亏了 <code>type</code> 属性，我们也可以上传/下载 <code>Blob</code> 对象。下面我们将举一个 Blob 文件下载的示例，不过在看具体示例前我们得简单介绍一下 Blob URL。</p>
<p><strong>1. Blob URL/Object URL</strong></p>
<p>Blob URL/Object URL 是一种伪协议，允许 Blob 和 File 对象用作图像，下载二进制数据链接等的 URL 源。在浏览器中，我们使用 <code>URL.createObjectURL</code> 方法来创建 Blob URL，该方法接收一个 <code>Blob</code> 对象，并为其创建一个唯一的 URL，其形式为 <code>blob:&lt;origin&gt;/&lt;uuid&gt;</code> ，对应的示例如下：</p>
<pre><code class="html">blob:https://example.org/40a5fb5a-d56d-4a33-b4e2-0acf6a8e5f641</code></pre>
<p>浏览器内部为每个通过 <code>URL.createObjectURL</code> 生成的 URL 存储了一个 URL → Blob 映射。因此，此类 URL 较短，但可以访问 <code>Blob</code> 。生成的 URL 仅在当前文档打开的状态下才有效。它允许引用 <code>&lt;img&gt;</code> 、 <code>&lt;a&gt;</code> 中的 <code>Blob</code> ，但如果你访问的 Blob URL 不再存在，则会从浏览器中收到 404 错误。</p>
<p>上述的 Blob URL 看似很不错，但实际上它也有副作用。虽然存储了 URL → Blob 的映射，但 Blob 本身仍驻留在内存中，浏览器无法释放它。映射在文档卸载时自动清除，因此 Blob 对象随后被释放。</p>
<p>但是，如果应用程序寿命很长，那不会很快发生。因此，如果我们创建一个 Blob URL，即使不再需要该 Blob，它也会存在内存中。</p>
<p>针对这个问题，我们可以调用 <code>URL.revokeObjectURL(url)</code> 方法，从内部映射中删除引用，从而允许删除 Blob（如果没有其他引用），并释放内存。接下来，我们来看一下 Blob 文件下载的具体示例。</p>
<p><strong>2. Blob 文件下载示例</strong></p>
<p><strong>index.html</strong></p>
<pre><code class="html">&lt;!DOCTYPE&nbsp;html&gt;
&lt;html&gt;&nbsp;&nbsp;

&lt;head&gt;&nbsp;&nbsp;&nbsp;
    &lt;meta&nbsp;charset="UTF-8"&nbsp; /&gt;&nbsp;&nbsp;&nbsp;&nbsp;
    &lt;title&gt;Blob&nbsp;文件下载示例&lt;/title&gt;&nbsp;&nbsp;
&lt;/head&gt;&nbsp;&nbsp;

&lt;body&gt;&nbsp;&nbsp;&nbsp;&nbsp;
    &lt;button&nbsp;id="downloadBtn"&gt;文件下载&lt;/button&gt;&nbsp;&nbsp;&nbsp;&nbsp;
    &lt;script&nbsp;src="index.js"&gt;&lt;/script&gt;&nbsp;&nbsp;
&lt;/body&gt;

&lt;/html&gt;</code></pre>
<p><strong>index.js</strong></p>
<pre><code class="js">const download = (fileName, blob) =&gt; {
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = fileName;
    link.click();
    link.remove();
    URL.revokeObjectURL(link.href);
};
const downloadBtn = document.querySelector("#downloadBtn");
downloadBtn.addEventListener("click", (event) =&gt; {
    const fileName = "blob.txt";
    const myBlob = new Blob(["一文彻底掌握&nbsp;Blob&nbsp;Web&nbsp;API"], {
        type: "text/plain"
    });
    download(fileName, myBlob);
});</code></pre>
<p>在示例中，我们通过调用 Blob 的构造函数来创建类型为 <strong>“text/plain”</strong> 的 Blob 对象，然后通过动态创建 <code>a</code> 标签来实现文件的下载。</p>
<h4 id="3-4-Blob-转换为-Base64"><a href="#3-4-Blob-转换为-Base64" class="headerlink" title="3.4 Blob 转换为 Base64"></a><span style="display: none; "></span>3.4 Blob 转换为 Base64<span style="display: none; "></span></h4><p><code>URL.createObjectURL</code> 的一个替代方法是，将 <code>Blob</code> 转换为 base64 编码的字符串。<strong>Base64</strong> 是一种基于 64 个可打印字符来表示二进制数据的表示方法，<strong>它常用于在处理文本数据的场合，表示、传输、存储一些二进制数据，包括 MIME 的电子邮件及 XML 的一些复杂数据。</strong></p>
<p>在 MIME 格式的电子邮件中，base64 可以用来将二进制的字节序列数据编码成 ASCII 字符序列构成的文本。使用时，在传输编码方式中指定 base64。使用的字符包括大小写拉丁字母各 26 个、数字 10 个、加号 + 和斜杠 /，共 64 个字符，等号 = 用来作为后缀用途。</p>
<p>下面我们来介绍如何在 HTML 中嵌入 base64 编码的图片。在编写 HTML 网页时，对于一些简单图片，通常会选择将图片内容直接内嵌在网页中，从而减少不必要的网络请求，但是图片数据是二进制数据，该怎么嵌入呢？绝大多数现代浏览器都支持一种名为 <code>Data URLs</code> 的特性，允许使用 base64 对图片或其他文件的二进制数据进行编码，将其作为文本字符串嵌入网页中。</p>
<p>Data URLs 由四个部分组成：前缀（ <code>data:</code> ）、指示数据类型的 MIME 类型、如果非文本则为可选的 <code>base64</code> 标记、数据本身：</p>
<pre><code class="html">data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</code></pre>
<p><code>mediatype</code> 是个 MIME 类型的字符串，例如 “ <code>image/jpeg</code> “ 表示 JPEG 图像文件。如果被省略，则默认值为 <code>text/plain;charset=US-ASCII</code> 。如果数据是文本类型，你可以直接将文本嵌入（根据文档类型，使用合适的实体字符或转义字符）。如果是二进制数据，你可以将数据进行 base64 编码之后再进行嵌入。比如嵌入一张图片：</p>
<pre><code class="html">&lt;img&nbsp;alt="logo"&nbsp;src="data:image /png;base64,iVBORw0KGgoAAAANSUhEUg..."&gt;</code></pre>
<p><strong>但需要注意的是：如果图片较大，图片的色彩层次比较丰富，则不适合使用这种方式，因为该图片经过 base64 编码后的字符串非常大，会明显增大 HTML 页面的大小，从而影响加载速度。</strong> 除此之外，利用 FileReader API，我们也可以方便的实现图片本地预览功能，具体代码如下：</p>
<pre><code class="html">&lt;input&nbsp;type="file"&nbsp;accept="image /*"&nbsp;onchange="loadFile(event)"&gt;
&lt;img&nbsp;id="output" /&gt;
&lt;script&gt;
    const loadFile = function(event) {
        const reader = new FileReader();
        reader.onload = function() {
            const output = document.querySelector('output');
            output.src = reader.result;
        };
        reader.readAsDataURL(event.target.files[0]);
    };
&lt;/script&gt;</code></pre>
<p>在以上示例中，我们为 file 类型输入框绑定 <code>onchange</code> 事件处理函数 <code>loadFile</code> ，在该函数中，我们创建了一个 FileReader 对象并为该对象绑定 <code>onload</code> 相应的事件处理函数，然后调用 FileReader 对象的 <code>readAsDataURL()</code> 方法，把本地图片对应的 File 对象转换为 Data URL。</p>
<p>在完成本地图片预览之后，我们可以直接把图片对应的 Data URLs 数据提交到服务器。针对这种情形，服务端需要做一些相关处理，才能正常保存上传的图片，这里以 Express 为例，具体处理代码如下：</p>
<pre><code class="js">const app = require('express')();
app.post('/upload', function(req, res) {
    let imgData = req.body.imgData; //&nbsp;获取POST请求中的base64图片数据&nbsp;&nbsp;&nbsp;&nbsp;
    let base64Data = imgData.replace(/^data:image\/\w+;base64,/, "");
    let dataBuffer = Buffer.from(base64Data, 'base64');
    fs.writeFile("image.png", dataBuffer, function(err) {
        if (err) {
            res.send(err);
        } else {
            res.send("图片上传成功！");
        }
    });
});</code></pre>
<p>对于 FileReader 对象来说，除了支持把 Blob/File 对象转换为 Data URL 之外，它还提供了 <code>readAsArrayBuffer()</code> 和 <code>readAsText()</code> 方法，用于把 Blob/File 对象转换为其它的数据格式。这里我们来看个 <code>readAsArrayBuffer()</code> 的使用示例：</p>
<pre><code class="js">//&nbsp;从&nbsp;blob&nbsp;获取&nbsp;arrayBuffer
let fileReader = new FileReader();
fileReader.onload = function(event) {
    let arrayBuffer = fileReader.result;
};
fileReader.readAsArrayBuffer(blob);</code></pre>
<h4 id="3-5-图片压缩"><a href="#3-5-图片压缩" class="headerlink" title="3.5 图片压缩"></a><span style="display: none; "></span>3.5 图片压缩<span style="display: none; "></span></h4><p>在一些场合中，我们希望在上传本地图片时，先对图片进行一定的压缩，然后再提交到服务器，从而减少传输的数据量。在前端要实现图片压缩，我们可以利用 Canvas 对象提供的 <code>toDataURL()</code> 方法，该方法接收 <code>type</code> 和 <code>encoderOptions</code> 两个可选参数。</p>
<p>其中 <code>type</code> 表示图片格式，默认为 <code>image/png</code> 。而 <code>encoderOptions</code> 用于表示图片的质量，在指定图片格式为 <code>image/jpeg</code> 或 <code>image/webp</code> 的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 <code>0.92</code> ，其他参数会被忽略。</p>
<p>下面我们来看一下具体如何实现图片压缩：</p>
<pre><code class="js">//&nbsp;compress.js
const MAX_WIDTH = 800; //&nbsp;图片最大宽度
function compress(base64, quality, mimeType) {
    let canvas = document.createElement("canvas");
    let img = document.createElement("img");
    img.crossOrigin = "anonymous";
    return new Promise((resolve, reject) =&gt; {
        img.src = base64;
        img.onload = () =&gt; {
            let targetWidth, targetHeight;
            if (img.width &gt; MAX_WIDTH) {
                targetWidth = MAX_WIDTH;
                targetHeight = (img.height * MAX_WIDTH) / img.width;
            } else {
                targetWidth = img.width;
                targetHeight = img.height;
            }
            canvas.width = targetWidth;
            canvas.height = targetHeight;
            let ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, targetWidth, targetHeight); //&nbsp;清除画布&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            let imageData = canvas.toDataURL(mimeType, quality / 100);
            resolve(imageData);
        };
    });
}</code></pre>
<p>对于返回的 Data URL 格式的图片数据，为了进一步减少传输的数据量，我们可以把它转换为 Blob 对象：</p>
<pre><code class="js">function dataUrlToBlob(base64, mimeType) {
    let bytes = window.atob(base64.split(",")[1]);
    let ab = new ArrayBuffer(bytes.length);
    let ia = new Uint8Array(ab);
    for (let i = 0; i &lt; bytes.length; i++) {
        ia[i] = bytes.charCodeAt(i);
    }
    return new Blob([ia], {
        type: mimeType
    });
}</code></pre>
<p>在转换完成后，我们就可以压缩后的图片对应的 Blob 对象封装在 FormData 对象中，然后再通过 AJAX 提交到服务器上：</p>
<pre><code class="js">function uploadFile(url, blob) {
    let formData = new FormData();
    let request = new XMLHttpRequest();
    formData.append("image", blob);
    request.open("POST", url, true);
    request.send(formData);
}</code></pre>
<p>其实 Canvas 对象除了提供 <code>toDataURL()</code> 方法之外，它还提供了一个 <code>toBlob()</code> 方法，该方法的语法如下：</p>
<blockquote>
<p>canvas.toBlob(callback, mimeType, qualityArgument)</p>
</blockquote>
<p>和 <code>toDataURL()</code> 方法相比， <code>toBlob()</code> 方法是异步的，因此多了个 <code>callback</code> 参数，这个 <code>callback</code> 回调方法默认的第一个参数就是转换好的 <code>blob</code> 文件信息。</p>
<p>介绍完上述的内容，我们来看一下本地图片压缩完整的示例：</p>
<pre><code class="html">&lt;!DOCTYPE&nbsp;html&gt;
&lt;html&gt;&nbsp;&nbsp;

&lt;head&gt;&nbsp;&nbsp;&nbsp;&nbsp;
    &lt;meta&nbsp;charset="UTF-8"&nbsp; /&gt;&nbsp;&nbsp;&nbsp;&nbsp;
    &lt;meta&nbsp;name="viewport"&nbsp;content="width=device-width,&nbsp;initial-scale=1.0"&nbsp; /&gt;&nbsp;&nbsp;&nbsp;&nbsp;
    &lt;title&gt;本地图片压缩&lt;/title&gt;&nbsp;&nbsp;
&lt;/head&gt;&nbsp;&nbsp;

&lt;body&gt;&nbsp;&nbsp;&nbsp;&nbsp;
    &lt;input&nbsp;type="file"&nbsp;accept="image /*"&nbsp;onchange="loadFile(event)" &nbsp; /&gt;&nbsp;&nbsp;&nbsp;&nbsp;
    &lt;script&nbsp;src=". /compress.js"&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;
    &lt;script&gt;
        const loadFile = function(event) {
            const reader = new FileReader();
            reader.onload = async function() {
                let compressedDataURL = await compress(
                    reader.result,
                    90,
                    "image/jpeg"
                );
                let compressedImageBlob = dataUrlToBlob(compressedDataURL);
                uploadFile("https://httpbin.org/post", compressedImageBlob);
            };
            reader.readAsDataURL(event.target.files[0]);
        };
    &lt;/script&gt;&nbsp;&nbsp;
&lt;/body&gt;

&lt;/html&gt;</code></pre>
<h4 id="3-6-生成-PDF-文档"><a href="#3-6-生成-PDF-文档" class="headerlink" title="3.6 生成 PDF 文档"></a><span style="display: none; "></span>3.6 生成 PDF 文档<span style="display: none; "></span></h4><p>PDF（便携式文件格式，Portable Document Format）是由 Adobe Systems 在 1993 年用于文件交换所发展出的文件格式。在浏览器端，利用一些现成的开源库，比如 jsPDF，我们也可以方便地生成 PDF 文档。</p>
<pre><code class="html">&lt;!DOCTYPE&nbsp;html&gt;
&lt;html&gt;&nbsp;&nbsp;

&lt;head&gt;&nbsp;&nbsp;&nbsp;&nbsp;
    &lt;meta&nbsp;charset="UTF-8"&nbsp; /&gt;&nbsp;&nbsp;&nbsp;&nbsp;
    &lt;meta&nbsp;name="viewport"&nbsp;content="width=device-width,&nbsp;initial-scale=1.0"&nbsp; /&gt;&nbsp;&nbsp;&nbsp;&nbsp;
    &lt;title&gt;客户端生成&nbsp;PDF&nbsp;示例&lt;/title&gt;&nbsp;&nbsp;
&lt;/head&gt;&nbsp;&nbsp;

&lt;body&gt;&nbsp;&nbsp;&nbsp;&nbsp;
    &lt;h3&gt;客户端生成&nbsp;PDF&nbsp;示例&lt;/h3&gt;&nbsp;&nbsp;&nbsp;&nbsp;
    &lt;script&nbsp;src="https: //unpkg.com/jspdf@latest/dist/jspdf.min.js"&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;
    &lt;script&gt;
        (function generatePdf() {
            const doc = new jsPDF();
            doc.text("Hello&nbsp;semlinker!", 66, 88);
            const blob = new Blob([doc.output()], {
                type: "application/pdf"
            });
            blob.text().then((blobAsText) =&gt; {
                console.log(blobAsText);
            });
        })();
    &lt;/script&gt;&nbsp;&nbsp;
&lt;/body&gt;

&lt;/html&gt;</code></pre>
<p>在以上示例中，我们首先创建 PDF 文档对象，然后调用该对象上的 <code>text()</code> 方法在指定的坐标点上添加 <code>Hello semlinker!</code> 文本，然后我们利用生成的 PDF 内容来创建对应的 Blob 对象，需要注意的是我们设置 Blob 的类型为 <code>application/pdf</code> ，最后我们把 Blob 对象中保存的内容转换为文本并输出到控制台。由于内容较多，这里我们只列出少部分输出结果：</p>
<pre><code class="js">% PDF - 1.3 % ºß¬ à3 0 obj &lt;&lt; /Type&nbsp;/Page / Parent 1 0 R / Resources 2 0 R / MediaBox[0 0 595.28 841.89] / Contents 4 0 R &gt;&gt; endobj....</code></pre>
<p>其实 jsPDF 除了支持纯文本之外，它也可以生成带图片的 PDF 文档，比如：</p>
<pre><code class="js">let imgData = 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/...';
let doc = new jsPDF();
doc.setFontSize(40);
doc.text(35, 25, 'Paranyan&nbsp;loves&nbsp;jsPDF');
doc.addImage(imgData, 'JPEG', 15, 40, 180, 160);</code></pre>
<p>Blob 的应用场景还很多，这里我们就不一一列举了，感兴趣的小伙伴可以自行查阅相关资料。</p>
<h3 id="四、Blob-与-ArrayBuffer-的区别"><a href="#四、Blob-与-ArrayBuffer-的区别" class="headerlink" title="四、Blob 与 ArrayBuffer 的区别"></a><span style="display: none; "></span>四、Blob 与 ArrayBuffer 的区别<span style="display: none; "></span></h3><p><strong>ArrayBuffer</strong> 对象用于表示通用的，固定长度的原始二进制数据缓冲区。你不能直接操纵 ArrayBuffer 的内容，而是需要创建一个类型化数组对象或 DataView 对象，该对象以特定格式表示缓冲区，并使用该对象读取和写入缓冲区的内容。</p>
<p><strong>Blob</strong> 类型的对象表示不可变的类似文件对象的原始数据。Blob 表示的不一定是 JavaScript 原生格式的数据。File 接口基于 Blob，继承了Blob 功能并将其扩展为支持用户系统上的文件。</p>
<h4 id="4-1-Blob-vs-ArrayBuffer"><a href="#4-1-Blob-vs-ArrayBuffer" class="headerlink" title="4.1 Blob vs ArrayBuffer"></a><span style="display: none; "></span>4.1 Blob vs ArrayBuffer<span style="display: none; "></span></h4><ul>
<li><p>除非你需要使用 ArrayBuffer 提供的写入/编辑的能力，否则 Blob 格式可能是最好的。</p>
</li>
<li><p>Blob 对象是不可变的，而 ArrayBuffer 是可以通过 TypedArrays 或 DataView 来操作。</p>
</li>
<li><p>ArrayBuffer 是存在内存中的，可以直接操作。而 Blob 可以位于磁盘、高速缓存内存和其他不可用的位置。</p>
</li>
<li><p>虽然 Blob 可以直接作为参数传递给其他函数，比如 <code>window.URL.createObjectURL()</code>。但是，你可能仍需要 FileReader 之类的 File API 才能与 Blob 一起使用。</p>
</li>
<li><p>Blob 与 ArrayBuffer 对象之间是可以相互转化的：</p>
</li>
<li><p>使用 FileReader 的 <code>readAsArrayBuffer()</code> 方法，可以把 Blob 对象转换为 ArrayBuffer 对象；</p>
</li>
<li><p>使用 Blob 构造函数，如 <code>new Blob([new Uint8Array(data]);</code>，可以把 ArrayBuffer 对象转换为 Blob 对象。</p>
</li>
</ul>
<p>对于 HTTP 的场景，比如在 AJAX 场景下，<strong>Blob</strong> 和 <strong>ArrayBuffer</strong> 可以通过以下方式来使用：</p>
<pre><code class="js">function GET(url, callback) {
    let xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer'; //&nbsp;or&nbsp;xhr.responseType&nbsp;=&nbsp;"blob";&nbsp;&nbsp;
    xhr.send();
    xhr.onload = function(e) {
            if (xhr.status != 200) {
                alert("Unexpected&nbsp;status&nbsp;code&nbsp;" + xhr.status + "&nbsp;for&nbsp;" + url);
                return false;
            }
            callback(new Uint8Array(xhr.response)); //&nbsp;or&nbsp;new&nbsp;Blob([xhr.response]);&nbsp;&nbsp;};}</code></pre>
<p>对于 <strong>ArrayBuffer</strong> 和 <strong>Uint8Array</strong> 感兴趣的读者，可以阅读<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;mid=2247484317&amp;idx=1&amp;sn=c0b397b6bd5fdfced0c1bebc187a7c0d&amp;chksm=ea47a2c5dd302bd37b285f65dd7a92df8ca1bc213465091e82a28be08ec5808b905e9fb69bec&amp;scene=21#wechat_redirect"><strong>Deno bytes 模块全解析</strong></a>这篇文章。</p>
<p>了解完上述的内容，相信有的读者可能会觉得意犹未尽。那么，对于 Blob 来说还有哪些内容可以继续深入学习的呢？本人下一步的计划是基于 Deno 的源码，来逐步分析 DenoBlob 的具体实现。当然也会顺便分析一下 <code>URL.createObjectURL()</code> 方法和 <code>revokeObjectURL()</code> 方法的实现。  </p>
<h3 id="五、参考资源"><a href="#五、参考资源" class="headerlink" title="五、参考资源"></a><span style="display: none; "></span>五、参考资源<span style="display: none; "></span></h3><ul>
<li><p>MDN - Blob</p>
</li>
<li><p>MDN - Data URLs</p>
</li>
<li><p>javascript.info - blob</p>
</li>
<li><p>flaviocopes - blob</p>
</li>
<li><p>arraybuffer-vs-blob</p>
</li>
<li><p>javascript-interview-question-what-is-a-blob</p>
</li>
</ul>
</article><section class="is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-small is-default" href="/My-Blogs/2021/01/08/JavaScript/%E4%BD%BF%E7%94%A8Intersection%20Observer%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%BA%E5%9F%9F%E6%B8%B2%E6%9F%93/" title="使用Intersection Observer接口实现可视区域渲染">Previous</a><a class="button is-small is-default" href="/My-Blogs/2021/01/08/JavaScript/javascript%E6%A8%A1%E5%9D%97%E5%8C%96%E6%BC%94%E8%BF%9B%E5%8F%8A%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/" title="javascript模块化演进及原理浅析">Next</a></section><article class="mt-6 comment-container"><script src="https://utteranc.es/client.js" repo="529303664/My-Blogs" issue-term="pathname" theme="github-light" async></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/https://twitter.com/Lucas55207840?s=05"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/529303664"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><a title="rss" target="_blank" rel="noopener nofollow" href="/My-Blogs/atom.xml"><i class="iconfont icon-rss"></i></a><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com/https://www.facebook.com/profile.php?id=100010703889793"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Lucas 2021</span></p><div class="is-flex"><p>Powered by Hexo｜</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by &nbspHaojen&nbsp</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script>hljs.initHighlighting();

var directory = document.querySelectorAll('.toc a')
if (directory.length > 0) {
    var contentTocList = []
    var activeClassName = 'is-active'

    directory.forEach(function (link) {
        if (!link.href) return
        var id = decodeURI(link.href).split('#')[1]
        contentTocList.push(document.getElementById(id))
    })

    var DELAY = 150
    var needWait = false
    window.addEventListener('scroll', function (evt) {
        if (needWait) {
            return
        }
        needWait = true
        var tocContainer = document.querySelector('.toc')
        setTimeout(function () {
            var spacing = 60
            var activeTopicEl = null
            var scrollTop = window.pageYOffset
            for (var i = 0; i < contentTocList.length; i++) {
                var currentTopic = contentTocList[i]

                if (currentTopic.offsetTop > scrollTop + spacing / 2) {
                    // jump to next loop
                    continue
                }

                if (!activeTopicEl) {
                    activeTopicEl = currentTopic
                } else if (currentTopic.offsetTop + spacing >= activeTopicEl.offsetTop - spacing) {
                    activeTopicEl = currentTopic
                }

                var beforeActiveEl = document.querySelector('.toc' + ' .' + activeClassName)
                beforeActiveEl && beforeActiveEl.classList.remove(activeClassName)

                var selectTarget = '.toc a[href="#' + encodeURI(activeTopicEl.id) + '"]'
                var direc = document.querySelector(selectTarget)
                direc.classList.add(activeClassName)

                var tocContainerHeight = tocContainer.getBoundingClientRect().height
                if (direc.offsetTop >= tocContainerHeight - spacing) {
                    tocContainer.scrollTo({
                        // top: direc.offsetTop - spacing,
                        top: direc.offsetTop + 100 - tocContainerHeight,
                    })
                }
                else {
                    tocContainer.scrollTo({ top: 0 })
                }
            }
            needWait = false
        }, DELAY)

    })

}</script></body></html>