<!DOCTYPE html><html class="appearance-auto" lang="zh-cn"><head><meta charset="UTF-8"><title>浅谈Vue3新特性</title><meta name="description" content="完善自己"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><link rel="icon"><link rel="stylesheet" href="/My-Blogs/style/bulma.css"><link rel="stylesheet" href="/My-Blogs/style/base.css"><link rel="stylesheet" href="/My-Blogs/style/helper.css"><script src="/My-Blogs/js/main.js"></script><link rel="stylesheet" href="/My-Blogs/style/post.css"><link rel="stylesheet" href="/My-Blogs/style/highlight-theme-light.css"><script src="/My-Blogs/jslib/highlight.pack.js"></script><meta name="generator" content="Hexo 5.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/My-Blogs/atom.xml" title="John Doe's blog" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-space-between is-hidden-mobile"><section class="is-hidden-mobile"><h2><a href="/My-Blogs/">Lucas's blog</a></h2></section><h3 class="is-hidden-mobile"></h3><aside><h3 class="is-inline-block"><a href="/My-Blogs/">Home</a></h3><h3 class="is-inline-block"><a href="/My-Blogs/about">About</a></h3><h3 class="is-inline-block"><a href="/My-Blogs/archives">Archives</a></h3></aside></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/My-Blogs/">Home</a></h3><h3 class="is-inline-block"><a href="/My-Blogs/about">About</a></h3><h3 class="is-inline-block"><a href="/My-Blogs/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E5%BF%AB"><span class="toc-text">更快</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E5%B0%8F"><span class="toc-text">更小</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80API%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">全局API的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue2%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">Vue2的使用方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue3%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">Vue3的使用方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BB%84%E4%BB%B6%E4%B8%8Ehelper%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">内部组件与helper的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E5%8F%8B%E5%A5%BD%EF%BC%9F"><span class="toc-text">更友好？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#VUE2%E7%BB%84%E4%BB%B6%E7%8E%B0%E5%AD%98%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-text">VUE2组件现存的缺陷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8componsition-API"><span class="toc-text">使用componsition API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%88%9B%E5%BB%BA%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B1%9E%E6%80%A7%E7%9A%84API"><span class="toc-text">两种创建响应式属性的API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ref-%E4%B8%BA%E4%BC%A0%E5%85%A5%E7%9A%84%E5%80%BC%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%B9%E8%B1%A1%EF%BC%8C%E9%80%9A%E8%BF%87value%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E4%B8%8E%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%80%BC"><span class="toc-text">ref: 为传入的值封装一个响应式对象，通过value属性访问与设置对象的值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#reactive-%E8%AE%A9%E4%BC%A0%E5%85%A5%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%88%90%E4%B8%BA%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%B9%E8%B1%A1"><span class="toc-text">reactive: 让传入的对象成为响应式对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96API"><span class="toc-text">其他API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#watchEffect"><span class="toc-text">watchEffect</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#compisition-API%E7%9A%84%E4%B8%8B%E4%B8%80%E6%AD%A5"><span class="toc-text">compisition API的下一步</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8E%B0%E5%AD%98%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">现存的缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8B%E4%B8%80%E6%AD%A5"><span class="toc-text">下一步</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%8F%98%E5%8C%96"><span class="toc-text">其他变化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%86%8D%E6%94%AF%E6%8C%81keyCode%E4%BF%AE%E9%A5%B0"><span class="toc-text">不再支持keyCode修饰</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%B8%A1%E7%B1%BB%E5%90%8D%E5%8F%98%E6%9B%B4"><span class="toc-text">过渡类名变更</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-model%E5%8F%98%E6%9B%B4"><span class="toc-text">v-model变更</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A"><span class="toc-text">更多</span></a></li></ol></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/My-Blogs/tags/vue3"><i class="tag post-item-tag">vue3</i></a></header><h1 class="mt-0 mb-1 is-family-serif">浅谈Vue3新特性</h1><time class="has-text-grey" datetime="2021-01-08T17:42:31.000Z">2021-01-08</time><article class="mt-2 post-content"><p>Vue3的<a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-next">release版本</a>终于发布了，新的Vue3在语法以及底层都进行了全新的重构，带来了更快的运行速度，更小的构建包，更友好的编程规范。</p>
<a id="more"></a>

<h2 id="更快"><a href="#更快" class="headerlink" title="更快"></a>更快</h2><p>传统的虚拟dom算法：</p>
<p>组件patch的时候，需要重新创建整个vdom树，然后遍历整棵树进行diff，update…</p>
<p>更快的虚拟dom算法，源自编译模板时给予更多的运行时提示：</p>
<ol>
<li> 编译模板时对动态内容进行patch标记，告诉patch算法只关注被标记的动态部分</li>
</ol>
<p><img src="/My-Blogs/images/%E6%B5%85%E8%B0%88Vue3%E6%96%B0%E7%89%B9%E6%80%A7-01.png"></p>
<ol>
<li> 对静态内容进行静态提升（变量提升），只在页面初始化时创建并渲染一次，其余时候不再渲染</li>
</ol>
<p><img src="/My-Blogs/images/%E6%B5%85%E8%B0%88Vue3%E6%96%B0%E7%89%B9%E6%80%A7-02.png"></p>
<ol>
<li> 对事件监听函数进行缓存，防止内联监听函数带来的副作用</li>
</ol>
<p>开启缓存前：</p>
<p><img src="/My-Blogs/images/%E6%B5%85%E8%B0%88Vue3%E6%96%B0%E7%89%B9%E6%80%A7-03.png"></p>
<p>开启缓存后：</p>
<p><img src="/My-Blogs/images/%E6%B5%85%E8%B0%88Vue3%E6%96%B0%E7%89%B9%E6%80%A7-04.png"></p>
<p>……</p>
<p>从在线模板编译器中编辑并查看新变化 =&gt;<a target="_blank" rel="noopener" href="https://vue-next-template-explorer.netlify.app/">模板编译器</a></p>
<h2 id="更小"><a href="#更小" class="headerlink" title="更小"></a>更小</h2><h3 id="全局API的使用"><a href="#全局API的使用" class="headerlink" title="全局API的使用"></a>全局API的使用</h3><p>全局 API 现在只能作为 ES 模块构建的命名导出进行访问。</p>
<h4 id="Vue2的使用方式"><a href="#Vue2的使用方式" class="headerlink" title="Vue2的使用方式"></a>Vue2的使用方式</h4><p>Vue.nextTick（this.$nextTick）、Vue.set、Vue.delete …</p>
<h4 id="Vue3的使用方式"><a href="#Vue3的使用方式" class="headerlink" title="Vue3的使用方式"></a>Vue3的使用方式</h4><p>import { nextTick, set, delete, … } from ‘vue’; </p>
<p>nextTick(() =&gt; {// dosomething});<br>……</p>
<h3 id="内部组件与helper的使用"><a href="#内部组件与helper的使用" class="headerlink" title="内部组件与helper的使用"></a>内部组件与helper的使用</h3><p>当在模板中使用到transtion组件、keepAlive组件、 …</p>
<p>经complier编译后，生成</p>
<p>import { transtion, keepAlive, … } from ‘vue’</p>
<p>当在模板中使用到v-show、v-model…</p>
<p>complier编译后，生成</p>
<p>import { vShow, vModel … } from ‘vue’</p>
<p>意味着只有在应用程序实际使用了某个API或者组件的时候才会导入它。没有使用到的功能代码将不会出现在最终的构建包中。框架体积进一步缩小。</p>
<h2 id="更友好？"><a href="#更友好？" class="headerlink" title="更友好？"></a>更友好？</h2><h4 id="VUE2组件现存的缺陷"><a href="#VUE2组件现存的缺陷" class="headerlink" title="VUE2组件现存的缺陷"></a>VUE2组件现存的缺陷</h4><ol>
<li><p> 组件越来越大，可读性和可维护性越来越差。根本原因在于Vue使用的option API：必须按配置(options)来组织代码，你需要把一个功能的实现分布在各个配置里：data，computed，watcher，methods，但是在某些情况下按功能来组织代码更合理。如果要在一个很大的组件中修改一个功能，就要跳到各个属性找，如果组件里面还用了mixins，还得跳文件看</p>
</li>
<li><p>mixins无法特别好的在多个组件中复用同一段代码  </p>
<p> mixins有什么问题？<br> 可读性太差，得跳到mixins所在的文件中才能知道它到底有什么<br> 不同的mixins容易冲突<br> 复用其他同伴的mixins的时候，有些代码不合自己的预期，但是不能随意更改</p>
</li>
<li><p> 对typeScript的支持有限</p>
</li>
</ol>
<h4 id="使用componsition-API"><a href="#使用componsition-API" class="headerlink" title="使用componsition API"></a>使用componsition API</h4><p>什么时候使用componsition API？</p>
<p><img src="/My-Blogs/images/%E6%B5%85%E8%B0%88Vue3%E6%96%B0%E7%89%B9%E6%80%A7-05.png"></p>
<ol>
<li> 如果你有一个很大的组件，想要按功能来聚合代码。</li>
<li> 如果你想要复用组件的一部分代码。</li>
<li> 如果你想要更好地支持typeScript</li>
</ol>
<pre><code class="JS">import useFeature1 from '../use/useFeature1';
import useFeature2 from '../use/useFeature2';

export default {
  setup() {

    const {
      data1,
      data2,
      method1,
      computed1,
      ...
    } = useFeature1();
    const {
      data3,
      data4,
      method2,
      computed2,
      ...
    } = useFeature2();
    // do something
    return {
      data1,
      data2,
      method1,
      ...
    };

  }
}</code></pre>
<p>上面这段代码是compsition API的一种示例，它做到了：按功能组织代码，想要修改某个业务逻辑时，不需要满大街找散布各地的数据和方法了，响应式属性与组件解耦，自由控制需要成为响应式的以及需要暴露给模板的属性。</p>
<p>setup内的代码只依赖于传入的参数和全局引入的Vue API，而不是特殊修改过的 <code>this</code> 。所以只需要导出你想要复用的功能函数。甚至可以导出整个 <code>setup</code> 函数去实现“类似”继承的效果。</p>
<h4 id="两种创建响应式属性的API"><a href="#两种创建响应式属性的API" class="headerlink" title="两种创建响应式属性的API"></a>两种创建响应式属性的API</h4><h5 id="ref-为传入的值封装一个响应式对象，通过value属性访问与设置对象的值"><a href="#ref-为传入的值封装一个响应式对象，通过value属性访问与设置对象的值" class="headerlink" title="ref: 为传入的值封装一个响应式对象，通过value属性访问与设置对象的值"></a>ref: 为传入的值封装一个响应式对象，通过value属性访问与设置对象的值</h5><pre><code class="JS">setup() {
  const capacity = ref(3);
  const attending = ref(['tim', 'Bob', 'Joe']);
  watch(capacity, () =&gt; {

    console.log('capacity changed!');

  });
  watch(attending, () =&gt; {

    console.log('attending changed!');

  });
  onMounted(() =&gt; {

    capacity.value += 1; // capacity changed!
    attending.value[0] = 'Jack'; // ?
    // 通过ref封装的响应式对象无法进行深层监听

  });
  return {
    capacity
  };
}</code></pre>
<h5 id="reactive-让传入的对象成为响应式对象"><a href="#reactive-让传入的对象成为响应式对象" class="headerlink" title="reactive: 让传入的对象成为响应式对象"></a>reactive: 让传入的对象成为响应式对象</h5><pre><code class="JS">setup() {
  const event = reactive({

    capacity: 3,
    attending: ['tim', 'Bob', 'Joe'],

  });
  watch(event, () =&gt; {

    console.log('something changed!');

  });
  onMounted(() =&gt; {

    event.attending[0] = 'Jack'; // something changed!

  });
  return {
    event
  };
}</code></pre>
<p>Vue3的响应式监听的实现方式与Vue2有很大不同，并挣脱了Vue2中无法监听动态增加对象属性与数组元素直接赋值的束缚。</p>
<p>点这里查看<a target="_blank" rel="noopener" href="https://github.com/LaiTaoGDUT/learnVue3/blob/master/public/reactive.html">简略版本的新响应式监听实现</a></p>
<h4 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h4><h5 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h5><pre><code class="JS">setup() {
  const capacity = ref(3);
  const attending = ref(['tim', 'Bob', 'Joe']);
  const stop = watchEffect(() =&gt; {

    console.log(capacity.value + attending.value.length);

  })
  onMounted(() =&gt; {

    capacity.value += 1; // 7

  });
  return {
    capacity,
    attending,
    stop
  };
}
stop(); // 停止监听</code></pre>
<p><a target="_blank" rel="noopener" href="https://vue3js.cn/docs/zh/api/">更多API请参考官方文档</a></p>
<h4 id="compisition-API的下一步"><a href="#compisition-API的下一步" class="headerlink" title="compisition API的下一步"></a>compisition API的下一步</h4><h5 id="现存的缺点"><a href="#现存的缺点" class="headerlink" title="现存的缺点"></a>现存的缺点</h5><ol>
<li> ref和reactive太像了，初上手时很难决定到底用哪个。</li>
<li> 没有了options的限制，一不小心就可能会写出比使用option API更加臃肿难读的代码</li>
<li> 使用Composition API时，需要区分哪些值或者对象是响应式的，哪些不是。</li>
<li> 阅读或者修改ref会有点麻烦，因为必须通过<code>.value</code>才能实现。</li>
<li> 一旦组件需要使用的数据多起来，import和return语句就会很冗长。</li>
</ol>
<h5 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h5><p><a target="_blank" rel="noopener" href="https://github.com/vuejs/rfcs/pull/222">New script setup and ref sugar</a></p>
<p>前阵子，Vue3.0提出了两个新提案，分别为script-setup提案与ref-suger提案</p>
<p>对于以下源代码：</p>
<pre><code class="HTML">&lt;script&gt;
  import {
    ref
  } from 'vue'

  export default {
    setup() {

      const count = ref(1)
      const inc = () =&gt; {
        count.value++
      }

      return {
        count,
        inc
      }

    }
  }
&lt;/script&gt;</code></pre>
<p><strong>使用script-setup 提案，将 options.setup 提取到代码顶层，所有顶层声明默认导出为模板使用</strong></p>
<pre><code class="HTML">&lt;script setup&gt;
  import {
    ref
  } from 'vue'

  const count = ref(0)
  const inc = () =&gt; {
    count.value++
  }
&lt;/script&gt;</code></pre>
<p><strong>使用ref-sugar 提案，将 ref.value 的写法，做进一步简化，放弃<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/label">标记语句</a>的普通语法，将其作为ref声明的语法糖。</strong></p>
<pre><code class="HTML">&lt;script setup&gt;
  ref: count = 1
  const inc = () =&gt; {
    count++
  }
  // 通过添加$前缀来访问响应式对象
  console.log($count.value)
&lt;/script&gt;</code></pre>
<p>这是Vue3带来的小改进还是大挑战 ？</p>
<h2 id="其他变化"><a href="#其他变化" class="headerlink" title="其他变化"></a>其他变化</h2><h4 id="不再支持keyCode修饰"><a href="#不再支持keyCode修饰" class="headerlink" title="不再支持keyCode修饰"></a>不再支持keyCode修饰</h4><pre><code class="HTML">&lt;input v-on:keyup.13="handleEnter"&gt;&lt;/input&gt;</code></pre>
<p>替换为</p>
<pre><code class="HTML">&lt;input v-on:keyup:enter="handleEnter"&gt;&lt;/input&gt;</code></pre>
<h4 id="过渡类名变更"><a href="#过渡类名变更" class="headerlink" title="过渡类名变更"></a>过渡类名变更</h4><p>.v-enter =&gt; .v-enter-from</p>
<p>.v-leave =&gt; .v-leave-from</p>
<h4 id="v-model变更"><a href="#v-model变更" class="headerlink" title="v-model变更"></a>v-model变更</h4><p>可使用多个v-model, 不再需要.sync修饰符来进行双向绑定了</p>
<pre><code class="HTML">&lt;ChildComponent v-model:title="pageTitle" /&gt;</code></pre>
<p>相当于</p>
<pre><code class="HTML">&lt;ChildComponent :title="pageTitle" @update:title="pageTitle = $event" /&gt;</code></pre>
<h4 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h4><p>Vue认为$ on，$ off 和 $once 实例方法不应该由它来提供，因此Vue3将它们移除了</p>
<p>过滤器filters被移除了，需要使用计算属性或方法来代替</p>
<p>新增Suspence组件 =&gt; 组件loading完成前显示后备内容</p>
<p>新增teleport组件（portal） =&gt; 允许传送组件内容到根节点以外的任何地方<br>…</p>
</article><section class="is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-small is-default" href="/My-Blogs/2021/01/08/webpack/easywebpack/easywebpack%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0svg%E5%A4%84%E7%90%86/" title="easywebpack项目添加svg处理">Previous</a><a class="button is-small is-default" href="/My-Blogs/2021/01/08/Redis/%E3%80%90Redis%E3%80%91%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="Redis缓存的三大问题及其解决方案">Next</a></section><article class="mt-6 comment-container"><script src="https://utteranc.es/client.js" repo="529303664/My-Blogs" issue-term="pathname" theme="github-light" async></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/https://twitter.com/Lucas55207840?s=05"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/529303664"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><a title="rss" target="_blank" rel="noopener nofollow" href="/My-Blogs/atom.xml"><i class="iconfont icon-rss"></i></a><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com/https://www.facebook.com/profile.php?id=100010703889793"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Lucas 2022</span></p><div class="is-flex"><p>Powered by Hexo｜</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by &nbspHaojen&nbsp</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script>hljs.initHighlighting();

var directory = document.querySelectorAll('.toc a')
if (directory.length > 0) {
    var contentTocList = []
    var activeClassName = 'is-active'

    directory.forEach(function (link) {
        if (!link.href) return
        var id = decodeURI(link.href).split('#')[1]
        contentTocList.push(document.getElementById(id))
    })

    var DELAY = 150
    var needWait = false
    window.addEventListener('scroll', function (evt) {
        if (needWait) {
            return
        }
        needWait = true
        var tocContainer = document.querySelector('.toc')
        setTimeout(function () {
            var spacing = 60
            var activeTopicEl = null
            var scrollTop = window.pageYOffset
            for (var i = 0; i < contentTocList.length; i++) {
                var currentTopic = contentTocList[i]

                if (currentTopic.offsetTop > scrollTop + spacing / 2) {
                    // jump to next loop
                    continue
                }

                if (!activeTopicEl) {
                    activeTopicEl = currentTopic
                } else if (currentTopic.offsetTop + spacing >= activeTopicEl.offsetTop - spacing) {
                    activeTopicEl = currentTopic
                }

                var beforeActiveEl = document.querySelector('.toc' + ' .' + activeClassName)
                beforeActiveEl && beforeActiveEl.classList.remove(activeClassName)

                var selectTarget = '.toc a[href="#' + encodeURI(activeTopicEl.id) + '"]'
                var direc = document.querySelector(selectTarget)
                direc.classList.add(activeClassName)

                var tocContainerHeight = tocContainer.getBoundingClientRect().height
                if (direc.offsetTop >= tocContainerHeight - spacing) {
                    tocContainer.scrollTo({
                        // top: direc.offsetTop - spacing,
                        top: direc.offsetTop + 100 - tocContainerHeight,
                    })
                }
                else {
                    tocContainer.scrollTo({ top: 0 })
                }
            }
            needWait = false
        }, DELAY)

    })

}</script></body></html>