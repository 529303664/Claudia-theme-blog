<!DOCTYPE html><html class="appearance-auto" lang="zh-cn"><head><meta charset="UTF-8"><title>PRPL模式加快Web应用加载</title><meta name="description" content="完善自己"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><link rel="icon"><link rel="stylesheet" href="/My-Blogs/style/bulma.css"><link rel="stylesheet" href="/My-Blogs/style/base.css"><link rel="stylesheet" href="/My-Blogs/style/helper.css"><script src="/My-Blogs/js/main.js"></script><link rel="stylesheet" href="/My-Blogs/style/post.css"><link rel="stylesheet" href="/My-Blogs/style/highlight-theme-light.css"><script src="/My-Blogs/jslib/highlight.pack.js"></script><meta name="generator" content="Hexo 5.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/My-Blogs/atom.xml" title="John Doe's blog" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-space-between is-hidden-mobile"><section class="is-hidden-mobile"><h2><a href="/My-Blogs/">Lucas's blog</a></h2></section><h3 class="is-hidden-mobile"></h3><aside><h3 class="is-inline-block"><a href="/My-Blogs/">Home</a></h3><h3 class="is-inline-block"><a href="/My-Blogs/about">About</a></h3><h3 class="is-inline-block"><a href="/My-Blogs/archives">Archives</a></h3></aside></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/My-Blogs/">Home</a></h3><h3 class="is-inline-block"><a href="/My-Blogs/about">About</a></h3><h3 class="is-inline-block"><a href="/My-Blogs/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9-PRPL%EF%BC%9F"><span class="toc-text">为什么选择 PRPL？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PRPL-%E5%BA%94%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E6%8A%80%E6%9C%AF%EF%BC%9F"><span class="toc-text">PRPL 应包含哪些技术？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-PRPL-%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">如何实现 PRPL 模式？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%B7%AF%E7%94%B1%E6%88%96%E5%9F%BA%E4%BA%8E%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8B%86%E5%88%86%E5%92%8C%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD"><span class="toc-text">基于路由或基于组件的代码拆分和延迟加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E7%BC%93%E5%AD%98"><span class="toc-text">预缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PRPL-%E4%BD%BF%E7%94%A8%E4%BD%95%E7%A7%8D%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">PRPL 使用何种应用程序结构？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/My-Blogs/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><i class="tag post-item-tag">性能优化</i></a></header><h1 class="mt-0 mb-1 is-family-serif">PRPL模式加快Web应用加载</h1><time class="has-text-grey" datetime="2021-01-08T18:01:13.000Z">2021-01-08</time><article class="mt-2 post-content"><p>PRPL 是一种用于结构化和交付 Web 应用程序和渐进式 Web 应用（PWA）的模式，重点在于改进应用的交付和启动性能。这个模式包含一组步骤，以实现快速、可靠、高效的加载：</p>
<a id="more"></a>

<ul>
<li><p><code>Push</code>, 推送初始路由所需的所有资源，并且只推送这些资源，以确保它们尽早可用。</p>
</li>
<li><p><code>Render</code>, 在加载其他资源之前，渲染初始路由并使其具备交互能力。</p>
</li>
<li><p><code>Pre-cache</code>, 预缓存用户可能访问的其他路由的资源，从而在恶劣的网络条件下尽可能提高对后续请求的响应能力和弹性。</p>
</li>
<li><p><code>Lazy-load</code>, 当用户请求时，按需延迟加载路由；关键路由的资源应立即从缓存中加载，而相对不常用的资源可以根据请求从网络获取。</p>
</li>
</ul>
<blockquote>
<p>注意：PRPL模式是由Polymer团队于2016年首次引入的，但已被证明适用于其他许多技术栈。</p>
</blockquote>
<p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-01.png" alt="img"></p>
<center>PRPL 模式加载顺序</center>

<p>服务器和服务 Worker 一起为非活动路由预缓存资源。当用户切换路由时，应用会延迟加载尚未缓存的所有必需资源，并创建所需的视图。</p>
<p>Twitter.com 自 2017 年以来就在生产中使用 PRPL 模式了。下面我们可以看到，他们对关键脚本使用了粒度代码拆分，并使用 <code>&lt;linkrel=preload&gt;</code> 推送脚本以尽快让脚本可用：</p>
<p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-02.png" alt="img"></p>
<br>

<center style="margin-top: 20px">PRPL 模式：预加载关键脚本</center>

<br>

<p>其他路由会按需延迟加载。Twitter 在整个用户体验部分中会按需提供 40 多个块。Twitter 还使用服务 Workers 对其他路由进行（离线）资产预缓存，以提高对后续导航操作的响应能力：</p>
<br>

<p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-03.png" alt="img"></p>
<br>

<center style="margin-top: 20px">PRPL 模式：离线缓存资源</center>

<br>

<p>他们的应用程序外壳程序（骨架 UI）也是离线缓存的，就算用户通过缓慢或不稳定的网络连接加载站点，也会立即加载它们：</p>
<p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-04.png" alt="img"></p>
<center>PRPL 模式：应用程序外壳</center>

<h2 id="为什么选择-PRPL？"><a href="#为什么选择-PRPL？" class="headerlink" title="为什么选择 PRPL？"></a>为什么选择 PRPL？</h2><p>应用使用 PRPL 构建是为了达到可靠、快速和引人入胜的目的。除了这些基本目标，PRPL 还旨在：</p>
<ul>
<li><p><strong>改善应用的交互就绪水平</strong>。为了做到这一点，在第一个视图渲染并具备交互能力之前，不会向浏览器发送多余的资源。</p>
</li>
<li><p><strong>提高应用的缓存效率，尤其是长期缓存效率</strong>。为了做到这一点，资源会以很细的粒度向浏览器发送。当资源被解绑或松散地打包时，对代码的每次更改给缓存的负面影响也会减少。</p>
</li>
<li><p><strong>降低开发和部署的复杂性</strong>。为了做到这一点，这种模式使用应用的隐式依赖图将每个入口点精确映射到所需的资源集，从而减少或消除了手动管理打包和交付的需求。</p>
</li>
</ul>
<h2 id="PRPL-应包含哪些技术？"><a href="#PRPL-应包含哪些技术？" class="headerlink" title="PRPL 应包含哪些技术？"></a>PRPL 应包含哪些技术？</h2><p>PRPL 是一种能以各种方式实现的概念模式，但是通过以下现代 Web 特性的某种组合，可以最轻松有效地实现 PRPL：</p>
<ul>
<li><p>像JavaScript Modules这样的现代模块系统，使工具可以轻松构造完整的依赖图；</p>
</li>
<li><p>服务Workers，为后续的应用视图预缓存（“安装”）资源（进而支持离线优先架构）</p>
</li>
<li><p>预加载，用于尽快交付所需资源。你还可以使用预加载链接头，这些头可以被协作服务器拦截并升级为HTTP/2 Server Push（详情可见<a target="_blank" rel="noopener" href="https://www.smashingmagazine.com/2017/04/guide-http2-server-push/">原文</a>）。一定要记住，尽管Push功能强大，但它也面临着许多已知的挑战；不过PRPL使用服务Worker可以避免过度推送的问题（仅针对初始负载使用push）。</p>
</li>
</ul>
<h2 id="如何实现-PRPL-模式？"><a href="#如何实现-PRPL-模式？" class="headerlink" title="如何实现 PRPL 模式？"></a>如何实现 PRPL 模式？</h2><p>PRPL 的很大一部分理念是对 JS 打包思维的颠覆，并在提供资源时拆分成尽可能接近编写资源时的粒度（至少拆分成独立的功能模块）。那么如何实现细粒度呢？</p>
<h3 id="基于路由或基于组件的代码拆分和延迟加载"><a href="#基于路由或基于组件的代码拆分和延迟加载" class="headerlink" title="基于路由或基于组件的代码拆分和延迟加载"></a>基于路由或基于组件的代码拆分和延迟加载</h3><p>你正在将事物编写为组件。也许你正在使用 ES 模块。对于 Webpack，我们使用动态导入和代码拆分，将你的代码库拆分为按需加载的块。</p>

<br>

<p>Next.js 和 Nuxt.js 之类的元框架会默认实现基于路由的代码拆分。如果你使用的是 create-react-app 之类的工具链样板，则需要借助 React Router 之类的路由器进行动态导入，才能将基于路由或基于组件的代码拆分添加到你的应用程序中。</p>

<br>

<p>对于 PRPL 的 push/preload 部分，Webpack 还支持将 preload 作为魔术注释来预加载关键脚本。</p>

<br>

<h3 id="预缓存"><a href="#预缓存" class="headerlink" title="预缓存"></a>预缓存</h3><p>可以使用服务 worker 预缓存剩余的路由。另一种常见的做法是，利用 Workbox 之类的服务 worker 库来简化为应用程序预缓存路由和块的过程。</p>

<br>

<h2 id="PRPL-使用何种应用程序结构？"><a href="#PRPL-使用何种应用程序结构？" class="headerlink" title="PRPL 使用何种应用程序结构？"></a>PRPL 使用何种应用程序结构？</h2><p>PRPL 鼓励采用以下结构的单页应用（SPA）架构：</p>

<br>

<ul>
<li><p>从每个有效路由提供的应用程序的主入口点。</p>
</li>
<li><p>这个文件应该很小，因为它将通过不同的URL提供，因此会被多次缓存。入口点中的所有资源URL都必须是绝对的，因为它可以从非顶级URL提供。</p>
</li>
<li><p>外壳（app-shell），其中包括顶级应用逻辑、router等。</p>
</li>
<li><p>延迟加载的应用片段。</p>
</li>
<li><p>可以代表特定视图代码的片段，或其他可以延迟加载的代码（例如，主应用的一些部分在第一次绘制时并不需要，比如说菜单，直到用户与应用交互时才显示）。外壳负责根据需要动态导入这些片段。</p>
</li>
</ul>
<p><img src="/My-Blogs/images/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/PRPL%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%BF%ABWeb%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD-05.png" alt="img"></p>
<center style="margin: 20px 0 20px 0; ">应用外壳骨架模式</center>

<p>应用应根据需要调用动态导入以延迟加载片段。例如，当用户更改为新路由时，它将导入与该路由关联的片段。这可能会向服务器发起新请求，或者只是从缓存中加载资源。

</p>

<br>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>除了针对 PWA 的基本目标和标准之外，PRPL 还尽量针对以下方面做了优化：</p>

<br>

<ul>
<li><p>尽量减少交互的准备工作——特别是在首次使用时（无论入口点如何）。</p>
</li>
<li><p>尽量提升缓存效率，尤其是更新不断发布后的长期缓存效率。</p>
</li>
<li><p>简化开发和部署。</p>
</li>
</ul>
<p>自 2016 年诞生以来，PRPL 模式已获得了大规模使用，值得你在优化应用加载时考虑。</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://addyosmani.com/blog/the-prpl-pattern/">https://addyosmani.com/blog/the-prpl-pattern/</a></p>
</article><section class="is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-small is-default" href="/My-Blogs/2021/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/db%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="db操作常见问题">Previous</a><a class="button is-small is-default" href="/My-Blogs/2021/01/08/%E5%AE%89%E5%85%A8/%E8%B0%88%E8%B0%88%E7%99%BB%E5%BD%95/" title="谈谈登录">Next</a></section><article class="mt-6 comment-container"><script src="https://utteranc.es/client.js" repo="529303664/My-Blogs" issue-term="pathname" theme="github-light" async></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/https://twitter.com/Lucas55207840?s=05"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/529303664"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><a title="rss" target="_blank" rel="noopener nofollow" href="/My-Blogs/atom.xml"><i class="iconfont icon-rss"></i></a><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com/https://www.facebook.com/profile.php?id=100010703889793"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Lucas 2021</span></p><div class="is-flex"><p>Powered by Hexo｜</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by &nbspHaojen&nbsp</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script>hljs.initHighlighting();

var directory = document.querySelectorAll('.toc a')
if (directory.length > 0) {
    var contentTocList = []
    var activeClassName = 'is-active'

    directory.forEach(function (link) {
        if (!link.href) return
        var id = decodeURI(link.href).split('#')[1]
        contentTocList.push(document.getElementById(id))
    })

    var DELAY = 150
    var needWait = false
    window.addEventListener('scroll', function (evt) {
        if (needWait) {
            return
        }
        needWait = true
        var tocContainer = document.querySelector('.toc')
        setTimeout(function () {
            var spacing = 60
            var activeTopicEl = null
            var scrollTop = window.pageYOffset
            for (var i = 0; i < contentTocList.length; i++) {
                var currentTopic = contentTocList[i]

                if (currentTopic.offsetTop > scrollTop + spacing / 2) {
                    // jump to next loop
                    continue
                }

                if (!activeTopicEl) {
                    activeTopicEl = currentTopic
                } else if (currentTopic.offsetTop + spacing >= activeTopicEl.offsetTop - spacing) {
                    activeTopicEl = currentTopic
                }

                var beforeActiveEl = document.querySelector('.toc' + ' .' + activeClassName)
                beforeActiveEl && beforeActiveEl.classList.remove(activeClassName)

                var selectTarget = '.toc a[href="#' + encodeURI(activeTopicEl.id) + '"]'
                var direc = document.querySelector(selectTarget)
                direc.classList.add(activeClassName)

                var tocContainerHeight = tocContainer.getBoundingClientRect().height
                if (direc.offsetTop >= tocContainerHeight - spacing) {
                    tocContainer.scrollTo({
                        // top: direc.offsetTop - spacing,
                        top: direc.offsetTop + 100 - tocContainerHeight,
                    })
                }
                else {
                    tocContainer.scrollTo({ top: 0 })
                }
            }
            needWait = false
        }, DELAY)

    })

}</script></body></html>