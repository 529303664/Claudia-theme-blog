<!DOCTYPE html><html class="appearance-auto" lang="zh-cn"><head><meta charset="UTF-8"><title>微服务缓存原理与最佳实践</title><meta name="description" content="完善自己"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><link rel="icon"><link rel="stylesheet" href="/My-Blogs/style/bulma.css"><link rel="stylesheet" href="/My-Blogs/style/base.css"><link rel="stylesheet" href="/My-Blogs/style/helper.css"><script src="/My-Blogs/js/main.js"></script><link rel="stylesheet" href="/My-Blogs/style/post.css"><link rel="stylesheet" href="/My-Blogs/style/highlight-theme-light.css"><script src="/My-Blogs/jslib/highlight.pack.js"></script><meta name="generator" content="Hexo 5.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/My-Blogs/atom.xml" title="John Doe's blog" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-space-between is-hidden-mobile"><section class="is-hidden-mobile"><h2><a href="/My-Blogs/">Lucas's blog</a></h2></section><h3 class="is-hidden-mobile"></h3><aside><h3 class="is-inline-block"><a href="/My-Blogs/">Home</a></h3><h3 class="is-inline-block"><a href="/My-Blogs/about">About</a></h3><h3 class="is-inline-block"><a href="/My-Blogs/archives">Archives</a></h3></aside></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/My-Blogs/">Home</a></h3><h3 class="is-inline-block"><a href="/My-Blogs/about">About</a></h3><h3 class="is-inline-block"><a href="/My-Blogs/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-text">为什么需要缓存？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5"><span class="toc-text">缓存读写策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache-Aside"><span class="toc-text">Cache Aside</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Write-Through"><span class="toc-text">Write Through</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Write-Back"><span class="toc-text">Write Back</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-text">替换策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%92%8C%E5%AD%98%E5%82%A8%E6%9B%B4%E6%96%B0%E9%A1%BA%E5%BA%8F"><span class="toc-text">缓存和存储更新顺序</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/My-Blogs/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84"><i class="tag post-item-tag">分布式架构</i></a><a href="/My-Blogs/tags/%E7%BC%93%E5%AD%98"><i class="tag post-item-tag">缓存</i></a></header><h1 class="mt-0 mb-1 is-family-serif">微服务缓存原理与最佳实践</h1><time class="has-text-grey" datetime="2021-01-08T17:52:53.000Z">2021-01-08</time><article class="mt-2 post-content"><p>文章主要介绍了分布式架构里的微服务缓存原理与最佳实践，下面让我们来一起看看吧</p>
<a id="more"></a>

<h2 id="为什么需要缓存？"><a href="#为什么需要缓存？" class="headerlink" title="为什么需要缓存？"></a>为什么需要缓存？</h2><ol>
<li><p> 程序存储在 <code>disk</code> 中</p>
</li>
<li><p> 程序是运行在 <code>RAM</code> 之中，也就是我们所说的 <code>main memory</code></p>
</li>
<li><p> 程序的计算逻辑在 <code>CPU</code> 中执行</p>
</li>
</ol>
<p>来看一个最简单的例子： <code>a = a + 1</code></p>
<ol>
<li><p> <code>load x:</code></p>
</li>
<li><p> <code>x0 = x0 + 1</code></p>
</li>
<li><p> <code>load x0 -&gt; RAM</code></p>
</li>
</ol>
<p><img src="/My-Blogs/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-01.png" alt="img"></p>
<p>上面提到了3种存储介质。我们都知道，三类的读写速度和成本成反比，所以我们在克服速度问题上需要引入一个 中间层。这个中间层，需要高速存取的速度，但是成本可接受。于是乎, <code>Cache</code> 被引入</p>
<p><img src="/My-Blogs/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-02.png" alt="img"></p>
<p>而在计算机系统中，有两种默认缓存：</p>
<p>CPU 里面的末级缓存，即 <code>LLC</code> 。缓存内存中的数据</p>
<p>内存中的高速页缓存，即 <code>page cache</code> 。缓存磁盘中的数据</p>
<h2 id="缓存读写策略"><a href="#缓存读写策略" class="headerlink" title="缓存读写策略"></a>缓存读写策略</h2><p>引入 <code>Cache</code> 之后，我们继续来看看操作缓存会发生什么。因为存在存取速度的差异「而且差异很大」，从而在操作数据时，延迟或程序失败等都会导致缓存和实际存储层数据不一致。</p>
<p>我们就以标准的 <code>Cache+DB</code> 来看看经典读写策略和应用场景。</p>
<h3 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache Aside"></a>Cache Aside</h3><p>先来考虑一种最简单的业务场景，比如用户表: <code>userId</code> : 用户id, <code>phone</code> : 用户电话token, <code>avtoar</code> : 用户头像url，缓存中我们用 <code>phone</code> 作为key存储用户头像。当用户修改头像url该如何做？</p>
<p>更新DB数据，再更新 <code>Cache</code> 数据</p>
<p>更新 DB 数据，再删除 <code>Cache</code> 数据</p>
<p>首先 变更数据库 和 变更缓存 是两个独立的操作，而我们并没有对操作做任何的并发控制。那么当两个线程并发更新它们的时候，就会因为写入顺序的不同造成数据不一致。</p>
<p>所以更好的方案是 <code>2</code> :</p>
<p>更新数据时不更新缓存，而是直接删除缓存</p>
<p>后续的请求发现缓存缺失，回去查询 <code>DB</code> ，并将结果 <code>load cache</code></p>
<p><img src="/My-Blogs/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-03.png" alt="img"></p>
<p>这个策略就是我们使用缓存最常见的策略: <code>Cache Aside</code> 。这个策略数据以数据库中的数据为准，缓存中的数据是按需加载的，分为读策略和写策略。</p>
<p>但是可见的问题也就出现了：频繁的读写操作会导致 <code>Cache</code> 反复地替换，缓存命中率降低。当然如果在业务中对命中率有监控报警时，可以考虑以下方案：</p>
<ol>
<li><p> 更新数据时同时更新缓存，但是在更新缓存前加一个 分布式锁。这样同一时间只有一个线程操作缓存，解决了并发问题。同时在后续读请求中时读到最新的缓存，解决了不一致的问题。</p>
</li>
<li><p> 更新数据时同时更新缓存，但是给缓存一个较短的 <code>TTL</code>。</p>
</li>
</ol>
<p>当然除了这个策略，在计算机体系还有其他几种经典的缓存策略，它们也有各自适用的使用场景。</p>
<h3 id="Write-Through"><a href="#Write-Through" class="headerlink" title="Write Through"></a>Write Through</h3><p>先查询写入数据key是否击中缓存，如果在 -&gt; 更新缓存，同时缓存组件同步数据至DB；不存在，则触发 ·。</p>
<p>而一般 · 有两种方式：</p>
<p><code>Write Allocate</code> ：写时直接分配 <code>Cache line</code></p>
<p><code>No-write allocate</code> ：写时不写入缓存，直接写入DB，return</p>
<p>在 <code>Write Through</code> 中，一般采取 <code>No-write allocate</code> 。因为其实无论哪种，最终数据都会持久化到DB中，省去一步缓存的写入，提升写性能。而缓存由 <code>Read Through</code> 写入缓存。</p>
<p><img src="/My-Blogs/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-04.png" alt="img"></p>
<p>这个策略的核心原则：<strong>用户只与缓存打交道，由缓存组件和DB通信，写入或者读取数据</strong>。在一些本地进程缓存组件可以考虑这种策略。</p>
<h3 id="Write-Back"><a href="#Write-Back" class="headerlink" title="Write Back"></a>Write Back</h3><p>相信你也看出上述方案的缺陷：写数据时缓存和数据库同步，但是我们知道这两块存储介质的速度差几个数量级，对写入性能是有很大影响。那我们是否异步更新数据库？</p>
<p><code>Write back</code> 就是在写数据时只更新该 Cache Line 对应的数据，并把该行标记为 Dirty。在读数据时或是在缓存满时换出「缓存替换策略」时，将 Dirty 写入存储。</p>
<p>需要注意的是：在 <code>Write Miss</code> 情况下，采取的是 <code>Write Allocate</code> ，即写入存储同时写入缓存，这样我们在之后的写请求只需要更新缓存。</p>
<p><img src="/My-Blogs/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-05.png" alt="img"></p>
<blockquote>
<p><code>async purge</code> 此类概念其实存在计算机体系中。 <code>Mysql</code> 中刷脏页，本质都是尽可能防止随机写，统一写磁盘时机。</p>
</blockquote>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><code>Redis</code> 是一个独立的系统软件，和我们写的业务程序是两个软件。当我们部署了Redis 实例后，它只会被动地等待客户端发送请求，然后再进行处理。所以，如果应用程序想要使用 Redis 缓存，我们就要在程序中增加相应的缓存操作代码。所以我们也把 <code>Redis</code> 称为 <strong>旁路缓存</strong>，也就是说：读取缓存、读取数据库和更新缓存的操作都需要在应用程序中来完成。</p>
<p>而作为缓存的 <code>Redis</code> ，同样需要面临常见的问题：</p>
<ul>
<li><p>缓存的容量终究有限</p>
</li>
<li><p>上游并发请求冲击</p>
</li>
<li><p>缓存与后端存储数据一致性</p>
</li>
</ul>
<h3 id="替换策略"><a href="#替换策略" class="headerlink" title="替换策略"></a>替换策略</h3><p>一般来说，缓存对于选定的被淘汰数据，会根据其是干净数据还是脏数据，选择直接删除还是写回数据库。但是，在 Redis 中，被淘汰数据无论干净与否都会被删除，所以，这是我们在使用 Redis 缓存时要特别注意的：当数据修改成为脏数据时，需要在数据库中也把数据修改过来。</p>
<p>所以不管替换策略是什么，脏数据有可能在换入换出中丢失。那我们在产生脏数据就应该删除缓存，而不是更新缓存，一切数据应该以数据库为准。这也很好理解，缓存写入应该交给读请求来完成；写请求尽可能保证数据一致性。</p>
<p>至于替换策略有哪些，网上已经有很多文章归纳之间的优劣，这里就不再赘述。</p>
<h2 id="缓存和存储更新顺序"><a href="#缓存和存储更新顺序" class="headerlink" title="缓存和存储更新顺序"></a>缓存和存储更新顺序</h2><p>这是开发中常见纠结问题：<strong>到底是先删除缓存还是先更新存储</strong>？</p>
<blockquote>
<p>情况一：先删除缓存，再更新存储；</p>
<ul>
<li>A 删除缓存，更新存储时网络延迟</li>
<li>B 读请求，发现缓存缺失，读存储 -&gt; 此时读到旧数据</li>
</ul>
</blockquote>
<p>这样会产生两个问题：</p>
<ul>
<li>B 读取旧值</li>
<li>B 同时读请求会把旧值写入缓存，导致后续读请求读到旧值</li>
</ul>
<p>既然是缓存可能是旧值，那就不管删除。有一个并不优雅的解决方案：<strong>在写请求更新完存储值以后</strong>， <code>sleep()</code> <strong>一小段时间，再进行一次缓存删除操作</strong>。</p>
<p><code>sleep</code> 是为了确保读请求结束，写请求可以删除读请求造成的缓存脏数据，当然也要考虑到 redis 主从同步的耗时。不过还是要根据实际业务而定。</p>
<p>这个方案会在第一次删除缓存值后，延迟一段时间再次进行删除，被称为： <code>延迟双删</code> 。</p>
<blockquote>
<p>情况二：先更新数据库值，再删除缓存值：</p>
<ul>
<li>A 删除存储值，但是删除缓存网络延迟</li>
<li>B 读请求时，缓存击中，就直接返回旧值</li>
</ul>
</blockquote>
<p>这种情况对业务的影响较小，而绝大多数缓存组件都是采取此种更新顺序，满足最终一致性要求。</p>
<blockquote>
<p>情况三：新用户注册，直接写入数据库，同时缓存中肯定没有。如果程序此时读从库，由于主从延迟，导致读取不到用户数据。</p>
</blockquote>
<p>这种情况就需要针对 Insert 这种操作：插入新数据入数据库同时写缓存。使得后续读请求可以直接读缓存，同时因为是刚插入的新数据，在一段时间修改的可能性不大。</p>
<p><strong>以上方案在复杂的情况或多或少都有潜在问题，需要贴合业务做具体的修改。</strong></p>
</article><section class="is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-small is-default" href="/My-Blogs/2021/01/08/%E5%8D%8F%E8%AE%AE/ssh/ssh%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/" title="ssh的基本用法">Previous</a><a class="button is-small is-default" href="/My-Blogs/2021/01/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/%E6%A6%82%E5%BF%B5/%E6%9E%B6%E6%9E%84%E4%B8%89%E9%AB%98%E6%80%BB%E7%BB%93/" title="架构三高总结">Next</a></section><article class="mt-6 comment-container"><script src="https://utteranc.es/client.js" repo="529303664/My-Blogs" issue-term="pathname" theme="github-light" async></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/https://twitter.com/Lucas55207840?s=05"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/529303664"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><a title="rss" target="_blank" rel="noopener nofollow" href="/My-Blogs/atom.xml"><i class="iconfont icon-rss"></i></a><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com/https://www.facebook.com/profile.php?id=100010703889793"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Lucas 2022</span></p><div class="is-flex"><p>Powered by Hexo｜</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by &nbspHaojen&nbsp</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script>hljs.initHighlighting();

var directory = document.querySelectorAll('.toc a')
if (directory.length > 0) {
    var contentTocList = []
    var activeClassName = 'is-active'

    directory.forEach(function (link) {
        if (!link.href) return
        var id = decodeURI(link.href).split('#')[1]
        contentTocList.push(document.getElementById(id))
    })

    var DELAY = 150
    var needWait = false
    window.addEventListener('scroll', function (evt) {
        if (needWait) {
            return
        }
        needWait = true
        var tocContainer = document.querySelector('.toc')
        setTimeout(function () {
            var spacing = 60
            var activeTopicEl = null
            var scrollTop = window.pageYOffset
            for (var i = 0; i < contentTocList.length; i++) {
                var currentTopic = contentTocList[i]

                if (currentTopic.offsetTop > scrollTop + spacing / 2) {
                    // jump to next loop
                    continue
                }

                if (!activeTopicEl) {
                    activeTopicEl = currentTopic
                } else if (currentTopic.offsetTop + spacing >= activeTopicEl.offsetTop - spacing) {
                    activeTopicEl = currentTopic
                }

                var beforeActiveEl = document.querySelector('.toc' + ' .' + activeClassName)
                beforeActiveEl && beforeActiveEl.classList.remove(activeClassName)

                var selectTarget = '.toc a[href="#' + encodeURI(activeTopicEl.id) + '"]'
                var direc = document.querySelector(selectTarget)
                direc.classList.add(activeClassName)

                var tocContainerHeight = tocContainer.getBoundingClientRect().height
                if (direc.offsetTop >= tocContainerHeight - spacing) {
                    tocContainer.scrollTo({
                        // top: direc.offsetTop - spacing,
                        top: direc.offsetTop + 100 - tocContainerHeight,
                    })
                }
                else {
                    tocContainer.scrollTo({ top: 0 })
                }
            }
            needWait = false
        }, DELAY)

    })

}</script></body></html>