<!DOCTYPE html><html class="appearance-auto" lang="zh-cn"><head><meta charset="UTF-8"><title>Typescript快速入门</title><meta name="description" content="完善自己"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><link rel="icon"><link rel="stylesheet" href="/My-Blogs/style/bulma.css"><link rel="stylesheet" href="/My-Blogs/style/base.css"><link rel="stylesheet" href="/My-Blogs/style/helper.css"><script src="/My-Blogs/js/main.js"></script><link rel="stylesheet" href="/My-Blogs/style/post.css"><link rel="stylesheet" href="/My-Blogs/style/highlight-theme-light.css"><script src="/My-Blogs/jslib/highlight.pack.js"></script><meta name="generator" content="Hexo 5.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/My-Blogs/atom.xml" title="John Doe's blog" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-space-between is-hidden-mobile"><section class="is-hidden-mobile"><h2><a href="/My-Blogs/">Lucas's blog</a></h2></section><h3 class="is-hidden-mobile"></h3><aside><h3 class="is-inline-block"><a href="/My-Blogs/">Home</a></h3><h3 class="is-inline-block"><a href="/My-Blogs/about">About</a></h3><h3 class="is-inline-block"><a href="/My-Blogs/archives">Archives</a></h3></aside></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/My-Blogs/">Home</a></h3><h3 class="is-inline-block"><a href="/My-Blogs/about">About</a></h3><h3 class="is-inline-block"><a href="/My-Blogs/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Types"><span class="toc-text">Types</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Primitive-Types"><span class="toc-text">Primitive Types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array"><span class="toc-text">Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Enum"><span class="toc-text">Enum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nullable"><span class="toc-text">Nullable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Any"><span class="toc-text">Any</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-VS-object"><span class="toc-text">Object VS object</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Interfaces"><span class="toc-text">Interfaces</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8E"><span class="toc-text">接口声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7"><span class="toc-text">可选属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7"><span class="toc-text">只读属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF"><span class="toc-text">接口继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%B1%9E%E6%80%A7"><span class="toc-text">索引属性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Functions"><span class="toc-text">Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-text">函数声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-text">函数类型声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B6%85%E8%BD%BD"><span class="toc-text">函数超载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0"><span class="toc-text">工厂函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Classes"><span class="toc-text">Classes</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%A3%B0%E6%98%8E"><span class="toc-text">类声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="toc-text">类继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">访问修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">只读修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%B1%9E%E6%80%A7"><span class="toc-text">参数属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-text">实现接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95%E8%B6%85%E8%BD%BD"><span class="toc-text">类方法超载</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Generics"><span class="toc-text">Generics</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8C%83%E5%9E%8B%E5%87%BD%E6%95%B0"><span class="toc-text">范型函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8C%83%E5%9E%8B%E7%B1%BB"><span class="toc-text">范型类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-text">泛型约束</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/My-Blogs/tags/Typescript"><i class="tag post-item-tag">Typescript</i></a></header><h1 class="mt-0 mb-1 is-family-serif">Typescript快速入门</h1><time class="has-text-grey" datetime="2022-03-06T10:42:27.000Z">2022-03-06</time><article class="mt-2 post-content"><blockquote>
<p>TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.</p>
<p>Any browser. Any host. Any OS. Open source.</p>
</blockquote>
<p>漫漫前端路，语言何其多。行走在前端开发的道路上，新鲜事物层出不穷，你是否有些应接不暇呢？在众多耀眼的前端语言明星中，TypeScript 无疑是你值得探究一番的那一颗（<del>对，就是这么武断</del>）。</p>
<a id="more"></a>

<h1 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h1><p>大家都知道 JavaScript 是一种弱类型语言，想必很多人也知道不少有关自动类型转换的奇技淫巧。弱类型在我们写代码时带来了不少便利，也为面试题扩充了不少题库，但同时也埋下了一个个地雷，时不时踩一个。尤其是写一些基础库时，为了使用者的正确使用，要编写各种冗长的使用文档，遇上<del>不靠谱</del>不看文档的开发者，不仅要花时间解释用法，有时为了代码鲁棒性还得做各种各样的校验和兼容，费时费力。这时候类似 TypeScript 的强类型语言的优势就体现出来了，不按正确的方式调用编译都通不过，把问题直接挡在门外。</p>
<p>那么问题来了：“我习惯了开发 JavaScript，会不会很难接受 TypeScript 啊？”这个问题暂时放放，我们先来看看 TypeScript 的类型究竟是啥。</p>
<h2 id="Primitive-Types"><a href="#Primitive-Types" class="headerlink" title="Primitive Types"></a>Primitive Types</h2><p>说到<strong>基本类型</strong>，首先就能想到御三家：<code>string</code>、<code>number</code> 和 <code>boolean</code>，这三个类型在 TypeScript 的类型体系中占据了半壁江山，为其他复杂类型奠定了基石。</p>
<p>要指定一个变量的类型很简单，在 JavaScript 的变量声明后加上 <code>: type</code> 就可以了。</p>
<pre><code class="typescript">const numberVal: number = 0;
const booleanVal: boolean = true;
const stringVal: string = 'string';</code></pre>
<p>赋值、使用变量时和 JavaScript 完全一样。</p>
<pre><code class="typescript">let numberVal: number = 0;
numberVal += 10;
console.log(`Value: ${numberVal}`);</code></pre>
<p>对于有初值并且类型唯一的变量，我们也可以省略类型的声明，由 TypeScript 自动推导。</p>
<pre><code class="typescript">let inferredNumberVal = 1;
inferredNumberVal = 2;</code></pre>
<p>当变量被赋予错误类型的值，或是用于错误的函数时，TypeScript 会给出错误。</p>
<pre><code class="typescript">let numberVal: number = 0;
numberVal = '1'; // TS2322: Type '"1"' is not assignable to type 'number'.
stringVal.localeCompare(numberVal); // TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.</code></pre>
<p><code>symbol</code> 的使用与 <code>string</code> 等大同小异，至于 <code>null</code> 和 <code>undefined</code> 放到后文再说。</p>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>数组也是很常见的数据类型，定义也很浅显易懂。</p>
<pre><code class="typescript">let list: number[] = [1, 2, 3];
list.push(4);
const numberVal = list.shift();</code></pre>
<p>除了用 <code>[]</code> 的形式，也可以通过泛型（Generics）定义。</p>
<pre><code class="typescript">let list: Array&lt;number&gt; = [1, 2, 3];</code></pre>
<p>大部分情况建议使用 <code>[]</code> 的形式，遇到较复杂的类型时再考虑使用 <code>Array&lt;elementType&gt;</code> 的形式。</p>
<h2 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h2><p>对于一些事先确定范围的数据类型，我们一般会通过定义常量对象来描述。</p>
<pre><code class="javascript">const NetworkType = {
    None: 0,
    Wifi: 1,
    Edge: 2,
    Unknown: 3,
};

let type = NetworkType.None;</code></pre>
<p>按照上面这种写法，可以推导出变量 <code>type</code> 的类型其实是 <code>number</code>，但是并没有体现出 <code>NetworkType</code> 的取值范围。对于这种情况，TypeScript 给我们提供了枚举类型。</p>
<pre><code class="typescript">enum NetworkType {
    None,
    Wifi,
    Edge,
    Unknown,
}

let type: NetworkType = NetworkType.Wifi;</code></pre>
<p>通常情况下，枚举值会从 <code>0</code> 开始被依次赋值，当然我们也可以在定义时修改。</p>
<pre><code class="typescript">enum NetworkType {
    None = 1,            // 1
    Wifi,                     // 2
    Edge,                  // 3
    Unknown = 9,    // 9
}</code></pre>
<p>也可以使用 <code>string</code> 类型定义枚举类型，此时每一个枚举值都必须赋初值。</p>
<pre><code class="typescript">enum NetworkType {
    None = 'NONE',
    Wifi = 'WIFI',
    Edge = 'EDGE',
    Unknown = 'UNKNOWN',
}</code></pre>
<p>可以通过枚举值获得枚举名。</p>
<pre><code class="typescript">enum NetworkType {
    None,
    Wifi,
    Edge,
    Unknown,
}
const type = NetworkType.None;
const nameOfType = NetworkType[type]; // name === 'None'</code></pre>
<p>是不是有点神奇？其实看一下编译成 JavaScript 的代码就很好理解了：</p>
<pre><code class="javascript">var NetworkType;
(function (NetworkType) {
    NetworkType[NetworkType["None"] = 0] = "None";
    NetworkType[NetworkType["Wifi"] = 1] = "Wifi";
    NetworkType[NetworkType["Edge"] = 2] = "Edge";
    NetworkType[NetworkType["Unknown"] = 3] = "Unknown";
})(NetworkType || (NetworkType = {}));
var type = NetworkType.None;
var nameOfType = NetworkType[type]; // name === 'None'</code></pre>
<p>不过很多场景下我们并不需要通过枚举值反推枚举名，或是担心在运行时枚举值被修改，这时候我们就可以使用 <code>const enum</code> 了。</p>
<pre><code class="typescript">const enum NetworkType {
    None,
    Wifi,
    Edge,
    Unknown,
}
const type = NetworkType.None;</code></pre>
<p>对应的编译后代码：</p>
<pre><code class="js">var type = 0 /* None */;</code></pre>
<p>简洁明了。</p>
<h2 id="Nullable"><a href="#Nullable" class="headerlink" title="Nullable"></a>Nullable</h2><p>默认情况下 <code>null</code> 和 <code>undefined</code> 包含在其他类型内，例如：</p>
<pre><code class="typescript">let numberVal: number; // numberVal is undefined
let stringVal: string = null;</code></pre>
<p>大多数情况我们不会定义某个变量类型为 <code>null</code> 或 <code>undefined</code>，毕竟没有使用场景。不过在启用 TypeScript 的 <code>--strictNullChecks</code> 参数时， <code>null</code> 和 <code>undefined</code> 将从其他类型独立出来。</p>
<pre><code class="typescript">let stringVal: string | null = null;</code></pre>
<p>由 <code>|</code> 分隔的若干类型构成联合类型，例如 <code>string | null</code> 表示类型可以是 <code>string</code> 或 <code>null</code>。</p>
<h2 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h2><p>假设有一个场景，需要解析用户配置，配置项以对象的形式提供，看起来好像很简单：</p>
<pre><code class="typescript">let config: Object = getConfig();
console.log(config.name); // TS2339: Property 'name' does not exist on type 'Object'.</code></pre>
<p>咦，怎么报错了？不是说好的配置项是个对象吗？其实这是很多人在编写 TypeScript 时会遇到的第一个误区。我们知道在 JavaScript 的世界所有对象都继承自 <code>Object</code>，TypeScript 也一样。对于一个 <code>Object</code> 类型的变量，我们可以给它赋任意值：</p>
<pre><code class="typescript">let obj: Object;

obj = 1;
obj = 'Hello world!';
obj = false;
obj = function noop() {};
obj = [false, 1, '2'];
obj = {};
obj = null;</code></pre>
<p>也正因此我们无法从 <code>Object</code> 类型推导出真正的类型，自然也就无法验证类型的合法性了。那这个方法应该怎么写？</p>
<pre><code class="typescript">let config: any = getConfig();
console.log(config.name); // OK!</code></pre>
<p>是的，TypeScript 有个厉害的类型叫 <code>any</code>。严格来说不应该把 <code>any</code> 归为类型，更多时候应该说是一个让 Typescript 忽略类型检查的标记。</p>
<h2 id="Object-VS-object"><a href="#Object-VS-object" class="headerlink" title="Object VS object"></a>Object VS object</h2><p>除了刚刚说到的 <code>Object</code> 类型，可能大家还会遇到 <code>object</code> 这个类型。初看之下好像两者没什么区别，但实际上两者属于两个不同的世界。</p>
<p><code>Object</code> 来自 JavaScript，就是大家熟知的那个所有对象类型的根；<code>object</code> 是 TypeScript 的基本类型，用于指代除了基本类型之外的所有类型。</p>
<p>把刚才的例子改一下，看看会发生什么？</p>
<pre><code class="typescript">let obj: object;

obj = 1; // Error
obj = 'Hello world!'; // Error
obj = false; // Error
obj = function noop() {};
obj = [false, 1, '2'];
obj = {};
obj = null; // Error when enable --strictNullChecks</code></pre>
<hr>
<h1 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h1><p>只有基础类型是肯定不够用的，而 <code>any</code> 虽然能用于各种复杂的类型，但我们都应该明白 <code>any</code> 不能用于类型检查，自然不是最好的选择。这里就要介绍一下 TypeScript 的接口（interface）了，这可是 TypeScript 的核心之一，主打定义类型和类型检查。</p>
<h2 id="接口声明"><a href="#接口声明" class="headerlink" title="接口声明"></a>接口声明</h2><p>声明和使用一个接口很简单，作为类型定义时，接口的使用方法与基础类型完全一样。</p>
<pre><code class="typescript">interface Point {
    x: number;
    y: number;
}

let p: Point;
p = { x: 0 }; // TS2322: Type '{ x: number; }' is not assignable to type 'Point'.
p = { x: 0, z: 0 }; // TS2322: Type '{ x: number; z: number; }' is not assignable to type 'Point'.
p = { x: 0, y: 0 }; // OK!</code></pre>
<h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><p>接口的属性值可以设置为可选。</p>
<pre><code class="typescript">interface ColorizedPoint extends Point {
    color?: string;
}

let defaultPoint: ColorizedPoint = { x: 0, y: 0 };
defaultPoint.color = 'blue';
let redPoint: ColorizedPoint = { x: 0, y: 0, color: 'red' };</code></pre>
<h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><p>接口的属性值可以设置为只读。</p>
<pre><code class="typescript">interface FixedPoint extends Point {
    readonly x: number;
    readonly y: number;
}

let p: FixedPoint = { x: 0, y: 0 };
p.x = 1; // TS2540: Cannot assign to 'x' because it is a constant or a read-only property.</code></pre>
<h2 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h2><p>接口可以被继承，父类型可以接受子类型，但不意味着可以接受与子类型同构的数据。</p>
<pre><code class="typescript">interface StereoPoint extends Point {
    z: number;
}

let point: Point;
let stereoPoint: StereoPoint = { x: 0, y: 0, z: 0 };
point = stereoPoint; // OK!
point = { x: 0, y: 0, z: 0 }; // TS2322: Type '{ x: number; y: number; z: number; }' is not assignable to type 'Point'.</code></pre>
<h2 id="索引属性"><a href="#索引属性" class="headerlink" title="索引属性"></a>索引属性</h2><p>在某些场景，我们可能只关心数据结构中的特定属性，或是数据有统一的结构但属性名不可枚举，例如 HTTP 请求的响应头。</p>
<pre><code class="typescript">interface ResponseHeaders {
    'accept'?: string;
    'set-cookie'?: string[];
    [header: string]: string | string[];
}</code></pre>
<p>这里的 <code>[header: string]: string | string[] | undefined;</code> 定义了接口的索引属性，表示 <code>ResponseHeaders</code> 可以接受任意属性名为 <code>string</code> 类型、值为 <code>string | stirng[]</code> 类型的数据。</p>
<p>索引属性的属性名类型也支持 <code>number</code> 类型，例如：</p>
<pre><code class="typescript">interface ArrayLike {
    length: number;
    [index: number]: any;
}

let array: ArrayLike = [0, 1, 2];
array[3] = 3;</code></pre>
<hr>
<h1 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h1><p>函数（function）是 JavaScript 应用程序的基础，TypeScript 为 JavaScript 的基础上为函数添加了许多额外的功能。</p>
<h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>函数的声明与 JavaScript 没有太大区别，给参数和函数加上 <code>: type</code> 声明即可。</p>
<pre><code class="typescript">function filterData(list: string[]): string[] {
    return list.filter((val) =&gt; val.length &gt; 5);
}

function log(...args: string[]): void {
    console.log(...filterData(args));
}</code></pre>
<p>这里顺便提一下，<code>void</code> 也是 TypeScript 的基本类型，但基本都用来定义函数的返回值，就不在之前赘述了。</p>
<h2 id="函数类型声明"><a href="#函数类型声明" class="headerlink" title="函数类型声明"></a>函数类型声明</h2><p>这里稍稍有点绕，函数声明在 JavaScript 也有，但是函数类型的声明就是 TypeScript 独有的了，用来定义一系列函数的类型，包括参数数量和类型、返回值类型。</p>
<p>通过 <code>type</code> 声明</p>
<pre><code class="typescript">type DataFilter = (value: string) =&gt; boolean;</code></pre>
<p>通过 <code>interface</code> 声明</p>
<pre><code class="typescript">interface DataFilter {
    (value: string): boolean;
}</code></pre>
<p>声明了函数类型就可以开心地用了</p>
<pre><code class="typescript">function filterData(list: string[], dataFilter: DataFilter): string[] {
    return list.filter(dataFilter);
}</code></pre>
<p>不过很多时候函数类型声明并不是必须的，比如上面的例子，也可以直接写成</p>
<pre><code class="typescript">function filterData(list: string[], dataFilter: (value: string) =&gt; boolean): string[] {
    return list.filter(dataFilter);
}</code></pre>
<h2 id="函数超载"><a href="#函数超载" class="headerlink" title="函数超载"></a>函数超载</h2><p>先看一个例子：</p>
<pre><code class="typescript">function padding(all: number);
function padding(topAndBottom: number, leftAndRight: number);
function padding(top: number, right: number, bottom: number, left: number);
function padding(all: number, leftAndRight?: number, bottom?: number, left?: number) {
    if (leftAndRight === undefined &amp;&amp; bottom === undefined &amp;&amp; left === undefined) {
        leftAndRight = bottom = left = all;
    } else if (bottom === undefined &amp;&amp; left === undefined) {
        bottom = all;
        left = leftAndRight;
    }

    return {
        top: all,
        right: leftAndRight,
        bottom: bottom,
        left: left
    };
}

padding(1); // { top: 1, right: 1, bottom: 1, left: 1 }
padding(1, 2); // { top: 1, right: 2, bottom: 1, left: 2 }
padding(1, 2, 1); // TS2575: No overload expects 3 arguments, but overloads do exist that expect either 2 or 4 arguments.
padding(1, 2, 1, 2); // { top: 1, right: 2, bottom: 1, left: 2 }</code></pre>
<p>执行 <code>padding()</code> 函数时，传入不同的参数列表，不同位置上的参数所代表的含义也会发生变化。此时前三行函数声明只用于 TypeScript 的类型检查和推导，真正执行的还是第四行开始的代码。</p>
<h2 id="工厂函数"><a href="#工厂函数" class="headerlink" title="工厂函数"></a>工厂函数</h2><p>某些情况下我们需要动态生成一些函数，完成一些特定的功能，比如下面这个例子：</p>
<pre><code class="typescript">// 声明需要生成的函数类型
interface Validator {
    tester: RegExp;

    (value: string, index?: number): boolean;

    (values: string[]): boolean;
}

// 工厂函数
function createValidator(tester: RegExp): Validator {
    /**
     * `&lt;Validator&gt;` 用于把 `function` 类型转换成 `Validator` 类型；
     * `this: Validator` 用于指定函数运行时的上下文。
     */
    const validator = &lt;Validator&gt;function (this: Validator, value: string | string[], index?: number): boolean {
        if (typeof value === 'string') {
            return this.tester.test(value.slice(index));
        }

        return value.every((val) =&gt; this.tester.test(val));
    };

    validator.tester = tester;

    return validator.bind(validator);
}

const validate: Validator = createValidator(/\.fordeal\.com$/i);

validate('12345'); // false
validate('www.fordeal.com', 3); // true
validate(['www.fordeal.com', 'api.fordeal.com']); // true
validate(['www.fordeal.com', 'api.fordeal.com'], 3); // TS2345: Argument of type 'string[]' is not assignable to parameter of type 'string'.</code></pre>
<p><em>注：这里为了体现函数运行时的上下文，把 <code>tester</code> 挂到了 <code>Validator</code> 对象上，实际上通过闭包也可以实现一样的功能，在实际开发中请合理选择实现方法。</em></p>
<h1 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h1><p>接触过 ES6 的同学肯定知道 JavaScript 的类（class），这可以说是面向对象编程的基石。TypeScript 里的类完全向 JavaScript 兼容，并添加了很多额外的功能。</p>
<h2 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h2><p>拿之前的 <code>Point</code> 为例：</p>
<pre><code class="typescript">class Point {
    x: number;
    y: number;

    constructor(x: number, y: number) {
        this.x = x;
        this.y = y;
    }

    toString(): string {
        return `(${this.x}, ${this.y})`;
    }
}</code></pre>
<p>可以看到除了增加类型定义，和 ES6 的类声明基本一样。</p>
<h2 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h2><p>和接口一样，类也可以被继承。</p>
<pre><code class="typescript">class NamedPoint extends Point {
    name: string;

    constructor(x: number, y: number, name: string) {
        super(x, y);

        this.name = name;
    }

    toString(): string {
        return this.name + super.toString();
    }
}</code></pre>
<p>在派生类中可以通过 <code>super</code> 关键字访问基类。</p>
<p>此外，接口同样可以继承类。</p>
<pre><code class="typescript">interface FixedPoint extends Point {
    readonly x: number;
    readonly y: number;
}

let p0: Point = new Point(0, 0);
let p1: FixedPoint = p0;

p0.x += 10; // OK!
p1.x += 10; // TS2540: Cannot assign to 'x' because it is a constant or a read-only property.</code></pre>
<h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>访问修饰符（Access modifiers）包括：<code>public</code>、<code>private</code> 和 <code>protected</code>，默认均为 <code>public</code>。</p>
<pre><code class="typescript">class A {
    public a: number = 0;
    protected b: number = 1;
    private c: number = 2;
}

class B extends A {
    getB(): number {
        return this.b; // OK!
    }

    getC(): number {
        return this.c; // Error!
    }
}

new A().a; // OK!
new A().b; // Error!
new A().c; // Error!</code></pre>
<ul>
<li><code>public</code> 在任意地方都可以访问；</li>
<li><code>private</code> 不能在声明它的类的外部访问；</li>
<li><code>protected</code> 与 <code>private</code> 比较类似，不过可以在类的派生类中访问。</li>
</ul>
<h2 id="只读修饰符"><a href="#只读修饰符" class="headerlink" title="只读修饰符"></a>只读修饰符</h2><p>与接口的只读属性类似，类的属性也可以通过 <code>readonly</code> 修饰。</p>
<pre><code class="typescript">class FixedPoint extends Point {
    readonly x: number;
    readonly y: number;
    readonly isReadonly: boolean = true;

    setX(x: number): void {
        this.x = x; // Error!
    }
}

new FixedPoint(0, 0).x = 1; // Error!</code></pre>
<p>被 <code>readonly</code> 修饰的属性只能在定义属性或构造函数中被初始化。</p>
<h2 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h2><p>都说“懒惰是进步的源泉”，参数属性（Parameter property）就是一个很好的印证，还是以之前的 <code>Point</code> 为例：</p>
<pre><code class="typescript">class Point {
    constructor(protected x: number, public y: number) {
    }

    toString(): string {
        return `(${this.x}, ${this.y})`;
    }
}</code></pre>
<p>这样的类声明和之前的写法等效，通过给构造函数的参数添加修饰符，把声明和赋值合并至一处。</p>
<pre><code class="typescript">class A {
    constructor(protected a: number) {
    }
}

class B {
    constructor(private b: number) {
    }
}

class C {
    constructor(readonly c: number) {
    }
}

class D {
    constructor(private readonly d: number) {
    }
}</code></pre>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><p>接口可以继承自类，那类可以继承自接口吗？这是个好问题，不过在这之前我们先要分清两个概念：类型和实现。</p>
<p>类似 <code>type A = string | number</code> 和接口这些都属于类型，只作用在 TypeScript 的环境里，并不会对真实的 JavaScript 环境产生影响；而对于变量、函数或类这些定义都属于实现，是可以在 JavaScript 环境运行的逻辑。</p>
<p>现在再来看“类可以继承自接口吗”这个问题，显然是不可以的。类是实现，接口是类型，举个不太好的例子，有点像从虚无中产生物质（不要说是暗物质），自然不能实现。</p>
<p>但是！虽然类不能继承接口，但是我们可以实现（implement）接口。</p>
<pre><code class="typescript">interface IStorage {
    readonly size: number;

    delete(key: string): boolean;

    get(key: string): any;

    has(key: string): boolean;

    set(key: string, value: any): void;
}

class PersistentStorage implements IStorage {
    get size(): number {
        /* Implement */
    }

    delete(key: string): boolean {
        /* Implement */
    }

    get(key: string): any {
        /* Implement */
    }

    has(key: string): boolean {
        /* Implement */
    }

    set(key: string, value: any): void {
        /* Implement */
    }

    protected save(): void {
        /* Implement */
    }
}

class MemoryStorage implements IStorage {
    get size(): number {
        /* Implement */
    }

    delete(key: string): boolean {
        /* Implement */
    }

    get(key: string): any {
        /* Implement */
    }

    has(key: string): boolean {
        /* Implement */
    }

    set(key: string, value: any): void {
        /* Implement */
    }
}</code></pre>
<ul>
<li>这种场景下，接口建议以 <code>I</code>（Interface）开头以与类做区分；</li>
<li>接口给类的实现提供了指导作用，类需要实现接口中定义的所有属性和方法；</li>
<li>接口只定义类的 <code>public</code> 部分，不需要也不能定义 <code>protected</code> 和 <code>private</code> 部分。</li>
</ul>
<p>具体的使用场景在这里就不展开了，有兴趣的可以关注后续的分享。</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类（Abstract class）介于接口和类之间，它可以被继承，但是无法实例化。</p>
<pre><code class="typescript">abstract class Shape {
    abstract readonly perimeter: number;

    abstract calcArea(): number;

    toString(): string {
        return `Perimeter: ${this.perimeter}, area: ${this.calcArea()}`;
    }
}

class Square extends Shape {
    readonly perimeter: number;

    constructor(public readonly n: number) {
        super();

        this.perimeter = n * 4;
    }

    calcArea(): number {
        return this.n ** 2;
    }
}

class Circle extends Shape {
    constructor(public radius: number) {
        super();
    }

    get perimeter(): number {
        return 2 * Math.PI * this.radius;
    }

    calcArea(): number {
        return Math.PI * (this.radius ** 2);
    }
}

new Shape().toString(); // TS2511: Cannot create an instance of an abstract class.
new Square(1).toString(); // 'Perimeter: 4, area: 1'
new Circle(1).toString(); // 'Perimeter: 6.283185307179586, area: 3.141592653589793'</code></pre>
<p>在抽象类 <code>Shape</code> 中，<code>perimeter</code> 属性和 <code>calcArea()</code> 方法都被标记为 <code>abstract</code>，所以派生类在继承时必须都实现。<code>calcArea()</code> 方法很简单就不多说了，注意一下 <code>perimeter</code> 属性：</p>
<ul>
<li>在 <code>Square</code> 类的构造函数中，边长 <code>n</code> 带有 <code>readonly</code> 修饰符，意味着 <code>perimeter</code> 也固定不变，所以可以直接通过 <code>n * 4</code> 赋值；</li>
<li>而 <code>Circle</code> 类的半径 <code>radius</code> 是可变的，意味着当 <code>radius</code> 改变时 <code>perimeter</code> 也应该随之变化，所以选择 getter 实现。</li>
</ul>
<p>在复杂的项目开发中经常会遇到类似的情况，是选择属性还是通过 getter/setter 实现可以多斟酌下。</p>
<h2 id="类方法超载"><a href="#类方法超载" class="headerlink" title="类方法超载"></a>类方法超载</h2><p>函数可以超载，类似的类方法也可以。</p>
<pre><code class="typescript">interface IStyle {
    padding(all: number);

    padding(topAndBottom: number, leftAndRight: number);

    padding(top: number, right: number, bottom: number, left: number);
}

class Style implements IStyle {
    padding(all: number);
    padding(topAndBottom: number, leftAndRight: number);
    padding(top: number, right: number, bottom: number, left: number);
    padding(all: number, leftAndRight?: number, bottom?: number, left?: number) {
        if (leftAndRight === undefined &amp;&amp; bottom === undefined &amp;&amp; left === undefined) {
            leftAndRight = bottom = left = all;
        } else if (bottom === undefined &amp;&amp; left === undefined) {
            bottom = all;
            left = leftAndRight;
        }

        return {
            top: all,
            right: leftAndRight,
            bottom: bottom,
            left: left
        };
    }
}

const style = new Style();

style.padding(1);
style.padding(1, 2);
style.padding(1, 2, 1);
style.padding(1, 2, 1, 2);</code></pre>
<h1 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h1><p>泛型（generics）是在定义类型时非常常见，对于可复用的类型，泛型的引入使得同一份定义可以满足多样的数据类型，大大提高类型的灵活性。</p>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>先回忆一下之前我们定义的 <code>ArrayLike</code></p>
<pre><code class="typescript">interface ArrayLike {
    length: number;
    [index: number]: any;
}

let array: ArrayLike = [0, true, '2'];
let element = array[0];</code></pre>
<p>通过 <code>ArrayLike</code> 我们可以简单的接受一个数组类型，但这样存在一个问题：无法描述数组元素的类型。例子里的 <code>element</code> 变量的类型只能推导出 <code>any</code>，同时在对 <code>array</code> 赋值时我们也没法限制数组元素的类型。</p>
<p>现在回忆一下如何定义一个数字类型的数组：<code>number[]</code> 或是 <code>Array&lt;number&gt;</code>。这里的 <code>Array&lt;number&gt;</code> 用的就是泛型。那么泛型怎么定义呢？</p>
<pre><code class="typescript">interface ArrayLike&lt;T&gt; {
    length: number;
    [index: number]: T;
}

let numbers: ArrayLike&lt;number&gt; = [0, 1, 2];
let val: string = numbers[0]; // TS2322: Type 'number' is not assignable to type 'string'.
let strings: ArrayLike&lt;string&gt; = [0, 1, 2]; // TS2322: Type 'number[]' is not assignable to type 'ArrayLike&lt;string&gt;'.</code></pre>
<p>通过 <code>&lt;T1, T2, ...&gt;</code> 传入若干<strong>类型变量</strong>，可以在后续定义中使用类型变量替代具体的类型。需要注意的是类型变量是一种特殊的变量，只用于表示类型而不是值。</p>
<h2 id="范型函数"><a href="#范型函数" class="headerlink" title="范型函数"></a>范型函数</h2><p>我们同样可以用泛型定义函数。</p>
<pre><code class="typescript">function filterData&lt;T&gt;(list: T[], dataFilter: (value: T) =&gt; boolean): T[] {
    return list.filter(dataFilter);
}

let numbers: number[] = filterData([0, 1, 2, 3], (value) =&gt; value % 2 === 0);
let strings: string[] = filterData(['0', '11', '222', '333'], (value) =&gt; value.length % 2 === 0);</code></pre>
<p>通过泛型我们的 <code>filterData()</code> 就可以处理各种不同类型的数据了。</p>
<h2 id="范型类"><a href="#范型类" class="headerlink" title="范型类"></a>范型类</h2><p>范型类的定义和接口类似。</p>
<pre><code class="typescript">class ValueHolder&lt;T&gt; {
    constructor(public value: T) {
    }

    toString(): string {
        return `I have a ${typeof this.value}`;
    }
}

new ValueHolder(0).toString(); // 'I have a number'
new ValueHolder('0').toString(); // 'I have a string'</code></pre>
<h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p>有的时候我们的逻辑并不能支持所有类型，所以需要在定义泛型时约束可选的类型。</p>
<pre><code class="typescript">function logShape&lt;T extends Shape&gt;(shape: T): void {
    console.log(shape.constructor.name, shape.perimeter, shape.calcArea());
}

logShape(new Square(1)); // Square 4 1
logShape(new Circle(1)); // Circle 6.283185307179586 3.141592653589793
logShape('Shape'); // TS2345: Argument of type '"Shape"' is not assignable to parameter of type 'Shape'.</code></pre>
</article><section class="is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-small is-default" href="/My-Blogs/2021/12/22/JavaScript/%E7%AE%97%E6%B3%95%E7%AF%87-%E4%BE%8B%E9%A2%98/" title="算法篇-例题">Next</a></section><article class="mt-6 comment-container"><script src="https://utteranc.es/client.js" repo="529303664/My-Blogs" issue-term="pathname" theme="github-light" async></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/https://twitter.com/Lucas55207840?s=05"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/529303664"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><a title="rss" target="_blank" rel="noopener nofollow" href="/My-Blogs/atom.xml"><i class="iconfont icon-rss"></i></a><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com/https://www.facebook.com/profile.php?id=100010703889793"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Lucas 2022</span></p><div class="is-flex"><p>Powered by Hexo｜</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by &nbspHaojen&nbsp</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script>hljs.initHighlighting();

var directory = document.querySelectorAll('.toc a')
if (directory.length > 0) {
    var contentTocList = []
    var activeClassName = 'is-active'

    directory.forEach(function (link) {
        if (!link.href) return
        var id = decodeURI(link.href).split('#')[1]
        contentTocList.push(document.getElementById(id))
    })

    var DELAY = 150
    var needWait = false
    window.addEventListener('scroll', function (evt) {
        if (needWait) {
            return
        }
        needWait = true
        var tocContainer = document.querySelector('.toc')
        setTimeout(function () {
            var spacing = 60
            var activeTopicEl = null
            var scrollTop = window.pageYOffset
            for (var i = 0; i < contentTocList.length; i++) {
                var currentTopic = contentTocList[i]

                if (currentTopic.offsetTop > scrollTop + spacing / 2) {
                    // jump to next loop
                    continue
                }

                if (!activeTopicEl) {
                    activeTopicEl = currentTopic
                } else if (currentTopic.offsetTop + spacing >= activeTopicEl.offsetTop - spacing) {
                    activeTopicEl = currentTopic
                }

                var beforeActiveEl = document.querySelector('.toc' + ' .' + activeClassName)
                beforeActiveEl && beforeActiveEl.classList.remove(activeClassName)

                var selectTarget = '.toc a[href="#' + encodeURI(activeTopicEl.id) + '"]'
                var direc = document.querySelector(selectTarget)
                direc.classList.add(activeClassName)

                var tocContainerHeight = tocContainer.getBoundingClientRect().height
                if (direc.offsetTop >= tocContainerHeight - spacing) {
                    tocContainer.scrollTo({
                        // top: direc.offsetTop - spacing,
                        top: direc.offsetTop + 100 - tocContainerHeight,
                    })
                }
                else {
                    tocContainer.scrollTo({ top: 0 })
                }
            }
            needWait = false
        }, DELAY)

    })

}</script></body></html>